var alloy = (function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var queryString$1 = {};

    var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

    var token = '%[a-f0-9]{2}';
    var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
    var multiMatcher = new RegExp('(' + token + ')+', 'gi');

    function decodeComponents(components, split) {
    	try {
    		// Try to decode the entire string first
    		return [decodeURIComponent(components.join(''))];
    	} catch (err) {
    		// Do nothing
    	}

    	if (components.length === 1) {
    		return components;
    	}

    	split = split || 1;

    	// Split the array in 2 parts
    	var left = components.slice(0, split);
    	var right = components.slice(split);

    	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }

    function decode(input) {
    	try {
    		return decodeURIComponent(input);
    	} catch (err) {
    		var tokens = input.match(singleMatcher) || [];

    		for (var i = 1; i < tokens.length; i++) {
    			input = decodeComponents(tokens, i).join('');

    			tokens = input.match(singleMatcher) || [];
    		}

    		return input;
    	}
    }

    function customDecodeURIComponent(input) {
    	// Keep track of all the replacements and prefill the map with the `BOM`
    	var replaceMap = {
    		'%FE%FF': '\uFFFD\uFFFD',
    		'%FF%FE': '\uFFFD\uFFFD'
    	};

    	var match = multiMatcher.exec(input);
    	while (match) {
    		try {
    			// Decode as big chunks as possible
    			replaceMap[match[0]] = decodeURIComponent(match[0]);
    		} catch (err) {
    			var result = decode(match[0]);

    			if (result !== match[0]) {
    				replaceMap[match[0]] = result;
    			}
    		}

    		match = multiMatcher.exec(input);
    	}

    	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    	replaceMap['%C2'] = '\uFFFD';

    	var entries = Object.keys(replaceMap);

    	for (var i = 0; i < entries.length; i++) {
    		// Replace all decoded components
    		var key = entries[i];
    		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    	}

    	return input;
    }

    var decodeUriComponent = function (encodedURI) {
    	if (typeof encodedURI !== 'string') {
    		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    	}

    	try {
    		encodedURI = encodedURI.replace(/\+/g, ' ');

    		// Try the built in decoder first
    		return decodeURIComponent(encodedURI);
    	} catch (err) {
    		// Fallback to a more advanced decoder
    		return customDecodeURIComponent(encodedURI);
    	}
    };

    var splitOnFirst = (string, separator) => {
    	if (!(typeof string === 'string' && typeof separator === 'string')) {
    		throw new TypeError('Expected the arguments to be of type `string`');
    	}

    	if (separator === '') {
    		return [string];
    	}

    	const separatorIndex = string.indexOf(separator);

    	if (separatorIndex === -1) {
    		return [string];
    	}

    	return [
    		string.slice(0, separatorIndex),
    		string.slice(separatorIndex + separator.length)
    	];
    };

    var filterObj = function (obj, predicate) {
    	var ret = {};
    	var keys = Object.keys(obj);
    	var isArr = Array.isArray(predicate);

    	for (var i = 0; i < keys.length; i++) {
    		var key = keys[i];
    		var val = obj[key];

    		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
    			ret[key] = val;
    		}
    	}

    	return ret;
    };

    (function (exports) {
    	const strictUriEncode$1 = strictUriEncode;
    	const decodeComponent = decodeUriComponent;
    	const splitOnFirst$1 = splitOnFirst;
    	const filterObject = filterObj;

    	const isNullOrUndefined = value => value === null || value === undefined;

    	function encoderForArrayFormat(options) {
    		switch (options.arrayFormat) {
    			case 'index':
    				return key => (result, value) => {
    					const index = result.length;

    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, [encode(key, options), '[', index, ']'].join('')];
    					}

    					return [
    						...result,
    						[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
    					];
    				};

    			case 'bracket':
    				return key => (result, value) => {
    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, [encode(key, options), '[]'].join('')];
    					}

    					return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
    				};

    			case 'comma':
    			case 'separator':
    				return key => (result, value) => {
    					if (value === null || value === undefined || value.length === 0) {
    						return result;
    					}

    					if (result.length === 0) {
    						return [[encode(key, options), '=', encode(value, options)].join('')];
    					}

    					return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
    				};

    			default:
    				return key => (result, value) => {
    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, encode(key, options)];
    					}

    					return [...result, [encode(key, options), '=', encode(value, options)].join('')];
    				};
    		}
    	}

    	function parserForArrayFormat(options) {
    		let result;

    		switch (options.arrayFormat) {
    			case 'index':
    				return (key, value, accumulator) => {
    					result = /\[(\d*)\]$/.exec(key);

    					key = key.replace(/\[\d*\]$/, '');

    					if (!result) {
    						accumulator[key] = value;
    						return;
    					}

    					if (accumulator[key] === undefined) {
    						accumulator[key] = {};
    					}

    					accumulator[key][result[1]] = value;
    				};

    			case 'bracket':
    				return (key, value, accumulator) => {
    					result = /(\[\])$/.exec(key);
    					key = key.replace(/\[\]$/, '');

    					if (!result) {
    						accumulator[key] = value;
    						return;
    					}

    					if (accumulator[key] === undefined) {
    						accumulator[key] = [value];
    						return;
    					}

    					accumulator[key] = [].concat(accumulator[key], value);
    				};

    			case 'comma':
    			case 'separator':
    				return (key, value, accumulator) => {
    					const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
    					const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
    					value = isEncodedArray ? decode(value, options) : value;
    					const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
    					accumulator[key] = newValue;
    				};

    			default:
    				return (key, value, accumulator) => {
    					if (accumulator[key] === undefined) {
    						accumulator[key] = value;
    						return;
    					}

    					accumulator[key] = [].concat(accumulator[key], value);
    				};
    		}
    	}

    	function validateArrayFormatSeparator(value) {
    		if (typeof value !== 'string' || value.length !== 1) {
    			throw new TypeError('arrayFormatSeparator must be single character string');
    		}
    	}

    	function encode(value, options) {
    		if (options.encode) {
    			return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    		}

    		return value;
    	}

    	function decode(value, options) {
    		if (options.decode) {
    			return decodeComponent(value);
    		}

    		return value;
    	}

    	function keysSorter(input) {
    		if (Array.isArray(input)) {
    			return input.sort();
    		}

    		if (typeof input === 'object') {
    			return keysSorter(Object.keys(input))
    				.sort((a, b) => Number(a) - Number(b))
    				.map(key => input[key]);
    		}

    		return input;
    	}

    	function removeHash(input) {
    		const hashStart = input.indexOf('#');
    		if (hashStart !== -1) {
    			input = input.slice(0, hashStart);
    		}

    		return input;
    	}

    	function getHash(url) {
    		let hash = '';
    		const hashStart = url.indexOf('#');
    		if (hashStart !== -1) {
    			hash = url.slice(hashStart);
    		}

    		return hash;
    	}

    	function extract(input) {
    		input = removeHash(input);
    		const queryStart = input.indexOf('?');
    		if (queryStart === -1) {
    			return '';
    		}

    		return input.slice(queryStart + 1);
    	}

    	function parseValue(value, options) {
    		if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
    			value = Number(value);
    		} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    			value = value.toLowerCase() === 'true';
    		}

    		return value;
    	}

    	function parse(query, options) {
    		options = Object.assign({
    			decode: true,
    			sort: true,
    			arrayFormat: 'none',
    			arrayFormatSeparator: ',',
    			parseNumbers: false,
    			parseBooleans: false
    		}, options);

    		validateArrayFormatSeparator(options.arrayFormatSeparator);

    		const formatter = parserForArrayFormat(options);

    		// Create an object with no prototype
    		const ret = Object.create(null);

    		if (typeof query !== 'string') {
    			return ret;
    		}

    		query = query.trim().replace(/^[?#&]/, '');

    		if (!query) {
    			return ret;
    		}

    		for (const param of query.split('&')) {
    			if (param === '') {
    				continue;
    			}

    			let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '=');

    			// Missing `=` should be `null`:
    			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    			value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
    			formatter(decode(key, options), value, ret);
    		}

    		for (const key of Object.keys(ret)) {
    			const value = ret[key];
    			if (typeof value === 'object' && value !== null) {
    				for (const k of Object.keys(value)) {
    					value[k] = parseValue(value[k], options);
    				}
    			} else {
    				ret[key] = parseValue(value, options);
    			}
    		}

    		if (options.sort === false) {
    			return ret;
    		}

    		return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
    			const value = ret[key];
    			if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
    				// Sort object keys, not values
    				result[key] = keysSorter(value);
    			} else {
    				result[key] = value;
    			}

    			return result;
    		}, Object.create(null));
    	}

    	exports.extract = extract;
    	exports.parse = parse;

    	exports.stringify = (object, options) => {
    		if (!object) {
    			return '';
    		}

    		options = Object.assign({
    			encode: true,
    			strict: true,
    			arrayFormat: 'none',
    			arrayFormatSeparator: ','
    		}, options);

    		validateArrayFormatSeparator(options.arrayFormatSeparator);

    		const shouldFilter = key => (
    			(options.skipNull && isNullOrUndefined(object[key])) ||
    			(options.skipEmptyString && object[key] === '')
    		);

    		const formatter = encoderForArrayFormat(options);

    		const objectCopy = {};

    		for (const key of Object.keys(object)) {
    			if (!shouldFilter(key)) {
    				objectCopy[key] = object[key];
    			}
    		}

    		const keys = Object.keys(objectCopy);

    		if (options.sort !== false) {
    			keys.sort(options.sort);
    		}

    		return keys.map(key => {
    			const value = object[key];

    			if (value === undefined) {
    				return '';
    			}

    			if (value === null) {
    				return encode(key, options);
    			}

    			if (Array.isArray(value)) {
    				return value
    					.reduce(formatter(key), [])
    					.join('&');
    			}

    			return encode(key, options) + '=' + encode(value, options);
    		}).filter(x => x.length > 0).join('&');
    	};

    	exports.parseUrl = (url, options) => {
    		options = Object.assign({
    			decode: true
    		}, options);

    		const [url_, hash] = splitOnFirst$1(url, '#');

    		return Object.assign(
    			{
    				url: url_.split('?')[0] || '',
    				query: parse(extract(url), options)
    			},
    			options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
    		);
    	};

    	exports.stringifyUrl = (object, options) => {
    		options = Object.assign({
    			encode: true,
    			strict: true
    		}, options);

    		const url = removeHash(object.url).split('?')[0] || '';
    		const queryFromUrl = exports.extract(object.url);
    		const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

    		const query = Object.assign(parsedQueryFromUrl, object.query);
    		let queryString = exports.stringify(query, options);
    		if (queryString) {
    			queryString = `?${queryString}`;
    		}

    		let hash = getHash(object.url);
    		if (object.fragmentIdentifier) {
    			hash = `#${encode(object.fragmentIdentifier, options)}`;
    		}

    		return `${url}${queryString}${hash}`;
    	};

    	exports.pick = (input, filter, options) => {
    		options = Object.assign({
    			parseFragmentIdentifier: true
    		}, options);

    		const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
    		return exports.stringifyUrl({
    			url,
    			query: filterObject(query, filter),
    			fragmentIdentifier
    		}, options);
    	};

    	exports.exclude = (input, filter, options) => {
    		const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

    		return exports.pick(input, exclusionFilter, options);
    	}; 
    } (queryString$1));

    var queryString = /*@__PURE__*/getDefaultExportFromCjs(queryString$1);

    /**
     * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.
     *
     * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.
     */
    const DEBUG_BUILD$3 = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);

    /** Internal global with common properties and Sentry extensions  */

    /** Get's the global object for the current JavaScript runtime */
    const GLOBAL_OBJ = globalThis ;

    /**
     * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.
     *
     * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.
     */
    const DEBUG_BUILD$2 = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);

    // This is a magic string replaced by rollup

    const SDK_VERSION = "9.14.0" ;

    /**
     * An object that contains globally accessible properties and maintains a scope stack.
     * @hidden
     */

    /**
     * Returns the global shim registry.
     *
     * FIXME: This function is problematic, because despite always returning a valid Carrier,
     * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
     * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
     **/
    function getMainCarrier() {
      // This ensures a Sentry carrier exists
      getSentryCarrier(GLOBAL_OBJ);
      return GLOBAL_OBJ;
    }

    /** Will either get the existing sentry carrier, or create a new one. */
    function getSentryCarrier(carrier) {
      const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});

      // For now: First SDK that sets the .version property wins
      __SENTRY__.version = __SENTRY__.version || SDK_VERSION;

      // Intentionally populating and returning the version of "this" SDK instance
      // rather than what's set in .version so that "this" SDK always gets its carrier
      return (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});
    }

    /**
     * Returns a global singleton contained in the global `__SENTRY__[]` object.
     *
     * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
     * function and added to the `__SENTRY__` object.
     *
     * @param name name of the global singleton on __SENTRY__
     * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
     * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value
     * @returns the singleton
     */
    function getGlobalSingleton(
      name,
      creator,
      obj = GLOBAL_OBJ,
    ) {
      const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});
      const carrier = (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});
      // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes
      return carrier[name] || (carrier[name] = creator());
    }

    /** Prefix for logging strings */
    const PREFIX = 'Sentry Logger ';

    const CONSOLE_LEVELS = [
      'debug',
      'info',
      'warn',
      'error',
      'log',
      'assert',
      'trace',
    ] ;

    /** This may be mutated by the console instrumentation. */
    const originalConsoleMethods

     = {};

    /** A Sentry Logger instance. */

    /**
     * Temporarily disable sentry console instrumentations.
     *
     * @param callback The function to run against the original `console` messages
     * @returns The results of the callback
     */
    function consoleSandbox(callback) {
      if (!('console' in GLOBAL_OBJ)) {
        return callback();
      }

      const console = GLOBAL_OBJ.console ;
      const wrappedFuncs = {};

      const wrappedLevels = Object.keys(originalConsoleMethods) ;

      // Restore all wrapped console methods
      wrappedLevels.forEach(level => {
        const originalConsoleMethod = originalConsoleMethods[level] ;
        wrappedFuncs[level] = console[level] ;
        console[level] = originalConsoleMethod;
      });

      try {
        return callback();
      } finally {
        // Revert restoration to wrapped state
        wrappedLevels.forEach(level => {
          console[level] = wrappedFuncs[level] ;
        });
      }
    }

    function makeLogger() {
      let enabled = false;
      const logger = {
        enable: () => {
          enabled = true;
        },
        disable: () => {
          enabled = false;
        },
        isEnabled: () => enabled,
      };

      if (DEBUG_BUILD$2) {
        CONSOLE_LEVELS.forEach(name => {
          logger[name] = (...args) => {
            if (enabled) {
              consoleSandbox(() => {
                GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
              });
            }
          };
        });
      } else {
        CONSOLE_LEVELS.forEach(name => {
          logger[name] = () => undefined;
        });
      }

      return logger ;
    }

    /**
     * This is a logger singleton which either logs things or no-ops if logging is not enabled.
     * The logger is a singleton on the carrier, to ensure that a consistent logger is used throughout the SDK.
     */
    const logger = getGlobalSingleton('logger', makeLogger);

    const STACKTRACE_FRAME_LIMIT = 50;
    const UNKNOWN_FUNCTION = '?';
    // Used to sanitize webpack (error: *) wrapped stack errors
    const WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
    const STRIP_FRAME_REGEXP = /captureMessage|captureException/;

    /**
     * Creates a stack parser with the supplied line parsers
     *
     * StackFrames are returned in the correct order for Sentry Exception
     * frames and with Sentry SDK internal frames removed from the top and bottom
     *
     */
    function createStackParser(...parsers) {
      const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);

      return (stack, skipFirstLines = 0, framesToPop = 0) => {
        const frames = [];
        const lines = stack.split('\n');

        for (let i = skipFirstLines; i < lines.length; i++) {
          const line = lines[i] ;
          // Ignore lines over 1kb as they are unlikely to be stack frames.
          // Many of the regular expressions use backtracking which results in run time that increases exponentially with
          // input size. Huge strings can result in hangs/Denial of Service:
          // https://github.com/getsentry/sentry-javascript/issues/2286
          if (line.length > 1024) {
            continue;
          }

          // https://github.com/getsentry/sentry-javascript/issues/5459
          // Remove webpack (error: *) wrappers
          const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;

          // https://github.com/getsentry/sentry-javascript/issues/7813
          // Skip Error: lines
          if (cleanedLine.match(/\S*Error: /)) {
            continue;
          }

          for (const parser of sortedParsers) {
            const frame = parser(cleanedLine);

            if (frame) {
              frames.push(frame);
              break;
            }
          }

          if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {
            break;
          }
        }

        return stripSentryFramesAndReverse(frames.slice(framesToPop));
      };
    }

    /**
     * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.
     * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the
     * function that caused the crash is the last frame in the array.
     * @hidden
     */
    function stripSentryFramesAndReverse(stack) {
      if (!stack.length) {
        return [];
      }

      const localStack = Array.from(stack);

      // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
      if (/sentryWrapped/.test(getLastStackFrame(localStack).function || '')) {
        localStack.pop();
      }

      // Reversing in the middle of the procedure allows us to just pop the values off the stack
      localStack.reverse();

      // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
      if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {
        localStack.pop();

        // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`
        // is produced within the scope itself, making it:
        //
        //   Sentry.captureException()
        //   scope.captureException()
        //
        // instead of just the top `Sentry` call itself.
        // This forces us to possibly strip an additional frame in the exact same was as above.
        if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {
          localStack.pop();
        }
      }

      return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({
        ...frame,
        filename: frame.filename || getLastStackFrame(localStack).filename,
        function: frame.function || UNKNOWN_FUNCTION,
      }));
    }

    function getLastStackFrame(arr) {
      return arr[arr.length - 1] || {};
    }

    const defaultFunctionName = '<anonymous>';

    /**
     * Safely extract function name from itself
     */
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== 'function') {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      } catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        return defaultFunctionName;
      }
    }

    /**
     * Get's stack frames from an event without needing to check for undefined properties.
     */
    function getFramesFromEvent(event) {
      const exception = event.exception;

      if (exception) {
        const frames = [];
        try {
          // @ts-expect-error Object could be undefined
          exception.values.forEach(value => {
            // @ts-expect-error Value could be undefined
            if (value.stacktrace.frames) {
              // @ts-expect-error Value could be undefined
              frames.push(...value.stacktrace.frames);
            }
          });
          return frames;
        } catch (_oO) {
          return undefined;
        }
      }
      return undefined;
    }

    // We keep the handlers globally
    const handlers = {};
    const instrumented = {};

    /** Add a handler function. */
    function addHandler(type, handler) {
      handlers[type] = handlers[type] || [];
      (handlers[type] ).push(handler);
    }

    /** Maybe run an instrumentation function, unless it was already called. */
    function maybeInstrument(type, instrumentFn) {
      if (!instrumented[type]) {
        instrumented[type] = true;
        try {
          instrumentFn();
        } catch (e) {
          DEBUG_BUILD$2 && logger.error(`Error while instrumenting ${type}`, e);
        }
      }
    }

    /** Trigger handlers for a given instrumentation type. */
    function triggerHandlers(type, data) {
      const typeHandlers = type && handlers[type];
      if (!typeHandlers) {
        return;
      }

      for (const handler of typeHandlers) {
        try {
          handler(data);
        } catch (e) {
          DEBUG_BUILD$2 &&
            logger.error(
              `Error while triggering instrumentation handler.\nType: ${type}\nName: ${getFunctionName(handler)}\nError:`,
              e,
            );
        }
      }
    }

    let _oldOnErrorHandler = null;

    /**
     * Add an instrumentation handler for when an error is captured by the global error handler.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addGlobalErrorInstrumentationHandler(handler) {
      const type = 'error';
      addHandler(type, handler);
      maybeInstrument(type, instrumentError);
    }

    function instrumentError() {
      _oldOnErrorHandler = GLOBAL_OBJ.onerror;

      // Note: The reason we are doing window.onerror instead of window.addEventListener('error')
      // is that we are using this handler in the Loader Script, to handle buffered errors consistently
      GLOBAL_OBJ.onerror = function (
        msg,
        url,
        line,
        column,
        error,
      ) {
        const handlerData = {
          column,
          error,
          line,
          msg,
          url,
        };
        triggerHandlers('error', handlerData);

        if (_oldOnErrorHandler) {
          // eslint-disable-next-line prefer-rest-params
          return _oldOnErrorHandler.apply(this, arguments);
        }

        return false;
      };

      GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
    }

    let _oldOnUnhandledRejectionHandler = null;

    /**
     * Add an instrumentation handler for when an unhandled promise rejection is captured.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addGlobalUnhandledRejectionInstrumentationHandler(
      handler,
    ) {
      const type = 'unhandledrejection';
      addHandler(type, handler);
      maybeInstrument(type, instrumentUnhandledRejection);
    }

    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;

      // Note: The reason we are doing window.onunhandledrejection instead of window.addEventListener('unhandledrejection')
      // is that we are using this handler in the Loader Script, to handle buffered rejections consistently
      GLOBAL_OBJ.onunhandledrejection = function (e) {
        const handlerData = e;
        triggerHandlers('unhandledrejection', handlerData);

        if (_oldOnUnhandledRejectionHandler) {
          // eslint-disable-next-line prefer-rest-params
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }

        return true;
      };

      GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
    }

    // eslint-disable-next-line @typescript-eslint/unbound-method
    const objectToString = Object.prototype.toString;

    /**
     * Checks whether given value's type is one of a few Error or Error-like
     * {@link isError}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isError(wat) {
      switch (objectToString.call(wat)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
        case '[object WebAssembly.Exception]':
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    /**
     * Checks whether given value is an instance of the given built-in class.
     *
     * @param wat The value to be checked
     * @param className
     * @returns A boolean representing the result.
     */
    function isBuiltin(wat, className) {
      return objectToString.call(wat) === `[object ${className}]`;
    }

    /**
     * Checks whether given value's type is ErrorEvent
     * {@link isErrorEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isErrorEvent$1(wat) {
      return isBuiltin(wat, 'ErrorEvent');
    }

    /**
     * Checks whether given value's type is DOMError
     * {@link isDOMError}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isDOMError(wat) {
      return isBuiltin(wat, 'DOMError');
    }

    /**
     * Checks whether given value's type is DOMException
     * {@link isDOMException}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isDOMException(wat) {
      return isBuiltin(wat, 'DOMException');
    }

    /**
     * Checks whether given value's type is a string
     * {@link isString}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isString(wat) {
      return isBuiltin(wat, 'String');
    }

    /**
     * Checks whether given string is parameterized
     * {@link isParameterizedString}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isParameterizedString(wat) {
      return (
        typeof wat === 'object' &&
        wat !== null &&
        '__sentry_template_string__' in wat &&
        '__sentry_template_values__' in wat
      );
    }

    /**
     * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
     * {@link isPrimitive}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isPrimitive(wat) {
      return wat === null || isParameterizedString(wat) || (typeof wat !== 'object' && typeof wat !== 'function');
    }

    /**
     * Checks whether given value's type is an object literal, or a class instance.
     * {@link isPlainObject}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isPlainObject(wat) {
      return isBuiltin(wat, 'Object');
    }

    /**
     * Checks whether given value's type is an Event instance
     * {@link isEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isEvent(wat) {
      return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
    }

    /**
     * Checks whether given value's type is an Element instance
     * {@link isElement}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isElement(wat) {
      return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
    }

    /**
     * Checks whether given value's type is an regexp
     * {@link isRegExp}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isRegExp(wat) {
      return isBuiltin(wat, 'RegExp');
    }

    /**
     * Checks whether given value has a then function.
     * @param wat A value to be checked.
     */
    function isThenable(wat) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      return Boolean(wat?.then && typeof wat.then === 'function');
    }

    /**
     * Checks whether given value's type is a SyntheticEvent
     * {@link isSyntheticEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isSyntheticEvent(wat) {
      return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
    }

    /**
     * Checks whether given value's type is an instance of provided constructor.
     * {@link isInstanceOf}.
     *
     * @param wat A value to be checked.
     * @param base A constructor to be used in a check.
     * @returns A boolean representing the result.
     */
    function isInstanceOf(wat, base) {
      try {
        return wat instanceof base;
      } catch (_e) {
        return false;
      }
    }

    /**
     * Checks whether given value's type is a Vue ViewModel.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isVueViewModel(wat) {
      // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.
      return !!(typeof wat === 'object' && wat !== null && ((wat ).__isVue || (wat )._isVue));
    }

    /**
     * Checks whether the given parameter is a Standard Web API Request instance.
     *
     * Returns false if Request is not available in the current runtime.
     */
    function isRequest(request) {
      return typeof Request !== 'undefined' && isInstanceOf(request, Request);
    }

    const WINDOW$3 = GLOBAL_OBJ ;

    const DEFAULT_MAX_STRING_LENGTH = 80;

    /**
     * Given a child DOM element, returns a query-selector statement describing that
     * and its ancestors
     * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
     * @returns generated DOM path
     */
    function htmlTreeAsString(
      elem,
      options = {},
    ) {
      if (!elem) {
        return '<unknown>';
      }

      // try/catch both:
      // - accessing event.target (see getsentry/raven-js#838, #768)
      // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
      // - can throw an exception in some circumstances.
      try {
        let currentElem = elem ;
        const MAX_TRAVERSE_HEIGHT = 5;
        const out = [];
        let height = 0;
        let len = 0;
        const separator = ' > ';
        const sepLength = separator.length;
        let nextStr;
        const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
        const maxStringLength = (!Array.isArray(options) && options.maxStringLength) || DEFAULT_MAX_STRING_LENGTH;

        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          // bail out if
          // - nextStr is the 'html' element
          // - the length of the string that would be created exceeds maxStringLength
          //   (ignore this limit if we are on the first iteration)
          if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength)) {
            break;
          }

          out.push(nextStr);

          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }

        return out.reverse().join(separator);
      } catch (_oO) {
        return '<unknown>';
      }
    }

    /**
     * Returns a simple, query-selector representation of a DOM element
     * e.g. [HTMLElement] => input#foo.btn[name=baz]
     * @returns generated DOM path
     */
    function _htmlElementAsString(el, keyAttrs) {
      const elem = el

    ;

      const out = [];

      if (!elem?.tagName) {
        return '';
      }

      // @ts-expect-error WINDOW has HTMLElement
      if (WINDOW$3.HTMLElement) {
        // If using the component name annotation plugin, this value may be available on the DOM node
        if (elem instanceof HTMLElement && elem.dataset) {
          if (elem.dataset['sentryComponent']) {
            return elem.dataset['sentryComponent'];
          }
          if (elem.dataset['sentryElement']) {
            return elem.dataset['sentryElement'];
          }
        }
      }

      out.push(elem.tagName.toLowerCase());

      // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
      const keyAttrPairs = keyAttrs?.length
        ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])
        : null;

      if (keyAttrPairs?.length) {
        keyAttrPairs.forEach(keyAttrPair => {
          out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
        });
      } else {
        if (elem.id) {
          out.push(`#${elem.id}`);
        }

        const className = elem.className;
        if (className && isString(className)) {
          const classes = className.split(/\s+/);
          for (const c of classes) {
            out.push(`.${c}`);
          }
        }
      }
      const allowedAttrs = ['aria-label', 'type', 'name', 'title', 'alt'];
      for (const k of allowedAttrs) {
        const attr = elem.getAttribute(k);
        if (attr) {
          out.push(`[${k}="${attr}"]`);
        }
      }

      return out.join('');
    }

    /**
     * A safe form of location.href
     */
    function getLocationHref() {
      try {
        return WINDOW$3.document.location.href;
      } catch (oO) {
        return '';
      }
    }

    /**
     * Given a DOM element, traverses up the tree until it finds the first ancestor node
     * that has the `data-sentry-component` or `data-sentry-element` attribute with `data-sentry-component` taking
     * precedence. This attribute is added at build-time by projects that have the component name annotation plugin installed.
     *
     * @returns a string representation of the component for the provided DOM element, or `null` if not found
     */
    function getComponentName(elem) {
      // @ts-expect-error WINDOW has HTMLElement
      if (!WINDOW$3.HTMLElement) {
        return null;
      }

      let currentElem = elem ;
      const MAX_TRAVERSE_HEIGHT = 5;
      for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {
        if (!currentElem) {
          return null;
        }

        if (currentElem instanceof HTMLElement) {
          if (currentElem.dataset['sentryComponent']) {
            return currentElem.dataset['sentryComponent'];
          }
          if (currentElem.dataset['sentryElement']) {
            return currentElem.dataset['sentryElement'];
          }
        }

        currentElem = currentElem.parentNode;
      }

      return null;
    }

    /**
     * Truncates given string to the maximum characters count
     *
     * @param str An object that contains serializable values
     * @param max Maximum number of characters in truncated string (0 = unlimited)
     * @returns string Encoded
     */
    function truncate(str, max = 0) {
      if (typeof str !== 'string' || max === 0) {
        return str;
      }
      return str.length <= max ? str : `${str.slice(0, max)}...`;
    }

    /**
     * Join values in array
     * @param input array of values to be joined together
     * @param delimiter string to be placed in-between values
     * @returns Joined values
     */
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return '';
      }

      const output = [];
      // eslint-disable-next-line @typescript-eslint/prefer-for-of
      for (let i = 0; i < input.length; i++) {
        const value = input[i];
        try {
          // This is a hack to fix a Vue3-specific bug that causes an infinite loop of
          // console warnings. This happens when a Vue template is rendered with
          // an undeclared variable, which we try to stringify, ultimately causing
          // Vue to issue another warning which repeats indefinitely.
          // see: https://github.com/getsentry/sentry-javascript/pull/8981
          if (isVueViewModel(value)) {
            output.push('[VueViewModel]');
          } else {
            output.push(String(value));
          }
        } catch (e) {
          output.push('[value cannot be serialized]');
        }
      }

      return output.join(delimiter);
    }

    /**
     * Checks if the given value matches a regex or string
     *
     * @param value The string to test
     * @param pattern Either a regex or a string against which `value` will be matched
     * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match
     * `pattern` if it contains `pattern`. Only applies to string-type patterns.
     */
    function isMatchingPattern(
      value,
      pattern,
      requireExactStringMatch = false,
    ) {
      if (!isString(value)) {
        return false;
      }

      if (isRegExp(pattern)) {
        return pattern.test(value);
      }
      if (isString(pattern)) {
        return requireExactStringMatch ? value === pattern : value.includes(pattern);
      }

      return false;
    }

    /**
     * Test the given string against an array of strings and regexes. By default, string matching is done on a
     * substring-inclusion basis rather than a strict equality basis
     *
     * @param testString The string to test
     * @param patterns The patterns against which to test the string
     * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to
     * count. If false, `testString` will match a string pattern if it contains that pattern.
     * @returns
     */
    function stringMatchesSomePattern(
      testString,
      patterns = [],
      requireExactStringMatch = false,
    ) {
      return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));
    }

    /**
     * Replace a method in an object with a wrapped version of itself.
     *
     * If the method on the passed object is not a function, the wrapper will not be applied.
     *
     * @param source An object that contains a method to be wrapped.
     * @param name The name of the method to be wrapped.
     * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
     * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
     * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
     * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
     * @returns void
     */
    function fill(source, name, replacementFactory) {
      if (!(name in source)) {
        return;
      }

      // explicitly casting to unknown because we don't know the type of the method initially at all
      const original = source[name] ;

      if (typeof original !== 'function') {
        return;
      }

      const wrapped = replacementFactory(original) ;

      // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
      // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
      if (typeof wrapped === 'function') {
        markFunctionWrapped(wrapped, original);
      }

      try {
        source[name] = wrapped;
      } catch {
        DEBUG_BUILD$2 && logger.log(`Failed to replace method "${name}" in object`, source);
      }
    }

    /**
     * Defines a non-enumerable property on the given object.
     *
     * @param obj The object on which to set the property
     * @param name The name of the property to be set
     * @param value The value to which to set the property
     */
    function addNonEnumerableProperty(obj, name, value) {
      try {
        Object.defineProperty(obj, name, {
          // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
          value: value,
          writable: true,
          configurable: true,
        });
      } catch (o_O) {
        DEBUG_BUILD$2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
      }
    }

    /**
     * Remembers the original function on the wrapped function and
     * patches up the prototype.
     *
     * @param wrapped the wrapper function
     * @param original the original function that gets wrapped
     */
    function markFunctionWrapped(wrapped, original) {
      try {
        const proto = original.prototype || {};
        wrapped.prototype = original.prototype = proto;
        addNonEnumerableProperty(wrapped, '__sentry_original__', original);
      } catch (o_O) {} // eslint-disable-line no-empty
    }

    /**
     * This extracts the original function if available.  See
     * `markFunctionWrapped` for more information.
     *
     * @param func the function to unwrap
     * @returns the unwrapped version of the function if available.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function getOriginalFunction(func) {
      return func.__sentry_original__;
    }

    /**
     * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their
     * non-enumerable properties attached.
     *
     * @param value Initial source that we have to transform in order for it to be usable by the serializer
     * @returns An Event or Error turned into an object - or the value argument itself, when value is neither an Event nor
     *  an Error.
     */
    function convertToPlainObject(value)

     {
      if (isError(value)) {
        return {
          message: value.message,
          name: value.name,
          stack: value.stack,
          ...getOwnProperties(value),
        };
      } else if (isEvent(value)) {
        const newObj

     = {
          type: value.type,
          target: serializeEventTarget(value.target),
          currentTarget: serializeEventTarget(value.currentTarget),
          ...getOwnProperties(value),
        };

        if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {
          newObj.detail = value.detail;
        }

        return newObj;
      } else {
        return value;
      }
    }

    /** Creates a string representation of the target of an `Event` object */
    function serializeEventTarget(target) {
      try {
        return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
      } catch (_oO) {
        return '<unknown>';
      }
    }

    /** Filters out all but an object's own properties */
    function getOwnProperties(obj) {
      if (typeof obj === 'object' && obj !== null) {
        const extractedProps = {};
        for (const property in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, property)) {
            extractedProps[property] = (obj )[property];
          }
        }
        return extractedProps;
      } else {
        return {};
      }
    }

    /**
     * Given any captured exception, extract its keys and create a sorted
     * and truncated list that will be used inside the event message.
     * eg. `Non-error exception captured with keys: foo, bar, baz`
     */
    function extractExceptionKeysForMessage(exception, maxLength = 40) {
      const keys = Object.keys(convertToPlainObject(exception));
      keys.sort();

      const firstKey = keys[0];

      if (!firstKey) {
        return '[object has no keys]';
      }

      if (firstKey.length >= maxLength) {
        return truncate(firstKey, maxLength);
      }

      for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        const serialized = keys.slice(0, includedKeys).join(', ');
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys.length) {
          return serialized;
        }
        return truncate(serialized, maxLength);
      }

      return '';
    }

    function getCrypto() {
      const gbl = GLOBAL_OBJ ;
      return gbl.crypto || gbl.msCrypto;
    }

    /**
     * UUID4 generator
     * @param crypto Object that provides the crypto API.
     * @returns string Generated UUID4.
     */
    function uuid4(crypto = getCrypto()) {
      let getRandomByte = () => Math.random() * 16;
      try {
        if (crypto?.randomUUID) {
          return crypto.randomUUID().replace(/-/g, '');
        }
        if (crypto?.getRandomValues) {
          getRandomByte = () => {
            // crypto.getRandomValues might return undefined instead of the typed array
            // in old Chromium versions (e.g. 23.0.1235.0 (151422))
            // However, `typedArray` is still filled in-place.
            // @see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#typedarray
            const typedArray = new Uint8Array(1);
            crypto.getRandomValues(typedArray);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return typedArray[0];
          };
        }
      } catch (_) {
        // some runtimes can crash invoking crypto
        // https://github.com/getsentry/sentry-javascript/issues/8935
      }

      // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
      // Concatenating the following numbers as strings results in '10000000100040008000100000000000'
      return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>
        // eslint-disable-next-line no-bitwise
        ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),
      );
    }

    function getFirstException(event) {
      return event.exception?.values?.[0];
    }

    /**
     * Extracts either message or type+value from an event that can be used for user-facing logs
     * @returns event's description
     */
    function getEventDescription(event) {
      const { message, event_id: eventId } = event;
      if (message) {
        return message;
      }

      const firstException = getFirstException(event);
      if (firstException) {
        if (firstException.type && firstException.value) {
          return `${firstException.type}: ${firstException.value}`;
        }
        return firstException.type || firstException.value || eventId || '<unknown>';
      }
      return eventId || '<unknown>';
    }

    /**
     * Adds exception values, type and value to an synthetic Exception.
     * @param event The event to modify.
     * @param value Value of the exception.
     * @param type Type of the exception.
     * @hidden
     */
    function addExceptionTypeValue(event, value, type) {
      const exception = (event.exception = event.exception || {});
      const values = (exception.values = exception.values || []);
      const firstException = (values[0] = values[0] || {});
      if (!firstException.value) {
        firstException.value = value || '';
      }
      if (!firstException.type) {
        firstException.type = type || 'Error';
      }
    }

    /**
     * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
     *
     * @param event The event to modify.
     * @param newMechanism Mechanism data to add to the event.
     * @hidden
     */
    function addExceptionMechanism(event, newMechanism) {
      const firstException = getFirstException(event);
      if (!firstException) {
        return;
      }

      const defaultMechanism = { type: 'generic', handled: true };
      const currentMechanism = firstException.mechanism;
      firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };

      if (newMechanism && 'data' in newMechanism) {
        const mergedData = { ...currentMechanism?.data, ...newMechanism.data };
        firstException.mechanism.data = mergedData;
      }
    }

    /**
     * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
     * in question), and marks it captured if not.
     *
     * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
     * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
     * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
     * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
     * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
     * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
     * see it.
     *
     * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
     * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
     * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
     * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
     * must be done before the exception captured.
     *
     * @param A thrown exception to check or flag as having been seen
     * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
     */
    function checkOrSetAlreadyCaught(exception) {
      if (isAlreadyCaptured(exception)) {
        return true;
      }

      try {
        // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
        // `ExtraErrorData` integration
        addNonEnumerableProperty(exception , '__sentry_captured__', true);
      } catch (err) {
        // `exception` is a primitive, so we can't mark it seen
      }

      return false;
    }

    function isAlreadyCaptured(exception) {
      try {
        return (exception ).__sentry_captured__;
      } catch {} // eslint-disable-line no-empty
    }

    const ONE_SECOND_IN_MS = 1000;

    /**
     * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}
     * for accessing a high-resolution monotonic clock.
     */

    /**
     * Returns a timestamp in seconds since the UNIX epoch using the Date API.
     */
    function dateTimestampInSeconds() {
      return Date.now() / ONE_SECOND_IN_MS;
    }

    /**
     * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
     * support the API.
     *
     * Wrapping the native API works around differences in behavior from different browsers.
     */
    function createUnixTimestampInSecondsFunc() {
      const { performance } = GLOBAL_OBJ ;
      if (!performance?.now) {
        return dateTimestampInSeconds;
      }

      // Some browser and environments don't have a timeOrigin, so we fallback to
      // using Date.now() to compute the starting time.
      const approxStartingTimeOrigin = Date.now() - performance.now();
      const timeOrigin = performance.timeOrigin == undefined ? approxStartingTimeOrigin : performance.timeOrigin;

      // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current
      // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.
      //
      // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the
      // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and
      // correct for this.
      // See: https://github.com/getsentry/sentry-javascript/issues/2590
      // See: https://github.com/mdn/content/issues/4713
      // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6
      return () => {
        return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;
      };
    }

    /**
     * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
     * availability of the Performance API.
     *
     * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
     * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
     * skew can grow to arbitrary amounts like days, weeks or months.
     * See https://github.com/getsentry/sentry-javascript/issues/2590.
     */
    const timestampInSeconds = createUnixTimestampInSecondsFunc();

    /**
     * Creates a new `Session` object by setting certain default parameters. If optional @param context
     * is passed, the passed properties are applied to the session object.
     *
     * @param context (optional) additional properties to be applied to the returned session object
     *
     * @returns a new `Session` object
     */
    function makeSession(context) {
      // Both timestamp and started are in seconds since the UNIX epoch.
      const startingTime = timestampInSeconds();

      const session = {
        sid: uuid4(),
        init: true,
        timestamp: startingTime,
        started: startingTime,
        duration: 0,
        status: 'ok',
        errors: 0,
        ignoreDuration: false,
        toJSON: () => sessionToJSON(session),
      };

      if (context) {
        updateSession(session, context);
      }

      return session;
    }

    /**
     * Updates a session object with the properties passed in the context.
     *
     * Note that this function mutates the passed object and returns void.
     * (Had to do this instead of returning a new and updated session because closing and sending a session
     * makes an update to the session after it was passed to the sending logic.
     * @see Client.captureSession )
     *
     * @param session the `Session` to update
     * @param context the `SessionContext` holding the properties that should be updated in @param session
     */
    // eslint-disable-next-line complexity
    function updateSession(session, context = {}) {
      if (context.user) {
        if (!session.ipAddress && context.user.ip_address) {
          session.ipAddress = context.user.ip_address;
        }

        if (!session.did && !context.did) {
          session.did = context.user.id || context.user.email || context.user.username;
        }
      }

      session.timestamp = context.timestamp || timestampInSeconds();

      if (context.abnormal_mechanism) {
        session.abnormal_mechanism = context.abnormal_mechanism;
      }

      if (context.ignoreDuration) {
        session.ignoreDuration = context.ignoreDuration;
      }
      if (context.sid) {
        // Good enough uuid validation. — Kamil
        session.sid = context.sid.length === 32 ? context.sid : uuid4();
      }
      if (context.init !== undefined) {
        session.init = context.init;
      }
      if (!session.did && context.did) {
        session.did = `${context.did}`;
      }
      if (typeof context.started === 'number') {
        session.started = context.started;
      }
      if (session.ignoreDuration) {
        session.duration = undefined;
      } else if (typeof context.duration === 'number') {
        session.duration = context.duration;
      } else {
        const duration = session.timestamp - session.started;
        session.duration = duration >= 0 ? duration : 0;
      }
      if (context.release) {
        session.release = context.release;
      }
      if (context.environment) {
        session.environment = context.environment;
      }
      if (!session.ipAddress && context.ipAddress) {
        session.ipAddress = context.ipAddress;
      }
      if (!session.userAgent && context.userAgent) {
        session.userAgent = context.userAgent;
      }
      if (typeof context.errors === 'number') {
        session.errors = context.errors;
      }
      if (context.status) {
        session.status = context.status;
      }
    }

    /**
     * Closes a session by setting its status and updating the session object with it.
     * Internally calls `updateSession` to update the passed session object.
     *
     * Note that this function mutates the passed session (@see updateSession for explanation).
     *
     * @param session the `Session` object to be closed
     * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,
     *               this function will keep the previously set status, unless it was `'ok'` in which case
     *               it is changed to `'exited'`.
     */
    function closeSession(session, status) {
      let context = {};
      if (status) {
        context = { status };
      } else if (session.status === 'ok') {
        context = { status: 'exited' };
      }

      updateSession(session, context);
    }

    /**
     * Serializes a passed session object to a JSON object with a slightly different structure.
     * This is necessary because the Sentry backend requires a slightly different schema of a session
     * than the one the JS SDKs use internally.
     *
     * @param session the session to be converted
     *
     * @returns a JSON object of the passed session
     */
    function sessionToJSON(session) {
      return {
        sid: `${session.sid}`,
        init: session.init,
        // Make sure that sec is converted to ms for date constructor
        started: new Date(session.started * 1000).toISOString(),
        timestamp: new Date(session.timestamp * 1000).toISOString(),
        status: session.status,
        errors: session.errors,
        did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,
        duration: session.duration,
        abnormal_mechanism: session.abnormal_mechanism,
        attrs: {
          release: session.release,
          environment: session.environment,
          ip_address: session.ipAddress,
          user_agent: session.userAgent,
        },
      };
    }

    /**
     * Generate a random, valid trace ID.
     */
    function generateTraceId() {
      return uuid4();
    }

    /**
     * Generate a random, valid span ID.
     */
    function generateSpanId() {
      return uuid4().substring(16);
    }

    /**
     * Shallow merge two objects.
     * Does not mutate the passed in objects.
     * Undefined/empty values in the merge object will overwrite existing values.
     *
     * By default, this merges 2 levels deep.
     */
    function merge(initialObj, mergeObj, levels = 2) {
      // If the merge value is not an object, or we have no merge levels left,
      // we just set the value to the merge value
      if (!mergeObj || typeof mergeObj !== 'object' || levels <= 0) {
        return mergeObj;
      }

      // If the merge object is an empty object, and the initial object is not undefined, we return the initial object
      if (initialObj && Object.keys(mergeObj).length === 0) {
        return initialObj;
      }

      // Clone object
      const output = { ...initialObj };

      // Merge values into output, resursively
      for (const key in mergeObj) {
        if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
          output[key] = merge(output[key], mergeObj[key], levels - 1);
        }
      }

      return output;
    }

    const SCOPE_SPAN_FIELD = '_sentrySpan';

    /**
     * Set the active span for a given scope.
     * NOTE: This should NOT be used directly, but is only used internally by the trace methods.
     */
    function _setSpanForScope(scope, span) {
      if (span) {
        addNonEnumerableProperty(scope , SCOPE_SPAN_FIELD, span);
      } else {
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete (scope )[SCOPE_SPAN_FIELD];
      }
    }

    /**
     * Get the active span for a given scope.
     * NOTE: This should NOT be used directly, but is only used internally by the trace methods.
     */
    function _getSpanForScope(scope) {
      return scope[SCOPE_SPAN_FIELD];
    }

    /**
     * Default value for maximum number of breadcrumbs added to an event.
     */
    const DEFAULT_MAX_BREADCRUMBS = 100;

    /**
     * A context to be used for capturing an event.
     * This can either be a Scope, or a partial ScopeContext,
     * or a callback that receives the current scope and returns a new scope to use.
     */

    /**
     * Holds additional event information.
     */
    class Scope {
      /** Flag if notifying is happening. */

      /** Callback for client to receive scope changes. */

      /** Callback list that will be called during event processing. */

      /** Array of breadcrumbs. */

      /** User */

      /** Tags */

      /** Extra */

      /** Contexts */

      /** Attachments */

      /** Propagation Context for distributed tracing */

      /**
       * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
       * sent to Sentry
       */

      /** Fingerprint */

      /** Severity */

      /**
       * Transaction Name
       *
       * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
       * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
       */

      /** Session */

      /** The client on this scope */

      /** Contains the last event id of a captured event.  */

      // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.

       constructor() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._attachments = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
        this._propagationContext = {
          traceId: generateTraceId(),
          sampleRand: Math.random(),
        };
      }

      /**
       * Clone all data from this scope into a new scope.
       */
       clone() {
        const newScope = new Scope();
        newScope._breadcrumbs = [...this._breadcrumbs];
        newScope._tags = { ...this._tags };
        newScope._extra = { ...this._extra };
        newScope._contexts = { ...this._contexts };
        if (this._contexts.flags) {
          // We need to copy the `values` array so insertions on a cloned scope
          // won't affect the original array.
          newScope._contexts.flags = {
            values: [...this._contexts.flags.values],
          };
        }

        newScope._user = this._user;
        newScope._level = this._level;
        newScope._session = this._session;
        newScope._transactionName = this._transactionName;
        newScope._fingerprint = this._fingerprint;
        newScope._eventProcessors = [...this._eventProcessors];
        newScope._attachments = [...this._attachments];
        newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
        newScope._propagationContext = { ...this._propagationContext };
        newScope._client = this._client;
        newScope._lastEventId = this._lastEventId;

        _setSpanForScope(newScope, _getSpanForScope(this));

        return newScope;
      }

      /**
       * Update the client assigned to this scope.
       * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,
       * as well as manually created scopes.
       */
       setClient(client) {
        this._client = client;
      }

      /**
       * Set the ID of the last captured error event.
       * This is generally only captured on the isolation scope.
       */
       setLastEventId(lastEventId) {
        this._lastEventId = lastEventId;
      }

      /**
       * Get the client assigned to this scope.
       */
       getClient() {
        return this._client ;
      }

      /**
       * Get the ID of the last captured error event.
       * This is generally only available on the isolation scope.
       */
       lastEventId() {
        return this._lastEventId;
      }

      /**
       * @inheritDoc
       */
       addScopeListener(callback) {
        this._scopeListeners.push(callback);
      }

      /**
       * Add an event processor that will be called before an event is sent.
       */
       addEventProcessor(callback) {
        this._eventProcessors.push(callback);
        return this;
      }

      /**
       * Set the user for this scope.
       * Set to `null` to unset the user.
       */
       setUser(user) {
        // If null is passed we want to unset everything, but still define keys,
        // so that later down in the pipeline any existing values are cleared.
        this._user = user || {
          email: undefined,
          id: undefined,
          ip_address: undefined,
          username: undefined,
        };

        if (this._session) {
          updateSession(this._session, { user });
        }

        this._notifyScopeListeners();
        return this;
      }

      /**
       * Get the user from this scope.
       */
       getUser() {
        return this._user;
      }

      /**
       * Set an object that will be merged into existing tags on the scope,
       * and will be sent as tags data with the event.
       */
       setTags(tags) {
        this._tags = {
          ...this._tags,
          ...tags,
        };
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Set a single tag that will be sent as tags data with the event.
       */
       setTag(key, value) {
        this._tags = { ...this._tags, [key]: value };
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Set an object that will be merged into existing extra on the scope,
       * and will be sent as extra data with the event.
       */
       setExtras(extras) {
        this._extra = {
          ...this._extra,
          ...extras,
        };
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Set a single key:value extra entry that will be sent as extra data with the event.
       */
       setExtra(key, extra) {
        this._extra = { ...this._extra, [key]: extra };
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Sets the fingerprint on the scope to send with the events.
       * @param {string[]} fingerprint Fingerprint to group events in Sentry.
       */
       setFingerprint(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Sets the level on the scope for future events.
       */
       setLevel(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Sets the transaction name on the scope so that the name of e.g. taken server route or
       * the page location is attached to future events.
       *
       * IMPORTANT: Calling this function does NOT change the name of the currently active
       * root span. If you want to change the name of the active root span, use
       * `Sentry.updateSpanName(rootSpan, 'new name')` instead.
       *
       * By default, the SDK updates the scope's transaction name automatically on sensible
       * occasions, such as a page navigation or when handling a new request on the server.
       */
       setTransactionName(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Sets context data with the given name.
       * Data passed as context will be normalized. You can also pass `null` to unset the context.
       * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.
       */
       setContext(key, context) {
        if (context === null) {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete this._contexts[key];
        } else {
          this._contexts[key] = context;
        }

        this._notifyScopeListeners();
        return this;
      }

      /**
       * Set the session for the scope.
       */
       setSession(session) {
        if (!session) {
          delete this._session;
        } else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Get the session from the scope.
       */
       getSession() {
        return this._session;
      }

      /**
       * Updates the scope with provided data. Can work in three variations:
       * - plain object containing updatable attributes
       * - Scope instance that'll extract the attributes from
       * - callback function that'll receive the current scope as an argument and allow for modifications
       */
       update(captureContext) {
        if (!captureContext) {
          return this;
        }

        const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;

        const scopeInstance =
          scopeToMerge instanceof Scope
            ? scopeToMerge.getScopeData()
            : isPlainObject(scopeToMerge)
              ? (captureContext )
              : undefined;

        const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};

        this._tags = { ...this._tags, ...tags };
        this._extra = { ...this._extra, ...extra };
        this._contexts = { ...this._contexts, ...contexts };

        if (user && Object.keys(user).length) {
          this._user = user;
        }

        if (level) {
          this._level = level;
        }

        if (fingerprint.length) {
          this._fingerprint = fingerprint;
        }

        if (propagationContext) {
          this._propagationContext = propagationContext;
        }

        return this;
      }

      /**
       * Clears the current scope and resets its properties.
       * Note: The client will not be cleared.
       */
       clear() {
        // client is not cleared here on purpose!
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._session = undefined;
        _setSpanForScope(this, undefined);
        this._attachments = [];
        this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });

        this._notifyScopeListeners();
        return this;
      }

      /**
       * Adds a breadcrumb to the scope.
       * By default, the last 100 breadcrumbs are kept.
       */
       addBreadcrumb(breadcrumb, maxBreadcrumbs) {
        const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;

        // No data has been changed, so don't notify scope listeners
        if (maxCrumbs <= 0) {
          return this;
        }

        const mergedBreadcrumb = {
          timestamp: dateTimestampInSeconds(),
          ...breadcrumb,
          // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory
          message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message,
        };

        this._breadcrumbs.push(mergedBreadcrumb);
        if (this._breadcrumbs.length > maxCrumbs) {
          this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);
          this._client?.recordDroppedEvent('buffer_overflow', 'log_item');
        }

        this._notifyScopeListeners();

        return this;
      }

      /**
       * Get the last breadcrumb of the scope.
       */
       getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
      }

      /**
       * Clear all breadcrumbs from the scope.
       */
       clearBreadcrumbs() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      }

      /**
       * Add an attachment to the scope.
       */
       addAttachment(attachment) {
        this._attachments.push(attachment);
        return this;
      }

      /**
       * Clear all attachments from the scope.
       */
       clearAttachments() {
        this._attachments = [];
        return this;
      }

      /**
       * Get the data of this scope, which should be applied to an event during processing.
       */
       getScopeData() {
        return {
          breadcrumbs: this._breadcrumbs,
          attachments: this._attachments,
          contexts: this._contexts,
          tags: this._tags,
          extra: this._extra,
          user: this._user,
          level: this._level,
          fingerprint: this._fingerprint || [],
          eventProcessors: this._eventProcessors,
          propagationContext: this._propagationContext,
          sdkProcessingMetadata: this._sdkProcessingMetadata,
          transactionName: this._transactionName,
          span: _getSpanForScope(this),
        };
      }

      /**
       * Add data which will be accessible during event processing but won't get sent to Sentry.
       */
       setSDKProcessingMetadata(newData) {
        this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
        return this;
      }

      /**
       * Add propagation context to the scope, used for distributed tracing
       */
       setPropagationContext(context) {
        this._propagationContext = context;
        return this;
      }

      /**
       * Get propagation context from the scope, used for distributed tracing
       */
       getPropagationContext() {
        return this._propagationContext;
      }

      /**
       * Capture an exception for this scope.
       *
       * @returns {string} The id of the captured Sentry event.
       */
       captureException(exception, hint) {
        const eventId = hint?.event_id || uuid4();

        if (!this._client) {
          logger.warn('No client configured on scope - will not capture exception!');
          return eventId;
        }

        const syntheticException = new Error('Sentry syntheticException');

        this._client.captureException(
          exception,
          {
            originalException: exception,
            syntheticException,
            ...hint,
            event_id: eventId,
          },
          this,
        );

        return eventId;
      }

      /**
       * Capture a message for this scope.
       *
       * @returns {string} The id of the captured message.
       */
       captureMessage(message, level, hint) {
        const eventId = hint?.event_id || uuid4();

        if (!this._client) {
          logger.warn('No client configured on scope - will not capture message!');
          return eventId;
        }

        const syntheticException = new Error(message);

        this._client.captureMessage(
          message,
          level,
          {
            originalException: message,
            syntheticException,
            ...hint,
            event_id: eventId,
          },
          this,
        );

        return eventId;
      }

      /**
       * Capture a Sentry event for this scope.
       *
       * @returns {string} The id of the captured event.
       */
       captureEvent(event, hint) {
        const eventId = hint?.event_id || uuid4();

        if (!this._client) {
          logger.warn('No client configured on scope - will not capture event!');
          return eventId;
        }

        this._client.captureEvent(event, { ...hint, event_id: eventId }, this);

        return eventId;
      }

      /**
       * This will be called on every set call.
       */
       _notifyScopeListeners() {
        // We need this check for this._notifyingListeners to be able to work on scope during updates
        // If this check is not here we'll produce endless recursion when something is done with the scope
        // during the callback.
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(callback => {
            callback(this);
          });
          this._notifyingListeners = false;
        }
      }
    }

    /** Get the default current scope. */
    function getDefaultCurrentScope() {
      return getGlobalSingleton('defaultCurrentScope', () => new Scope());
    }

    /** Get the default isolation scope. */
    function getDefaultIsolationScope() {
      return getGlobalSingleton('defaultIsolationScope', () => new Scope());
    }

    /**
     * This is an object that holds a stack of scopes.
     */
    class AsyncContextStack {

       constructor(scope, isolationScope) {
        let assignedScope;
        if (!scope) {
          assignedScope = new Scope();
        } else {
          assignedScope = scope;
        }

        let assignedIsolationScope;
        if (!isolationScope) {
          assignedIsolationScope = new Scope();
        } else {
          assignedIsolationScope = isolationScope;
        }

        // scope stack for domains or the process
        this._stack = [{ scope: assignedScope }];
        this._isolationScope = assignedIsolationScope;
      }

      /**
       * Fork a scope for the stack.
       */
       withScope(callback) {
        const scope = this._pushScope();

        let maybePromiseResult;
        try {
          maybePromiseResult = callback(scope);
        } catch (e) {
          this._popScope();
          throw e;
        }

        if (isThenable(maybePromiseResult)) {
          // @ts-expect-error - isThenable returns the wrong type
          return maybePromiseResult.then(
            res => {
              this._popScope();
              return res;
            },
            e => {
              this._popScope();
              throw e;
            },
          );
        }

        this._popScope();
        return maybePromiseResult;
      }

      /**
       * Get the client of the stack.
       */
       getClient() {
        return this.getStackTop().client ;
      }

      /**
       * Returns the scope of the top stack.
       */
       getScope() {
        return this.getStackTop().scope;
      }

      /**
       * Get the isolation scope for the stack.
       */
       getIsolationScope() {
        return this._isolationScope;
      }

      /**
       * Returns the topmost scope layer in the order domain > local > process.
       */
       getStackTop() {
        return this._stack[this._stack.length - 1] ;
      }

      /**
       * Push a scope to the stack.
       */
       _pushScope() {
        // We want to clone the content of prev scope
        const scope = this.getScope().clone();
        this._stack.push({
          client: this.getClient(),
          scope,
        });
        return scope;
      }

      /**
       * Pop a scope from the stack.
       */
       _popScope() {
        if (this._stack.length <= 1) return false;
        return !!this._stack.pop();
      }
    }

    /**
     * Get the global async context stack.
     * This will be removed during the v8 cycle and is only here to make migration easier.
     */
    function getAsyncContextStack() {
      const registry = getMainCarrier();
      const sentry = getSentryCarrier(registry);

      return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));
    }

    function withScope$1(callback) {
      return getAsyncContextStack().withScope(callback);
    }

    function withSetScope(scope, callback) {
      const stack = getAsyncContextStack() ;
      return stack.withScope(() => {
        stack.getStackTop().scope = scope;
        return callback(scope);
      });
    }

    function withIsolationScope(callback) {
      return getAsyncContextStack().withScope(() => {
        return callback(getAsyncContextStack().getIsolationScope());
      });
    }

    /**
     * Get the stack-based async context strategy.
     */
    function getStackAsyncContextStrategy() {
      return {
        withIsolationScope,
        withScope: withScope$1,
        withSetScope,
        withSetIsolationScope: (_isolationScope, callback) => {
          return withIsolationScope(callback);
        },
        getCurrentScope: () => getAsyncContextStack().getScope(),
        getIsolationScope: () => getAsyncContextStack().getIsolationScope(),
      };
    }

    /**
     * Get the current async context strategy.
     * If none has been setup, the default will be used.
     */
    function getAsyncContextStrategy(carrier) {
      const sentry = getSentryCarrier(carrier);

      if (sentry.acs) {
        return sentry.acs;
      }

      // Otherwise, use the default one (stack)
      return getStackAsyncContextStrategy();
    }

    /**
     * Get the currently active scope.
     */
    function getCurrentScope() {
      const carrier = getMainCarrier();
      const acs = getAsyncContextStrategy(carrier);
      return acs.getCurrentScope();
    }

    /**
     * Get the currently active isolation scope.
     * The isolation scope is active for the current execution context.
     */
    function getIsolationScope() {
      const carrier = getMainCarrier();
      const acs = getAsyncContextStrategy(carrier);
      return acs.getIsolationScope();
    }

    /**
     * Get the global scope.
     * This scope is applied to _all_ events.
     */
    function getGlobalScope() {
      return getGlobalSingleton('globalScope', () => new Scope());
    }

    /**
     * Creates a new scope with and executes the given operation within.
     * The scope is automatically removed once the operation
     * finishes or throws.
     */

    /**
     * Either creates a new active scope, or sets the given scope as active scope in the given callback.
     */
    function withScope(
      ...rest
    ) {
      const carrier = getMainCarrier();
      const acs = getAsyncContextStrategy(carrier);

      // If a scope is defined, we want to make this the active scope instead of the default one
      if (rest.length === 2) {
        const [scope, callback] = rest;

        if (!scope) {
          return acs.withScope(callback);
        }

        return acs.withSetScope(scope, callback);
      }

      return acs.withScope(rest[0]);
    }

    /**
     * Get the currently active client.
     */
    function getClient() {
      return getCurrentScope().getClient();
    }

    /**
     * Get a trace context for the given scope.
     */
    function getTraceContextFromScope(scope) {
      const propagationContext = scope.getPropagationContext();

      const { traceId, parentSpanId, propagationSpanId } = propagationContext;

      const traceContext = {
        trace_id: traceId,
        span_id: propagationSpanId || generateSpanId(),
      };

      if (parentSpanId) {
        traceContext.parent_span_id = parentSpanId;
      }

      return traceContext;
    }

    /**
     * Use this attribute to represent the source of a span.
     * Should be one of: custom, url, route, view, component, task, unknown
     *
     */
    const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source';

    /**
     * Attributes that holds the sample rate that was locally applied to a span.
     * If this attribute is not defined, it means that the span inherited a sampling decision.
     *
     * NOTE: Is only defined on root spans.
     */
    const SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate';

    /**
     * Use this attribute to represent the operation of a span.
     */
    const SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op';

    /**
     * Use this attribute to represent the origin of a span.
     */
    const SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin';

    /**
     * The id of the profile that this span occurred in.
     */
    const SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id';

    const SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time';

    const SPAN_STATUS_UNSET = 0;
    const SPAN_STATUS_OK = 1;

    const SCOPE_ON_START_SPAN_FIELD = '_sentryScope';
    const ISOLATION_SCOPE_ON_START_SPAN_FIELD = '_sentryIsolationScope';

    /**
     * Grabs the scope and isolation scope off a span that were active when the span was started.
     */
    function getCapturedScopesOnSpan(span) {
      return {
        scope: (span )[SCOPE_ON_START_SPAN_FIELD],
        isolationScope: (span )[ISOLATION_SCOPE_ON_START_SPAN_FIELD],
      };
    }

    /**
     * Parse a sample rate from a given value.
     * This will either return a boolean or number sample rate, if the sample rate is valid (between 0 and 1).
     * If a string is passed, we try to convert it to a number.
     *
     * Any invalid sample rate will return `undefined`.
     */
    function parseSampleRate(sampleRate) {
      if (typeof sampleRate === 'boolean') {
        return Number(sampleRate);
      }

      const rate = typeof sampleRate === 'string' ? parseFloat(sampleRate) : sampleRate;
      if (typeof rate !== 'number' || isNaN(rate) || rate < 0 || rate > 1) {
        return undefined;
      }

      return rate;
    }

    const SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';

    const SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;

    /**
     * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the "sentry-" prefixed values
     * from it.
     *
     * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.
     * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.
     */
    function baggageHeaderToDynamicSamplingContext(
      // Very liberal definition of what any incoming header might look like
      baggageHeader,
    ) {
      const baggageObject = parseBaggageHeader(baggageHeader);

      if (!baggageObject) {
        return undefined;
      }

      // Read all "sentry-" prefixed values out of the baggage object and put it onto a dynamic sampling context object.
      const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
        if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
          const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
          acc[nonPrefixedKey] = value;
        }
        return acc;
      }, {});

      // Only return a dynamic sampling context object if there are keys in it.
      // A keyless object means there were no sentry values on the header, which means that there is no DSC.
      if (Object.keys(dynamicSamplingContext).length > 0) {
        return dynamicSamplingContext ;
      } else {
        return undefined;
      }
    }

    /**
     * Take a baggage header and parse it into an object.
     */
    function parseBaggageHeader(
      baggageHeader,
    ) {
      if (!baggageHeader || (!isString(baggageHeader) && !Array.isArray(baggageHeader))) {
        return undefined;
      }

      if (Array.isArray(baggageHeader)) {
        // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it
        return baggageHeader.reduce((acc, curr) => {
          const currBaggageObject = baggageHeaderToObject(curr);
          Object.entries(currBaggageObject).forEach(([key, value]) => {
            acc[key] = value;
          });
          return acc;
        }, {});
      }

      return baggageHeaderToObject(baggageHeader);
    }

    /**
     * Will parse a baggage header, which is a simple key-value map, into a flat object.
     *
     * @param baggageHeader The baggage header to parse.
     * @returns a flat object containing all the key-value pairs from `baggageHeader`.
     */
    function baggageHeaderToObject(baggageHeader) {
      return baggageHeader
        .split(',')
        .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))
        .reduce((acc, [key, value]) => {
          if (key && value) {
            acc[key] = value;
          }
          return acc;
        }, {});
    }

    const TRACE_FLAG_SAMPLED = 0x1;

    let hasShownSpanDropWarning = false;

    /**
     * Convert a span to a trace context, which can be sent as the `trace` context in a non-transaction event.
     */
    function spanToTraceContext(span) {
      const { spanId, traceId: trace_id, isRemote } = span.spanContext();

      // If the span is remote, we use a random/virtual span as span_id to the trace context,
      // and the remote span as parent_span_id
      const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;
      const scope = getCapturedScopesOnSpan(span).scope;

      const span_id = isRemote ? scope?.getPropagationContext().propagationSpanId || generateSpanId() : spanId;

      return {
        parent_span_id,
        span_id,
        trace_id,
      };
    }

    /**
     *  Converts the span links array to a flattened version to be sent within an envelope.
     *
     *  If the links array is empty, it returns `undefined` so the empty value can be dropped before it's sent.
     */
    function convertSpanLinksForEnvelope(links) {
      if (links && links.length > 0) {
        return links.map(({ context: { spanId, traceId, traceFlags, ...restContext }, attributes }) => ({
          span_id: spanId,
          trace_id: traceId,
          sampled: traceFlags === TRACE_FLAG_SAMPLED,
          attributes,
          ...restContext,
        }));
      } else {
        return undefined;
      }
    }

    /**
     * Convert a span time input into a timestamp in seconds.
     */
    function spanTimeInputToSeconds(input) {
      if (typeof input === 'number') {
        return ensureTimestampInSeconds(input);
      }

      if (Array.isArray(input)) {
        // See {@link HrTime} for the array-based time format
        return input[0] + input[1] / 1e9;
      }

      if (input instanceof Date) {
        return ensureTimestampInSeconds(input.getTime());
      }

      return timestampInSeconds();
    }

    /**
     * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.
     */
    function ensureTimestampInSeconds(timestamp) {
      const isMs = timestamp > 9999999999;
      return isMs ? timestamp / 1000 : timestamp;
    }

    /**
     * Convert a span to a JSON representation.
     */
    // Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).
    // This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.
    // And `spanToJSON` needs the Span class from `span.ts` to check here.
    function spanToJSON(span) {
      if (spanIsSentrySpan(span)) {
        return span.getSpanJSON();
      }

      const { spanId: span_id, traceId: trace_id } = span.spanContext();

      // Handle a span from @opentelemetry/sdk-base-trace's `Span` class
      if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
        const { attributes, startTime, name, endTime, parentSpanId, status, links } = span;

        return {
          span_id,
          trace_id,
          data: attributes,
          description: name,
          parent_span_id: parentSpanId,
          start_timestamp: spanTimeInputToSeconds(startTime),
          // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
          timestamp: spanTimeInputToSeconds(endTime) || undefined,
          status: getStatusMessage(status),
          op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
          origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ,
          links: convertSpanLinksForEnvelope(links),
        };
      }

      // Finally, at least we have `spanContext()`....
      // This should not actually happen in reality, but we need to handle it for type safety.
      return {
        span_id,
        trace_id,
        start_timestamp: 0,
        data: {},
      };
    }

    function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
      const castSpan = span ;
      return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
    }

    /** Exported only for tests. */

    /**
     * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.
     * :( So instead we approximate this by checking if it has the `getSpanJSON` method.
     */
    function spanIsSentrySpan(span) {
      return typeof (span ).getSpanJSON === 'function';
    }

    /**
     * Returns true if a span is sampled.
     * In most cases, you should just use `span.isRecording()` instead.
     * However, this has a slightly different semantic, as it also returns false if the span is finished.
     * So in the case where this distinction is important, use this method.
     */
    function spanIsSampled(span) {
      // We align our trace flags with the ones OpenTelemetry use
      // So we also check for sampled the same way they do.
      const { traceFlags } = span.spanContext();
      return traceFlags === TRACE_FLAG_SAMPLED;
    }

    /** Get the status message to use for a JSON representation of a span. */
    function getStatusMessage(status) {
      if (!status || status.code === SPAN_STATUS_UNSET) {
        return undefined;
      }

      if (status.code === SPAN_STATUS_OK) {
        return 'ok';
      }

      return status.message || 'unknown_error';
    }
    const ROOT_SPAN_FIELD = '_sentryRootSpan';

    /**
     * Returns the root span of a given span.
     */
    function getRootSpan(span) {
      return span[ROOT_SPAN_FIELD] || span;
    }

    /**
     * Logs a warning once if `beforeSendSpan` is used to drop spans.
     */
    function showSpanDropWarning() {
      if (!hasShownSpanDropWarning) {
        consoleSandbox(() => {
          // eslint-disable-next-line no-console
          console.warn(
            '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.',
          );
        });
        hasShownSpanDropWarning = true;
      }
    }

    // Treeshakable guard to remove all code related to tracing

    /**
     * Determines if span recording is currently enabled.
     *
     * Spans are recorded when at least one of `tracesSampleRate` and `tracesSampler`
     * is defined in the SDK config. This function does not make any assumption about
     * sampling decisions, it only checks if the SDK is configured to record spans.
     *
     * Important: This function only determines if span recording is enabled. Trace
     * continuation and propagation is separately controlled and not covered by this function.
     * If this function returns `false`, traces can still be propagated (which is what
     * we refer to by "Tracing without Performance")
     * @see https://develop.sentry.dev/sdk/telemetry/traces/tracing-without-performance/
     *
     * @param maybeOptions An SDK options object to be passed to this function.
     * If this option is not provided, the function will use the current client's options.
     */
    function hasSpansEnabled(
      maybeOptions,
    ) {
      if (typeof __SENTRY_TRACING__ === 'boolean' && !__SENTRY_TRACING__) {
        return false;
      }

      const options = maybeOptions || getClient()?.getOptions();
      return (
        !!options &&
        // Note: This check is `!= null`, meaning "nullish". `0` is not "nullish", `undefined` and `null` are. (This comment was brought to you by 15 minutes of questioning life)
        (options.tracesSampleRate != null || !!options.tracesSampler)
      );
    }

    const DEFAULT_ENVIRONMENT = 'production';

    /**
     * If you change this value, also update the terser plugin config to
     * avoid minification of the object property!
     */
    const FROZEN_DSC_FIELD = '_frozenDsc';

    /**
     * Creates a dynamic sampling context from a client.
     *
     * Dispatches the `createDsc` lifecycle hook as a side effect.
     */
    function getDynamicSamplingContextFromClient(trace_id, client) {
      const options = client.getOptions();

      const { publicKey: public_key } = client.getDsn() || {};

      // Instead of conditionally adding non-undefined values, we add them and then remove them if needed
      // otherwise, the order of baggage entries changes, which "breaks" a bunch of tests etc.
      const dsc = {
        environment: options.environment || DEFAULT_ENVIRONMENT,
        release: options.release,
        public_key,
        trace_id,
      };

      client.emit('createDsc', dsc);

      return dsc;
    }

    /**
     * Get the dynamic sampling context for the currently active scopes.
     */
    function getDynamicSamplingContextFromScope(client, scope) {
      const propagationContext = scope.getPropagationContext();
      return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);
    }

    /**
     * Creates a dynamic sampling context from a span (and client and scope)
     *
     * @param span the span from which a few values like the root span name and sample rate are extracted.
     *
     * @returns a dynamic sampling context
     */
    function getDynamicSamplingContextFromSpan(span) {
      const client = getClient();
      if (!client) {
        return {};
      }

      const rootSpan = getRootSpan(span);
      const rootSpanJson = spanToJSON(rootSpan);
      const rootSpanAttributes = rootSpanJson.data;
      const traceState = rootSpan.spanContext().traceState;

      // The span sample rate that was locally applied to the root span should also always be applied to the DSC, even if the DSC is frozen.
      // This is so that the downstream traces/services can use parentSampleRate in their `tracesSampler` to make consistent sampling decisions across the entire trace.
      const rootSpanSampleRate =
        traceState?.get('sentry.sample_rate') ?? rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
      function applyLocalSampleRateToDsc(dsc) {
        if (typeof rootSpanSampleRate === 'number' || typeof rootSpanSampleRate === 'string') {
          dsc.sample_rate = `${rootSpanSampleRate}`;
        }
        return dsc;
      }

      // For core implementation, we freeze the DSC onto the span as a non-enumerable property
      const frozenDsc = (rootSpan )[FROZEN_DSC_FIELD];
      if (frozenDsc) {
        return applyLocalSampleRateToDsc(frozenDsc);
      }

      // For OpenTelemetry, we freeze the DSC on the trace state
      const traceStateDsc = traceState?.get('sentry.dsc');

      // If the span has a DSC, we want it to take precedence
      const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);

      if (dscOnTraceState) {
        return applyLocalSampleRateToDsc(dscOnTraceState);
      }

      // Else, we generate it from the span
      const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);

      // We don't want to have a transaction name in the DSC if the source is "url" because URLs might contain PII
      const source = rootSpanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];

      // after JSON conversion, txn.name becomes jsonSpan.description
      const name = rootSpanJson.description;
      if (source !== 'url' && name) {
        dsc.transaction = name;
      }

      // How can we even land here with hasSpansEnabled() returning false?
      // Otel creates a Non-recording span in Tracing Without Performance mode when handling incoming requests
      // So we end up with an active span that is not sampled (neither positively nor negatively)
      if (hasSpansEnabled()) {
        dsc.sampled = String(spanIsSampled(rootSpan));
        dsc.sample_rand =
          // In OTEL we store the sample rand on the trace state because we cannot access scopes for NonRecordingSpans
          // The Sentry OTEL SpanSampler takes care of writing the sample rand on the root span
          traceState?.get('sentry.sample_rand') ??
          // On all other platforms we can actually get the scopes from a root span (we use this as a fallback)
          getCapturedScopesOnSpan(rootSpan).scope?.getPropagationContext().sampleRand.toString();
      }

      applyLocalSampleRateToDsc(dsc);

      client.emit('createDsc', dsc, rootSpan);

      return dsc;
    }

    /** Regular expression used to parse a Dsn. */
    const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

    function isValidProtocol(protocol) {
      return protocol === 'http' || protocol === 'https';
    }

    /**
     * Renders the string representation of this Dsn.
     *
     * By default, this will render the public representation without the password
     * component. To get the deprecated private representation, set `withPassword`
     * to true.
     *
     * @param withPassword When set to true, the password will be included.
     */
    function dsnToString(dsn, withPassword = false) {
      const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
      return (
        `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +
        `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`
      );
    }

    /**
     * Parses a Dsn from a given string.
     *
     * @param str A Dsn as string
     * @returns Dsn as DsnComponents or undefined if @param str is not a valid DSN string
     */
    function dsnFromString(str) {
      const match = DSN_REGEX.exec(str);

      if (!match) {
        // This should be logged to the console
        consoleSandbox(() => {
          // eslint-disable-next-line no-console
          console.error(`Invalid Sentry Dsn: ${str}`);
        });
        return undefined;
      }

      const [protocol, publicKey, pass = '', host = '', port = '', lastPath = ''] = match.slice(1);
      let path = '';
      let projectId = lastPath;

      const split = projectId.split('/');
      if (split.length > 1) {
        path = split.slice(0, -1).join('/');
        projectId = split.pop() ;
      }

      if (projectId) {
        const projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }

      return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });
    }

    function dsnFromComponents(components) {
      return {
        protocol: components.protocol,
        publicKey: components.publicKey || '',
        pass: components.pass || '',
        host: components.host,
        port: components.port || '',
        path: components.path || '',
        projectId: components.projectId,
      };
    }

    function validateDsn(dsn) {
      if (!DEBUG_BUILD$2) {
        return true;
      }

      const { port, projectId, protocol } = dsn;

      const requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
      const hasMissingRequiredComponent = requiredComponents.find(component => {
        if (!dsn[component]) {
          logger.error(`Invalid Sentry Dsn: ${component} missing`);
          return true;
        }
        return false;
      });

      if (hasMissingRequiredComponent) {
        return false;
      }

      if (!projectId.match(/^\d+$/)) {
        logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
        return false;
      }

      if (!isValidProtocol(protocol)) {
        logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
        return false;
      }

      if (port && isNaN(parseInt(port, 10))) {
        logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
        return false;
      }

      return true;
    }

    /**
     * Creates a valid Sentry Dsn object, identifying a Sentry instance and project.
     * @returns a valid DsnComponents object or `undefined` if @param from is an invalid DSN source
     */
    function makeDsn(from) {
      const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
      if (!components || !validateDsn(components)) {
        return undefined;
      }
      return components;
    }

    /**
     * Recursively normalizes the given object.
     *
     * - Creates a copy to prevent original input mutation
     * - Skips non-enumerable properties
     * - When stringifying, calls `toJSON` if implemented
     * - Removes circular references
     * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
     * - Translates known global objects/classes to a string representations
     * - Takes care of `Error` object serialization
     * - Optionally limits depth of final output
     * - Optionally limits number of properties/elements included in any single object/array
     *
     * @param input The object to be normalized.
     * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
     * @param maxProperties The max number of elements or properties to be included in any single array or
     * object in the normalized output.
     * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function normalize(input, depth = 100, maxProperties = +Infinity) {
      try {
        // since we're at the outermost level, we don't provide a key
        return visit('', input, depth, maxProperties);
      } catch (err) {
        return { ERROR: `**non-serializable** (${err})` };
      }
    }

    /** JSDoc */
    function normalizeToSize(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      object,
      // Default Node.js REPL depth
      depth = 3,
      // 100kB, as 200kB is max payload size, so half sounds reasonable
      maxSize = 100 * 1024,
    ) {
      const normalized = normalize(object, depth);

      if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
      }

      return normalized ;
    }

    /**
     * Visits a node to perform normalization on it
     *
     * @param key The key corresponding to the given node
     * @param value The node to be visited
     * @param depth Optional number indicating the maximum recursion depth
     * @param maxProperties Optional maximum number of properties/elements included in any single object/array
     * @param memo Optional Memo class handling decycling
     */
    function visit(
      key,
      value,
      depth = +Infinity,
      maxProperties = +Infinity,
      memo = memoBuilder(),
    ) {
      const [memoize, unmemoize] = memo;

      // Get the simple cases out of the way first
      if (
        value == null || // this matches null and undefined -> eqeq not eqeqeq
        ['boolean', 'string'].includes(typeof value) ||
        (typeof value === 'number' && Number.isFinite(value))
      ) {
        return value ;
      }

      const stringified = stringifyValue(key, value);

      // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
      // Everything else will have already been serialized, so if we don't see that pattern, we're done.
      if (!stringified.startsWith('[object ')) {
        return stringified;
      }

      // From here on, we can assert that `value` is either an object or an array.

      // Do not normalize objects that we know have already been normalized. As a general rule, the
      // "__sentry_skip_normalization__" property should only be used sparingly and only should only be set on objects that
      // have already been normalized.
      if ((value )['__sentry_skip_normalization__']) {
        return value ;
      }

      // We can set `__sentry_override_normalization_depth__` on an object to ensure that from there
      // We keep a certain amount of depth.
      // This should be used sparingly, e.g. we use it for the redux integration to ensure we get a certain amount of state.
      const remainingDepth =
        typeof (value )['__sentry_override_normalization_depth__'] === 'number'
          ? ((value )['__sentry_override_normalization_depth__'] )
          : depth;

      // We're also done if we've reached the max depth
      if (remainingDepth === 0) {
        // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
        return stringified.replace('object ', '');
      }

      // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
      if (memoize(value)) {
        return '[Circular ~]';
      }

      // If the value has a `toJSON` method, we call it to extract more information
      const valueWithToJSON = value ;
      if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
        try {
          const jsonValue = valueWithToJSON.toJSON();
          // We need to normalize the return value of `.toJSON()` in case it has circular references
          return visit('', jsonValue, remainingDepth - 1, maxProperties, memo);
        } catch (err) {
          // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
        }
      }

      // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
      // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
      // property/entry, and keep track of the number of items we add to it.
      const normalized = (Array.isArray(value) ? [] : {}) ;
      let numAdded = 0;

      // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
      // properties are non-enumerable and otherwise would get missed.
      const visitable = convertToPlainObject(value );

      for (const visitKey in visitable) {
        // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
          continue;
        }

        if (numAdded >= maxProperties) {
          normalized[visitKey] = '[MaxProperties ~]';
          break;
        }

        // Recursively visit all the child nodes
        const visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);

        numAdded++;
      }

      // Once we've visited all the branches, remove the parent from memo storage
      unmemoize(value);

      // Return accumulated values
      return normalized;
    }

    /* eslint-disable complexity */
    /**
     * Stringify the given value. Handles various known special values and types.
     *
     * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
     * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
     *
     * @param value The value to stringify
     * @returns A stringified representation of the given value
     */
    function stringifyValue(
      key,
      // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
      // our internal use, it'll do
      value,
    ) {
      try {
        if (key === 'domain' && value && typeof value === 'object' && (value )._events) {
          return '[Domain]';
        }

        if (key === 'domainEmitter') {
          return '[DomainEmitter]';
        }

        // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
        // which won't throw if they are not present.

        if (typeof global !== 'undefined' && value === global) {
          return '[Global]';
        }

        // eslint-disable-next-line no-restricted-globals
        if (typeof window !== 'undefined' && value === window) {
          return '[Window]';
        }

        // eslint-disable-next-line no-restricted-globals
        if (typeof document !== 'undefined' && value === document) {
          return '[Document]';
        }

        if (isVueViewModel(value)) {
          return '[VueViewModel]';
        }

        // React's SyntheticEvent thingy
        if (isSyntheticEvent(value)) {
          return '[SyntheticEvent]';
        }

        if (typeof value === 'number' && !Number.isFinite(value)) {
          return `[${value}]`;
        }

        if (typeof value === 'function') {
          return `[Function: ${getFunctionName(value)}]`;
        }

        if (typeof value === 'symbol') {
          return `[${String(value)}]`;
        }

        // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
        if (typeof value === 'bigint') {
          return `[BigInt: ${String(value)}]`;
        }

        // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
        // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
        // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
        // we can make sure that only plain objects come out that way.
        const objName = getConstructorName(value);

        // Handle HTML Elements
        if (/^HTML(\w*)Element$/.test(objName)) {
          return `[HTMLElement: ${objName}]`;
        }

        return `[object ${objName}]`;
      } catch (err) {
        return `**non-serializable** (${err})`;
      }
    }
    /* eslint-enable complexity */

    function getConstructorName(value) {
      const prototype = Object.getPrototypeOf(value);

      return prototype?.constructor ? prototype.constructor.name : 'null prototype';
    }

    /** Calculates bytes size of input string */
    function utf8Length(value) {
      // eslint-disable-next-line no-bitwise
      return ~-encodeURI(value).split(/%..|./).length;
    }

    /** Calculates bytes size of input object */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function jsonSize(value) {
      return utf8Length(JSON.stringify(value));
    }

    /**
     * Helper to decycle json objects
     */
    function memoBuilder() {
      const inner = new WeakSet();
      function memoize(obj) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }

      function unmemoize(obj) {
        inner.delete(obj);
      }
      return [memoize, unmemoize];
    }

    /**
     * Creates an envelope.
     * Make sure to always explicitly provide the generic to this function
     * so that the envelope types resolve correctly.
     */
    function createEnvelope(headers, items = []) {
      return [headers, items] ;
    }

    /**
     * Add an item to an envelope.
     * Make sure to always explicitly provide the generic to this function
     * so that the envelope types resolve correctly.
     */
    function addItemToEnvelope(envelope, newItem) {
      const [headers, items] = envelope;
      return [headers, [...items, newItem]] ;
    }

    /**
     * Convenience function to loop through the items and item types of an envelope.
     * (This function was mostly created because working with envelope types is painful at the moment)
     *
     * If the callback returns true, the rest of the items will be skipped.
     */
    function forEachEnvelopeItem(
      envelope,
      callback,
    ) {
      const envelopeItems = envelope[1];

      for (const envelopeItem of envelopeItems) {
        const envelopeItemType = envelopeItem[0].type;
        const result = callback(envelopeItem, envelopeItemType);

        if (result) {
          return true;
        }
      }

      return false;
    }

    /**
     * Encode a string to UTF8 array.
     */
    function encodeUTF8(input) {
      const carrier = getSentryCarrier(GLOBAL_OBJ);
      return carrier.encodePolyfill ? carrier.encodePolyfill(input) : new TextEncoder().encode(input);
    }

    /**
     * Serializes an envelope.
     */
    function serializeEnvelope(envelope) {
      const [envHeaders, items] = envelope;

      // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data
      let parts = JSON.stringify(envHeaders);

      function append(next) {
        if (typeof parts === 'string') {
          parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts), next];
        } else {
          parts.push(typeof next === 'string' ? encodeUTF8(next) : next);
        }
      }

      for (const item of items) {
        const [itemHeaders, payload] = item;

        append(`\n${JSON.stringify(itemHeaders)}\n`);

        if (typeof payload === 'string' || payload instanceof Uint8Array) {
          append(payload);
        } else {
          let stringifiedPayload;
          try {
            stringifiedPayload = JSON.stringify(payload);
          } catch (e) {
            // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.stringify()` still
            // fails, we try again after normalizing it again with infinite normalization depth. This of course has a
            // performance impact but in this case a performance hit is better than throwing.
            stringifiedPayload = JSON.stringify(normalize(payload));
          }
          append(stringifiedPayload);
        }
      }

      return typeof parts === 'string' ? parts : concatBuffers(parts);
    }

    function concatBuffers(buffers) {
      const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);

      const merged = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        merged.set(buffer, offset);
        offset += buffer.length;
      }

      return merged;
    }

    /**
     * Creates attachment envelope items
     */
    function createAttachmentEnvelopeItem(attachment) {
      const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data) : attachment.data;

      return [
        {
          type: 'attachment',
          length: buffer.length,
          filename: attachment.filename,
          content_type: attachment.contentType,
          attachment_type: attachment.attachmentType,
        },
        buffer,
      ];
    }

    const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
      session: 'session',
      sessions: 'session',
      attachment: 'attachment',
      transaction: 'transaction',
      event: 'error',
      client_report: 'internal',
      user_report: 'default',
      profile: 'profile',
      profile_chunk: 'profile',
      replay_event: 'replay',
      replay_recording: 'replay',
      check_in: 'monitor',
      feedback: 'feedback',
      span: 'span',
      raw_security: 'security',
      otel_log: 'log_item',
    };

    /**
     * Maps the type of an envelope item to a data category.
     */
    function envelopeItemTypeToDataCategory(type) {
      return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
    }

    /** Extracts the minimal SDK info from the metadata or an events */
    function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
      if (!metadataOrEvent?.sdk) {
        return;
      }
      const { name, version } = metadataOrEvent.sdk;
      return { name, version };
    }

    /**
     * Creates event envelope headers, based on event, sdk info and tunnel
     * Note: This function was extracted from the core package to make it available in Replay
     */
    function createEventEnvelopeHeaders(
      event,
      sdkInfo,
      tunnel,
      dsn,
    ) {
      const dynamicSamplingContext = event.sdkProcessingMetadata?.dynamicSamplingContext;
      return {
        event_id: event.event_id ,
        sent_at: new Date().toISOString(),
        ...(sdkInfo && { sdk: sdkInfo }),
        ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),
        ...(dynamicSamplingContext && {
          trace: dynamicSamplingContext,
        }),
      };
    }

    /**
     * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
     * Merge with existing data if any.
     **/
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];
      event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];
      return event;
    }

    /** Creates an envelope from a Session */
    function createSessionEnvelope(
      session,
      dsn,
      metadata,
      tunnel,
    ) {
      const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
      const envelopeHeaders = {
        sent_at: new Date().toISOString(),
        ...(sdkInfo && { sdk: sdkInfo }),
        ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),
      };

      const envelopeItem =
        'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session.toJSON()];

      return createEnvelope(envelopeHeaders, [envelopeItem]);
    }

    /**
     * Create an Envelope from an event.
     */
    function createEventEnvelope(
      event,
      dsn,
      metadata,
      tunnel,
    ) {
      const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);

      /*
        Note: Due to TS, event.type may be `replay_event`, theoretically.
        In practice, we never call `createEventEnvelope` with `replay_event` type,
        and we'd have to adjust a looot of types to make this work properly.
        We want to avoid casting this around, as that could lead to bugs (e.g. when we add another type)
        So the safe choice is to really guard against the replay_event type here.
      */
      const eventType = event.type && event.type !== 'replay_event' ? event.type : 'event';

      enhanceEventWithSdkInfo(event, metadata?.sdk);

      const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);

      // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to
      // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may
      // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid
      // of this `delete`, lest we miss putting it back in the next time the property is in use.)
      delete event.sdkProcessingMetadata;

      const eventItem = [{ type: eventType }, event];
      return createEnvelope(envelopeHeaders, [eventItem]);
    }

    /* eslint-disable @typescript-eslint/no-explicit-any */

    /** SyncPromise internal states */
    var States; (function (States) {
      /** Pending */
      const PENDING = 0; States[States["PENDING"] = PENDING] = "PENDING";
      /** Resolved / OK */
      const RESOLVED = 1; States[States["RESOLVED"] = RESOLVED] = "RESOLVED";
      /** Rejected / Error */
      const REJECTED = 2; States[States["REJECTED"] = REJECTED] = "REJECTED";
    })(States || (States = {}));

    // Overloads so we can call resolvedSyncPromise without arguments and generic argument

    /**
     * Creates a resolved sync promise.
     *
     * @param value the value to resolve the promise with
     * @returns the resolved sync promise
     */
    function resolvedSyncPromise(value) {
      return new SyncPromise(resolve => {
        resolve(value);
      });
    }

    /**
     * Creates a rejected sync promise.
     *
     * @param value the value to reject the promise with
     * @returns the rejected sync promise
     */
    function rejectedSyncPromise(reason) {
      return new SyncPromise((_, reject) => {
        reject(reason);
      });
    }

    /**
     * Thenable class that behaves like a Promise and follows it's interface
     * but is not async internally
     */
    class SyncPromise {

       constructor(executor) {
        this._state = States.PENDING;
        this._handlers = [];

        this._runExecutor(executor);
      }

      /** @inheritdoc */
       then(
        onfulfilled,
        onrejected,
      ) {
        return new SyncPromise((resolve, reject) => {
          this._handlers.push([
            false,
            result => {
              if (!onfulfilled) {
                // TODO: ¯\_(ツ)_/¯
                // TODO: FIXME
                resolve(result );
              } else {
                try {
                  resolve(onfulfilled(result));
                } catch (e) {
                  reject(e);
                }
              }
            },
            reason => {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve(onrejected(reason));
                } catch (e) {
                  reject(e);
                }
              }
            },
          ]);
          this._executeHandlers();
        });
      }

      /** @inheritdoc */
       catch(
        onrejected,
      ) {
        return this.then(val => val, onrejected);
      }

      /** @inheritdoc */
       finally(onfinally) {
        return new SyncPromise((resolve, reject) => {
          let val;
          let isRejected;

          return this.then(
            value => {
              isRejected = false;
              val = value;
              if (onfinally) {
                onfinally();
              }
            },
            reason => {
              isRejected = true;
              val = reason;
              if (onfinally) {
                onfinally();
              }
            },
          ).then(() => {
            if (isRejected) {
              reject(val);
              return;
            }

            resolve(val );
          });
        });
      }

      /** Excute the resolve/reject handlers. */
       _executeHandlers() {
        if (this._state === States.PENDING) {
          return;
        }

        const cachedHandlers = this._handlers.slice();
        this._handlers = [];

        cachedHandlers.forEach(handler => {
          if (handler[0]) {
            return;
          }

          if (this._state === States.RESOLVED) {
            handler[1](this._value );
          }

          if (this._state === States.REJECTED) {
            handler[2](this._value);
          }

          handler[0] = true;
        });
      }

      /** Run the executor for the SyncPromise. */
       _runExecutor(executor) {
        const setResult = (state, value) => {
          if (this._state !== States.PENDING) {
            return;
          }

          if (isThenable(value)) {
            void (value ).then(resolve, reject);
            return;
          }

          this._state = state;
          this._value = value;

          this._executeHandlers();
        };

        const resolve = (value) => {
          setResult(States.RESOLVED, value);
        };

        const reject = (reason) => {
          setResult(States.REJECTED, reason);
        };

        try {
          executor(resolve, reject);
        } catch (e) {
          reject(e);
        }
      }
    }

    /**
     * Process an array of event processors, returning the processed event (or `null` if the event was dropped).
     */
    function notifyEventProcessors(
      processors,
      event,
      hint,
      index = 0,
    ) {
      return new SyncPromise((resolve, reject) => {
        const processor = processors[index];
        if (event === null || typeof processor !== 'function') {
          resolve(event);
        } else {
          const result = processor({ ...event }, hint) ;

          DEBUG_BUILD$3 && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);

          if (isThenable(result)) {
            void result
              .then(final => notifyEventProcessors(processors, final, hint, index + 1).then(resolve))
              .then(null, reject);
          } else {
            void notifyEventProcessors(processors, result, hint, index + 1)
              .then(resolve)
              .then(null, reject);
          }
        }
      });
    }

    let parsedStackResults;
    let lastKeysCount;
    let cachedFilenameDebugIds;

    /**
     * Returns a map of filenames to debug identifiers.
     */
    function getFilenameToDebugIdMap(stackParser) {
      const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
      if (!debugIdMap) {
        return {};
      }

      const debugIdKeys = Object.keys(debugIdMap);

      // If the count of registered globals hasn't changed since the last call, we
      // can just return the cached result.
      if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {
        return cachedFilenameDebugIds;
      }

      lastKeysCount = debugIdKeys.length;

      // Build a map of filename -> debug_id.
      cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {
        if (!parsedStackResults) {
          parsedStackResults = {};
        }

        const result = parsedStackResults[stackKey];

        if (result) {
          acc[result[0]] = result[1];
        } else {
          const parsedStack = stackParser(stackKey);

          for (let i = parsedStack.length - 1; i >= 0; i--) {
            const stackFrame = parsedStack[i];
            const filename = stackFrame?.filename;
            const debugId = debugIdMap[stackKey];

            if (filename && debugId) {
              acc[filename] = debugId;
              parsedStackResults[stackKey] = [filename, debugId];
              break;
            }
          }
        }

        return acc;
      }, {});

      return cachedFilenameDebugIds;
    }

    /**
     * Applies data from the scope to the event and runs all event processors on it.
     */
    function applyScopeDataToEvent(event, data) {
      const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;

      // Apply general data
      applyDataToEvent(event, data);

      // We want to set the trace context for normal events only if there isn't already
      // a trace context on the event. There is a product feature in place where we link
      // errors with transaction and it relies on that.
      if (span) {
        applySpanToEvent(event, span);
      }

      applyFingerprintToEvent(event, fingerprint);
      applyBreadcrumbsToEvent(event, breadcrumbs);
      applySdkMetadataToEvent(event, sdkProcessingMetadata);
    }

    /** Merge data of two scopes together. */
    function mergeScopeData(data, mergeData) {
      const {
        extra,
        tags,
        user,
        contexts,
        level,
        sdkProcessingMetadata,
        breadcrumbs,
        fingerprint,
        eventProcessors,
        attachments,
        propagationContext,
        transactionName,
        span,
      } = mergeData;

      mergeAndOverwriteScopeData(data, 'extra', extra);
      mergeAndOverwriteScopeData(data, 'tags', tags);
      mergeAndOverwriteScopeData(data, 'user', user);
      mergeAndOverwriteScopeData(data, 'contexts', contexts);

      data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);

      if (level) {
        data.level = level;
      }

      if (transactionName) {
        data.transactionName = transactionName;
      }

      if (span) {
        data.span = span;
      }

      if (breadcrumbs.length) {
        data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
      }

      if (fingerprint.length) {
        data.fingerprint = [...data.fingerprint, ...fingerprint];
      }

      if (eventProcessors.length) {
        data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
      }

      if (attachments.length) {
        data.attachments = [...data.attachments, ...attachments];
      }

      data.propagationContext = { ...data.propagationContext, ...propagationContext };
    }

    /**
     * Merges certain scope data. Undefined values will overwrite any existing values.
     * Exported only for tests.
     */
    function mergeAndOverwriteScopeData

    (data, prop, mergeVal) {
      data[prop] = merge(data[prop], mergeVal, 1);
    }

    function applyDataToEvent(event, data) {
      const { extra, tags, user, contexts, level, transactionName } = data;

      if (Object.keys(extra).length) {
        event.extra = { ...extra, ...event.extra };
      }

      if (Object.keys(tags).length) {
        event.tags = { ...tags, ...event.tags };
      }

      if (Object.keys(user).length) {
        event.user = { ...user, ...event.user };
      }

      if (Object.keys(contexts).length) {
        event.contexts = { ...contexts, ...event.contexts };
      }

      if (level) {
        event.level = level;
      }

      // transaction events get their `transaction` from the root span name
      if (transactionName && event.type !== 'transaction') {
        event.transaction = transactionName;
      }
    }

    function applyBreadcrumbsToEvent(event, breadcrumbs) {
      const mergedBreadcrumbs = [...(event.breadcrumbs || []), ...breadcrumbs];
      event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;
    }

    function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
      event.sdkProcessingMetadata = {
        ...event.sdkProcessingMetadata,
        ...sdkProcessingMetadata,
      };
    }

    function applySpanToEvent(event, span) {
      event.contexts = {
        trace: spanToTraceContext(span),
        ...event.contexts,
      };

      event.sdkProcessingMetadata = {
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
        ...event.sdkProcessingMetadata,
      };

      const rootSpan = getRootSpan(span);
      const transactionName = spanToJSON(rootSpan).description;
      if (transactionName && !event.transaction && event.type === 'transaction') {
        event.transaction = transactionName;
      }
    }

    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    function applyFingerprintToEvent(event, fingerprint) {
      // Make sure it's an array first and we actually have something in place
      event.fingerprint = event.fingerprint
        ? Array.isArray(event.fingerprint)
          ? event.fingerprint
          : [event.fingerprint]
        : [];

      // If we have something on the scope, then merge it with event
      if (fingerprint) {
        event.fingerprint = event.fingerprint.concat(fingerprint);
      }

      // If we have no data at all, remove empty array default
      if (!event.fingerprint.length) {
        delete event.fingerprint;
      }
    }

    /**
     * This type makes sure that we get either a CaptureContext, OR an EventHint.
     * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:
     * { user: { id: '123' }, mechanism: { handled: false } }
     */

    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     * @hidden
     */
    function prepareEvent(
      options,
      event,
      hint,
      scope,
      client,
      isolationScope,
    ) {
      const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;
      const prepared = {
        ...event,
        event_id: event.event_id || hint.event_id || uuid4(),
        timestamp: event.timestamp || dateTimestampInSeconds(),
      };
      const integrations = hint.integrations || options.integrations.map(i => i.name);

      applyClientOptions(prepared, options);
      applyIntegrationsMetadata(prepared, integrations);

      if (client) {
        client.emit('applyFrameMetadata', event);
      }

      // Only put debug IDs onto frames for error events.
      if (event.type === undefined) {
        applyDebugIds(prepared, options.stackParser);
      }

      // If we have scope given to us, use it as the base for further modifications.
      // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
      const finalScope = getFinalScope(scope, hint.captureContext);

      if (hint.mechanism) {
        addExceptionMechanism(prepared, hint.mechanism);
      }

      const clientEventProcessors = client ? client.getEventProcessors() : [];

      // This should be the last thing called, since we want that
      // {@link Scope.addEventProcessor} gets the finished prepared event.
      // Merge scope data together
      const data = getGlobalScope().getScopeData();

      if (isolationScope) {
        const isolationData = isolationScope.getScopeData();
        mergeScopeData(data, isolationData);
      }

      if (finalScope) {
        const finalScopeData = finalScope.getScopeData();
        mergeScopeData(data, finalScopeData);
      }

      const attachments = [...(hint.attachments || []), ...data.attachments];
      if (attachments.length) {
        hint.attachments = attachments;
      }

      applyScopeDataToEvent(prepared, data);

      const eventProcessors = [
        ...clientEventProcessors,
        // Run scope event processors _after_ all other processors
        ...data.eventProcessors,
      ];

      const result = notifyEventProcessors(eventProcessors, prepared, hint);

      return result.then(evt => {
        if (evt) {
          // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified
          // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.
          // This should not cause any PII issues, since we're only moving data that is already on the event and not adding
          // any new data
          applyDebugMeta(evt);
        }

        if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
          return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
        }
        return evt;
      });
    }

    /**
     * Enhances event using the client configuration.
     * It takes care of all "static" values like environment, release and `dist`,
     * as well as truncating overly long values.
     *
     * Only exported for tests.
     *
     * @param event event instance to be enhanced
     */
    function applyClientOptions(event, options) {
      const { environment, release, dist, maxValueLength = 250 } = options;

      // empty strings do not make sense for environment, release, and dist
      // so we handle them the same as if they were not provided
      event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;

      if (!event.release && release) {
        event.release = release;
      }

      if (!event.dist && dist) {
        event.dist = dist;
      }

      const request = event.request;
      if (request?.url) {
        request.url = truncate(request.url, maxValueLength);
      }
    }

    /**
     * Puts debug IDs into the stack frames of an error event.
     */
    function applyDebugIds(event, stackParser) {
      // Build a map of filename -> debug_id
      const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);

      event.exception?.values?.forEach(exception => {
        exception.stacktrace?.frames?.forEach(frame => {
          if (frame.filename) {
            frame.debug_id = filenameDebugIdMap[frame.filename];
          }
        });
      });
    }

    /**
     * Moves debug IDs from the stack frames of an error event into the debug_meta field.
     */
    function applyDebugMeta(event) {
      // Extract debug IDs and filenames from the stack frames on the event.
      const filenameDebugIdMap = {};
      event.exception?.values?.forEach(exception => {
        exception.stacktrace?.frames?.forEach(frame => {
          if (frame.debug_id) {
            if (frame.abs_path) {
              filenameDebugIdMap[frame.abs_path] = frame.debug_id;
            } else if (frame.filename) {
              filenameDebugIdMap[frame.filename] = frame.debug_id;
            }
            delete frame.debug_id;
          }
        });
      });

      if (Object.keys(filenameDebugIdMap).length === 0) {
        return;
      }

      // Fill debug_meta information
      event.debug_meta = event.debug_meta || {};
      event.debug_meta.images = event.debug_meta.images || [];
      const images = event.debug_meta.images;
      Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {
        images.push({
          type: 'sourcemap',
          code_file: filename,
          debug_id,
        });
      });
    }

    /**
     * This function adds all used integrations to the SDK info in the event.
     * @param event The event that will be filled with all integrations.
     */
    function applyIntegrationsMetadata(event, integrationNames) {
      if (integrationNames.length > 0) {
        event.sdk = event.sdk || {};
        event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];
      }
    }

    /**
     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
     * Normalized keys:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * @param event Event
     * @returns Normalized event
     */
    function normalizeEvent(event, depth, maxBreadth) {
      if (!event) {
        return null;
      }

      const normalized = {
        ...event,
        ...(event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map(b => ({
            ...b,
            ...(b.data && {
              data: normalize(b.data, depth, maxBreadth),
            }),
          })),
        }),
        ...(event.user && {
          user: normalize(event.user, depth, maxBreadth),
        }),
        ...(event.contexts && {
          contexts: normalize(event.contexts, depth, maxBreadth),
        }),
        ...(event.extra && {
          extra: normalize(event.extra, depth, maxBreadth),
        }),
      };

      // event.contexts.trace stores information about a Transaction. Similarly,
      // event.spans[] stores information about child Spans. Given that a
      // Transaction is conceptually a Span, normalization should apply to both
      // Transactions and Spans consistently.
      // For now the decision is to skip normalization of Transactions and Spans,
      // so this block overwrites the normalized event to add back the original
      // Transaction information prior to normalization.
      if (event.contexts?.trace && normalized.contexts) {
        normalized.contexts.trace = event.contexts.trace;

        // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it
        if (event.contexts.trace.data) {
          normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
        }
      }

      // event.spans[].data may contain circular/dangerous data so we need to normalize it
      if (event.spans) {
        normalized.spans = event.spans.map(span => {
          return {
            ...span,
            ...(span.data && {
              data: normalize(span.data, depth, maxBreadth),
            }),
          };
        });
      }

      // event.contexts.flags (FeatureFlagContext) stores context for our feature
      // flag integrations. It has a greater nesting depth than our other typed
      // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want
      // to skip this in case of conflicting, user-provided context.
      if (event.contexts?.flags && normalized.contexts) {
        normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);
      }

      return normalized;
    }

    function getFinalScope(scope, captureContext) {
      if (!captureContext) {
        return scope;
      }

      const finalScope = scope ? scope.clone() : new Scope();
      finalScope.update(captureContext);
      return finalScope;
    }

    /**
     * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.
     * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.
     */
    function parseEventHintOrCaptureContext(
      hint,
    ) {
      if (!hint) {
        return undefined;
      }

      // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext
      if (hintIsScopeOrFunction(hint)) {
        return { captureContext: hint };
      }

      if (hintIsScopeContext(hint)) {
        return {
          captureContext: hint,
        };
      }

      return hint;
    }

    function hintIsScopeOrFunction(hint) {
      return hint instanceof Scope || typeof hint === 'function';
    }

    const captureContextKeys = [
      'user',
      'level',
      'extra',
      'contexts',
      'tags',
      'fingerprint',
      'propagationContext',
    ] ;

    function hintIsScopeContext(hint) {
      return Object.keys(hint).some(key => captureContextKeys.includes(key ));
    }

    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception The exception to capture.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured Sentry event.
     */
    function captureException(exception, hint) {
      return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
    }

    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured event.
     */
    function captureEvent(event, hint) {
      return getCurrentScope().captureEvent(event, hint);
    }

    /**
     * Start a session on the current isolation scope.
     *
     * @param context (optional) additional properties to be applied to the returned session object
     *
     * @returns the new active session
     */
    function startSession(context) {
      const isolationScope = getIsolationScope();
      const currentScope = getCurrentScope();

      // Will fetch userAgent if called from browser sdk
      const { userAgent } = GLOBAL_OBJ.navigator || {};

      const session = makeSession({
        user: currentScope.getUser() || isolationScope.getUser(),
        ...(userAgent && { userAgent }),
        ...context,
      });

      // End existing session if there's one
      const currentSession = isolationScope.getSession();
      if (currentSession?.status === 'ok') {
        updateSession(currentSession, { status: 'exited' });
      }

      endSession();

      // Afterwards we set the new session on the scope
      isolationScope.setSession(session);

      return session;
    }

    /**
     * End the session on the current isolation scope.
     */
    function endSession() {
      const isolationScope = getIsolationScope();
      const currentScope = getCurrentScope();

      const session = currentScope.getSession() || isolationScope.getSession();
      if (session) {
        closeSession(session);
      }
      _sendSessionUpdate();

      // the session is over; take it off of the scope
      isolationScope.setSession();
    }

    /**
     * Sends the current Session on the scope
     */
    function _sendSessionUpdate() {
      const isolationScope = getIsolationScope();
      const client = getClient();
      const session = isolationScope.getSession();
      if (session && client) {
        client.captureSession(session);
      }
    }

    /**
     * Sends the current session on the scope to Sentry
     *
     * @param end If set the session will be marked as exited and removed from the scope.
     *            Defaults to `false`.
     */
    function captureSession(end = false) {
      // both send the update and pull the session from the scope
      if (end) {
        endSession();
        return;
      }

      // only send the update
      _sendSessionUpdate();
    }

    const SENTRY_API_VERSION = '7';

    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    function getBaseApiEndpoint(dsn) {
      const protocol = dsn.protocol ? `${dsn.protocol}:` : '';
      const port = dsn.port ? `:${dsn.port}` : '';
      return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;
    }

    /** Returns the ingest API endpoint for target. */
    function _getIngestEndpoint(dsn) {
      return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
    }

    /** Returns a URL-encoded string with auth config suitable for a query string. */
    function _encodedAuth(dsn, sdkInfo) {
      const params = {
        sentry_version: SENTRY_API_VERSION,
      };

      if (dsn.publicKey) {
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        params.sentry_key = dsn.publicKey;
      }

      if (sdkInfo) {
        params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;
      }

      return new URLSearchParams(params).toString();
    }

    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
      return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
    }

    const installedIntegrations = [];

    /**
     * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
     * integrations are added unless they were already provided before.
     * @param integrations array of integration instances
     * @param withDefault should enable default integrations
     */
    function setupIntegrations(client, integrations) {
      const integrationIndex = {};

      integrations.forEach((integration) => {
        // guard against empty provided integrations
        if (integration) {
          setupIntegration(client, integration, integrationIndex);
        }
      });

      return integrationIndex;
    }

    /**
     * Execute the `afterAllSetup` hooks of the given integrations.
     */
    function afterSetupIntegrations(client, integrations) {
      for (const integration of integrations) {
        // guard against empty provided integrations
        if (integration?.afterAllSetup) {
          integration.afterAllSetup(client);
        }
      }
    }

    /** Setup a single integration.  */
    function setupIntegration(client, integration, integrationIndex) {
      if (integrationIndex[integration.name]) {
        DEBUG_BUILD$3 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
        return;
      }
      integrationIndex[integration.name] = integration;

      // `setupOnce` is only called the first time
      if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === 'function') {
        integration.setupOnce();
        installedIntegrations.push(integration.name);
      }

      // `setup` is run for each client
      if (integration.setup && typeof integration.setup === 'function') {
        integration.setup(client);
      }

      if (typeof integration.preprocessEvent === 'function') {
        const callback = integration.preprocessEvent.bind(integration) ;
        client.on('preprocessEvent', (event, hint) => callback(event, hint, client));
      }

      if (typeof integration.processEvent === 'function') {
        const callback = integration.processEvent.bind(integration) ;

        const processor = Object.assign((event, hint) => callback(event, hint, client), {
          id: integration.name,
        });

        client.addEventProcessor(processor);
      }

      DEBUG_BUILD$3 && logger.log(`Integration installed: ${integration.name}`);
    }

    /**
     * Define an integration function that can be used to create an integration instance.
     * Note that this by design hides the implementation details of the integration, as they are considered internal.
     */
    function defineIntegration(fn) {
      return fn;
    }

    /**
     * Creates client report envelope
     * @param discarded_events An array of discard events
     * @param dsn A DSN that can be set on the header. Optional.
     */
    function createClientReportEnvelope(
      discarded_events,
      dsn,
      timestamp,
    ) {
      const clientReportItem = [
        { type: 'client_report' },
        {
          timestamp: timestamp || dateTimestampInSeconds(),
          discarded_events,
        },
      ];
      return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
    }

    /**
     * Get a list of possible event messages from a Sentry event.
     */
    function getPossibleEventMessages(event) {
      const possibleMessages = [];

      if (event.message) {
        possibleMessages.push(event.message);
      }

      try {
        // @ts-expect-error Try catching to save bundle size
        const lastException = event.exception.values[event.exception.values.length - 1];
        if (lastException?.value) {
          possibleMessages.push(lastException.value);
          if (lastException.type) {
            possibleMessages.push(`${lastException.type}: ${lastException.value}`);
          }
        }
      } catch (e) {
        // ignore errors here
      }

      return possibleMessages;
    }

    /**
     * Converts a transaction event to a span JSON object.
     */
    function convertTransactionEventToSpanJson(event) {
      const { trace_id, parent_span_id, span_id, status, origin, data, op } = event.contexts?.trace ?? {};

      return {
        data: data ?? {},
        description: event.transaction,
        op,
        parent_span_id,
        span_id: span_id ?? '',
        start_timestamp: event.start_timestamp ?? 0,
        status,
        timestamp: event.timestamp,
        trace_id: trace_id ?? '',
        origin,
        profile_id: data?.[SEMANTIC_ATTRIBUTE_PROFILE_ID] ,
        exclusive_time: data?.[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME] ,
        measurements: event.measurements,
        is_segment: true,
      };
    }

    /**
     * Converts a span JSON object to a transaction event.
     */
    function convertSpanJsonToTransactionEvent(span) {
      return {
        type: 'transaction',
        timestamp: span.timestamp,
        start_timestamp: span.start_timestamp,
        transaction: span.description,
        contexts: {
          trace: {
            trace_id: span.trace_id,
            span_id: span.span_id,
            parent_span_id: span.parent_span_id,
            op: span.op,
            status: span.status,
            origin: span.origin,
            data: {
              ...span.data,
              ...(span.profile_id && { [SEMANTIC_ATTRIBUTE_PROFILE_ID]: span.profile_id }),
              ...(span.exclusive_time && { [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: span.exclusive_time }),
            },
          },
        },
        measurements: span.measurements,
      };
    }

    const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    const MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';

    const INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');
    const DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');

    function _makeInternalError(message) {
      return {
        message,
        [INTERNAL_ERROR_SYMBOL]: true,
      };
    }

    function _makeDoNotSendEventError(message) {
      return {
        message,
        [DO_NOT_SEND_EVENT_SYMBOL]: true,
      };
    }

    function _isInternalError(error) {
      return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;
    }

    function _isDoNotSendEventError(error) {
      return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;
    }

    /**
     * Base implementation for all JavaScript SDK clients.
     *
     * Call the constructor with the corresponding options
     * specific to the client subclass. To access these options later, use
     * {@link Client.getOptions}.
     *
     * If a Dsn is specified in the options, it will be parsed and stored. Use
     * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
     * invalid, the constructor will throw a {@link SentryException}. Note that
     * without a valid Dsn, the SDK will not send any events to Sentry.
     *
     * Before sending an event, it is passed through
     * {@link Client._prepareEvent} to add SDK information and scope data
     * (breadcrumbs and context). To add more custom information, override this
     * method and extend the resulting prepared event.
     *
     * To issue automatically created events (e.g. via instrumentation), use
     * {@link Client.captureEvent}. It will prepare the event and pass it through
     * the callback lifecycle. To issue auto-breadcrumbs, use
     * {@link Client.addBreadcrumb}.
     *
     * @example
     * class NodeClient extends Client<NodeOptions> {
     *   public constructor(options: NodeOptions) {
     *     super(options);
     *   }
     *
     *   // ...
     * }
     */
    class Client {
      /** Options passed to the SDK. */

      /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */

      /** Array of set up integrations. */

      /** Number of calls being processed */

      /** Holds flushable  */

      // eslint-disable-next-line @typescript-eslint/ban-types

      /**
       * Initializes this client instance.
       *
       * @param options Options for the client.
       */
       constructor(options) {
        this._options = options;
        this._integrations = {};
        this._numProcessing = 0;
        this._outcomes = {};
        this._hooks = {};
        this._eventProcessors = [];

        if (options.dsn) {
          this._dsn = makeDsn(options.dsn);
        } else {
          DEBUG_BUILD$3 && logger.warn('No DSN provided, client will not send events.');
        }

        if (this._dsn) {
          const url = getEnvelopeEndpointWithUrlEncodedAuth(
            this._dsn,
            options.tunnel,
            options._metadata ? options._metadata.sdk : undefined,
          );
          this._transport = options.transport({
            tunnel: this._options.tunnel,
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...options.transportOptions,
            url,
          });
        }
      }

      /**
       * Captures an exception event and sends it to Sentry.
       *
       * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.
       */
       captureException(exception, hint, scope) {
        const eventId = uuid4();

        // ensure we haven't captured this very object before
        if (checkOrSetAlreadyCaught(exception)) {
          DEBUG_BUILD$3 && logger.log(ALREADY_SEEN_ERROR);
          return eventId;
        }

        const hintWithEventId = {
          event_id: eventId,
          ...hint,
        };

        this._process(
          this.eventFromException(exception, hintWithEventId).then(event =>
            this._captureEvent(event, hintWithEventId, scope),
          ),
        );

        return hintWithEventId.event_id;
      }

      /**
       * Captures a message event and sends it to Sentry.
       *
       * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.
       */
       captureMessage(
        message,
        level,
        hint,
        currentScope,
      ) {
        const hintWithEventId = {
          event_id: uuid4(),
          ...hint,
        };

        const eventMessage = isParameterizedString(message) ? message : String(message);

        const promisedEvent = isPrimitive(message)
          ? this.eventFromMessage(eventMessage, level, hintWithEventId)
          : this.eventFromException(message, hintWithEventId);

        this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));

        return hintWithEventId.event_id;
      }

      /**
       * Captures a manually created event and sends it to Sentry.
       *
       * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.
       */
       captureEvent(event, hint, currentScope) {
        const eventId = uuid4();

        // ensure we haven't captured this very object before
        if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
          DEBUG_BUILD$3 && logger.log(ALREADY_SEEN_ERROR);
          return eventId;
        }

        const hintWithEventId = {
          event_id: eventId,
          ...hint,
        };

        const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
        const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
        const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;

        this._process(
          this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope),
        );

        return hintWithEventId.event_id;
      }

      /**
       * Captures a session.
       */
       captureSession(session) {
        this.sendSession(session);
        // After sending, we set init false to indicate it's not the first occurrence
        updateSession(session, { init: false });
      }

      /**
       * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.
       *
       * @param checkIn An object that describes a check in.
       * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
       * to create a monitor automatically when sending a check in.
       * @param scope An optional scope containing event metadata.
       * @returns A string representing the id of the check in.
       */

      /**
       * Get the current Dsn.
       */
       getDsn() {
        return this._dsn;
      }

      /**
       * Get the current options.
       */
       getOptions() {
        return this._options;
      }

      /**
       * Get the SDK metadata.
       * @see SdkMetadata
       */
       getSdkMetadata() {
        return this._options._metadata;
      }

      /**
       * Returns the transport that is used by the client.
       * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
       */
       getTransport() {
        return this._transport;
      }

      /**
       * Wait for all events to be sent or the timeout to expire, whichever comes first.
       *
       * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
       *   cause the client to wait until all events are sent before resolving the promise.
       * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
       * still events in the queue when the timeout is reached.
       */
       flush(timeout) {
        const transport = this._transport;
        if (transport) {
          this.emit('flush');
          return this._isClientDoneProcessing(timeout).then(clientFinished => {
            return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);
          });
        } else {
          return resolvedSyncPromise(true);
        }
      }

      /**
       * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
       *
       * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
       *   the client to wait until all events are sent before disabling itself.
       * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
       * it doesn't.
       */
       close(timeout) {
        return this.flush(timeout).then(result => {
          this.getOptions().enabled = false;
          this.emit('close');
          return result;
        });
      }

      /**
       * Get all installed event processors.
       */
       getEventProcessors() {
        return this._eventProcessors;
      }

      /**
       * Adds an event processor that applies to any event processed by this client.
       */
       addEventProcessor(eventProcessor) {
        this._eventProcessors.push(eventProcessor);
      }

      /**
       * Initialize this client.
       * Call this after the client was set on a scope.
       */
       init() {
        if (
          this._isEnabled() ||
          // Force integrations to be setup even if no DSN was set when we have
          // Spotlight enabled. This is particularly important for browser as we
          // don't support the `spotlight` option there and rely on the users
          // adding the `spotlightBrowserIntegration()` to their integrations which
          // wouldn't get initialized with the check below when there's no DSN set.
          this._options.integrations.some(({ name }) => name.startsWith('Spotlight'))
        ) {
          this._setupIntegrations();
        }
      }

      /**
       * Gets an installed integration by its name.
       *
       * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.
       */
       getIntegrationByName(integrationName) {
        return this._integrations[integrationName] ;
      }

      /**
       * Add an integration to the client.
       * This can be used to e.g. lazy load integrations.
       * In most cases, this should not be necessary,
       * and you're better off just passing the integrations via `integrations: []` at initialization time.
       * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.
       */
       addIntegration(integration) {
        const isAlreadyInstalled = this._integrations[integration.name];

        // This hook takes care of only installing if not already installed
        setupIntegration(this, integration, this._integrations);
        // Here we need to check manually to make sure to not run this multiple times
        if (!isAlreadyInstalled) {
          afterSetupIntegrations(this, [integration]);
        }
      }

      /**
       * Send a fully prepared event to Sentry.
       */
       sendEvent(event, hint = {}) {
        this.emit('beforeSendEvent', event, hint);

        let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);

        for (const attachment of hint.attachments || []) {
          env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));
        }

        const promise = this.sendEnvelope(env);
        if (promise) {
          promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);
        }
      }

      /**
       * Send a session or session aggregrates to Sentry.
       */
       sendSession(session) {
        // Backfill release and environment on session
        const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;
        if ('aggregates' in session) {
          const sessionAttrs = session.attrs || {};
          if (!sessionAttrs.release && !clientReleaseOption) {
            DEBUG_BUILD$3 && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
            return;
          }
          sessionAttrs.release = sessionAttrs.release || clientReleaseOption;
          sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;
          session.attrs = sessionAttrs;
        } else {
          if (!session.release && !clientReleaseOption) {
            DEBUG_BUILD$3 && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
            return;
          }
          session.release = session.release || clientReleaseOption;
          session.environment = session.environment || clientEnvironmentOption;
        }

        this.emit('beforeSendSession', session);

        const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);

        // sendEnvelope should not throw
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.sendEnvelope(env);
      }

      /**
       * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).
       */
       recordDroppedEvent(reason, category, count = 1) {
        if (this._options.sendClientReports) {
          // We want to track each category (error, transaction, session, replay_event) separately
          // but still keep the distinction between different type of outcomes.
          // We could use nested maps, but it's much easier to read and type this way.
          // A correct type for map-based implementation if we want to go that route
          // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`
          // With typescript 4.1 we could even use template literal types
          const key = `${reason}:${category}`;
          DEBUG_BUILD$3 && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ''}`);
          this._outcomes[key] = (this._outcomes[key] || 0) + count;
        }
      }

      /* eslint-disable @typescript-eslint/unified-signatures */
      /**
       * Register a callback for whenever a span is started.
       * Receives the span as argument.
       * @returns {() => void} A function that, when executed, removes the registered callback.
       */

      /**
       * Register a hook on this client.
       */
       on(hook, callback) {
        const hooks = (this._hooks[hook] = this._hooks[hook] || []);

        // @ts-expect-error We assume the types are correct
        hooks.push(callback);

        // This function returns a callback execution handler that, when invoked,
        // deregisters a callback. This is crucial for managing instances where callbacks
        // need to be unregistered to prevent self-referencing in callback closures,
        // ensuring proper garbage collection.
        return () => {
          // @ts-expect-error We assume the types are correct
          const cbIndex = hooks.indexOf(callback);
          if (cbIndex > -1) {
            hooks.splice(cbIndex, 1);
          }
        };
      }

      /** Fire a hook whenever a span starts. */

      /**
       * Emit a hook that was previously registered via `on()`.
       */
       emit(hook, ...rest) {
        const callbacks = this._hooks[hook];
        if (callbacks) {
          callbacks.forEach(callback => callback(...rest));
        }
      }

      /**
       * Send an envelope to Sentry.
       */
       sendEnvelope(envelope) {
        this.emit('beforeEnvelope', envelope);

        if (this._isEnabled() && this._transport) {
          return this._transport.send(envelope).then(null, reason => {
            DEBUG_BUILD$3 && logger.error('Error while sending envelope:', reason);
            return reason;
          });
        }

        DEBUG_BUILD$3 && logger.error('Transport disabled');

        return resolvedSyncPromise({});
      }

      /* eslint-enable @typescript-eslint/unified-signatures */

      /** Setup integrations for this client. */
       _setupIntegrations() {
        const { integrations } = this._options;
        this._integrations = setupIntegrations(this, integrations);
        afterSetupIntegrations(this, integrations);
      }

      /** Updates existing session based on the provided event */
       _updateSessionFromEvent(session, event) {
        let crashed = event.level === 'fatal';
        let errored = false;
        const exceptions = event.exception?.values;

        if (exceptions) {
          errored = true;

          for (const ex of exceptions) {
            const mechanism = ex.mechanism;
            if (mechanism?.handled === false) {
              crashed = true;
              break;
            }
          }
        }

        // A session is updated and that session update is sent in only one of the two following scenarios:
        // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
        // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update
        const sessionNonTerminal = session.status === 'ok';
        const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);

        if (shouldUpdateAndSend) {
          updateSession(session, {
            ...(crashed && { status: 'crashed' }),
            errors: session.errors || Number(errored || crashed),
          });
          this.captureSession(session);
        }
      }

      /**
       * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
       * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
       * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
       * `false` otherwise
       */
       _isClientDoneProcessing(timeout) {
        return new SyncPromise(resolve => {
          let ticked = 0;
          const tick = 1;

          const interval = setInterval(() => {
            if (this._numProcessing == 0) {
              clearInterval(interval);
              resolve(true);
            } else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve(false);
              }
            }
          }, tick);
        });
      }

      /** Determines whether this SDK is enabled and a transport is present. */
       _isEnabled() {
        return this.getOptions().enabled !== false && this._transport !== undefined;
      }

      /**
       * Adds common information to events.
       *
       * The information includes release and environment from `options`,
       * breadcrumbs and context (extra, tags and user) from the scope.
       *
       * Information that is already present in the event is never overwritten. For
       * nested objects, such as the context, keys are merged.
       *
       * @param event The original event.
       * @param hint May contain additional information about the original exception.
       * @param currentScope A scope containing event metadata.
       * @returns A new event with more information.
       */
       _prepareEvent(
        event,
        hint,
        currentScope,
        isolationScope,
      ) {
        const options = this.getOptions();
        const integrations = Object.keys(this._integrations);
        if (!hint.integrations && integrations?.length) {
          hint.integrations = integrations;
        }

        this.emit('preprocessEvent', event, hint);

        if (!event.type) {
          isolationScope.setLastEventId(event.event_id || hint.event_id);
        }

        return prepareEvent(options, event, hint, currentScope, this, isolationScope).then(evt => {
          if (evt === null) {
            return evt;
          }

          this.emit('postprocessEvent', evt, hint);

          evt.contexts = {
            trace: getTraceContextFromScope(currentScope),
            ...evt.contexts,
          };

          const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);

          evt.sdkProcessingMetadata = {
            dynamicSamplingContext,
            ...evt.sdkProcessingMetadata,
          };

          return evt;
        });
      }

      /**
       * Processes the event and logs an error in case of rejection
       * @param event
       * @param hint
       * @param scope
       */
       _captureEvent(
        event,
        hint = {},
        currentScope = getCurrentScope(),
        isolationScope = getIsolationScope(),
      ) {
        if (DEBUG_BUILD$3 && isErrorEvent(event)) {
          logger.log(`Captured error event \`${getPossibleEventMessages(event)[0] || '<unknown>'}\``);
        }

        return this._processEvent(event, hint, currentScope, isolationScope).then(
          finalEvent => {
            return finalEvent.event_id;
          },
          reason => {
            if (DEBUG_BUILD$3) {
              if (_isDoNotSendEventError(reason)) {
                logger.log(reason.message);
              } else if (_isInternalError(reason)) {
                logger.warn(reason.message);
              } else {
                logger.warn(reason);
              }
            }
            return undefined;
          },
        );
      }

      /**
       * Processes an event (either error or message) and sends it to Sentry.
       *
       * This also adds breadcrumbs and context information to the event. However,
       * platform specific meta data (such as the User's IP address) must be added
       * by the SDK implementor.
       *
       *
       * @param event The event to send to Sentry.
       * @param hint May contain additional information about the original exception.
       * @param currentScope A scope containing event metadata.
       * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
       */
       _processEvent(
        event,
        hint,
        currentScope,
        isolationScope,
      ) {
        const options = this.getOptions();
        const { sampleRate } = options;

        const isTransaction = isTransactionEvent(event);
        const isError = isErrorEvent(event);
        const eventType = event.type || 'error';
        const beforeSendLabel = `before send for type \`${eventType}\``;

        // 1.0 === 100% events are sent
        // 0.0 === 0% events are sent
        // Sampling for transaction happens somewhere else
        const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : parseSampleRate(sampleRate);
        if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {
          this.recordDroppedEvent('sample_rate', 'error');
          return rejectedSyncPromise(
            _makeDoNotSendEventError(
              `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
            ),
          );
        }

        const dataCategory = (eventType === 'replay_event' ? 'replay' : eventType) ;

        return this._prepareEvent(event, hint, currentScope, isolationScope)
          .then(prepared => {
            if (prepared === null) {
              this.recordDroppedEvent('event_processor', dataCategory);
              throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');
            }

            const isInternalException = hint.data && (hint.data ).__sentry__ === true;
            if (isInternalException) {
              return prepared;
            }

            const result = processBeforeSend(this, options, prepared, hint);
            return _validateBeforeSendResult(result, beforeSendLabel);
          })
          .then(processedEvent => {
            if (processedEvent === null) {
              this.recordDroppedEvent('before_send', dataCategory);
              if (isTransaction) {
                const spans = event.spans || [];
                // the transaction itself counts as one span, plus all the child spans that are added
                const spanCount = 1 + spans.length;
                this.recordDroppedEvent('before_send', 'span', spanCount);
              }
              throw _makeDoNotSendEventError(`${beforeSendLabel} returned \`null\`, will not send event.`);
            }

            const session = currentScope.getSession() || isolationScope.getSession();
            if (isError && session) {
              this._updateSessionFromEvent(session, processedEvent);
            }

            if (isTransaction) {
              const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;
              const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;

              const droppedSpanCount = spanCountBefore - spanCountAfter;
              if (droppedSpanCount > 0) {
                this.recordDroppedEvent('before_send', 'span', droppedSpanCount);
              }
            }

            // None of the Sentry built event processor will update transaction name,
            // so if the transaction name has been changed by an event processor, we know
            // it has to come from custom event processor added by a user
            const transactionInfo = processedEvent.transaction_info;
            if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
              const source = 'custom';
              processedEvent.transaction_info = {
                ...transactionInfo,
                source,
              };
            }

            this.sendEvent(processedEvent, hint);
            return processedEvent;
          })
          .then(null, reason => {
            if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {
              throw reason;
            }

            this.captureException(reason, {
              data: {
                __sentry__: true,
              },
              originalException: reason,
            });
            throw _makeInternalError(
              `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`,
            );
          });
      }

      /**
       * Occupies the client with processing and event
       */
       _process(promise) {
        this._numProcessing++;
        void promise.then(
          value => {
            this._numProcessing--;
            return value;
          },
          reason => {
            this._numProcessing--;
            return reason;
          },
        );
      }

      /**
       * Clears outcomes on this client and returns them.
       */
       _clearOutcomes() {
        const outcomes = this._outcomes;
        this._outcomes = {};
        return Object.entries(outcomes).map(([key, quantity]) => {
          const [reason, category] = key.split(':') ;
          return {
            reason,
            category,
            quantity,
          };
        });
      }

      /**
       * Sends client reports as an envelope.
       */
       _flushOutcomes() {
        DEBUG_BUILD$3 && logger.log('Flushing outcomes...');

        const outcomes = this._clearOutcomes();

        if (outcomes.length === 0) {
          DEBUG_BUILD$3 && logger.log('No outcomes to send');
          return;
        }

        // This is really the only place where we want to check for a DSN and only send outcomes then
        if (!this._dsn) {
          DEBUG_BUILD$3 && logger.log('No dsn provided, will not send outcomes');
          return;
        }

        DEBUG_BUILD$3 && logger.log('Sending outcomes:', outcomes);

        const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));

        // sendEnvelope should not throw
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.sendEnvelope(envelope);
      }

      /**
       * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
       */

    }

    /**
     * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.
     */
    function _validateBeforeSendResult(
      beforeSendResult,
      beforeSendLabel,
    ) {
      const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
      if (isThenable(beforeSendResult)) {
        return beforeSendResult.then(
          event => {
            if (!isPlainObject(event) && event !== null) {
              throw _makeInternalError(invalidValueError);
            }
            return event;
          },
          e => {
            throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);
          },
        );
      } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
        throw _makeInternalError(invalidValueError);
      }
      return beforeSendResult;
    }

    /**
     * Process the matching `beforeSendXXX` callback.
     */
    function processBeforeSend(
      client,
      options,
      event,
      hint,
    ) {
      const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;
      let processedEvent = event;

      if (isErrorEvent(processedEvent) && beforeSend) {
        return beforeSend(processedEvent, hint);
      }

      if (isTransactionEvent(processedEvent)) {
        if (beforeSendSpan) {
          // process root span
          const processedRootSpanJson = beforeSendSpan(convertTransactionEventToSpanJson(processedEvent));
          if (!processedRootSpanJson) {
            showSpanDropWarning();
          } else {
            // update event with processed root span values
            processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));
          }

          // process child spans
          if (processedEvent.spans) {
            const processedSpans = [];
            for (const span of processedEvent.spans) {
              const processedSpan = beforeSendSpan(span);
              if (!processedSpan) {
                showSpanDropWarning();
                processedSpans.push(span);
              } else {
                processedSpans.push(processedSpan);
              }
            }
            processedEvent.spans = processedSpans;
          }
        }

        if (beforeSendTransaction) {
          if (processedEvent.spans) {
            // We store the # of spans before processing in SDK metadata,
            // so we can compare it afterwards to determine how many spans were dropped
            const spanCountBefore = processedEvent.spans.length;
            processedEvent.sdkProcessingMetadata = {
              ...event.sdkProcessingMetadata,
              spanCountBeforeProcessing: spanCountBefore,
            };
          }
          return beforeSendTransaction(processedEvent , hint);
        }
      }

      return processedEvent;
    }

    function isErrorEvent(event) {
      return event.type === undefined;
    }

    function isTransactionEvent(event) {
      return event.type === 'transaction';
    }

    /**
     * Creates OTEL log envelope item for a serialized OTEL log.
     *
     * @param log - The serialized OTEL log to include in the envelope.
     * @returns The created OTEL log envelope item.
     */
    function createOtelLogEnvelopeItem(log) {
      return [
        {
          type: 'otel_log',
        },
        log,
      ];
    }

    /**
     * Creates an envelope for a list of logs.
     *
     * @param logs - The logs to include in the envelope.
     * @param metadata - The metadata to include in the envelope.
     * @param tunnel - The tunnel to include in the envelope.
     * @param dsn - The DSN to include in the envelope.
     * @returns The created envelope.
     */
    function createOtelLogEnvelope(
      logs,
      metadata,
      tunnel,
      dsn,
    ) {
      const headers = {};

      if (metadata?.sdk) {
        headers.sdk = {
          name: metadata.sdk.name,
          version: metadata.sdk.version,
        };
      }

      if (!!tunnel && !!dsn) {
        headers.dsn = dsnToString(dsn);
      }

      return createEnvelope(headers, logs.map(createOtelLogEnvelopeItem));
    }

    const CLIENT_TO_LOG_BUFFER_MAP = new WeakMap();

    /**
     * Flushes the logs buffer to Sentry.
     *
     * @param client - A client.
     * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.
     *
     * @experimental This method will experience breaking changes. This is not yet part of
     * the stable Sentry SDK API and can be changed or removed without warning.
     */
    function _INTERNAL_flushLogsBuffer(client, maybeLogBuffer) {
      const logBuffer = maybeLogBuffer ?? CLIENT_TO_LOG_BUFFER_MAP.get(client) ?? [];
      if (logBuffer.length === 0) {
        return;
      }

      const clientOptions = client.getOptions();
      const envelope = createOtelLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());

      // Clear the log buffer after envelopes have been constructed.
      logBuffer.length = 0;

      client.emit('flushLogs');

      // sendEnvelope should not throw
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      client.sendEnvelope(envelope);
    }

    const SENTRY_BUFFER_FULL_ERROR = Symbol.for('SentryBufferFullError');

    /**
     * Creates an new PromiseBuffer object with the specified limit
     * @param limit max number of promises that can be stored in the buffer
     */
    function makePromiseBuffer(limit) {
      const buffer = [];

      function isReady() {
        return limit === undefined || buffer.length < limit;
      }

      /**
       * Remove a promise from the queue.
       *
       * @param task Can be any PromiseLike<T>
       * @returns Removed promise.
       */
      function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(undefined);
      }

      /**
       * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
       *
       * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
       *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
       *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
       *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
       *        limit check.
       * @returns The original promise.
       */
      function add(taskProducer) {
        if (!isReady()) {
          return rejectedSyncPromise(SENTRY_BUFFER_FULL_ERROR);
        }

        // start the task and add its promise to the queue
        const task = taskProducer();
        if (buffer.indexOf(task) === -1) {
          buffer.push(task);
        }
        void task
          .then(() => remove(task))
          // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
          // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
          // have promises, so TS has to polyfill when down-compiling.)
          .then(null, () =>
            remove(task).then(null, () => {
              // We have to add another catch here because `remove()` starts a new promise chain.
            }),
          );
        return task;
      }

      /**
       * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
       * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
       * `false` otherwise
       */
      function drain(timeout) {
        return new SyncPromise((resolve, reject) => {
          let counter = buffer.length;

          if (!counter) {
            return resolve(true);
          }

          // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
          const capturedSetTimeout = setTimeout(() => {
            if (timeout && timeout > 0) {
              resolve(false);
            }
          }, timeout);

          // if all promises resolve in time, cancel the timer and resolve to `true`
          buffer.forEach(item => {
            void resolvedSyncPromise(item).then(() => {
              if (!--counter) {
                clearTimeout(capturedSetTimeout);
                resolve(true);
              }
            }, reject);
          });
        });
      }

      return {
        $: buffer,
        add,
        drain,
      };
    }

    // Intentionally keeping the key broad, as we don't know for sure what rate limit headers get returned from backend

    const DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds

    /**
     * Extracts Retry-After value from the request header or returns default value
     * @param header string representation of 'Retry-After' header
     * @param now current unix timestamp
     *
     */
    function parseRetryAfterHeader(header, now = Date.now()) {
      const headerDelay = parseInt(`${header}`, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1000;
      }

      const headerDate = Date.parse(`${header}`);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }

      return DEFAULT_RETRY_AFTER;
    }

    /**
     * Gets the time that the given category is disabled until for rate limiting.
     * In case no category-specific limit is set but a general rate limit across all categories is active,
     * that time is returned.
     *
     * @return the time in ms that the category is disabled until or 0 if there's no active rate limit.
     */
    function disabledUntil(limits, dataCategory) {
      return limits[dataCategory] || limits.all || 0;
    }

    /**
     * Checks if a category is rate limited
     */
    function isRateLimited(limits, dataCategory, now = Date.now()) {
      return disabledUntil(limits, dataCategory) > now;
    }

    /**
     * Update ratelimits from incoming headers.
     *
     * @return the updated RateLimits object.
     */
    function updateRateLimits(
      limits,
      { statusCode, headers },
      now = Date.now(),
    ) {
      const updatedRateLimits = {
        ...limits,
      };

      // "The name is case-insensitive."
      // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
      const rateLimitHeader = headers?.['x-sentry-rate-limits'];
      const retryAfterHeader = headers?.['retry-after'];

      if (rateLimitHeader) {
        /**
         * rate limit headers are of the form
         *     <header>,<header>,..
         * where each <header> is of the form
         *     <retry_after>: <categories>: <scope>: <reason_code>: <namespaces>
         * where
         *     <retry_after> is a delay in seconds
         *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
         *         <category>;<category>;...
         *     <scope> is what's being limited (org, project, or key) - ignored by SDK
         *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
         *     <namespaces> Semicolon-separated list of metric namespace identifiers. Defines which namespace(s) will be affected.
         *         Only present if rate limit applies to the metric_bucket data category.
         */
        for (const limit of rateLimitHeader.trim().split(',')) {
          const [retryAfter, categories, , , namespaces] = limit.split(':', 5) ;
          const headerDelay = parseInt(retryAfter, 10);
          const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
          if (!categories) {
            updatedRateLimits.all = now + delay;
          } else {
            for (const category of categories.split(';')) {
              if (category === 'metric_bucket') {
                // namespaces will be present when category === 'metric_bucket'
                if (!namespaces || namespaces.split(';').includes('custom')) {
                  updatedRateLimits[category] = now + delay;
                }
              } else {
                updatedRateLimits[category] = now + delay;
              }
            }
          }
        }
      } else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
      } else if (statusCode === 429) {
        updatedRateLimits.all = now + 60 * 1000;
      }

      return updatedRateLimits;
    }

    const DEFAULT_TRANSPORT_BUFFER_SIZE = 64;

    /**
     * Creates an instance of a Sentry `Transport`
     *
     * @param options
     * @param makeRequest
     */
    function createTransport(
      options,
      makeRequest,
      buffer = makePromiseBuffer(
        options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE,
      ),
    ) {
      let rateLimits = {};
      const flush = (timeout) => buffer.drain(timeout);

      function send(envelope) {
        const filteredEnvelopeItems = [];

        // Drop rate limited items from envelope
        forEachEnvelopeItem(envelope, (item, type) => {
          const dataCategory = envelopeItemTypeToDataCategory(type);
          if (isRateLimited(rateLimits, dataCategory)) {
            options.recordDroppedEvent('ratelimit_backoff', dataCategory);
          } else {
            filteredEnvelopeItems.push(item);
          }
        });

        // Skip sending if envelope is empty after filtering out rate limited events
        if (filteredEnvelopeItems.length === 0) {
          return resolvedSyncPromise({});
        }

        const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems );

        // Creates client report for each item in an envelope
        const recordEnvelopeLoss = (reason) => {
          forEachEnvelopeItem(filteredEnvelope, (item, type) => {
            options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));
          });
        };

        const requestTask = () =>
          makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(
            response => {
              // We don't want to throw on NOK responses, but we want to at least log them
              if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {
                DEBUG_BUILD$3 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
              }

              rateLimits = updateRateLimits(rateLimits, response);
              return response;
            },
            error => {
              recordEnvelopeLoss('network_error');
              DEBUG_BUILD$3 && logger.error('Encountered error running transport request:', error);
              throw error;
            },
          );

        return buffer.add(requestTask).then(
          result => result,
          error => {
            if (error === SENTRY_BUFFER_FULL_ERROR) {
              DEBUG_BUILD$3 && logger.error('Skipped sending event because buffer is full.');
              recordEnvelopeLoss('queue_overflow');
              return resolvedSyncPromise({});
            } else {
              throw error;
            }
          },
        );
      }

      return {
        send,
        flush,
      };
    }

    // By default, we want to infer the IP address, unless this is explicitly set to `null`
    // We do this after all other processing is done
    // If `ip_address` is explicitly set to `null` or a value, we leave it as is

    /**
     * @internal
     */
    function addAutoIpAddressToUser(objWithMaybeUser) {
      if (objWithMaybeUser.user?.ip_address === undefined) {
        objWithMaybeUser.user = {
          ...objWithMaybeUser.user,
          ip_address: '{{auto}}',
        };
      }
    }

    /**
     * @internal
     */
    function addAutoIpAddressToSession(session) {
      if ('aggregates' in session) {
        if (session.attrs?.['ip_address'] === undefined) {
          session.attrs = {
            ...session.attrs,
            ip_address: '{{auto}}',
          };
        }
      } else {
        if (session.ipAddress === undefined) {
          session.ipAddress = '{{auto}}';
        }
      }
    }

    /**
     * A builder for the SDK metadata in the options for the SDK initialization.
     *
     * Note: This function is identical to `buildMetadata` in Remix and NextJS and SvelteKit.
     * We don't extract it for bundle size reasons.
     * @see https://github.com/getsentry/sentry-javascript/pull/7404
     * @see https://github.com/getsentry/sentry-javascript/pull/4196
     *
     * If you make changes to this function consider updating the others as well.
     *
     * @param options SDK options object that gets mutated
     * @param names list of package names
     */
    function applySdkMetadata(options, name, names = [name], source = 'npm') {
      const metadata = options._metadata || {};

      if (!metadata.sdk) {
        metadata.sdk = {
          name: `sentry.javascript.${name}`,
          packages: names.map(name => ({
            name: `${source}:@sentry/${name}`,
            version: SDK_VERSION,
          })),
          version: SDK_VERSION,
        };
      }

      options._metadata = metadata;
    }

    /**
     * Default maximum number of breadcrumbs added to an event. Can be overwritten
     * with {@link Options.maxBreadcrumbs}.
     */
    const DEFAULT_BREADCRUMBS = 100;

    /**
     * Records a new breadcrumb which will be attached to future events.
     *
     * Breadcrumbs will be added to subsequent events to provide more context on
     * user's actions prior to an error or crash.
     */
    function addBreadcrumb(breadcrumb, hint) {
      const client = getClient();
      const isolationScope = getIsolationScope();

      if (!client) return;

      const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();

      if (maxBreadcrumbs <= 0) return;

      const timestamp = dateTimestampInSeconds();
      const mergedBreadcrumb = { timestamp, ...breadcrumb };
      const finalBreadcrumb = beforeBreadcrumb
        ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )
        : mergedBreadcrumb;

      if (finalBreadcrumb === null) return;

      if (client.emit) {
        client.emit('beforeAddBreadcrumb', finalBreadcrumb, hint);
      }

      isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    }

    let originalFunctionToString;

    const INTEGRATION_NAME$6 = 'FunctionToString';

    const SETUP_CLIENTS = new WeakMap();

    const _functionToStringIntegration = (() => {
      return {
        name: INTEGRATION_NAME$6,
        setupOnce() {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          originalFunctionToString = Function.prototype.toString;

          // intrinsics (like Function.prototype) might be immutable in some environments
          // e.g. Node with --frozen-intrinsics, XS (an embedded JavaScript engine) or SES (a JavaScript proposal)
          try {
            Function.prototype.toString = function ( ...args) {
              const originalFunction = getOriginalFunction(this);
              const context =
                SETUP_CLIENTS.has(getClient() ) && originalFunction !== undefined ? originalFunction : this;
              return originalFunctionToString.apply(context, args);
            };
          } catch {
            // ignore errors here, just don't patch this
          }
        },
        setup(client) {
          SETUP_CLIENTS.set(client, true);
        },
      };
    }) ;

    /**
     * Patch toString calls to return proper name for wrapped functions.
     *
     * ```js
     * Sentry.init({
     *   integrations: [
     *     functionToStringIntegration(),
     *   ],
     * });
     * ```
     */
    const functionToStringIntegration = defineIntegration(_functionToStringIntegration);

    // "Script error." is hard coded into browsers for errors that it can't read.
    // this is the result of a script being pulled in from an external domain and CORS.
    const DEFAULT_IGNORE_ERRORS = [
      /^Script error\.?$/,
      /^Javascript error: Script error\.? on line 0$/,
      /^ResizeObserver loop completed with undelivered notifications.$/, // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
      /^Cannot redefine property: googletag$/, // This is thrown when google tag manager is used in combination with an ad blocker
      /^Can't find variable: gmo$/, // Error from Google Search App https://issuetracker.google.com/issues/396043331
      /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/, // Random error that happens but not actionable or noticeable to end-users.
      'can\'t redefine non-configurable property "solana"', // Probably a browser extension or custom browser (Brave) throwing this error
      "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", // Error thrown by GTM, seemingly not affecting end-users
      "Can't find variable: _AutofillCallbackHandler", // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
      /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/, // unactionable error from CEFSharp, a .NET library that embeds chromium in .NET apps
      /^Java exception was raised during method invocation$/, // error from Facebook Mobile browser (https://github.com/getsentry/sentry-javascript/issues/15065)
    ];

    /** Options for the EventFilters integration */

    const INTEGRATION_NAME$5 = 'EventFilters';

    /**
     * An integration that filters out events (errors and transactions) based on:
     *
     * - (Errors) A curated list of known low-value or irrelevant errors (see {@link DEFAULT_IGNORE_ERRORS})
     * - (Errors) A list of error messages or urls/filenames passed in via
     *   - Top level Sentry.init options (`ignoreErrors`, `denyUrls`, `allowUrls`)
     *   - The same options passed to the integration directly via @param options
     * - (Transactions/Spans) A list of root span (transaction) names passed in via
     *   - Top level Sentry.init option (`ignoreTransactions`)
     *   - The same option passed to the integration directly via @param options
     *
     * Events filtered by this integration will not be sent to Sentry.
     */
    const eventFiltersIntegration = defineIntegration((options = {}) => {
      let mergedOptions;
      return {
        name: INTEGRATION_NAME$5,
        setup(client) {
          const clientOptions = client.getOptions();
          mergedOptions = _mergeOptions(options, clientOptions);
        },
        processEvent(event, _hint, client) {
          if (!mergedOptions) {
            const clientOptions = client.getOptions();
            mergedOptions = _mergeOptions(options, clientOptions);
          }
          return _shouldDropEvent$1(event, mergedOptions) ? null : event;
        },
      };
    });

    /**
     * An integration that filters out events (errors and transactions) based on:
     *
     * - (Errors) A curated list of known low-value or irrelevant errors (see {@link DEFAULT_IGNORE_ERRORS})
     * - (Errors) A list of error messages or urls/filenames passed in via
     *   - Top level Sentry.init options (`ignoreErrors`, `denyUrls`, `allowUrls`)
     *   - The same options passed to the integration directly via @param options
     * - (Transactions/Spans) A list of root span (transaction) names passed in via
     *   - Top level Sentry.init option (`ignoreTransactions`)
     *   - The same option passed to the integration directly via @param options
     *
     * Events filtered by this integration will not be sent to Sentry.
     *
     * @deprecated this integration was renamed and will be removed in a future major version.
     * Use `eventFiltersIntegration` instead.
     */
    const inboundFiltersIntegration = defineIntegration(((options = {}) => {
      return {
        ...eventFiltersIntegration(options),
        name: 'InboundFilters',
      };
    }) );

    function _mergeOptions(
      internalOptions = {},
      clientOptions = {},
    ) {
      return {
        allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],
        denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],
        ignoreErrors: [
          ...(internalOptions.ignoreErrors || []),
          ...(clientOptions.ignoreErrors || []),
          ...(internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS),
        ],
        ignoreTransactions: [...(internalOptions.ignoreTransactions || []), ...(clientOptions.ignoreTransactions || [])],
      };
    }

    function _shouldDropEvent$1(event, options) {
      if (!event.type) {
        // Filter errors
        if (_isIgnoredError(event, options.ignoreErrors)) {
          DEBUG_BUILD$3 &&
            logger.warn(
              `Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(event)}`,
            );
          return true;
        }
        if (_isUselessError(event)) {
          DEBUG_BUILD$3 &&
            logger.warn(
              `Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${getEventDescription(
            event,
          )}`,
            );
          return true;
        }
        if (_isDeniedUrl(event, options.denyUrls)) {
          DEBUG_BUILD$3 &&
            logger.warn(
              `Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${getEventDescription(
            event,
          )}.\nUrl: ${_getEventFilterUrl(event)}`,
            );
          return true;
        }
        if (!_isAllowedUrl(event, options.allowUrls)) {
          DEBUG_BUILD$3 &&
            logger.warn(
              `Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${getEventDescription(
            event,
          )}.\nUrl: ${_getEventFilterUrl(event)}`,
            );
          return true;
        }
      } else if (event.type === 'transaction') {
        // Filter transactions

        if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
          DEBUG_BUILD$3 &&
            logger.warn(
              `Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${getEventDescription(event)}`,
            );
          return true;
        }
      }
      return false;
    }

    function _isIgnoredError(event, ignoreErrors) {
      if (!ignoreErrors?.length) {
        return false;
      }

      return getPossibleEventMessages(event).some(message => stringMatchesSomePattern(message, ignoreErrors));
    }

    function _isIgnoredTransaction(event, ignoreTransactions) {
      if (!ignoreTransactions?.length) {
        return false;
      }

      const name = event.transaction;
      return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
    }

    function _isDeniedUrl(event, denyUrls) {
      if (!denyUrls?.length) {
        return false;
      }
      const url = _getEventFilterUrl(event);
      return !url ? false : stringMatchesSomePattern(url, denyUrls);
    }

    function _isAllowedUrl(event, allowUrls) {
      if (!allowUrls?.length) {
        return true;
      }
      const url = _getEventFilterUrl(event);
      return !url ? true : stringMatchesSomePattern(url, allowUrls);
    }

    function _getLastValidUrl(frames = []) {
      for (let i = frames.length - 1; i >= 0; i--) {
        const frame = frames[i];

        if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
          return frame.filename || null;
        }
      }

      return null;
    }

    function _getEventFilterUrl(event) {
      try {
        // If there are linked exceptions or exception aggregates we only want to match against the top frame of the "root" (the main exception)
        // The root always comes last in linked exceptions
        const rootException = [...(event.exception?.values ?? [])]
          .reverse()
          .find(value => value.mechanism?.parent_id === undefined && value.stacktrace?.frames?.length);
        const frames = rootException?.stacktrace?.frames;
        return frames ? _getLastValidUrl(frames) : null;
      } catch (oO) {
        DEBUG_BUILD$3 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
        return null;
      }
    }

    function _isUselessError(event) {
      // We only want to consider events for dropping that actually have recorded exception values.
      if (!event.exception?.values?.length) {
        return false;
      }

      return (
        // No top-level message
        !event.message &&
        // There are no exception values that have a stacktrace, a non-generic-Error type or value
        !event.exception.values.some(value => value.stacktrace || (value.type && value.type !== 'Error') || value.value)
      );
    }

    /**
     * Creates exceptions inside `event.exception.values` for errors that are nested on properties based on the `key` parameter.
     */
    function applyAggregateErrorsToEvent(
      exceptionFromErrorImplementation,
      parser,
      key,
      limit,
      event,
      hint,
    ) {
      if (!event.exception?.values || !hint || !isInstanceOf(hint.originalException, Error)) {
        return;
      }

      // Generally speaking the last item in `event.exception.values` is the exception originating from the original Error
      const originalException =
        event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : undefined;

      // We only create exception grouping if there is an exception in the event.
      if (originalException) {
        event.exception.values = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          hint.originalException ,
          key,
          event.exception.values,
          originalException,
          0,
        );
      }
    }

    function aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser,
      limit,
      error,
      key,
      prevExceptions,
      exception,
      exceptionId,
    ) {
      if (prevExceptions.length >= limit + 1) {
        return prevExceptions;
      }

      let newExceptions = [...prevExceptions];

      // Recursively call this function in order to walk down a chain of errors
      if (isInstanceOf(error[key], Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, error[key]);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          error[key],
          key,
          [newException, ...newExceptions],
          newException,
          newExceptionId,
        );
      }

      // This will create exception grouping for AggregateErrors
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError
      if (Array.isArray(error.errors)) {
        error.errors.forEach((childError, i) => {
          if (isInstanceOf(childError, Error)) {
            applyExceptionGroupFieldsForParentException(exception, exceptionId);
            const newException = exceptionFromErrorImplementation(parser, childError);
            const newExceptionId = newExceptions.length;
            applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
            newExceptions = aggregateExceptionsFromError(
              exceptionFromErrorImplementation,
              parser,
              limit,
              childError,
              key,
              [newException, ...newExceptions],
              newException,
              newExceptionId,
            );
          }
        });
      }

      return newExceptions;
    }

    function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
      // Don't know if this default makes sense. The protocol requires us to set these values so we pick *some* default.
      exception.mechanism = exception.mechanism || { type: 'generic', handled: true };

      exception.mechanism = {
        ...exception.mechanism,
        ...(exception.type === 'AggregateError' && { is_exception_group: true }),
        exception_id: exceptionId,
      };
    }

    function applyExceptionGroupFieldsForChildException(
      exception,
      source,
      exceptionId,
      parentId,
    ) {
      // Don't know if this default makes sense. The protocol requires us to set these values so we pick *some* default.
      exception.mechanism = exception.mechanism || { type: 'generic', handled: true };

      exception.mechanism = {
        ...exception.mechanism,
        type: 'chained',
        source,
        exception_id: exceptionId,
        parent_id: parentId,
      };
    }

    /**
     * Add an instrumentation handler for when a console.xxx method is called.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addConsoleInstrumentationHandler(handler) {
      const type = 'console';
      addHandler(type, handler);
      maybeInstrument(type, instrumentConsole);
    }

    function instrumentConsole() {
      if (!('console' in GLOBAL_OBJ)) {
        return;
      }

      CONSOLE_LEVELS.forEach(function (level) {
        if (!(level in GLOBAL_OBJ.console)) {
          return;
        }

        fill(GLOBAL_OBJ.console, level, function (originalConsoleMethod) {
          originalConsoleMethods[level] = originalConsoleMethod;

          return function (...args) {
            const handlerData = { args, level };
            triggerHandlers('console', handlerData);

            const log = originalConsoleMethods[level];
            log?.apply(GLOBAL_OBJ.console, args);
          };
        });
      });
    }

    /**
     * Converts a string-based level into a `SeverityLevel`, normalizing it along the way.
     *
     * @param level String representation of desired `SeverityLevel`.
     * @returns The `SeverityLevel` corresponding to the given string, or 'log' if the string isn't a valid level.
     */
    function severityLevelFromString(level) {
      return (
        level === 'warn' ? 'warning' : ['fatal', 'error', 'warning', 'log', 'info', 'debug'].includes(level) ? level : 'log'
      ) ;
    }

    const INTEGRATION_NAME$4 = 'Dedupe';

    const _dedupeIntegration = (() => {
      let previousEvent;

      return {
        name: INTEGRATION_NAME$4,
        processEvent(currentEvent) {
          // We want to ignore any non-error type events, e.g. transactions or replays
          // These should never be deduped, and also not be compared against as _previousEvent.
          if (currentEvent.type) {
            return currentEvent;
          }

          // Juuust in case something goes wrong
          try {
            if (_shouldDropEvent(currentEvent, previousEvent)) {
              DEBUG_BUILD$3 && logger.warn('Event dropped due to being a duplicate of previously captured event.');
              return null;
            }
          } catch (_oO) {} // eslint-disable-line no-empty

          return (previousEvent = currentEvent);
        },
      };
    }) ;

    /**
     * Deduplication filter.
     */
    const dedupeIntegration = defineIntegration(_dedupeIntegration);

    /** only exported for tests. */
    function _shouldDropEvent(currentEvent, previousEvent) {
      if (!previousEvent) {
        return false;
      }

      if (_isSameMessageEvent(currentEvent, previousEvent)) {
        return true;
      }

      if (_isSameExceptionEvent(currentEvent, previousEvent)) {
        return true;
      }

      return false;
    }

    function _isSameMessageEvent(currentEvent, previousEvent) {
      const currentMessage = currentEvent.message;
      const previousMessage = previousEvent.message;

      // If neither event has a message property, they were both exceptions, so bail out
      if (!currentMessage && !previousMessage) {
        return false;
      }

      // If only one event has a stacktrace, but not the other one, they are not the same
      if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {
        return false;
      }

      if (currentMessage !== previousMessage) {
        return false;
      }

      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }

      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }

      return true;
    }

    function _isSameExceptionEvent(currentEvent, previousEvent) {
      const previousException = _getExceptionFromEvent(previousEvent);
      const currentException = _getExceptionFromEvent(currentEvent);

      if (!previousException || !currentException) {
        return false;
      }

      if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
        return false;
      }

      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }

      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }

      return true;
    }

    function _isSameStacktrace(currentEvent, previousEvent) {
      let currentFrames = getFramesFromEvent(currentEvent);
      let previousFrames = getFramesFromEvent(previousEvent);

      // If neither event has a stacktrace, they are assumed to be the same
      if (!currentFrames && !previousFrames) {
        return true;
      }

      // If only one event has a stacktrace, but not the other one, they are not the same
      if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {
        return false;
      }

      currentFrames = currentFrames ;
      previousFrames = previousFrames ;

      // If number of frames differ, they are not the same
      if (previousFrames.length !== currentFrames.length) {
        return false;
      }

      // Otherwise, compare the two
      for (let i = 0; i < previousFrames.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const frameA = previousFrames[i];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const frameB = currentFrames[i];

        if (
          frameA.filename !== frameB.filename ||
          frameA.lineno !== frameB.lineno ||
          frameA.colno !== frameB.colno ||
          frameA.function !== frameB.function
        ) {
          return false;
        }
      }

      return true;
    }

    function _isSameFingerprint(currentEvent, previousEvent) {
      let currentFingerprint = currentEvent.fingerprint;
      let previousFingerprint = previousEvent.fingerprint;

      // If neither event has a fingerprint, they are assumed to be the same
      if (!currentFingerprint && !previousFingerprint) {
        return true;
      }

      // If only one event has a fingerprint, but not the other one, they are not the same
      if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {
        return false;
      }

      currentFingerprint = currentFingerprint ;
      previousFingerprint = previousFingerprint ;

      // Otherwise, compare the two
      try {
        return !!(currentFingerprint.join('') === previousFingerprint.join(''));
      } catch (_oO) {
        return false;
      }
    }

    function _getExceptionFromEvent(event) {
      return event.exception?.values && event.exception.values[0];
    }

    // Curious about `thismessage:/`? See: https://www.rfc-editor.org/rfc/rfc2557.html

    /**
     * Parses string form of URL into an object
     * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
     * // intentionally using regex and not <a/> href parsing trick because React Native and other
     * // environments where DOM might not be available
     * @returns parsed URL object
     */
    function parseUrl(url) {
      if (!url) {
        return {};
      }

      const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

      if (!match) {
        return {};
      }

      // coerce to undefined values to empty string so we don't get 'undefined'
      const query = match[6] || '';
      const fragment = match[8] || '';
      return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        search: query,
        hash: fragment,
        relative: match[5] + query + fragment, // everything minus origin
      };
    }

    /**
     * Determine a breadcrumb's log level (only `warning` or `error`) based on an HTTP status code.
     */
    function getBreadcrumbLogLevelFromHttpStatusCode(statusCode) {
      // NOTE: undefined defaults to 'info' in Sentry
      if (statusCode === undefined) {
        return undefined;
      } else if (statusCode >= 400 && statusCode < 500) {
        return 'warning';
      } else if (statusCode >= 500) {
        return 'error';
      } else {
        return undefined;
      }
    }

    const WINDOW$2 = GLOBAL_OBJ ;

    /**
     * Tells whether current environment supports History API
     * {@link supportsHistory}.
     *
     * @returns Answer to the given question.
     */
    function supportsHistory() {
      return 'history' in WINDOW$2 && !!WINDOW$2.history;
    }

    /**
     * Tells whether current environment supports Fetch API
     * {@link supportsFetch}.
     *
     * @returns Answer to the given question.
     */
    function supportsFetch() {
      if (!('fetch' in WINDOW$2)) {
        return false;
      }

      try {
        new Headers();
        new Request('http://www.example.com');
        new Response();
        return true;
      } catch (e) {
        return false;
      }
    }

    /**
     * isNative checks if the given function is a native implementation
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function isNativeFunction(func) {
      return func && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }

    /**
     * Tells whether current environment supports Fetch API natively
     * {@link supportsNativeFetch}.
     *
     * @returns true if `window.fetch` is natively implemented, false otherwise
     */
    function supportsNativeFetch() {
      if (typeof EdgeRuntime === 'string') {
        return true;
      }

      if (!supportsFetch()) {
        return false;
      }

      // Fast path to avoid DOM I/O
      // eslint-disable-next-line @typescript-eslint/unbound-method
      if (isNativeFunction(WINDOW$2.fetch)) {
        return true;
      }

      // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
      // so create a "pure" iframe to see if that has native fetch
      let result = false;
      const doc = WINDOW$2.document;
      // eslint-disable-next-line deprecation/deprecation
      if (doc && typeof (doc.createElement ) === 'function') {
        try {
          const sandbox = doc.createElement('iframe');
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow?.fetch) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            result = isNativeFunction(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        } catch (err) {
          DEBUG_BUILD$2 &&
            logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
        }
      }

      return result;
    }

    /**
     * Add an instrumentation handler for when a fetch request happens.
     * The handler function is called once when the request starts and once when it ends,
     * which can be identified by checking if it has an `endTimestamp`.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addFetchInstrumentationHandler(
      handler,
      skipNativeFetchCheck,
    ) {
      const type = 'fetch';
      addHandler(type, handler);
      maybeInstrument(type, () => instrumentFetch(undefined, skipNativeFetchCheck));
    }

    function instrumentFetch(onFetchResolved, skipNativeFetchCheck = false) {
      if (skipNativeFetchCheck && !supportsNativeFetch()) {
        return;
      }

      fill(GLOBAL_OBJ, 'fetch', function (originalFetch) {
        return function (...args) {
          // We capture the error right here and not in the Promise error callback because Safari (and probably other
          // browsers too) will wipe the stack trace up to this point, only leaving us with this file which is useless.

          // NOTE: If you are a Sentry user, and you are seeing this stack frame,
          //       it means the error, that was caused by your fetch call did not
          //       have a stack trace, so the SDK backfilled the stack trace so
          //       you can see which fetch call failed.
          const virtualError = new Error();

          const { method, url } = parseFetchArgs(args);
          const handlerData = {
            args,
            fetchData: {
              method,
              url,
            },
            startTimestamp: timestampInSeconds() * 1000,
            // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation
            virtualError,
            headers: getHeadersFromFetchArgs(args),
          };

          // if there is no callback, fetch is instrumented directly
          if (!onFetchResolved) {
            triggerHandlers('fetch', {
              ...handlerData,
            });
          }

          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          return originalFetch.apply(GLOBAL_OBJ, args).then(
            async (response) => {
              if (onFetchResolved) {
                onFetchResolved(response);
              } else {
                triggerHandlers('fetch', {
                  ...handlerData,
                  endTimestamp: timestampInSeconds() * 1000,
                  response,
                });
              }

              return response;
            },
            (error) => {
              triggerHandlers('fetch', {
                ...handlerData,
                endTimestamp: timestampInSeconds() * 1000,
                error,
              });

              if (isError(error) && error.stack === undefined) {
                // NOTE: If you are a Sentry user, and you are seeing this stack frame,
                //       it means the error, that was caused by your fetch call did not
                //       have a stack trace, so the SDK backfilled the stack trace so
                //       you can see which fetch call failed.
                error.stack = virtualError.stack;
                addNonEnumerableProperty(error, 'framesToPop', 1);
              }

              // We enhance the not-so-helpful "Failed to fetch" error messages with the host
              // Possible messages we handle here:
              // * "Failed to fetch" (chromium)
              // * "Load failed" (webkit)
              // * "NetworkError when attempting to fetch resource." (firefox)
              if (
                error instanceof TypeError &&
                (error.message === 'Failed to fetch' ||
                  error.message === 'Load failed' ||
                  error.message === 'NetworkError when attempting to fetch resource.')
              ) {
                try {
                  const url = new URL(handlerData.fetchData.url);
                  error.message = `${error.message} (${url.host})`;
                } catch {
                  // ignore it if errors happen here
                }
              }

              // NOTE: If you are a Sentry user, and you are seeing this stack frame,
              //       it means the sentry.javascript SDK caught an error invoking your application code.
              //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
              throw error;
            },
          );
        };
      });
    }

    function hasProp(obj, prop) {
      return !!obj && typeof obj === 'object' && !!(obj )[prop];
    }

    function getUrlFromResource(resource) {
      if (typeof resource === 'string') {
        return resource;
      }

      if (!resource) {
        return '';
      }

      if (hasProp(resource, 'url')) {
        return resource.url;
      }

      if (resource.toString) {
        return resource.toString();
      }

      return '';
    }

    /**
     * Parses the fetch arguments to find the used Http method and the url of the request.
     * Exported for tests only.
     */
    function parseFetchArgs(fetchArgs) {
      if (fetchArgs.length === 0) {
        return { method: 'GET', url: '' };
      }

      if (fetchArgs.length === 2) {
        const [url, options] = fetchArgs ;

        return {
          url: getUrlFromResource(url),
          method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET',
        };
      }

      const arg = fetchArgs[0];
      return {
        url: getUrlFromResource(arg ),
        method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET',
      };
    }

    function getHeadersFromFetchArgs(fetchArgs) {
      const [requestArgument, optionsArgument] = fetchArgs;

      try {
        if (
          typeof optionsArgument === 'object' &&
          optionsArgument !== null &&
          'headers' in optionsArgument &&
          optionsArgument.headers
        ) {
          return new Headers(optionsArgument.headers );
        }

        if (isRequest(requestArgument)) {
          return new Headers(requestArgument.headers);
        }
      } catch {
        // noop
      }

      return;
    }

    /*
     * This module exists for optimizations in the build process through rollup and terser.  We define some global
     * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
     * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
     * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
     * `logger` and preventing node-related code from appearing in browser bundles.
     *
     * Attention:
     * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
     * users. These flags should live in their respective packages, as we identified user tooling (specifically webpack)
     * having issues tree-shaking these constants across package boundaries.
     * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
     * users to be able to shake away expressions that it guards.
     */

    /**
     * Get source of SDK.
     */
    function getSDKSource() {
      // This comment is used to identify this line in the CDN bundle build step and replace this with "return 'cdn';"
      /* __SENTRY_SDK_SOURCE__ */ return 'npm';
    }

    const WINDOW$1 = GLOBAL_OBJ ;

    let ignoreOnError = 0;

    /**
     * @hidden
     */
    function shouldIgnoreOnError() {
      return ignoreOnError > 0;
    }

    /**
     * @hidden
     */
    function ignoreNextOnError() {
      // onerror should trigger before setTimeout
      ignoreOnError++;
      setTimeout(() => {
        ignoreOnError--;
      });
    }

    // eslint-disable-next-line @typescript-eslint/ban-types

    /**
     * Instruments the given function and sends an event to Sentry every time the
     * function throws an exception.
     *
     * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always
     * has a correct `this` context.
     * @returns The wrapped function.
     * @hidden
     */
    function wrap(
      fn,
      options

     = {},
    ) {
      // for future readers what this does is wrap a function and then create
      // a bi-directional wrapping between them.
      //
      // example: wrapped = wrap(original);
      //  original.__sentry_wrapped__ -> wrapped
      //  wrapped.__sentry_original__ -> original

      function isFunction(fn) {
        return typeof fn === 'function';
      }

      if (!isFunction(fn)) {
        return fn;
      }

      try {
        // if we're dealing with a function that was previously wrapped, return
        // the original wrapper.
        const wrapper = (fn ).__sentry_wrapped__;
        if (wrapper) {
          if (typeof wrapper === 'function') {
            return wrapper;
          } else {
            // If we find that the `__sentry_wrapped__` function is not a function at the time of accessing it, it means
            // that something messed with it. In that case we want to return the originally passed function.
            return fn;
          }
        }

        // We don't wanna wrap it twice
        if (getOriginalFunction(fn)) {
          return fn;
        }
      } catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        // Bail on wrapping and return the function as-is (defers to window.onerror).
        return fn;
      }

      // Wrap the function itself
      // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`
      const sentryWrapped = function ( ...args) {
        try {
          // Also wrap arguments that are themselves functions
          const wrappedArguments = args.map(arg => wrap(arg, options));

          // Attempt to invoke user-land function
          // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
          //       means the sentry.javascript SDK caught an error invoking your application code. This
          //       is expected behavior and NOT indicative of a bug with sentry.javascript.
          return fn.apply(this, wrappedArguments);
        } catch (ex) {
          ignoreNextOnError();

          withScope(scope => {
            scope.addEventProcessor(event => {
              if (options.mechanism) {
                addExceptionTypeValue(event, undefined, undefined);
                addExceptionMechanism(event, options.mechanism);
              }

              event.extra = {
                ...event.extra,
                arguments: args,
              };

              return event;
            });

            captureException(ex);
          });

          throw ex;
        }
      } ;

      // Wrap the wrapped function in a proxy, to ensure any other properties of the original function remain available
      try {
        for (const property in fn) {
          if (Object.prototype.hasOwnProperty.call(fn, property)) {
            sentryWrapped[property ] = fn[property ];
          }
        }
      } catch {
        // Accessing some objects may throw
        // ref: https://github.com/getsentry/sentry-javascript/issues/1168
      }

      // Signal that this function has been wrapped/filled already
      // for both debugging and to prevent it to being wrapped/filled twice
      markFunctionWrapped(sentryWrapped, fn);

      addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);

      // Restore original function name (not all browsers allow that)
      try {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name');
        if (descriptor.configurable) {
          Object.defineProperty(sentryWrapped, 'name', {
            get() {
              return fn.name;
            },
          });
        }
      } catch {
        // This may throw if e.g. the descriptor does not exist, or a browser does not allow redefining `name`.
        // to save some bytes we simply try-catch this
      }

      return sentryWrapped;
    }

    /**
     * This function creates an exception from a JavaScript Error
     */
    function exceptionFromError(stackParser, ex) {
      // Get the frames first since Opera can lose the stack if we touch anything else first
      const frames = parseStackFrames(stackParser, ex);

      const exception = {
        type: extractType(ex),
        value: extractMessage(ex),
      };

      if (frames.length) {
        exception.stacktrace = { frames };
      }

      if (exception.type === undefined && exception.value === '') {
        exception.value = 'Unrecoverable error caught';
      }

      return exception;
    }

    function eventFromPlainObject(
      stackParser,
      exception,
      syntheticException,
      isUnhandledRejection,
    ) {
      const client = getClient();
      const normalizeDepth = client?.getOptions().normalizeDepth;

      // If we can, we extract an exception from the object properties
      const errorFromProp = getErrorPropertyFromObject(exception);

      const extra = {
        __serialized__: normalizeToSize(exception, normalizeDepth),
      };

      if (errorFromProp) {
        return {
          exception: {
            values: [exceptionFromError(stackParser, errorFromProp)],
          },
          extra,
        };
      }

      const event = {
        exception: {
          values: [
            {
              type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',
              value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }),
            } ,
          ],
        },
        extra,
      } ;

      if (syntheticException) {
        const frames = parseStackFrames(stackParser, syntheticException);
        if (frames.length) {
          // event.exception.values[0] has been set above
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          event.exception.values[0].stacktrace = { frames };
        }
      }

      return event;
    }

    function eventFromError(stackParser, ex) {
      return {
        exception: {
          values: [exceptionFromError(stackParser, ex)],
        },
      };
    }

    /** Parses stack frames from an error */
    function parseStackFrames(
      stackParser,
      ex,
    ) {
      // Access and store the stacktrace property before doing ANYTHING
      // else to it because Opera is not very good at providing it
      // reliably in other circumstances.
      const stacktrace = ex.stacktrace || ex.stack || '';

      const skipLines = getSkipFirstStackStringLines(ex);
      const framesToPop = getPopFirstTopFrames(ex);

      try {
        return stackParser(stacktrace, skipLines, framesToPop);
      } catch (e) {
        // no-empty
      }

      return [];
    }

    // Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108
    const reactMinifiedRegexp = /Minified React error #\d+;/i;

    /**
     * Certain known React errors contain links that would be falsely
     * parsed as frames. This function check for these errors and
     * returns number of the stack string lines to skip.
     */
    function getSkipFirstStackStringLines(ex) {
      if (ex && reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }

      return 0;
    }

    /**
     * If error has `framesToPop` property, it means that the
     * creator tells us the first x frames will be useless
     * and should be discarded. Typically error from wrapper function
     * which don't point to the actual location in the developer's code.
     *
     * Example: https://github.com/zertosh/invariant/blob/master/invariant.js#L46
     */
    function getPopFirstTopFrames(ex) {
      if (typeof ex.framesToPop === 'number') {
        return ex.framesToPop;
      }

      return 0;
    }

    // https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Exception
    // @ts-expect-error - WebAssembly.Exception is a valid class
    function isWebAssemblyException(exception) {
      // Check for support
      // @ts-expect-error - WebAssembly.Exception is a valid class
      if (typeof WebAssembly !== 'undefined' && typeof WebAssembly.Exception !== 'undefined') {
        // @ts-expect-error - WebAssembly.Exception is a valid class
        return exception instanceof WebAssembly.Exception;
      } else {
        return false;
      }
    }

    /**
     * Extracts from errors what we use as the exception `type` in error events.
     *
     * Usually, this is the `name` property on Error objects but WASM errors need to be treated differently.
     */
    function extractType(ex) {
      const name = ex?.name;

      // The name for WebAssembly.Exception Errors needs to be extracted differently.
      // Context: https://github.com/getsentry/sentry-javascript/issues/13787
      if (!name && isWebAssemblyException(ex)) {
        // Emscripten sets array[type, message] to the "message" property on the WebAssembly.Exception object
        const hasTypeInMessage = ex.message && Array.isArray(ex.message) && ex.message.length == 2;
        return hasTypeInMessage ? ex.message[0] : 'WebAssembly.Exception';
      }

      return name;
    }

    /**
     * There are cases where stacktrace.message is an Event object
     * https://github.com/getsentry/sentry-javascript/issues/1949
     * In this specific case we try to extract stacktrace.message.error.message
     */
    function extractMessage(ex) {
      const message = ex?.message;

      if (isWebAssemblyException(ex)) {
        // For Node 18, Emscripten sets array[type, message] to the "message" property on the WebAssembly.Exception object
        if (Array.isArray(ex.message) && ex.message.length == 2) {
          return ex.message[1];
        }
        return 'wasm exception';
      }

      if (!message) {
        return 'No error message';
      }

      if (message.error && typeof message.error.message === 'string') {
        return message.error.message;
      }

      return message;
    }

    /**
     * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
     * @hidden
     */
    function eventFromException(
      stackParser,
      exception,
      hint,
      attachStacktrace,
    ) {
      const syntheticException = hint?.syntheticException || undefined;
      const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
      addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }
      event.level = 'error';
      if (hint?.event_id) {
        event.event_id = hint.event_id;
      }
      return resolvedSyncPromise(event);
    }

    /**
     * Builds and Event from a Message
     * @hidden
     */
    function eventFromMessage(
      stackParser,
      message,
      level = 'info',
      hint,
      attachStacktrace,
    ) {
      const syntheticException = hint?.syntheticException || undefined;
      const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      event.level = level;
      if (hint?.event_id) {
        event.event_id = hint.event_id;
      }
      return resolvedSyncPromise(event);
    }

    /**
     * @hidden
     */
    function eventFromUnknownInput(
      stackParser,
      exception,
      syntheticException,
      attachStacktrace,
      isUnhandledRejection,
    ) {
      let event;

      if (isErrorEvent$1(exception ) && (exception ).error) {
        // If it is an ErrorEvent with `error` property, extract it to get actual Error
        const errorEvent = exception ;
        return eventFromError(stackParser, errorEvent.error );
      }

      // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name
      // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be
      // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.
      //
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
      // https://webidl.spec.whatwg.org/#es-DOMException-specialness
      if (isDOMError(exception) || isDOMException(exception )) {
        const domException = exception ;

        if ('stack' in (exception )) {
          event = eventFromError(stackParser, exception );
        } else {
          const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');
          const message = domException.message ? `${name}: ${domException.message}` : name;
          event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
          addExceptionTypeValue(event, message);
        }
        if ('code' in domException) {
          // eslint-disable-next-line deprecation/deprecation
          event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };
        }

        return event;
      }
      if (isError(exception)) {
        // we have a real Error object, do nothing
        return eventFromError(stackParser, exception);
      }
      if (isPlainObject(exception) || isEvent(exception)) {
        // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize
        // it manually. This will allow us to group events based on top-level keys which is much better than creating a new
        // group on any key/value change.
        const objectException = exception ;
        event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
        addExceptionMechanism(event, {
          synthetic: true,
        });
        return event;
      }

      // If none of previous checks were valid, then it means that it's not:
      // - an instance of DOMError
      // - an instance of DOMException
      // - an instance of Event
      // - an instance of Error
      // - a valid ErrorEvent (one with an error property)
      // - a plain Object
      //
      // So bail out and capture it as a simple message:
      event = eventFromString(stackParser, exception , syntheticException, attachStacktrace);
      addExceptionTypeValue(event, `${exception}`, undefined);
      addExceptionMechanism(event, {
        synthetic: true,
      });

      return event;
    }

    function eventFromString(
      stackParser,
      message,
      syntheticException,
      attachStacktrace,
    ) {
      const event = {};

      if (attachStacktrace && syntheticException) {
        const frames = parseStackFrames(stackParser, syntheticException);
        if (frames.length) {
          event.exception = {
            values: [{ value: message, stacktrace: { frames } }],
          };
        }
        addExceptionMechanism(event, { synthetic: true });
      }

      if (isParameterizedString(message)) {
        const { __sentry_template_string__, __sentry_template_values__ } = message;

        event.logentry = {
          message: __sentry_template_string__,
          params: __sentry_template_values__,
        };
        return event;
      }

      event.message = message;
      return event;
    }

    function getNonErrorObjectExceptionValue(
      exception,
      { isUnhandledRejection },
    ) {
      const keys = extractExceptionKeysForMessage(exception);
      const captureType = isUnhandledRejection ? 'promise rejection' : 'exception';

      // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before
      // We still want to try to get a decent message for these cases
      if (isErrorEvent$1(exception)) {
        return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
      }

      if (isEvent(exception)) {
        const className = getObjectClassName(exception);
        return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
      }

      return `Object captured as ${captureType} with keys: ${keys}`;
    }

    function getObjectClassName(obj) {
      try {
        const prototype = Object.getPrototypeOf(obj);
        return prototype ? prototype.constructor.name : undefined;
      } catch (e) {
        // ignore errors here
      }
    }

    /** If a plain object has a property that is an `Error`, return this error. */
    function getErrorPropertyFromObject(obj) {
      for (const prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
          const value = obj[prop];
          if (value instanceof Error) {
            return value;
          }
        }
      }

      return undefined;
    }

    const DEFAULT_FLUSH_INTERVAL = 5000;

    /**
     * Configuration options for the Sentry Browser SDK.
     * @see @sentry/core Options for more information.
     */

    /**
     * The Sentry Browser SDK Client.
     *
     * @see BrowserOptions for documentation on configuration options.
     * @see SentryClient for usage documentation.
     */
    class BrowserClient extends Client {

      /**
       * Creates a new Browser SDK instance.
       *
       * @param options Configuration options for this SDK.
       */
       constructor(options) {
        const opts = {
          // We default this to true, as it is the safer scenario
          parentSpanIsAlwaysRootSpan: true,
          ...options,
        };
        const sdkSource = WINDOW$1.SENTRY_SDK_SOURCE || getSDKSource();
        applySdkMetadata(opts, 'browser', ['browser'], sdkSource);

        super(opts);

        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const client = this;
        const { sendDefaultPii, _experiments } = client._options;
        const enableLogs = _experiments?.enableLogs;

        if (opts.sendClientReports && WINDOW$1.document) {
          WINDOW$1.document.addEventListener('visibilitychange', () => {
            if (WINDOW$1.document.visibilityState === 'hidden') {
              this._flushOutcomes();
              if (enableLogs) {
                _INTERNAL_flushLogsBuffer(client);
              }
            }
          });
        }

        if (enableLogs) {
          client.on('flush', () => {
            _INTERNAL_flushLogsBuffer(client);
          });

          client.on('afterCaptureLog', () => {
            if (client._logFlushIdleTimeout) {
              clearTimeout(client._logFlushIdleTimeout);
            }

            client._logFlushIdleTimeout = setTimeout(() => {
              _INTERNAL_flushLogsBuffer(client);
            }, DEFAULT_FLUSH_INTERVAL);
          });
        }

        if (sendDefaultPii) {
          client.on('postprocessEvent', addAutoIpAddressToUser);
          client.on('beforeSendSession', addAutoIpAddressToSession);
        }
      }

      /**
       * @inheritDoc
       */
       eventFromException(exception, hint) {
        return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
      }

      /**
       * @inheritDoc
       */
       eventFromMessage(
        message,
        level = 'info',
        hint,
      ) {
        return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
      }

      /**
       * @inheritDoc
       */
       _prepareEvent(
        event,
        hint,
        currentScope,
        isolationScope,
      ) {
        event.platform = event.platform || 'javascript';

        return super._prepareEvent(event, hint, currentScope, isolationScope);
      }
    }

    /**
     * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.
     *
     * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.
     */
    const DEBUG_BUILD$1 = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);

    const WINDOW = GLOBAL_OBJ

    ;

    const DEBOUNCE_DURATION = 1000;

    let debounceTimerID;
    let lastCapturedEventType;
    let lastCapturedEventTargetId;

    /**
     * Add an instrumentation handler for when a click or a keypress happens.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addClickKeypressInstrumentationHandler(handler) {
      const type = 'dom';
      addHandler(type, handler);
      maybeInstrument(type, instrumentDOM);
    }

    /** Exported for tests only. */
    function instrumentDOM() {
      if (!WINDOW.document) {
        return;
      }

      // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
      // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
      // we instrument `addEventListener` so that we don't end up attaching this handler twice.
      const triggerDOMHandler = triggerHandlers.bind(null, 'dom');
      const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      WINDOW.document.addEventListener('click', globalDOMEventHandler, false);
      WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);

      // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
      // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
      // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
      // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
      // guaranteed to fire at least once.)
      ['EventTarget', 'Node'].forEach((target) => {
        const globalObject = WINDOW ;
        const proto = globalObject[target]?.prototype;

        // eslint-disable-next-line no-prototype-builtins
        if (!proto?.hasOwnProperty?.('addEventListener')) {
          return;
        }

        fill(proto, 'addEventListener', function (originalAddEventListener) {
          return function ( type, listener, options) {
            if (type === 'click' || type == 'keypress') {
              try {
                const handlers = (this.__sentry_instrumentation_handlers__ =
                  this.__sentry_instrumentation_handlers__ || {});
                const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });

                if (!handlerForType.handler) {
                  const handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }

                handlerForType.refCount++;
              } catch (e) {
                // Accessing dom properties is always fragile.
                // Also allows us to skip `addEventListeners` calls with no proper `this` context.
              }
            }

            return originalAddEventListener.call(this, type, listener, options);
          };
        });

        fill(
          proto,
          'removeEventListener',
          function (originalRemoveEventListener) {
            return function ( type, listener, options) {
              if (type === 'click' || type == 'keypress') {
                try {
                  const handlers = this.__sentry_instrumentation_handlers__ || {};
                  const handlerForType = handlers[type];

                  if (handlerForType) {
                    handlerForType.refCount--;
                    // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                    if (handlerForType.refCount <= 0) {
                      originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                      handlerForType.handler = undefined;
                      delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                    }

                    // If there are no longer any custom handlers of any type on this element, cleanup everything.
                    if (Object.keys(handlers).length === 0) {
                      delete this.__sentry_instrumentation_handlers__;
                    }
                  }
                } catch (e) {
                  // Accessing dom properties is always fragile.
                  // Also allows us to skip `addEventListeners` calls with no proper `this` context.
                }
              }

              return originalRemoveEventListener.call(this, type, listener, options);
            };
          },
        );
      });
    }

    /**
     * Check whether the event is similar to the last captured one. For example, two click events on the same button.
     */
    function isSimilarToLastCapturedEvent(event) {
      // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
      if (event.type !== lastCapturedEventType) {
        return false;
      }

      try {
        // If both events have the same type, it's still possible that actions were performed on different targets.
        // e.g. 2 clicks on different buttons.
        if (!event.target || (event.target )._sentryId !== lastCapturedEventTargetId) {
          return false;
        }
      } catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
      }

      // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
      // to which an event listener was attached), we treat them as the same action, as we want to capture
      // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
      return true;
    }

    /**
     * Decide whether an event should be captured.
     * @param event event to be captured
     */
    function shouldSkipDOMEvent(eventType, target) {
      // We are only interested in filtering `keypress` events for now.
      if (eventType !== 'keypress') {
        return false;
      }

      if (!target?.tagName) {
        return true;
      }

      // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
      // e.g.tabbing through elements, hotkeys, etc.
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return false;
      }

      return true;
    }

    /**
     * Wraps addEventListener to capture UI breadcrumbs
     */
    function makeDOMEventHandler(
      handler,
      globalListener = false,
    ) {
      return (event) => {
        // It's possible this handler might trigger multiple times for the same
        // event (e.g. event propagation through node ancestors).
        // Ignore if we've already captured that event.
        if (!event || event['_sentryCaptured']) {
          return;
        }

        const target = getEventTarget(event);

        // We always want to skip _some_ events.
        if (shouldSkipDOMEvent(event.type, target)) {
          return;
        }

        // Mark event as "seen"
        addNonEnumerableProperty(event, '_sentryCaptured', true);

        if (target && !target._sentryId) {
          // Add UUID to event target so we can identify if
          addNonEnumerableProperty(target, '_sentryId', uuid4());
        }

        const name = event.type === 'keypress' ? 'input' : event.type;

        // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.
        // If there is a last captured event, see if the new event is different enough to treat it as a unique one.
        // If that's the case, emit the previous event and store locally the newly-captured DOM event.
        if (!isSimilarToLastCapturedEvent(event)) {
          const handlerData = { event, name, global: globalListener };
          handler(handlerData);
          lastCapturedEventType = event.type;
          lastCapturedEventTargetId = target ? target._sentryId : undefined;
        }

        // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
        clearTimeout(debounceTimerID);
        debounceTimerID = WINDOW.setTimeout(() => {
          lastCapturedEventTargetId = undefined;
          lastCapturedEventType = undefined;
        }, DEBOUNCE_DURATION);
      };
    }

    function getEventTarget(event) {
      try {
        return event.target ;
      } catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
        return null;
      }
    }

    let lastHref;

    /**
     * Add an instrumentation handler for when a fetch request happens.
     * The handler function is called once when the request starts and once when it ends,
     * which can be identified by checking if it has an `endTimestamp`.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addHistoryInstrumentationHandler(handler) {
      const type = 'history';
      addHandler(type, handler);
      maybeInstrument(type, instrumentHistory);
    }

    /**
     * Exported just for testing
     */
    function instrumentHistory() {
      // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser
      // Which is why we also monkey-patch methods below, in addition to this
      WINDOW.addEventListener('popstate', () => {
        const to = WINDOW.location.href;
        // keep track of the current URL state, as we always receive only the updated state
        const from = lastHref;
        lastHref = to;

        if (from === to) {
          return;
        }

        const handlerData = { from, to } ;
        triggerHandlers('history', handlerData);
      });

      // Just guard against this not being available, in weird environments
      if (!supportsHistory()) {
        return;
      }

      function historyReplacementFunction(originalHistoryFunction) {
        return function ( ...args) {
          const url = args.length > 2 ? args[2] : undefined;
          if (url) {
            // coerce to string (this is what pushState does)
            const from = lastHref;
            const to = String(url);
            // keep track of the current URL state, as we always receive only the updated state
            lastHref = to;

            if (from === to) {
              return originalHistoryFunction.apply(this, args);
            }

            const handlerData = { from, to } ;
            triggerHandlers('history', handlerData);
          }
          return originalHistoryFunction.apply(this, args);
        };
      }

      fill(WINDOW.history, 'pushState', historyReplacementFunction);
      fill(WINDOW.history, 'replaceState', historyReplacementFunction);
    }

    /**
     * We generally want to use window.fetch / window.setTimeout.
     * However, in some cases this may be wrapped (e.g. by Zone.js for Angular),
     * so we try to get an unpatched version of this from a sandboxed iframe.
     */

    const cachedImplementations = {};

    /**
     * Get the native implementation of a browser function.
     *
     * This can be used to ensure we get an unwrapped version of a function, in cases where a wrapped function can lead to problems.
     *
     * The following methods can be retrieved:
     * - `setTimeout`: This can be wrapped by e.g. Angular, causing change detection to be triggered.
     * - `fetch`: This can be wrapped by e.g. ad-blockers, causing an infinite loop when a request is blocked.
     */
    function getNativeImplementation(
      name,
    ) {
      const cached = cachedImplementations[name];
      if (cached) {
        return cached;
      }

      let impl = WINDOW[name] ;

      // Fast path to avoid DOM I/O
      if (isNativeFunction(impl)) {
        return (cachedImplementations[name] = impl.bind(WINDOW) );
      }

      const document = WINDOW.document;
      // eslint-disable-next-line deprecation/deprecation
      if (document && typeof document.createElement === 'function') {
        try {
          const sandbox = document.createElement('iframe');
          sandbox.hidden = true;
          document.head.appendChild(sandbox);
          const contentWindow = sandbox.contentWindow;
          if (contentWindow?.[name]) {
            impl = contentWindow[name] ;
          }
          document.head.removeChild(sandbox);
        } catch (e) {
          // Could not create sandbox iframe, just use window.xxx
          DEBUG_BUILD$1 && logger.warn(`Could not create sandbox iframe for ${name} check, bailing to window.${name}: `, e);
        }
      }

      // Sanity check: This _should_ not happen, but if it does, we just skip caching...
      // This can happen e.g. in tests where fetch may not be available in the env, or similar.
      if (!impl) {
        return impl;
      }

      return (cachedImplementations[name] = impl.bind(WINDOW) );
    }

    /** Clear a cached implementation. */
    function clearCachedImplementation(name) {
      cachedImplementations[name] = undefined;
    }

    const SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';

    /**
     * Add an instrumentation handler for when an XHR request happens.
     * The handler function is called once when the request starts and once when it ends,
     * which can be identified by checking if it has an `endTimestamp`.
     *
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addXhrInstrumentationHandler(handler) {
      const type = 'xhr';
      addHandler(type, handler);
      maybeInstrument(type, instrumentXHR);
    }

    /** Exported only for tests. */
    function instrumentXHR() {
      if (!(WINDOW ).XMLHttpRequest) {
        return;
      }

      const xhrproto = XMLHttpRequest.prototype;

      // eslint-disable-next-line @typescript-eslint/unbound-method
      xhrproto.open = new Proxy(xhrproto.open, {
        apply(
          originalOpen,
          xhrOpenThisArg,
          xhrOpenArgArray

    ,
        ) {
          // NOTE: If you are a Sentry user, and you are seeing this stack frame,
          //       it means the error, that was caused by your XHR call did not
          //       have a stack trace. If you are using HttpClient integration,
          //       this is the expected behavior, as we are using this virtual error to capture
          //       the location of your XHR call, and group your HttpClient events accordingly.
          const virtualError = new Error();

          const startTimestamp = timestampInSeconds() * 1000;

          // open() should always be called with two or more arguments
          // But to be on the safe side, we actually validate this and bail out if we don't have a method & url
          const method = isString(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : undefined;
          const url = parseXhrUrlArg(xhrOpenArgArray[1]);

          if (!method || !url) {
            return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);
          }

          xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {
            method,
            url,
            request_headers: {},
          };

          // if Sentry key appears in URL, don't capture it as a request
          if (method === 'POST' && url.match(/sentry_key/)) {
            xhrOpenThisArg.__sentry_own_request__ = true;
          }

          const onreadystatechangeHandler = () => {
            // For whatever reason, this is not the same instance here as from the outer method
            const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];

            if (!xhrInfo) {
              return;
            }

            if (xhrOpenThisArg.readyState === 4) {
              try {
                // touching statusCode in some platforms throws
                // an exception
                xhrInfo.status_code = xhrOpenThisArg.status;
              } catch (e) {
                /* do nothing */
              }

              const handlerData = {
                endTimestamp: timestampInSeconds() * 1000,
                startTimestamp,
                xhr: xhrOpenThisArg,
                virtualError,
              };
              triggerHandlers('xhr', handlerData);
            }
          };

          if ('onreadystatechange' in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === 'function') {
            xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {
              apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {
                onreadystatechangeHandler();
                return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);
              },
            });
          } else {
            xhrOpenThisArg.addEventListener('readystatechange', onreadystatechangeHandler);
          }

          // Intercepting `setRequestHeader` to access the request headers of XHR instance.
          // This will only work for user/library defined headers, not for the default/browser-assigned headers.
          // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.
          xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {
            apply(
              originalSetRequestHeader,
              setRequestHeaderThisArg,
              setRequestHeaderArgArray,
            ) {
              const [header, value] = setRequestHeaderArgArray;

              const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];

              if (xhrInfo && isString(header) && isString(value)) {
                xhrInfo.request_headers[header.toLowerCase()] = value;
              }

              return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);
            },
          });

          return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);
        },
      });

      // eslint-disable-next-line @typescript-eslint/unbound-method
      xhrproto.send = new Proxy(xhrproto.send, {
        apply(originalSend, sendThisArg, sendArgArray) {
          const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];

          if (!sentryXhrData) {
            return originalSend.apply(sendThisArg, sendArgArray);
          }

          if (sendArgArray[0] !== undefined) {
            sentryXhrData.body = sendArgArray[0];
          }

          const handlerData = {
            startTimestamp: timestampInSeconds() * 1000,
            xhr: sendThisArg,
          };
          triggerHandlers('xhr', handlerData);

          return originalSend.apply(sendThisArg, sendArgArray);
        },
      });
    }

    /**
     * Parses the URL argument of a XHR method to a string.
     *
     * See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open#url
     * url: A string or any other object with a stringifier — including a URL object — that provides the URL of the resource to send the request to.
     *
     * @param url - The URL argument of an XHR method
     * @returns The parsed URL string or undefined if the URL is invalid
     */
    function parseXhrUrlArg(url) {
      if (isString(url)) {
        return url;
      }

      try {
        // If the passed in argument is not a string, it should have a `toString` method as a stringifier.
        // If that fails, we just return undefined (like in IE11 where URL is not available)
        return (url ).toString();
      } catch {} // eslint-disable-line no-empty

      return undefined;
    }

    /**
     * Creates a Transport that uses the Fetch API to send events to Sentry.
     */
    function makeFetchTransport(
      options,
      nativeFetch = getNativeImplementation('fetch'),
    ) {
      let pendingBodySize = 0;
      let pendingCount = 0;

      function makeRequest(request) {
        const requestSize = request.body.length;
        pendingBodySize += requestSize;
        pendingCount++;

        const requestOptions = {
          body: request.body,
          method: 'POST',
          referrerPolicy: 'strict-origin',
          headers: options.headers,
          // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
          // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
          // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
          // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).
          // Gotchas:
          // - `keepalive` isn't supported by Firefox
          // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
          //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
          //   We will therefore only activate the flag when we're below that limit.
          // There is also a limit of requests that can be open at the same time, so we also limit this to 15
          // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
          keepalive: pendingBodySize <= 60000 && pendingCount < 15,
          ...options.fetchOptions,
        };

        if (!nativeFetch) {
          clearCachedImplementation('fetch');
          return rejectedSyncPromise('No fetch implementation available');
        }

        try {
          // TODO: This may need a `suppressTracing` call in the future when we switch the browser SDK to OTEL
          return nativeFetch(options.url, requestOptions).then(response => {
            pendingBodySize -= requestSize;
            pendingCount--;
            return {
              statusCode: response.status,
              headers: {
                'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
                'retry-after': response.headers.get('Retry-After'),
              },
            };
          });
        } catch (e) {
          clearCachedImplementation('fetch');
          pendingBodySize -= requestSize;
          pendingCount--;
          return rejectedSyncPromise(e);
        }
      }

      return createTransport(options, makeRequest);
    }

    const CHROME_PRIORITY = 30;
    const GECKO_PRIORITY = 50;

    function createFrame(filename, func, lineno, colno) {
      const frame = {
        filename,
        function: func === '<anonymous>' ? UNKNOWN_FUNCTION : func,
        in_app: true, // All browser frames are considered in_app
      };

      if (lineno !== undefined) {
        frame.lineno = lineno;
      }

      if (colno !== undefined) {
        frame.colno = colno;
      }

      return frame;
    }

    // This regex matches frames that have no function name (ie. are at the top level of a module).
    // For example "at http://localhost:5000//script.js:1:126"
    // Frames _with_ function names usually look as follows: "at commitLayoutEffects (react-dom.development.js:23426:1)"
    const chromeRegexNoFnName = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;

    // This regex matches all the frames that have a function name.
    const chromeRegex =
      /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;

    const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;

    // Chromium based browsers: Chrome, Brave, new Opera, new Edge
    // We cannot call this variable `chrome` because it can conflict with global `chrome` variable in certain environments
    // See: https://github.com/getsentry/sentry-javascript/issues/6880
    const chromeStackParserFn = line => {
      // If the stack line has no function name, we need to parse it differently
      const noFnParts = chromeRegexNoFnName.exec(line) ;

      if (noFnParts) {
        const [, filename, line, col] = noFnParts;
        return createFrame(filename, UNKNOWN_FUNCTION, +line, +col);
      }

      const parts = chromeRegex.exec(line) ;

      if (parts) {
        const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

        if (isEval) {
          const subMatch = chromeEvalRegex.exec(parts[2]) ;

          if (subMatch) {
            // throw out eval line/column and use top-most line/column number
            parts[2] = subMatch[1]; // url
            parts[3] = subMatch[2]; // line
            parts[4] = subMatch[3]; // column
          }
        }

        // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now
        // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)
        const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);

        return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);
      }

      return;
    };

    const chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];

    // gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
    // generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
    // We need this specific case for now because we want no other regex to match.
    const geckoREgex =
      /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
    const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

    const gecko = line => {
      const parts = geckoREgex.exec(line) ;

      if (parts) {
        const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
        if (isEval) {
          const subMatch = geckoEvalRegex.exec(parts[3]) ;

          if (subMatch) {
            // throw out eval line/column and use top-most line number
            parts[1] = parts[1] || 'eval';
            parts[3] = subMatch[1];
            parts[4] = subMatch[2];
            parts[5] = ''; // no column when eval
          }
        }

        let filename = parts[3];
        let func = parts[1] || UNKNOWN_FUNCTION;
        [func, filename] = extractSafariExtensionDetails(func, filename);

        return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);
      }

      return;
    };

    const geckoStackLineParser = [GECKO_PRIORITY, gecko];

    const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];

    const defaultStackParser = createStackParser(...defaultStackLineParsers);

    /**
     * Safari web extensions, starting version unknown, can produce "frames-only" stacktraces.
     * What it means, is that instead of format like:
     *
     * Error: wat
     *   at function@url:row:col
     *   at function@url:row:col
     *   at function@url:row:col
     *
     * it produces something like:
     *
     *   function@url:row:col
     *   function@url:row:col
     *   function@url:row:col
     *
     * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.
     * This function is extracted so that we can use it in both places without duplicating the logic.
     * Unfortunately "just" changing RegExp is too complicated now and making it pass all tests
     * and fix this case seems like an impossible, or at least way too time-consuming task.
     */
    const extractSafariExtensionDetails = (func, filename) => {
      const isSafariExtension = func.indexOf('safari-extension') !== -1;
      const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;

      return isSafariExtension || isSafariWebExtension
        ? [
            func.indexOf('@') !== -1 ? (func.split('@')[0] ) : UNKNOWN_FUNCTION,
            isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,
          ]
        : [func, filename];
    };

    /**
     * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.
     *
     * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.
     */
    const DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);

    /* eslint-disable max-lines */


    /** maxStringLength gets capped to prevent 100 breadcrumbs exceeding 1MB event payload size */
    const MAX_ALLOWED_STRING_LENGTH = 1024;

    const INTEGRATION_NAME$3 = 'Breadcrumbs';

    const _breadcrumbsIntegration = ((options = {}) => {
      const _options = {
        console: true,
        dom: true,
        fetch: true,
        history: true,
        sentry: true,
        xhr: true,
        ...options,
      };

      return {
        name: INTEGRATION_NAME$3,
        setup(client) {
          // TODO(v10): Remove this functionality and use `consoleIntegration` from @sentry/core instead.
          if (_options.console) {
            addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
          }
          if (_options.dom) {
            addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
          }
          if (_options.xhr) {
            addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
          }
          if (_options.fetch) {
            addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
          }
          if (_options.history) {
            addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
          }
          if (_options.sentry) {
            client.on('beforeSendEvent', _getSentryBreadcrumbHandler(client));
          }
        },
      };
    }) ;

    const breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);

    /**
     * Adds a breadcrumb for Sentry events or transactions if this option is enabled.
     */
    function _getSentryBreadcrumbHandler(client) {
      return function addSentryBreadcrumb(event) {
        if (getClient() !== client) {
          return;
        }

        addBreadcrumb(
          {
            category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,
            event_id: event.event_id,
            level: event.level,
            message: getEventDescription(event),
          },
          {
            event,
          },
        );
      };
    }

    /**
     * A HOC that creates a function that creates breadcrumbs from DOM API calls.
     * This is a HOC so that we get access to dom options in the closure.
     */
    function _getDomBreadcrumbHandler(
      client,
      dom,
    ) {
      return function _innerDomBreadcrumb(handlerData) {
        if (getClient() !== client) {
          return;
        }

        let target;
        let componentName;
        let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;

        let maxStringLength =
          typeof dom === 'object' && typeof dom.maxStringLength === 'number' ? dom.maxStringLength : undefined;
        if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
          DEBUG_BUILD &&
            logger.warn(
              `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`,
            );
          maxStringLength = MAX_ALLOWED_STRING_LENGTH;
        }

        if (typeof keyAttrs === 'string') {
          keyAttrs = [keyAttrs];
        }

        // Accessing event.target can throw (see getsentry/raven-js#838, #768)
        try {
          const event = handlerData.event ;
          const element = _isEvent(event) ? event.target : event;

          target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
          componentName = getComponentName(element);
        } catch (e) {
          target = '<unknown>';
        }

        if (target.length === 0) {
          return;
        }

        const breadcrumb = {
          category: `ui.${handlerData.name}`,
          message: target,
        };

        if (componentName) {
          breadcrumb.data = { 'ui.component_name': componentName };
        }

        addBreadcrumb(breadcrumb, {
          event: handlerData.event,
          name: handlerData.name,
          global: handlerData.global,
        });
      };
    }

    /**
     * Creates breadcrumbs from console API calls
     */
    function _getConsoleBreadcrumbHandler(client) {
      return function _consoleBreadcrumb(handlerData) {
        if (getClient() !== client) {
          return;
        }

        const breadcrumb = {
          category: 'console',
          data: {
            arguments: handlerData.args,
            logger: 'console',
          },
          level: severityLevelFromString(handlerData.level),
          message: safeJoin(handlerData.args, ' '),
        };

        if (handlerData.level === 'assert') {
          if (handlerData.args[0] === false) {
            breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), ' ') || 'console.assert'}`;
            breadcrumb.data.arguments = handlerData.args.slice(1);
          } else {
            // Don't capture a breadcrumb for passed assertions
            return;
          }
        }

        addBreadcrumb(breadcrumb, {
          input: handlerData.args,
          level: handlerData.level,
        });
      };
    }

    /**
     * Creates breadcrumbs from XHR API calls
     */
    function _getXhrBreadcrumbHandler(client) {
      return function _xhrBreadcrumb(handlerData) {
        if (getClient() !== client) {
          return;
        }

        const { startTimestamp, endTimestamp } = handlerData;

        const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];

        // We only capture complete, non-sentry requests
        if (!startTimestamp || !endTimestamp || !sentryXhrData) {
          return;
        }

        const { method, url, status_code, body } = sentryXhrData;

        const data = {
          method,
          url,
          status_code,
        };

        const hint = {
          xhr: handlerData.xhr,
          input: body,
          startTimestamp,
          endTimestamp,
        };

        const breadcrumb = {
          category: 'xhr',
          data,
          type: 'http',
          level: getBreadcrumbLogLevelFromHttpStatusCode(status_code),
        };

        client.emit('beforeOutgoingRequestBreadcrumb', breadcrumb, hint );

        addBreadcrumb(breadcrumb, hint);
      };
    }

    /**
     * Creates breadcrumbs from fetch API calls
     */
    function _getFetchBreadcrumbHandler(client) {
      return function _fetchBreadcrumb(handlerData) {
        if (getClient() !== client) {
          return;
        }

        const { startTimestamp, endTimestamp } = handlerData;

        // We only capture complete fetch requests
        if (!endTimestamp) {
          return;
        }

        if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {
          // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)
          return;
        }

        ({
          method: handlerData.fetchData.method,
          url: handlerData.fetchData.url,
        });

        if (handlerData.error) {
          const data = handlerData.fetchData;
          const hint = {
            data: handlerData.error,
            input: handlerData.args,
            startTimestamp,
            endTimestamp,
          };

          const breadcrumb = {
            category: 'fetch',
            data,
            level: 'error',
            type: 'http',
          } ;

          client.emit('beforeOutgoingRequestBreadcrumb', breadcrumb, hint );

          addBreadcrumb(breadcrumb, hint);
        } else {
          const response = handlerData.response ;
          const data = {
            ...handlerData.fetchData,
            status_code: response?.status,
          };

          handlerData.fetchData.request_body_size;
          handlerData.fetchData.response_body_size;
          response?.status;

          const hint = {
            input: handlerData.args,
            response,
            startTimestamp,
            endTimestamp,
          };

          const breadcrumb = {
            category: 'fetch',
            data,
            type: 'http',
            level: getBreadcrumbLogLevelFromHttpStatusCode(data.status_code),
          };

          client.emit('beforeOutgoingRequestBreadcrumb', breadcrumb, hint );

          addBreadcrumb(breadcrumb, hint);
        }
      };
    }

    /**
     * Creates breadcrumbs from history API calls
     */
    function _getHistoryBreadcrumbHandler(client) {
      return function _historyBreadcrumb(handlerData) {
        if (getClient() !== client) {
          return;
        }

        let from = handlerData.from;
        let to = handlerData.to;
        const parsedLoc = parseUrl(WINDOW$1.location.href);
        let parsedFrom = from ? parseUrl(from) : undefined;
        const parsedTo = parseUrl(to);

        // Initial pushState doesn't provide `from` information
        if (!parsedFrom?.path) {
          parsedFrom = parsedLoc;
        }

        // Use only the path component of the URL if the URL matches the current
        // document (almost all the time when using pushState)
        if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
          to = parsedTo.relative;
        }
        if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
          from = parsedFrom.relative;
        }

        addBreadcrumb({
          category: 'navigation',
          data: {
            from,
            to,
          },
        });
      };
    }

    function _isEvent(event) {
      return !!event && !!(event ).target;
    }

    const DEFAULT_EVENT_TARGET = [
      'EventTarget',
      'Window',
      'Node',
      'ApplicationCache',
      'AudioTrackList',
      'BroadcastChannel',
      'ChannelMergerNode',
      'CryptoOperation',
      'EventSource',
      'FileReader',
      'HTMLUnknownElement',
      'IDBDatabase',
      'IDBRequest',
      'IDBTransaction',
      'KeyOperation',
      'MediaController',
      'MessagePort',
      'ModalWindow',
      'Notification',
      'SVGElementInstance',
      'Screen',
      'SharedWorker',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebSocket',
      'WebSocketWorker',
      'Worker',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload',
    ];

    const INTEGRATION_NAME$2 = 'BrowserApiErrors';

    const _browserApiErrorsIntegration = ((options = {}) => {
      const _options = {
        XMLHttpRequest: true,
        eventTarget: true,
        requestAnimationFrame: true,
        setInterval: true,
        setTimeout: true,
        ...options,
      };

      return {
        name: INTEGRATION_NAME$2,
        // TODO: This currently only works for the first client this is setup
        // We may want to adjust this to check for client etc.
        setupOnce() {
          if (_options.setTimeout) {
            fill(WINDOW$1, 'setTimeout', _wrapTimeFunction);
          }

          if (_options.setInterval) {
            fill(WINDOW$1, 'setInterval', _wrapTimeFunction);
          }

          if (_options.requestAnimationFrame) {
            fill(WINDOW$1, 'requestAnimationFrame', _wrapRAF);
          }

          if (_options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW$1) {
            fill(XMLHttpRequest.prototype, 'send', _wrapXHR);
          }

          const eventTargetOption = _options.eventTarget;
          if (eventTargetOption) {
            const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
            eventTarget.forEach(_wrapEventTarget);
          }
        },
      };
    }) ;

    /**
     * Wrap timer functions and event targets to catch errors and provide better meta data.
     */
    const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);

    function _wrapTimeFunction(original) {
      return function ( ...args) {
        const originalCallback = args[0];
        args[0] = wrap(originalCallback, {
          mechanism: {
            data: { function: getFunctionName(original) },
            handled: false,
            type: 'instrument',
          },
        });
        return original.apply(this, args);
      };
    }

    function _wrapRAF(original) {
      return function ( callback) {
        return original.apply(this, [
          wrap(callback, {
            mechanism: {
              data: {
                function: 'requestAnimationFrame',
                handler: getFunctionName(original),
              },
              handled: false,
              type: 'instrument',
            },
          }),
        ]);
      };
    }

    function _wrapXHR(originalSend) {
      return function ( ...args) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const xhr = this;
        const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];

        xmlHttpRequestProps.forEach(prop => {
          if (prop in xhr && typeof xhr[prop] === 'function') {
            fill(xhr, prop, function (original) {
              const wrapOptions = {
                mechanism: {
                  data: {
                    function: prop,
                    handler: getFunctionName(original),
                  },
                  handled: false,
                  type: 'instrument',
                },
              };

              // If Instrument integration has been called before BrowserApiErrors, get the name of original function
              const originalFunction = getOriginalFunction(original);
              if (originalFunction) {
                wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
              }

              // Otherwise wrap directly
              return wrap(original, wrapOptions);
            });
          }
        });

        return originalSend.apply(this, args);
      };
    }

    function _wrapEventTarget(target) {
      const globalObject = WINDOW$1 ;
      const proto = globalObject[target]?.prototype;

      // eslint-disable-next-line no-prototype-builtins
      if (!proto?.hasOwnProperty?.('addEventListener')) {
        return;
      }

      fill(proto, 'addEventListener', function (original)

     {
        return function ( eventName, fn, options) {
          try {
            if (isEventListenerObject(fn)) {
              // ESlint disable explanation:
              //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would
              //  introduce a bug here, because bind returns a new function that doesn't have our
              //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.
              //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.
              // eslint-disable-next-line @typescript-eslint/unbound-method
              fn.handleEvent = wrap(fn.handleEvent, {
                mechanism: {
                  data: {
                    function: 'handleEvent',
                    handler: getFunctionName(fn),
                    target,
                  },
                  handled: false,
                  type: 'instrument',
                },
              });
            }
          } catch {
            // can sometimes get 'Permission denied to access property "handle Event'
          }

          return original.apply(this, [
            eventName,
            wrap(fn, {
              mechanism: {
                data: {
                  function: 'addEventListener',
                  handler: getFunctionName(fn),
                  target,
                },
                handled: false,
                type: 'instrument',
              },
            }),
            options,
          ]);
        };
      });

      fill(proto, 'removeEventListener', function (originalRemoveEventListener)

     {
        return function ( eventName, fn, options) {
          /**
           * There are 2 possible scenarios here:
           *
           * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified
           * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function
           * as a pass-through, and call original `removeEventListener` with it.
           *
           * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using
           * our wrapped version of `addEventListener`, which internally calls `wrap` helper.
           * This helper "wraps" whole callback inside a try/catch statement, and attached appropriate metadata to it,
           * in order for us to make a distinction between wrapped/non-wrapped functions possible.
           * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.
           *
           * When someone adds a handler prior to initialization, and then do it again, but after,
           * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible
           * to get rid of the initial handler and it'd stick there forever.
           */
          try {
            const originalEventHandler = (fn ).__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          } catch (e) {
            // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
          }
          return originalRemoveEventListener.call(this, eventName, fn, options);
        };
      });
    }

    function isEventListenerObject(obj) {
      return typeof (obj ).handleEvent === 'function';
    }

    /**
     * When added, automatically creates sessions which allow you to track adoption and crashes (crash free rate) in your Releases in Sentry.
     * More information: https://docs.sentry.io/product/releases/health/
     *
     * Note: In order for session tracking to work, you need to set up Releases: https://docs.sentry.io/product/releases/
     */
    const browserSessionIntegration = defineIntegration(() => {
      return {
        name: 'BrowserSession',
        setupOnce() {
          if (typeof WINDOW$1.document === 'undefined') {
            DEBUG_BUILD &&
              logger.warn('Using the `browserSessionIntegration` in non-browser environments is not supported.');
            return;
          }

          // The session duration for browser sessions does not track a meaningful
          // concept that can be used as a metric.
          // Automatically captured sessions are akin to page views, and thus we
          // discard their duration.
          startSession({ ignoreDuration: true });
          captureSession();

          // We want to create a session for every navigation as well
          addHistoryInstrumentationHandler(({ from, to }) => {
            // Don't create an additional session for the initial route or if the location did not change
            if (from !== undefined && from !== to) {
              startSession({ ignoreDuration: true });
              captureSession();
            }
          });
        },
      };
    });

    const INTEGRATION_NAME$1 = 'GlobalHandlers';

    const _globalHandlersIntegration = ((options = {}) => {
      const _options = {
        onerror: true,
        onunhandledrejection: true,
        ...options,
      };

      return {
        name: INTEGRATION_NAME$1,
        setupOnce() {
          Error.stackTraceLimit = 50;
        },
        setup(client) {
          if (_options.onerror) {
            _installGlobalOnErrorHandler(client);
            globalHandlerLog('onerror');
          }
          if (_options.onunhandledrejection) {
            _installGlobalOnUnhandledRejectionHandler(client);
            globalHandlerLog('onunhandledrejection');
          }
        },
      };
    }) ;

    const globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);

    function _installGlobalOnErrorHandler(client) {
      addGlobalErrorInstrumentationHandler(data => {
        const { stackParser, attachStacktrace } = getOptions();

        if (getClient() !== client || shouldIgnoreOnError()) {
          return;
        }

        const { msg, url, line, column, error } = data;

        const event = _enhanceEventWithInitialFrame(
          eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),
          url,
          line,
          column,
        );

        event.level = 'error';

        captureEvent(event, {
          originalException: error,
          mechanism: {
            handled: false,
            type: 'onerror',
          },
        });
      });
    }

    function _installGlobalOnUnhandledRejectionHandler(client) {
      addGlobalUnhandledRejectionInstrumentationHandler(e => {
        const { stackParser, attachStacktrace } = getOptions();

        if (getClient() !== client || shouldIgnoreOnError()) {
          return;
        }

        const error = _getUnhandledRejectionError(e );

        const event = isPrimitive(error)
          ? _eventFromRejectionWithPrimitive(error)
          : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);

        event.level = 'error';

        captureEvent(event, {
          originalException: error,
          mechanism: {
            handled: false,
            type: 'onunhandledrejection',
          },
        });
      });
    }

    function _getUnhandledRejectionError(error) {
      if (isPrimitive(error)) {
        return error;
      }

      // dig the object of the rejection out of known event types
      try {

        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in (error )) {
          return (error ).reason;
        }

        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        if ('detail' in (error ) && 'reason' in (error ).detail) {
          return (error ).detail.reason;
        }
      } catch {} // eslint-disable-line no-empty

      return error;
    }

    /**
     * Create an event from a promise rejection where the `reason` is a primitive.
     *
     * @param reason: The `reason` property of the promise rejection
     * @returns An Event object with an appropriate `exception` value
     */
    function _eventFromRejectionWithPrimitive(reason) {
      return {
        exception: {
          values: [
            {
              type: 'UnhandledRejection',
              // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
              value: `Non-Error promise rejection captured with value: ${String(reason)}`,
            },
          ],
        },
      };
    }

    function _enhanceEventWithInitialFrame(
      event,
      url,
      line,
      column,
    ) {
      // event.exception
      const e = (event.exception = event.exception || {});
      // event.exception.values
      const ev = (e.values = e.values || []);
      // event.exception.values[0]
      const ev0 = (ev[0] = ev[0] || {});
      // event.exception.values[0].stacktrace
      const ev0s = (ev0.stacktrace = ev0.stacktrace || {});
      // event.exception.values[0].stacktrace.frames
      const ev0sf = (ev0s.frames = ev0s.frames || []);

      const colno = column;
      const lineno = line;
      const filename = isString(url) && url.length > 0 ? url : getLocationHref();

      // event.exception.values[0].stacktrace.frames
      if (ev0sf.length === 0) {
        ev0sf.push({
          colno,
          filename,
          function: UNKNOWN_FUNCTION,
          in_app: true,
          lineno,
        });
      }

      return event;
    }

    function globalHandlerLog(type) {
      DEBUG_BUILD && logger.log(`Global Handler attached: ${type}`);
    }

    function getOptions() {
      const client = getClient();
      const options = client?.getOptions() || {
        stackParser: () => [],
        attachStacktrace: false,
      };
      return options;
    }

    /**
     * Collects information about HTTP request headers and
     * attaches them to the event.
     */
    const httpContextIntegration = defineIntegration(() => {
      return {
        name: 'HttpContext',
        preprocessEvent(event) {
          // if none of the information we want exists, don't bother
          if (!WINDOW$1.navigator && !WINDOW$1.location && !WINDOW$1.document) {
            return;
          }

          // grab as much info as exists and add it to the event
          const url = event.request?.url || getLocationHref();
          const { referrer } = WINDOW$1.document || {};
          const { userAgent } = WINDOW$1.navigator || {};

          const headers = {
            ...event.request?.headers,
            ...(referrer && { Referer: referrer }),
            ...(userAgent && { 'User-Agent': userAgent }),
          };
          const request = {
            ...event.request,
            ...(url && { url }),
            headers,
          };

          event.request = request;
        },
      };
    });

    const DEFAULT_KEY = 'cause';
    const DEFAULT_LIMIT = 5;

    const INTEGRATION_NAME = 'LinkedErrors';

    const _linkedErrorsIntegration = ((options = {}) => {
      const limit = options.limit || DEFAULT_LIMIT;
      const key = options.key || DEFAULT_KEY;

      return {
        name: INTEGRATION_NAME,
        preprocessEvent(event, hint, client) {
          const options = client.getOptions();

          applyAggregateErrorsToEvent(
            // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
            exceptionFromError,
            options.stackParser,
            key,
            limit,
            event,
            hint,
          );
        },
      };
    }) ;

    /**
     * Aggregrate linked errors in an event.
     */
    const linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);

    /** Get the default integrations for the browser SDK. */
    function getDefaultIntegrations(_options) {
      /**
       * Note: Please make sure this stays in sync with Angular SDK, which re-exports
       * `getDefaultIntegrations` but with an adjusted set of integrations.
       */
      return [
        // TODO(v10): Replace with `eventFiltersIntegration` once we remove the deprecated `inboundFiltersIntegration`
        // eslint-disable-next-line deprecation/deprecation
        inboundFiltersIntegration(),
        functionToStringIntegration(),
        browserApiErrorsIntegration(),
        breadcrumbsIntegration(),
        globalHandlersIntegration(),
        linkedErrorsIntegration(),
        dedupeIntegration(),
        httpContextIntegration(),
        browserSessionIntegration(),
      ];
    }

    var config = {
        codeless: 'https://alloysdk.alloy.co/',
        api: 'https://docv-prod-api.alloy.co/'
    };

    var IOVATION_DOMAIN_KEY = 'iovation';
    var embedIovation = (function () { return __awaiter(void 0, void 0, void 0, function () {
        var delay, thirdPartyScript, thirdPartyId, script_1, firstPartyId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    window.IGLOO = window.IGLOO || {
                        loader: {
                            uri_hook: '/iojs/',
                            version: 'general5',
                            subkey: '5FExse+oA1134BhiwCF2EeQ1TfisPJGha4CpVG2nd7E=',
                        },
                    };
                    delay = function (milliseconds) {
                        return new Promise(function (resolve) { return setTimeout(resolve, milliseconds); });
                    };
                    thirdPartyScript = document.createElement('script');
                    thirdPartyScript.src = 'https://ci-mpsnare.iovation.com/snare.js';
                    thirdPartyScript.type = 'text/javascript';
                    thirdPartyScript.async = true;
                    document.head.appendChild(thirdPartyScript);
                    return [4 /*yield*/, new Promise(function (resolve) {
                            var getThirdPartyId = function () { return __awaiter(void 0, void 0, void 0, function () {
                                var id;
                                var _a;
                                return __generator(this, function (_b) {
                                    thirdPartyScript.removeEventListener('load', getThirdPartyId);
                                    try {
                                        id = typeof ioGetBlackbox === 'function' ? (_a = ioGetBlackbox()) === null || _a === void 0 ? void 0 : _a.blackbox : null;
                                        resolve(id);
                                    }
                                    catch (err) {
                                        resolve('');
                                    }
                                    return [2 /*return*/];
                                });
                            }); };
                            thirdPartyScript.addEventListener('load', getThirdPartyId);
                        })];
                case 1:
                    thirdPartyId = _a.sent();
                    if (!!thirdPartyId) return [3 /*break*/, 3];
                    script_1 = document.createElement('script');
                    script_1.src = 'https://scripts.alloy.com/iovation.js';
                    script_1.type = 'text/javascript';
                    script_1.async = true;
                    script_1.setAttribute('data-status', 'loading');
                    document.head.appendChild(script_1);
                    return [4 /*yield*/, new Promise(function (resolve) {
                            var getFirstPartyId = function () { return __awaiter(void 0, void 0, void 0, function () {
                                var id;
                                var _a;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            script_1.removeEventListener('load', getFirstPartyId);
                                            // TODO: refactor to remove delay
                                            return [4 /*yield*/, delay(500)];
                                        case 1:
                                            // TODO: refactor to remove delay
                                            _b.sent();
                                            try {
                                                id = (_a = window.IGLOO.getBlackbox()) === null || _a === void 0 ? void 0 : _a.blackbox;
                                                resolve(id);
                                            }
                                            catch (err) {
                                                resolve('');
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            script_1.addEventListener('load', getFirstPartyId);
                        })];
                case 2:
                    firstPartyId = _a.sent();
                    return [2 /*return*/, firstPartyId];
                case 3: return [2 /*return*/, thirdPartyId];
            }
        });
    }); });
    var removeIovation = function () {
        var scripts = document.querySelectorAll('script');
        scripts.forEach(function (script) {
            if (script.src.includes(IOVATION_DOMAIN_KEY)) {
                script.remove();
            }
        });
    };

    var dist = {};

    var v1$1 = {};

    var rngBrowser = {};

    Object.defineProperty(rngBrowser, "__esModule", {
      value: true
    });
    rngBrowser.default = rng;
    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);

    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var stringify$1 = {};

    var validate$1 = {};

    var regex = {};

    Object.defineProperty(regex, "__esModule", {
      value: true
    });
    regex.default = void 0;
    var _default$c = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    regex.default = _default$c;

    Object.defineProperty(validate$1, "__esModule", {
      value: true
    });
    validate$1.default = void 0;

    var _regex = _interopRequireDefault$8(regex);

    function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function validate(uuid) {
      return typeof uuid === 'string' && _regex.default.test(uuid);
    }

    var _default$b = validate;
    validate$1.default = _default$b;

    Object.defineProperty(stringify$1, "__esModule", {
      value: true
    });
    stringify$1.default = void 0;
    stringify$1.unsafeStringify = unsafeStringify;

    var _validate$2 = _interopRequireDefault$7(validate$1);

    function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }

    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }

    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!(0, _validate$2.default)(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    var _default$a = stringify;
    stringify$1.default = _default$a;

    Object.defineProperty(v1$1, "__esModule", {
      value: true
    });
    v1$1.default = void 0;

    var _rng$1 = _interopRequireDefault$6(rngBrowser);

    var _stringify$2 = stringify$1;

    function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html
    let _nodeId;

    let _clockseq; // Previous uuid creation time


    let _lastMSecs = 0;
    let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189

      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng$1.default)();

        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }

        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


      let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock

      let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval


      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested


      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

      msecs += 12219292800000; // `time_low`

      const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff; // `time_mid`

      const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`

      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

      b[i++] = clockseq & 0xff; // `node`

      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf || (0, _stringify$2.unsafeStringify)(b);
    }

    var _default$9 = v1;
    v1$1.default = _default$9;

    var v3$1 = {};

    var v35$1 = {};

    var parse$1 = {};

    Object.defineProperty(parse$1, "__esModule", {
      value: true
    });
    parse$1.default = void 0;

    var _validate$1 = _interopRequireDefault$5(validate$1);

    function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function parse(uuid) {
      if (!(0, _validate$1.default)(uuid)) {
        throw TypeError('Invalid UUID');
      }

      let v;
      const arr = new Uint8Array(16); // Parse ########-....-....-....-............

      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 0xff;
      arr[2] = v >>> 8 & 0xff;
      arr[3] = v & 0xff; // Parse ........-####-....-....-............

      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 0xff; // Parse ........-....-####-....-............

      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 0xff; // Parse ........-....-....-####-............

      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 0xff; // Parse ........-....-....-....-############
      // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
      arr[11] = v / 0x100000000 & 0xff;
      arr[12] = v >>> 24 & 0xff;
      arr[13] = v >>> 16 & 0xff;
      arr[14] = v >>> 8 & 0xff;
      arr[15] = v & 0xff;
      return arr;
    }

    var _default$8 = parse;
    parse$1.default = _default$8;

    Object.defineProperty(v35$1, "__esModule", {
      value: true
    });
    v35$1.URL = v35$1.DNS = void 0;
    v35$1.default = v35;

    var _stringify$1 = stringify$1;

    var _parse = _interopRequireDefault$4(parse$1);

    function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str)); // UTF8 escape

      const bytes = [];

      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }

      return bytes;
    }

    const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    v35$1.DNS = DNS;
    const URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    v35$1.URL = URL$1;

    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;

        if (typeof value === 'string') {
          value = stringToBytes(value);
        }

        if (typeof namespace === 'string') {
          namespace = (0, _parse.default)(namespace);
        }

        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`


        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;

        if (buf) {
          offset = offset || 0;

          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }

          return buf;
        }

        return (0, _stringify$1.unsafeStringify)(bytes);
      } // Function#name is not settable on some platforms (#270)


      try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
      } catch (err) {} // For CommonJS default export support


      generateUUID.DNS = DNS;
      generateUUID.URL = URL$1;
      return generateUUID;
    }

    var md5Browser = {};

    Object.defineProperty(md5Browser, "__esModule", {
      value: true
    });
    md5Browser.default = void 0;

    /*
     * Browser-compatible JavaScript MD5
     *
     * Modification of JavaScript MD5
     * https://github.com/blueimp/JavaScript-MD5
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * https://opensource.org/licenses/MIT
     *
     * Based on
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */
    function md5(bytes) {
      if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = new Uint8Array(msg.length);

        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }

      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    /*
     * Convert an array of little-endian words to an array of bytes
     */


    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = '0123456789abcdef';

      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 0xff;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
      }

      return output;
    }
    /**
     * Calculate output length with padding and bit length
     */


    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */


    function wordsToMd5(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;

      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }

      return [a, b, c, d];
    }
    /*
     * Convert an array bytes to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */


    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }

      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));

      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
      }

      return output;
    }
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */


    function safeAdd(x, y) {
      const lsw = (x & 0xffff) + (y & 0xffff);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 0xffff;
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */


    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    /*
     * These functions implement the four basic operations the algorithm uses.
     */


    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }

    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }

    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }

    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }

    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }

    var _default$7 = md5;
    md5Browser.default = _default$7;

    Object.defineProperty(v3$1, "__esModule", {
      value: true
    });
    v3$1.default = void 0;

    var _v$1 = _interopRequireDefault$3(v35$1);

    var _md = _interopRequireDefault$3(md5Browser);

    function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    const v3 = (0, _v$1.default)('v3', 0x30, _md.default);
    var _default$6 = v3;
    v3$1.default = _default$6;

    var v4$1 = {};

    var nativeBrowser = {};

    Object.defineProperty(nativeBrowser, "__esModule", {
      value: true
    });
    nativeBrowser.default = void 0;
    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default$5 = {
      randomUUID
    };
    nativeBrowser.default = _default$5;

    Object.defineProperty(v4$1, "__esModule", {
      value: true
    });
    v4$1.default = void 0;

    var _native = _interopRequireDefault$2(nativeBrowser);

    var _rng = _interopRequireDefault$2(rngBrowser);

    var _stringify = stringify$1;

    function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }

      options = options || {};

      const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return (0, _stringify.unsafeStringify)(rnds);
    }

    var _default$4 = v4;
    v4$1.default = _default$4;

    var v5$1 = {};

    var sha1Browser = {};

    Object.defineProperty(sha1Browser, "__esModule", {
      value: true
    });
    sha1Browser.default = void 0;

    // Adapted from Chris Veness' SHA1 code at
    // http://www.movable-type.co.uk/scripts/sha1.html
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;

        case 1:
          return x ^ y ^ z;

        case 2:
          return x & y ^ x & z ^ y & z;

        case 3:
          return x ^ y ^ z;
      }
    }

    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }

    function sha1(bytes) {
      const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
      const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

      if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

        bytes = [];

        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        // Convert Array-like to Array
        bytes = Array.prototype.slice.call(bytes);
      }

      bytes.push(0x80);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);

      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);

        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }

        M[i] = arr;
      }

      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);

        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }

        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }

        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];

        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }

        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }

      return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
    }

    var _default$3 = sha1;
    sha1Browser.default = _default$3;

    Object.defineProperty(v5$1, "__esModule", {
      value: true
    });
    v5$1.default = void 0;

    var _v = _interopRequireDefault$1(v35$1);

    var _sha = _interopRequireDefault$1(sha1Browser);

    function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    const v5 = (0, _v.default)('v5', 0x50, _sha.default);
    var _default$2 = v5;
    v5$1.default = _default$2;

    var nil = {};

    Object.defineProperty(nil, "__esModule", {
      value: true
    });
    nil.default = void 0;
    var _default$1 = '00000000-0000-0000-0000-000000000000';
    nil.default = _default$1;

    var version$2 = {};

    Object.defineProperty(version$2, "__esModule", {
      value: true
    });
    version$2.default = void 0;

    var _validate = _interopRequireDefault(validate$1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function version$1(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Invalid UUID');
      }

      return parseInt(uuid.slice(14, 15), 16);
    }

    var _default = version$1;
    version$2.default = _default;

    (function (exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	Object.defineProperty(exports, "NIL", {
    	  enumerable: true,
    	  get: function () {
    	    return _nil.default;
    	  }
    	});
    	Object.defineProperty(exports, "parse", {
    	  enumerable: true,
    	  get: function () {
    	    return _parse.default;
    	  }
    	});
    	Object.defineProperty(exports, "stringify", {
    	  enumerable: true,
    	  get: function () {
    	    return _stringify.default;
    	  }
    	});
    	Object.defineProperty(exports, "v1", {
    	  enumerable: true,
    	  get: function () {
    	    return _v.default;
    	  }
    	});
    	Object.defineProperty(exports, "v3", {
    	  enumerable: true,
    	  get: function () {
    	    return _v2.default;
    	  }
    	});
    	Object.defineProperty(exports, "v4", {
    	  enumerable: true,
    	  get: function () {
    	    return _v3.default;
    	  }
    	});
    	Object.defineProperty(exports, "v5", {
    	  enumerable: true,
    	  get: function () {
    	    return _v4.default;
    	  }
    	});
    	Object.defineProperty(exports, "validate", {
    	  enumerable: true,
    	  get: function () {
    	    return _validate.default;
    	  }
    	});
    	Object.defineProperty(exports, "version", {
    	  enumerable: true,
    	  get: function () {
    	    return _version.default;
    	  }
    	});

    	var _v = _interopRequireDefault(v1$1);

    	var _v2 = _interopRequireDefault(v3$1);

    	var _v3 = _interopRequireDefault(v4$1);

    	var _v4 = _interopRequireDefault(v5$1);

    	var _nil = _interopRequireDefault(nil);

    	var _version = _interopRequireDefault(version$2);

    	var _validate = _interopRequireDefault(validate$1);

    	var _stringify = _interopRequireDefault(stringify$1);

    	var _parse = _interopRequireDefault(parse$1);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } 
    } (dist));

    // eslint-disable-next-line import/prefer-default-export
    var setSessionId = function (storageLabel, neuroUserId) {
        var sessionId;
        if (!sessionStorage.getItem(storageLabel)) {
            sessionId = neuroUserId || dist.v4();
            sessionStorage.setItem(storageLabel, sessionId);
        }
        else {
            sessionId = sessionStorage.getItem(storageLabel);
        }
        return sessionId;
    };

    var NEUROID_DOMAIN_KEY = 'neuro-id.com';
    var embedNeuroId = function (neuroUserId, siteId, production, neuroIdFunnel) {
        sessionStorage.setItem('neuroIdOpen', 'true');
        var identityId = setSessionId('identityId', neuroUserId);
        // slice 'form_' off the siteId
        var siteIdString = window.encodeURIComponent(production
            ? siteId.slice(5)
            : (siteId + "-test").slice(5));
        // Create script
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = "//scripts." + NEUROID_DOMAIN_KEY + "/c/nid-" + siteIdString + ".js";
        script.async = true;
        if (!window.nid) {
            window.nid = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                (window.nid.q = window.nid.q || []).push(args);
            };
        }
        // Add script to document if there is no repeat
        document.head.appendChild(script);
        window.nid('identify', identityId);
        if (neuroIdFunnel) {
            window.nid('setVariable', 'funnel', neuroIdFunnel);
        }
        return identityId;
    };
    var removeNeuroId = function (removeScript) {
        if (removeScript === void 0) { removeScript = false; }
        // creates a check to avoid calling closeSession more than once
        if (sessionStorage.getItem('neuroIdOpen') === 'true' && window.nid) {
            window.nid('closeSession');
            sessionStorage.setItem('neuroIdOpen', 'false');
        }
        if (removeScript) {
            if (window.nidLoaded) {
                // The above neuroID embedded script loads a secondary script and uses this global window
                // variable to check if it's loaded. If true, secondary script will not be loaded when init/open
                // runs again in the same session.
                window.nidLoaded = false;
            }
            var scripts = document.querySelectorAll('script');
            scripts.forEach(function (script) {
                if (script.src.includes(NEUROID_DOMAIN_KEY)) {
                    script.remove();
                }
            });
        }
    };

    var embedSocure = (function (socurePublicToken) { return __awaiter(void 0, void 0, void 0, function () {
        var script, socureDeviceId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    script = document.createElement('script');
                    script.src = 'https://scripts.alloy.com/devicer.min.js';
                    script.type = 'text/javascript';
                    script.async = true;
                    script.setAttribute('data-status', 'loading');
                    // Add script to document body
                    document.head.appendChild(script);
                    return [4 /*yield*/, new Promise(function (resolve) {
                            // get device Id from devicer library
                            var getDeviceId = function () {
                                // remove listener after enter the first time
                                script.removeEventListener('load', getDeviceId);
                                var deviceFPOptions = {
                                    publicKey: socurePublicToken,
                                    userConsent: true,
                                    endpoint: 'device.alloy.com',
                                    context: 'homepage',
                                };
                                try {
                                    // get device ID
                                    devicer.run(deviceFPOptions, function (response) {
                                        resolve(response.sessionId);
                                    });
                                }
                                catch (err) {
                                    resolve('');
                                }
                            };
                            // wait to script to be fully loaded
                            script.addEventListener('load', getDeviceId);
                        })];
                case 1:
                    socureDeviceId = _a.sent();
                    return [2 /*return*/, socureDeviceId];
            }
        });
    }); });
    var removeSocure = function () {
        var scripts = document.querySelectorAll('script');
        scripts.forEach(function (script) {
            if (script.src.includes('scripts.alloy.com/devicer')) {
                script.remove();
            }
        });
    };

    var SOCURE_DI_DOMAIN_KEY = 'sdk.dv.socure.io';
    var embedSocureDigitalIntelligence = (function (sigmaDeviceOptions) { return __awaiter(void 0, void 0, void 0, function () {
        var script, socureSessionToken;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    script = document.createElement('script');
                    script.src = "https://" + SOCURE_DI_DOMAIN_KEY + "/latest/device-risk-sdk.js";
                    script.type = 'text/javascript';
                    script.defer = true;
                    script.setAttribute('data-status', 'loading');
                    // Add script to document body
                    document.head.appendChild(script);
                    return [4 /*yield*/, new Promise(function (resolve) {
                            var getSessionToken = function () {
                                // remove listener after enter the first time
                                script.removeEventListener('load', getSessionToken);
                                try {
                                    SigmaDeviceManager.initialize(sigmaDeviceOptions);
                                    SigmaDeviceManager.getSessionToken().then(function (sessionToken) {
                                        resolve(sessionToken);
                                    });
                                }
                                catch (err) {
                                    resolve('');
                                }
                            };
                            // wait for script to be fully loaded
                            script.addEventListener('load', getSessionToken);
                        })];
                case 1:
                    socureSessionToken = _a.sent();
                    return [2 /*return*/, socureSessionToken];
            }
        });
    }); });
    var removeSocureDigitalIntelligence = function () {
        var scripts = document.querySelectorAll('script');
        scripts.forEach(function (script) {
            if (script.src.includes(SOCURE_DI_DOMAIN_KEY)) {
                script.remove();
            }
        });
    };

    var THREATMETRIX_DOMAIN_KEY = 'h.online-metrix.net';
    var embedThreatmetrix = (function (orgId) {
        var sessionId = setSessionId('tmSessionId');
        // Sanitize orgId and sessionId by ensuring they are safe to use
        var safeOrgId = encodeURIComponent(orgId); // Encoding the values
        var safeSessionId = encodeURIComponent(sessionId);
        // Create script
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = "https://" + THREATMETRIX_DOMAIN_KEY + "/fp/tags?org_id=" + safeOrgId + "&session_id=" + safeSessionId;
        script.async = true;
        // Add script to document 
        document.head.appendChild(script);
        return sessionId;
    });
    var removeThreatmetrix = function () {
        var scripts = document.querySelectorAll('script');
        scripts.forEach(function (script) {
            if (script.src.includes(THREATMETRIX_DOMAIN_KEY)) {
                script.remove();
            }
        });
    };

    var FetchError = /** @class */ (function (_super) {
        __extends(FetchError, _super);
        function FetchError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'FetchError';
            _this.message = message || 'An error occurred while fetching the data.';
            return _this;
        }
        return FetchError;
    }(Error));

    var COMMON_HEADERS = {
        'X-Alloy-Sdk-Platform': 'Web',
        'X-Alloy-Sdk-Version': '1',
        'Content-Type': 'application/json',
    };
    function isWeb() {
        return typeof document !== 'undefined';
    }
    function commonFetch(_a) {
        var url = _a.url, method = _a.method, headers = _a.headers, fetchOptions = _a.fetchOptions, data = _a.data;
        return __awaiter(this, void 0, void 0, function () {
            var options, response, error, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        options = __assign({ method: method, headers: __assign(__assign(__assign({}, COMMON_HEADERS), { 'X-Parent-Domain': (isWeb()) ? document.referrer : '' }), headers) }, fetchOptions);
                        if (method && data && ['POST', 'PUT'].includes(method)) {
                            options.body = JSON.stringify(data);
                        }
                        return [4 /*yield*/, fetch("" + config.api + url, options)];
                    case 1:
                        response = _c.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        error = new FetchError();
                        _b = error;
                        return [4 /*yield*/, response.json()];
                    case 2:
                        _b.info = _c.sent();
                        error.status = response.status;
                        throw error;
                    case 3: return [2 /*return*/, response.json()];
                }
            });
        });
    }

    var fetchAuthInit = function (id) {
        return commonFetch({
            url: 'auth/init',
            method: 'POST',
            fetchOptions: {
                body: JSON.stringify({
                    id: id,
                }),
            },
        });
    };
    var fetchPublicInfo = function (key, accessToken) {
        return commonFetch({
            url: "client/public/" + key,
            headers: {
                'Authorization': "Bearer " + accessToken,
                'alloy-journey-application-sync': 'true'
            },
            method: 'GET',
        });
    };
    var generateJourneyApplication = function (journeyToken, accessToken, journeyData, production) {
        if (production === void 0) { production = false; }
        return commonFetch({
            url: "v1/journeys/" + journeyToken + "/applications",
            headers: {
                'Authorization': "Bearer " + accessToken,
                'alloy-journey-application-sync': 'true',
                'alloy-sandbox': production ? 'false' : 'true',
            },
            method: 'POST',
            fetchOptions: {
                body: JSON.stringify(__assign({}, journeyData))
            }
        });
    };
    var generateEvaluation = function (accessToken, evaluationData, entityToken, externalEntityId, production) {
        if (production === void 0) { production = false; }
        return commonFetch({
            url: 'evaluations',
            headers: __assign(__assign(__assign({ 'Authorization': "Bearer " + accessToken, 'Content-Type': 'application/json' }, (entityToken && { 'Alloy-Entity-Token': entityToken })), (externalEntityId && {
                'Alloy-External-Entity-ID': externalEntityId,
            })), { 'alloy-sandbox': production ? 'false' : 'true' }),
            method: 'POST',
            fetchOptions: {
                body: JSON.stringify(__assign({}, evaluationData))
            }
        });
    };

    var getEmbeddedDataSources = function (_a) {
        var socureDeviceId = _a.socureDeviceId, socureSessionToken = _a.socureSessionToken, isNeuroIdEnabled = _a.isNeuroIdEnabled, neuroIdSiteId = _a.neuroIdSiteId, iovationBlackboxId = _a.iovationBlackboxId, threatmetrixSessionId = _a.threatmetrixSessionId, threatmetrixOrgId = _a.threatmetrixOrgId;
        var sources = {};
        if (socureDeviceId)
            sources.socure_session_id = socureDeviceId;
        if (socureSessionToken)
            sources.socure_session_id = socureSessionToken;
        if (isNeuroIdEnabled && neuroIdSiteId) {
            var identityId = sessionStorage.getItem('identityId');
            sources.neuro_user_id = identityId;
            sources.site_id = neuroIdSiteId;
        }
        if (threatmetrixSessionId) {
            sources.threatmetrix_session_id = threatmetrixSessionId;
            sources.org_id = threatmetrixOrgId;
        }
        if (iovationBlackboxId) {
            sources.iovation_blackbox = iovationBlackboxId;
        }
        return sources;
    };

    var version = '2.3.0';

    var alloyId = 'alloy';
    var alloyInitParams = { key: '', npmPackageVersion: version };
    var alloyCallback;
    var iframeSrc;
    var sentryTelemetry = true;
    // filter Sentry integrations that use the global variable
    var integrations = getDefaultIntegrations().filter(function (defaultIntegration) {
        return !["BrowserApiErrors", "Breadcrumbs", "GlobalHandlers"].includes(defaultIntegration.name);
    });
    var client = new BrowserClient({
        dsn: "https://daf0ad474f2a2a0fb3429754a44caa47@o478884.ingest.us.sentry.io/4509204292894721",
        release: "alloy-web-sdk@" + version,
        stackParser: defaultStackParser,
        integrations: integrations,
        transport: makeFetchTransport,
    });
    var sentryScope = new Scope();
    sentryScope.setClient(client);
    client.init(); // initializing has to be done after setting the client on the scope
    var createEvaluation = function () { return __awaiter(void 0, void 0, void 0, function () {
        var key, entityToken, evaluationData, production, externalEntityId, socureDeviceId, socureSessionToken, iovationBlackboxId, neuroIdSiteId, threatmetrixSessionId, threatmetrixOrgId, token, isNeuroIdEnabled, currEntityToken, embeddedDataSources, data, evaluation;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    removeNeuroId();
                    key = alloyInitParams.key, entityToken = alloyInitParams.entityToken, evaluationData = alloyInitParams.evaluationData, production = alloyInitParams.production, externalEntityId = alloyInitParams.externalEntityId, socureDeviceId = alloyInitParams.socureDeviceId, socureSessionToken = alloyInitParams.socureSessionToken, iovationBlackboxId = alloyInitParams.iovationBlackboxId, neuroIdSiteId = alloyInitParams.neuroIdSiteId, threatmetrixSessionId = alloyInitParams.threatmetrixSessionId, threatmetrixOrgId = alloyInitParams.threatmetrixOrgId;
                    return [4 /*yield*/, fetchAuthInit(key)];
                case 1:
                    token = (_a.sent()).access_token;
                    isNeuroIdEnabled = !!neuroIdSiteId;
                    currEntityToken = entityToken;
                    embeddedDataSources = getEmbeddedDataSources({
                        socureDeviceId: socureDeviceId,
                        socureSessionToken: socureSessionToken,
                        isNeuroIdEnabled: isNeuroIdEnabled,
                        neuroIdSiteId: neuroIdSiteId,
                        iovationBlackboxId: iovationBlackboxId,
                        threatmetrixSessionId: threatmetrixSessionId,
                        threatmetrixOrgId: threatmetrixOrgId,
                    });
                    data = __assign(__assign({}, evaluationData), embeddedDataSources);
                    return [4 /*yield*/, generateEvaluation(token, data, currEntityToken, externalEntityId, production)];
                case 2:
                    evaluation = _a.sent();
                    return [2 /*return*/, evaluation];
            }
        });
    }); };
    var createJourneyApplication = function (data) { return __awaiter(void 0, void 0, void 0, function () {
        var key, journeyToken, production, socureDeviceId, socureSessionToken, iovationBlackboxId, neuroIdSiteId, threatmetrixSessionId, threatmetrixOrgId, journeyData, token, isNeuroIdEnabled, embeddedDataSources_1, journeyApplicationResponse;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    removeNeuroId();
                    key = alloyInitParams.key, journeyToken = alloyInitParams.journeyToken, production = alloyInitParams.production, socureDeviceId = alloyInitParams.socureDeviceId, socureSessionToken = alloyInitParams.socureSessionToken, iovationBlackboxId = alloyInitParams.iovationBlackboxId, neuroIdSiteId = alloyInitParams.neuroIdSiteId, threatmetrixSessionId = alloyInitParams.threatmetrixSessionId, threatmetrixOrgId = alloyInitParams.threatmetrixOrgId;
                    if (!journeyToken) return [3 /*break*/, 3];
                    journeyData = data;
                    return [4 /*yield*/, fetchAuthInit(key)];
                case 1:
                    token = (_b.sent()).access_token;
                    isNeuroIdEnabled = !!neuroIdSiteId;
                    embeddedDataSources_1 = getEmbeddedDataSources({
                        socureDeviceId: socureDeviceId,
                        socureSessionToken: socureSessionToken,
                        isNeuroIdEnabled: isNeuroIdEnabled,
                        neuroIdSiteId: neuroIdSiteId,
                        iovationBlackboxId: iovationBlackboxId,
                        threatmetrixSessionId: threatmetrixSessionId,
                        threatmetrixOrgId: threatmetrixOrgId,
                    });
                    if (Object.keys(embeddedDataSources_1).length >= 1) {
                        journeyData.entities = (_a = data.entities) === null || _a === void 0 ? void 0 : _a.map(function (entity) {
                            var entityWithDeviceId = entity;
                            entityWithDeviceId.data = __assign(__assign({}, entityWithDeviceId.data), embeddedDataSources_1);
                            return entityWithDeviceId;
                        });
                    }
                    return [4 /*yield*/, generateJourneyApplication(journeyToken, token, journeyData, production)];
                case 2:
                    journeyApplicationResponse = _b.sent();
                    alloyInitParams.journeyApplicationToken =
                        journeyApplicationResponse.journey_application_token;
                    return [2 /*return*/, journeyApplicationResponse];
                case 3: return [2 /*return*/, null];
            }
        });
    }); };
    var close = function () {
        try {
            removeNeuroId(true);
            removeIovation();
            removeSocure();
            removeSocureDigitalIntelligence();
            removeThreatmetrix();
            var element = document.getElementById(alloyId);
            if (element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }
        catch (err) {
            if (sentryTelemetry) {
                sentryScope.captureException(err);
            }
        }
    };
    var fetchClientServices = function (key) { return __awaiter(void 0, void 0, void 0, function () {
        var accessToken, publicInfo, isNeuroIdEnabled, neuroIdSiteId, isThreatmetrixEnabled, threatmetrixOrgId, isIovationEnabled, isSocureEnabled, socurePublicToken, isSocureDigitalIntelEnabled, socureDigitalIntelPublicToken;
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        return __generator(this, function (_y) {
            switch (_y.label) {
                case 0: return [4 /*yield*/, fetchAuthInit(key)];
                case 1:
                    accessToken = (_y.sent()).access_token;
                    return [4 /*yield*/, fetchPublicInfo(key, accessToken)];
                case 2:
                    publicInfo = _y.sent();
                    isNeuroIdEnabled = ((_b = (_a = publicInfo) === null || _a === void 0 ? void 0 : _a.services) === null || _b === void 0 ? void 0 : _b.neuro_id) || false;
                    neuroIdSiteId = ((_e = (_d = (_c = publicInfo) === null || _c === void 0 ? void 0 : _c.services) === null || _d === void 0 ? void 0 : _d.neuro_id) === null || _e === void 0 ? void 0 : _e.siteId) || '';
                    isThreatmetrixEnabled = ((_g = (_f = publicInfo) === null || _f === void 0 ? void 0 : _f.services) === null || _g === void 0 ? void 0 : _g.threatmetrix) || false;
                    threatmetrixOrgId = ((_k = (_j = (_h = publicInfo) === null || _h === void 0 ? void 0 : _h.services) === null || _j === void 0 ? void 0 : _j.threatmetrix) === null || _k === void 0 ? void 0 : _k.orgId) || '';
                    isIovationEnabled = ((_m = (_l = publicInfo) === null || _l === void 0 ? void 0 : _l.services) === null || _m === void 0 ? void 0 : _m.iovation) || false;
                    isSocureEnabled = ((_p = (_o = publicInfo) === null || _o === void 0 ? void 0 : _o.services) === null || _p === void 0 ? void 0 : _p.socure_dv) || false;
                    socurePublicToken = ((_s = (_r = (_q = publicInfo) === null || _q === void 0 ? void 0 : _q.services) === null || _r === void 0 ? void 0 : _r.socure_dv) === null || _s === void 0 ? void 0 : _s.publicToken) || false;
                    isSocureDigitalIntelEnabled = ((_u = (_t = publicInfo) === null || _t === void 0 ? void 0 : _t.services) === null || _u === void 0 ? void 0 : _u.socure_digital_intel) || false;
                    socureDigitalIntelPublicToken = ((_x = (_w = (_v = publicInfo) === null || _v === void 0 ? void 0 : _v.services) === null || _w === void 0 ? void 0 : _w.socure_digital_intel) === null || _x === void 0 ? void 0 : _x.publicToken) || '';
                    return [2 /*return*/, {
                            isNeuroIdEnabled: isNeuroIdEnabled,
                            neuroIdSiteId: neuroIdSiteId,
                            isIovationEnabled: isIovationEnabled,
                            isSocureEnabled: isSocureEnabled,
                            socurePublicToken: socurePublicToken,
                            isThreatmetrixEnabled: isThreatmetrixEnabled,
                            threatmetrixOrgId: threatmetrixOrgId,
                            isSocureDigitalIntelEnabled: isSocureDigitalIntelEnabled,
                            socureDigitalIntelPublicToken: socureDigitalIntelPublicToken,
                        }];
            }
        });
    }); };
    var init = function (_a) {
        var key = _a.key, apiUrl = _a.apiUrl, appUrl = _a.appUrl, entityToken = _a.entityToken, externalEntityId = _a.externalEntityId, evaluationData = _a.evaluationData, production = _a.production, maxEvaluationAttempts = _a.maxEvaluationAttempts, documents = _a.documents, selfie = _a.selfie, color = _a.color, customStyle = _a.customStyle, customerSlug = _a.customerSlug, forceMobile = _a.forceMobile, validationPreChecks = _a.validationPreChecks, showHeader = _a.showHeader, journeyApplicationToken = _a.journeyApplicationToken, journeyToken = _a.journeyToken, isSingleEntity = _a.isSingleEntity, isReactNative = _a.isReactNative, isAndroidDevice = _a.isAndroidDevice, neuroUserId = _a.neuroUserId, neuroIdFunnel = _a.neuroIdFunnel, socureCustomerSessionId = _a.socureCustomerSessionId, _b = _a.telemetry, telemetry = _b === void 0 ? true : _b;
        return __awaiter(void 0, void 0, void 0, function () {
            var sdkApiUrl, codelessUrl, _c, isNeuroIdEnabled, neuroIdSiteId, isThreatmetrixEnabled, threatmetrixOrgId, isIovationEnabled, isSocureEnabled, socurePublicToken, isSocureDigitalIntelEnabled, socureDigitalIntelPublicToken, socureDeviceId, socureSessionToken, identityId, sessionId, blackboxId, themeString, componentOverrideString, themeObject, componentOverrideObject, err_1;
            var _d, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        sentryTelemetry = telemetry;
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 9, , 10]);
                        // reset any residual init params when first initializing
                        Object.keys(alloyInitParams).forEach(function (alloyKey) {
                            delete alloyInitParams[alloyKey];
                        });
                        alloyInitParams.key = key;
                        alloyInitParams.npmPackageVersion = version;
                        if (customerSlug) {
                            sdkApiUrl = "https://" + customerSlug + "-alloysdk.api.alloy.com/";
                            codelessUrl = "https://" + customerSlug + "-alloysdk.app.alloy.com/";
                            config.codeless = codelessUrl;
                            config.api = sdkApiUrl;
                        }
                        // TODO: Remove once provisioning works on customerSlug basis
                        if (apiUrl && appUrl) {
                            config.codeless = appUrl;
                            config.api = apiUrl;
                        }
                        if (entityToken) {
                            alloyInitParams.entityToken = entityToken;
                        }
                        if (externalEntityId) {
                            alloyInitParams.externalEntityId = externalEntityId;
                        }
                        if (production) {
                            alloyInitParams.production = production;
                        }
                        if (maxEvaluationAttempts) {
                            alloyInitParams.maxEvaluationAttempts = maxEvaluationAttempts;
                        }
                        if (documents) {
                            alloyInitParams.documents = documents;
                        }
                        if (selfie) {
                            alloyInitParams.selfie = selfie;
                        }
                        if (forceMobile) {
                            alloyInitParams.forceMobile = forceMobile;
                        }
                        if (showHeader === false) {
                            alloyInitParams.showHeader = showHeader;
                        }
                        if (validationPreChecks) {
                            alloyInitParams.validationPreChecks = validationPreChecks;
                        }
                        if (journeyApplicationToken) {
                            alloyInitParams.journeyApplicationToken = journeyApplicationToken;
                        }
                        if (journeyToken) {
                            alloyInitParams.journeyToken = journeyToken;
                        }
                        if (isSingleEntity) {
                            alloyInitParams.isSingleEntity = isSingleEntity;
                        }
                        return [4 /*yield*/, fetchClientServices(key)];
                    case 2:
                        _c = _f.sent(), isNeuroIdEnabled = _c.isNeuroIdEnabled, neuroIdSiteId = _c.neuroIdSiteId, isThreatmetrixEnabled = _c.isThreatmetrixEnabled, threatmetrixOrgId = _c.threatmetrixOrgId, isIovationEnabled = _c.isIovationEnabled, isSocureEnabled = _c.isSocureEnabled, socurePublicToken = _c.socurePublicToken, isSocureDigitalIntelEnabled = _c.isSocureDigitalIntelEnabled, socureDigitalIntelPublicToken = _c.socureDigitalIntelPublicToken;
                        if (!(socurePublicToken && isSocureEnabled)) return [3 /*break*/, 4];
                        alloyInitParams.socurePublicToken = socurePublicToken;
                        return [4 /*yield*/, embedSocure(socurePublicToken)];
                    case 3:
                        socureDeviceId = _f.sent();
                        alloyInitParams.socureDeviceId = socureDeviceId;
                        _f.label = 4;
                    case 4:
                        if (!(socureDigitalIntelPublicToken && isSocureDigitalIntelEnabled)) return [3 /*break*/, 6];
                        alloyInitParams.socureDigitalIntelPublicToken = socureDigitalIntelPublicToken;
                        return [4 /*yield*/, embedSocureDigitalIntelligence({
                                sdkKey: socureDigitalIntelPublicToken,
                                customerSessionId: socureCustomerSessionId,
                            })];
                    case 5:
                        socureSessionToken = _f.sent();
                        alloyInitParams.socureSessionToken = socureSessionToken;
                        _f.label = 6;
                    case 6:
                        if (isNeuroIdEnabled && neuroIdSiteId) {
                            alloyInitParams.neuroIdSiteId = neuroIdSiteId;
                            identityId = embedNeuroId(neuroUserId, neuroIdSiteId, production || false, neuroIdFunnel);
                            // neuroUserId is alloy's internal mapping for identityId
                            alloyInitParams.neuroUserId = identityId;
                            if (neuroIdFunnel) {
                                alloyInitParams.neuroIdFunnel = neuroIdFunnel;
                            }
                        }
                        if (isThreatmetrixEnabled && threatmetrixOrgId) {
                            alloyInitParams.threatmetrixOrgId = threatmetrixOrgId;
                            sessionId = embedThreatmetrix(threatmetrixOrgId);
                            alloyInitParams.threatmetrixSessionId = sessionId;
                        }
                        if (!isIovationEnabled) return [3 /*break*/, 8];
                        return [4 /*yield*/, embedIovation()];
                    case 7:
                        blackboxId = _f.sent();
                        alloyInitParams.iovationBlackboxId = blackboxId;
                        _f.label = 8;
                    case 8:
                        if (isReactNative) {
                            alloyInitParams.isReactNative = isReactNative;
                        }
                        if (isAndroidDevice) {
                            alloyInitParams.isAndroidDevice = isAndroidDevice;
                        }
                        themeString = JSON.stringify((_d = customStyle) === null || _d === void 0 ? void 0 : _d.theme);
                        componentOverrideString = JSON.stringify((_e = customStyle) === null || _e === void 0 ? void 0 : _e.componentOverride);
                        themeObject = {
                            theme: themeString,
                        };
                        componentOverrideObject = {
                            componentOverride: componentOverrideString,
                        };
                        iframeSrc = "" + queryString.stringify(alloyInitParams) + (evaluationData ? "&" + queryString.stringify(evaluationData) : '') + (color ? "&" + queryString.stringify(color) : '') + (themeObject.theme ? "&" + queryString.stringify(themeObject) : '') + (componentOverrideObject.componentOverride
                            ? "&" + queryString.stringify(componentOverrideObject)
                            : '');
                        if (evaluationData) {
                            alloyInitParams.evaluationData = evaluationData;
                        }
                        return [3 /*break*/, 10];
                    case 9:
                        err_1 = _f.sent();
                        if (sentryTelemetry) {
                            sentryScope.captureException(err_1);
                        }
                        return [3 /*break*/, 10];
                    case 10: return [2 /*return*/, alloyInitParams];
                }
            });
        });
    };
    var getPublicUrl = function () {
        var publicUrl = config.codeless + "?" + iframeSrc;
        try {
            if (alloyInitParams.journeyApplicationToken &&
                !publicUrl.includes('journeyApplicationToken')) {
                publicUrl = config.codeless + "?" + iframeSrc + "&journeyApplicationToken=" + alloyInitParams.journeyApplicationToken;
            }
        }
        catch (err) {
            if (sentryTelemetry) {
                sentryScope.captureException(err);
            }
        }
        return publicUrl;
    };
    var open = function (cb, anchorElement) {
        try {
            removeNeuroId();
            var eventListener_1 = function (event) {
                var isAlloyUrl = event.origin === 'https://docv-iframe.alloy.co' ||
                    event.origin === 'https://alloysdk.alloy.co' ||
                    event.origin.includes('.app.alloy.com');
                if (!isAlloyUrl || !alloyCallback) {
                    return;
                }
                window.removeEventListener('message', eventListener_1);
                alloyCallback(event.data);
                close();
            };
            window.addEventListener('message', eventListener_1);
            alloyCallback = cb;
            if (!alloyInitParams.key) {
                // eslint-disable-next-line no-console
                console.error('The Alloy framework has not been initialized. You are missing the sdk key in your initialize parameters.');
            }
            else {
                var alloyHeadStyles = document.getElementById('alloy-iframe-style');
                if (!alloyHeadStyles) {
                    document.head.insertAdjacentHTML('beforeend', "<style id=\"alloy-iframe-style\">\n          @keyframes fade {\n            0%, 40% { opacity: 0 }\n            80% { opacity: 1 }\n          }\n          @keyframes slideopen {\n            from {\n              margin-top: 100%;\n            }\n\n            to {\n              margin-top: 0%;\n            }\n          }\n          .alloy-container {\n            height: 100%;\n            width: 100%;\n            position: fixed;\n            top: 0;\n            transform: none;\n            left: 0;\n            z-index: 2;\n          }\n          @media (min-width: 768px) {\n            .alloy-container {\n              animation: slideopen 1s linear;\n              height: 720px;\n              position: absolute;\n              left: 50%;\n              top: 50%;\n              transform: translate(-50%, -50%);\n              width: 50rem;\n            }\n          }\n          .alloy-iframe {\n              animation: fade 1.5s linear;\n              border: 0;\n              opacity: 1;\n              height: 100%;\n              max-height: 100%;\n              width: 100%;\n          }\n          @media (min-width: 768px) {\n              .alloy-iframe {\n                border-radius: 1rem;\n                box-shadow: 0 10px 20px 0 rgba(63,83,92,0.3);\n                overflow: scroll;\n              }\n            }</style>");
                }
                var container = document.getElementById(alloyId);
                if (!container) {
                    container = document.createElement('div');
                    container.className = 'alloy-container';
                    var alloyIframe = document.createElement('iframe');
                    alloyIframe.id = 'alloyIframe';
                    alloyIframe.src = getPublicUrl();
                    alloyIframe.allow = 'autoplay; camera; microphone; fullscreen; accelerometer; magnetometer; gyroscope; picture-in-picture';
                    alloyIframe.className = 'alloy-iframe';
                    container.id = alloyId;
                    document.body.appendChild(container);
                    container.appendChild(alloyIframe);
                    if (anchorElement && document.getElementById('alloy')) {
                        var idAnchor = document.getElementById(anchorElement);
                        var classAnchor = document.getElementsByClassName(anchorElement);
                        if (idAnchor) {
                            idAnchor.insertAdjacentElement('afterbegin', document.getElementById('alloy'));
                        }
                        else if (classAnchor[0]) {
                            classAnchor[0].insertAdjacentElement('afterbegin', document.getElementById('alloy'));
                        }
                    }
                }
            }
        }
        catch (err) {
            if (sentryTelemetry) {
                sentryScope.captureException(err);
            }
        }
    };
    var alloy = {
        init: init,
        open: open,
        close: close,
        createJourneyApplication: createJourneyApplication,
        createEvaluation: createEvaluation,
        getPublicUrl: getPublicUrl,
    };

    return alloy;

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxsb3lfc2RrX2J1bmRsZS5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RlY29kZS11cmktY29tcG9uZW50L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NwbGl0LW9uLWZpcnN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2ZpbHRlci1vYmovaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vZGVidWctYnVpbGQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC93b3JsZHdpZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9kZWJ1Zy1idWlsZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jYXJyaWVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3Qvc3RhY2t0cmFjZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2luc3RydW1lbnQvaGFuZGxlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9pbnN0cnVtZW50L2dsb2JhbEVycm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9nbG9iYWxVbmhhbmRsZWRSZWplY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9pcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2Jyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9zdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9vYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9taXNjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvdGltZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3Nlc3Npb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9wcm9wYWdhdGlvbkNvbnRleHQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9tZXJnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3NwYW5PblNjb3BlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vc2NvcGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9kZWZhdWx0U2NvcGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vYXN5bmNDb250ZXh0L3N0YWNrU3RyYXRlZ3kuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9hc3luY0NvbnRleHQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jdXJyZW50U2NvcGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vc2VtYW50aWNBdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdHJhY2luZy9zcGFuc3RhdHVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdHJhY2luZy91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3BhcnNlU2FtcGxlUmF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2JhZ2dhZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9zcGFuVXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9kc24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9ub3JtYWxpemUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9lbnZlbG9wZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2VudmVsb3BlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3Qvc3luY3Byb21pc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9ldmVudFByb2Nlc3NvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9kZWJ1Zy1pZHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9hcHBseVNjb3BlRGF0YVRvRXZlbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9wcmVwYXJlRXZlbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9leHBvcnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vYXBpLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vaW50ZWdyYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9jbGllbnRyZXBvcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9ldmVudFV0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvdHJhbnNhY3Rpb25FdmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2NsaWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2xvZ3MvZW52ZWxvcGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9sb2dzL2V4cG9ydHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9wcm9taXNlYnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvcmF0ZWxpbWl0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdHJhbnNwb3J0cy9iYXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvaXBBZGRyZXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvc2RrTWV0YWRhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9icmVhZGNydW1icy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVncmF0aW9ucy9mdW5jdGlvbnRvc3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vaW50ZWdyYXRpb25zL2V2ZW50RmlsdGVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2FnZ3JlZ2F0ZS1lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9pbnN0cnVtZW50L2NvbnNvbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9zZXZlcml0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVncmF0aW9ucy9kZWR1cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC91cmwuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy1ob2lzdC9icmVhZGNydW1iLWxvZy1sZXZlbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L3N1cHBvcnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMtaG9pc3QvaW5zdHJ1bWVudC9mZXRjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzLWhvaXN0L2Vudi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9oZWxwZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9idWlsZC9ucG0vZXNtL2V2ZW50YnVpbGRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9jbGllbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9kZWJ1Zy1idWlsZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5LWludGVybmFsL2Jyb3dzZXItdXRpbHMvYnVpbGQvZXNtL3R5cGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnktaW50ZXJuYWwvYnJvd3Nlci11dGlscy9idWlsZC9lc20vaW5zdHJ1bWVudC9kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9pbnN0cnVtZW50L2hpc3RvcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9nZXROYXRpdmVJbXBsZW1lbnRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5LWludGVybmFsL2Jyb3dzZXItdXRpbHMvYnVpbGQvZXNtL2luc3RydW1lbnQveGhyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9idWlsZC9ucG0vZXNtL3RyYW5zcG9ydHMvZmV0Y2guanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2J1aWxkL25wbS9lc20vc3RhY2stcGFyc2Vycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9kZWJ1Zy1idWlsZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9pbnRlZ3JhdGlvbnMvYnJlYWRjcnVtYnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2J1aWxkL25wbS9lc20vaW50ZWdyYXRpb25zL2Jyb3dzZXJhcGllcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2J1aWxkL25wbS9lc20vaW50ZWdyYXRpb25zL2Jyb3dzZXJzZXNzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9idWlsZC9ucG0vZXNtL2ludGVncmF0aW9ucy9nbG9iYWxoYW5kbGVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9pbnRlZ3JhdGlvbnMvaHR0cGNvbnRleHQuanMiLCIuLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2J1aWxkL25wbS9lc20vaW50ZWdyYXRpb25zL2xpbmtlZGVycm9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9zZGsuanMiLCIuLi9zcmMvY29uZmlnLnRzIiwiLi4vc3JjL3NlcnZpY2VzL2VtYmVkSW92YXRpb24udHMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9yZWdleC5qcyIsIi4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3N0cmluZ2lmeS5qcyIsIi4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjEuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3BhcnNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MzUuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L21kNS1icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92My5qcyIsIi4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbmF0aXZlLWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y1LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9uaWwuanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2luZGV4LmpzIiwiLi4vc3JjL3NlcnZpY2VzL2hlbHBlcnMudHMiLCIuLi9zcmMvc2VydmljZXMvZW1iZWROZXVyb0lkLnRzIiwiLi4vc3JjL3NlcnZpY2VzL2VtYmVkU29jdXJlLnRzIiwiLi4vc3JjL3NlcnZpY2VzL2VtYmVkU29jdXJlRGlnaXRhbEludGVsbGlnZW5jZS50cyIsIi4uL3NyYy9zZXJ2aWNlcy9lbWJlZFRocmVhdG1ldHJpeC50cyIsIi4uL3NyYy91dGlscy9lcnJvcnMudHMiLCIuLi9zcmMvdXRpbHMvZmV0Y2gudHMiLCIuLi9zcmMvdXRpbHMvYXBpLnRzIiwiLi4vc3JjL3V0aWxzL2RhdGFTb3VyY2VzLnRzIiwiLi4vc3JjL3ZlcnNpb24uanMiLCIuLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBzdHIgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCB4ID0+IGAlJHt4LmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9YCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9rZW4gPSAnJVthLWYwLTldezJ9JztcbnZhciBzaW5nbGVNYXRjaGVyID0gbmV3IFJlZ0V4cCgnKCcgKyB0b2tlbiArICcpfChbXiVdKz8pJywgJ2dpJyk7XG52YXIgbXVsdGlNYXRjaGVyID0gbmV3IFJlZ0V4cCgnKCcgKyB0b2tlbiArICcpKycsICdnaScpO1xuXG5mdW5jdGlvbiBkZWNvZGVDb21wb25lbnRzKGNvbXBvbmVudHMsIHNwbGl0KSB7XG5cdHRyeSB7XG5cdFx0Ly8gVHJ5IHRvIGRlY29kZSB0aGUgZW50aXJlIHN0cmluZyBmaXJzdFxuXHRcdHJldHVybiBbZGVjb2RlVVJJQ29tcG9uZW50KGNvbXBvbmVudHMuam9pbignJykpXTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gRG8gbm90aGluZ1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHRzcGxpdCA9IHNwbGl0IHx8IDE7XG5cblx0Ly8gU3BsaXQgdGhlIGFycmF5IGluIDIgcGFydHNcblx0dmFyIGxlZnQgPSBjb21wb25lbnRzLnNsaWNlKDAsIHNwbGl0KTtcblx0dmFyIHJpZ2h0ID0gY29tcG9uZW50cy5zbGljZShzcGxpdCk7XG5cblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgZGVjb2RlQ29tcG9uZW50cyhsZWZ0KSwgZGVjb2RlQ29tcG9uZW50cyhyaWdodCkpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0dmFyIHRva2VucyA9IGlucHV0Lm1hdGNoKHNpbmdsZU1hdGNoZXIpIHx8IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlucHV0ID0gZGVjb2RlQ29tcG9uZW50cyh0b2tlbnMsIGkpLmpvaW4oJycpO1xuXG5cdFx0XHR0b2tlbnMgPSBpbnB1dC5tYXRjaChzaW5nbGVNYXRjaGVyKSB8fCBbXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3VzdG9tRGVjb2RlVVJJQ29tcG9uZW50KGlucHV0KSB7XG5cdC8vIEtlZXAgdHJhY2sgb2YgYWxsIHRoZSByZXBsYWNlbWVudHMgYW5kIHByZWZpbGwgdGhlIG1hcCB3aXRoIHRoZSBgQk9NYFxuXHR2YXIgcmVwbGFjZU1hcCA9IHtcblx0XHQnJUZFJUZGJzogJ1xcdUZGRkRcXHVGRkZEJyxcblx0XHQnJUZGJUZFJzogJ1xcdUZGRkRcXHVGRkZEJ1xuXHR9O1xuXG5cdHZhciBtYXRjaCA9IG11bHRpTWF0Y2hlci5leGVjKGlucHV0KTtcblx0d2hpbGUgKG1hdGNoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIERlY29kZSBhcyBiaWcgY2h1bmtzIGFzIHBvc3NpYmxlXG5cdFx0XHRyZXBsYWNlTWFwW21hdGNoWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFswXSk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gZGVjb2RlKG1hdGNoWzBdKTtcblxuXHRcdFx0aWYgKHJlc3VsdCAhPT0gbWF0Y2hbMF0pIHtcblx0XHRcdFx0cmVwbGFjZU1hcFttYXRjaFswXV0gPSByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWF0Y2ggPSBtdWx0aU1hdGNoZXIuZXhlYyhpbnB1dCk7XG5cdH1cblxuXHQvLyBBZGQgYCVDMmAgYXQgdGhlIGVuZCBvZiB0aGUgbWFwIHRvIG1ha2Ugc3VyZSBpdCBkb2VzIG5vdCByZXBsYWNlIHRoZSBjb21iaW5hdG9yIGJlZm9yZSBldmVyeXRoaW5nIGVsc2Vcblx0cmVwbGFjZU1hcFsnJUMyJ10gPSAnXFx1RkZGRCc7XG5cblx0dmFyIGVudHJpZXMgPSBPYmplY3Qua2V5cyhyZXBsYWNlTWFwKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHQvLyBSZXBsYWNlIGFsbCBkZWNvZGVkIGNvbXBvbmVudHNcblx0XHR2YXIga2V5ID0gZW50cmllc1tpXTtcblx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UobmV3IFJlZ0V4cChrZXksICdnJyksIHJlcGxhY2VNYXBba2V5XSk7XG5cdH1cblxuXHRyZXR1cm4gaW5wdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVuY29kZWRVUkkpIHtcblx0aWYgKHR5cGVvZiBlbmNvZGVkVVJJICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBlbmNvZGVkVVJJYCB0byBiZSBvZiB0eXBlIGBzdHJpbmdgLCBnb3QgYCcgKyB0eXBlb2YgZW5jb2RlZFVSSSArICdgJyk7XG5cdH1cblxuXHR0cnkge1xuXHRcdGVuY29kZWRVUkkgPSBlbmNvZGVkVVJJLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuXG5cdFx0Ly8gVHJ5IHRoZSBidWlsdCBpbiBkZWNvZGVyIGZpcnN0XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkVVJJKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gRmFsbGJhY2sgdG8gYSBtb3JlIGFkdmFuY2VkIGRlY29kZXJcblx0XHRyZXR1cm4gY3VzdG9tRGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWRVUkkpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChzdHJpbmcsIHNlcGFyYXRvcikgPT4ge1xuXHRpZiAoISh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VwYXJhdG9yID09PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgYXJndW1lbnRzIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2AnKTtcblx0fVxuXG5cdGlmIChzZXBhcmF0b3IgPT09ICcnKSB7XG5cdFx0cmV0dXJuIFtzdHJpbmddO1xuXHR9XG5cblx0Y29uc3Qgc2VwYXJhdG9ySW5kZXggPSBzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuXG5cdGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gW3N0cmluZ107XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdHN0cmluZy5zbGljZSgwLCBzZXBhcmF0b3JJbmRleCksXG5cdFx0c3RyaW5nLnNsaWNlKHNlcGFyYXRvckluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aClcblx0XTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHByZWRpY2F0ZSkge1xuXHR2YXIgcmV0ID0ge307XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0dmFyIGlzQXJyID0gQXJyYXkuaXNBcnJheShwcmVkaWNhdGUpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmIChpc0FyciA/IHByZWRpY2F0ZS5pbmRleE9mKGtleSkgIT09IC0xIDogcHJlZGljYXRlKGtleSwgdmFsLCBvYmopKSB7XG5cdFx0XHRyZXRba2V5XSA9IHZhbDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG5jb25zdCBkZWNvZGVDb21wb25lbnQgPSByZXF1aXJlKCdkZWNvZGUtdXJpLWNvbXBvbmVudCcpO1xuY29uc3Qgc3BsaXRPbkZpcnN0ID0gcmVxdWlyZSgnc3BsaXQtb24tZmlyc3QnKTtcbmNvbnN0IGZpbHRlck9iamVjdCA9IHJlcXVpcmUoJ2ZpbHRlci1vYmonKTtcblxuY29uc3QgaXNOdWxsT3JVbmRlZmluZWQgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBlbmNvZGVyRm9yQXJyYXlGb3JtYXQob3B0aW9ucykge1xuXHRzd2l0Y2ggKG9wdGlvbnMuYXJyYXlGb3JtYXQpIHtcblx0XHRjYXNlICdpbmRleCc6XG5cdFx0XHRyZXR1cm4ga2V5ID0+IChyZXN1bHQsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnWycsIGluZGV4LCAnXSddLmpvaW4oJycpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0Li4ucmVzdWx0LFxuXHRcdFx0XHRcdFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJ1snLCBlbmNvZGUoaW5kZXgsIG9wdGlvbnMpLCAnXT0nLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKVxuXHRcdFx0XHRdO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2JyYWNrZXQnOlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnW10nXS5qb2luKCcnKV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnW109JywgZW5jb2RlKHZhbHVlLCBvcHRpb25zKV0uam9pbignJyldO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2NvbW1hJzpcblx0XHRjYXNlICdzZXBhcmF0b3InOlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gW1tlbmNvZGUoa2V5LCBvcHRpb25zKSwgJz0nLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW1tyZXN1bHQsIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyldLmpvaW4ob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcildO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4ga2V5ID0+IChyZXN1bHQsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgdmFsdWUgPT09IG51bGwpIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcEVtcHR5U3RyaW5nICYmIHZhbHVlID09PSAnJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBbLi4ucmVzdWx0LCBlbmNvZGUoa2V5LCBvcHRpb25zKV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnPScsIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyldLmpvaW4oJycpXTtcblx0XHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0aW9ucykge1xuXHRsZXQgcmVzdWx0O1xuXG5cdHN3aXRjaCAob3B0aW9ucy5hcnJheUZvcm1hdCkge1xuXHRcdGNhc2UgJ2luZGV4Jzpcblx0XHRcdHJldHVybiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpID0+IHtcblx0XHRcdFx0cmVzdWx0ID0gL1xcWyhcXGQqKVxcXSQvLmV4ZWMoa2V5KTtcblxuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXFxkKlxcXSQvLCAnJyk7XG5cblx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV1bcmVzdWx0WzFdXSA9IHZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2JyYWNrZXQnOlxuXHRcdFx0cmV0dXJuIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikgPT4ge1xuXHRcdFx0XHRyZXN1bHQgPSAvKFxcW1xcXSkkLy5leGVjKGtleSk7XG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXF0kLywgJycpO1xuXG5cdFx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW3ZhbHVlXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW10uY29uY2F0KGFjY3VtdWxhdG9yW2tleV0sIHZhbHVlKTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdjb21tYSc6XG5cdFx0Y2FzZSAnc2VwYXJhdG9yJzpcblx0XHRcdHJldHVybiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpID0+IHtcblx0XHRcdFx0Y29uc3QgaXNBcnJheSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG5cdFx0XHRcdGNvbnN0IGlzRW5jb2RlZEFycmF5ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzQXJyYXkgJiYgZGVjb2RlKHZhbHVlLCBvcHRpb25zKS5pbmNsdWRlcyhvcHRpb25zLmFycmF5Rm9ybWF0U2VwYXJhdG9yKSk7XG5cdFx0XHRcdHZhbHVlID0gaXNFbmNvZGVkQXJyYXkgPyBkZWNvZGUodmFsdWUsIG9wdGlvbnMpIDogdmFsdWU7XG5cdFx0XHRcdGNvbnN0IG5ld1ZhbHVlID0gaXNBcnJheSB8fCBpc0VuY29kZWRBcnJheSA/IHZhbHVlLnNwbGl0KG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpLm1hcChpdGVtID0+IGRlY29kZShpdGVtLCBvcHRpb25zKSkgOiB2YWx1ZSA9PT0gbnVsbCA/IHZhbHVlIDogZGVjb2RlKHZhbHVlLCBvcHRpb25zKTtcblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IG5ld1ZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdGlmIChhY2N1bXVsYXRvcltrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlGb3JtYXRTZXBhcmF0b3IodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUubGVuZ3RoICE9PSAxKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYXJyYXlGb3JtYXRTZXBhcmF0b3IgbXVzdCBiZSBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZycpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucy5lbmNvZGUpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5zdHJpY3QgPyBzdHJpY3RVcmlFbmNvZGUodmFsdWUpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKHZhbHVlLCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zLmRlY29kZSkge1xuXHRcdHJldHVybiBkZWNvZGVDb21wb25lbnQodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBrZXlzU29ydGVyKGlucHV0KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdHJldHVybiBpbnB1dC5zb3J0KCk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBrZXlzU29ydGVyKE9iamVjdC5rZXlzKGlucHV0KSlcblx0XHRcdC5zb3J0KChhLCBiKSA9PiBOdW1iZXIoYSkgLSBOdW1iZXIoYikpXG5cdFx0XHQubWFwKGtleSA9PiBpbnB1dFtrZXldKTtcblx0fVxuXG5cdHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFzaChpbnB1dCkge1xuXHRjb25zdCBoYXNoU3RhcnQgPSBpbnB1dC5pbmRleE9mKCcjJyk7XG5cdGlmIChoYXNoU3RhcnQgIT09IC0xKSB7XG5cdFx0aW5wdXQgPSBpbnB1dC5zbGljZSgwLCBoYXNoU3RhcnQpO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNoKHVybCkge1xuXHRsZXQgaGFzaCA9ICcnO1xuXHRjb25zdCBoYXNoU3RhcnQgPSB1cmwuaW5kZXhPZignIycpO1xuXHRpZiAoaGFzaFN0YXJ0ICE9PSAtMSkge1xuXHRcdGhhc2ggPSB1cmwuc2xpY2UoaGFzaFN0YXJ0KTtcblx0fVxuXG5cdHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0KGlucHV0KSB7XG5cdGlucHV0ID0gcmVtb3ZlSGFzaChpbnB1dCk7XG5cdGNvbnN0IHF1ZXJ5U3RhcnQgPSBpbnB1dC5pbmRleE9mKCc/Jyk7XG5cdGlmIChxdWVyeVN0YXJ0ID09PSAtMSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHJldHVybiBpbnB1dC5zbGljZShxdWVyeVN0YXJ0ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMucGFyc2VOdW1iZXJzICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudHJpbSgpICE9PSAnJykpIHtcblx0XHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5wYXJzZUJvb2xlYW5zICYmIHZhbHVlICE9PSBudWxsICYmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgfHwgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZhbHNlJykpIHtcblx0XHR2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocXVlcnksIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGRlY29kZTogdHJ1ZSxcblx0XHRzb3J0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZScsXG5cdFx0YXJyYXlGb3JtYXRTZXBhcmF0b3I6ICcsJyxcblx0XHRwYXJzZU51bWJlcnM6IGZhbHNlLFxuXHRcdHBhcnNlQm9vbGVhbnM6IGZhbHNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdHZhbGlkYXRlQXJyYXlGb3JtYXRTZXBhcmF0b3Iob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcik7XG5cblx0Y29uc3QgZm9ybWF0dGVyID0gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0aW9ucyk7XG5cblx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZVxuXHRjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2YgcXVlcnkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL15bPyMmXS8sICcnKTtcblxuXHRpZiAoIXF1ZXJ5KSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZvciAoY29uc3QgcGFyYW0gb2YgcXVlcnkuc3BsaXQoJyYnKSkge1xuXHRcdGlmIChwYXJhbSA9PT0gJycpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGxldCBba2V5LCB2YWx1ZV0gPSBzcGxpdE9uRmlyc3Qob3B0aW9ucy5kZWNvZGUgPyBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKSA6IHBhcmFtLCAnPScpO1xuXG5cdFx0Ly8gTWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFsnY29tbWEnLCAnc2VwYXJhdG9yJ10uaW5jbHVkZXMob3B0aW9ucy5hcnJheUZvcm1hdCkgPyB2YWx1ZSA6IGRlY29kZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0Zm9ybWF0dGVyKGRlY29kZShrZXksIG9wdGlvbnMpLCB2YWx1ZSwgcmV0KTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJldCkpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHJldFtrZXldO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlW2tdID0gcGFyc2VWYWx1ZSh2YWx1ZVtrXSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldFtrZXldID0gcGFyc2VWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc29ydCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0cmV0dXJuIChvcHRpb25zLnNvcnQgPT09IHRydWUgPyBPYmplY3Qua2V5cyhyZXQpLnNvcnQoKSA6IE9iamVjdC5rZXlzKHJldCkuc29ydChvcHRpb25zLnNvcnQpKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0Y29uc3QgdmFsdWUgPSByZXRba2V5XTtcblx0XHRpZiAoQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdC8vIFNvcnQgb2JqZWN0IGtleXMsIG5vdCB2YWx1ZXNcblx0XHRcdHJlc3VsdFtrZXldID0ga2V5c1NvcnRlcih2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gKG9iamVjdCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoIW9iamVjdCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlLFxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZScsXG5cdFx0YXJyYXlGb3JtYXRTZXBhcmF0b3I6ICcsJ1xuXHR9LCBvcHRpb25zKTtcblxuXHR2YWxpZGF0ZUFycmF5Rm9ybWF0U2VwYXJhdG9yKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuXG5cdGNvbnN0IHNob3VsZEZpbHRlciA9IGtleSA9PiAoXG5cdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0W2tleV0pKSB8fFxuXHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiBvYmplY3Rba2V5XSA9PT0gJycpXG5cdCk7XG5cblx0Y29uc3QgZm9ybWF0dGVyID0gZW5jb2RlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpO1xuXG5cdGNvbnN0IG9iamVjdENvcHkgPSB7fTtcblxuXHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG5cdFx0aWYgKCFzaG91bGRGaWx0ZXIoa2V5KSkge1xuXHRcdFx0b2JqZWN0Q29weVtrZXldID0gb2JqZWN0W2tleV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdENvcHkpO1xuXG5cdGlmIChvcHRpb25zLnNvcnQgIT09IGZhbHNlKSB7XG5cdFx0a2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG5cdH1cblxuXHRyZXR1cm4ga2V5cy5tYXAoa2V5ID0+IHtcblx0XHRjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0XHQucmVkdWNlKGZvcm1hdHRlcihrZXkpLCBbXSlcblx0XHRcdFx0LmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0aW9ucykgKyAnPScgKyBlbmNvZGUodmFsdWUsIG9wdGlvbnMpO1xuXHR9KS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApLmpvaW4oJyYnKTtcbn07XG5cbmV4cG9ydHMucGFyc2VVcmwgPSAodXJsLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRkZWNvZGU6IHRydWVcblx0fSwgb3B0aW9ucyk7XG5cblx0Y29uc3QgW3VybF8sIGhhc2hdID0gc3BsaXRPbkZpcnN0KHVybCwgJyMnKTtcblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbihcblx0XHR7XG5cdFx0XHR1cmw6IHVybF8uc3BsaXQoJz8nKVswXSB8fCAnJyxcblx0XHRcdHF1ZXJ5OiBwYXJzZShleHRyYWN0KHVybCksIG9wdGlvbnMpXG5cdFx0fSxcblx0XHRvcHRpb25zICYmIG9wdGlvbnMucGFyc2VGcmFnbWVudElkZW50aWZpZXIgJiYgaGFzaCA/IHtmcmFnbWVudElkZW50aWZpZXI6IGRlY29kZShoYXNoLCBvcHRpb25zKX0gOiB7fVxuXHQpO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnlVcmwgPSAob2JqZWN0LCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IHVybCA9IHJlbW92ZUhhc2gob2JqZWN0LnVybCkuc3BsaXQoJz8nKVswXSB8fCAnJztcblx0Y29uc3QgcXVlcnlGcm9tVXJsID0gZXhwb3J0cy5leHRyYWN0KG9iamVjdC51cmwpO1xuXHRjb25zdCBwYXJzZWRRdWVyeUZyb21VcmwgPSBleHBvcnRzLnBhcnNlKHF1ZXJ5RnJvbVVybCwge3NvcnQ6IGZhbHNlfSk7XG5cblx0Y29uc3QgcXVlcnkgPSBPYmplY3QuYXNzaWduKHBhcnNlZFF1ZXJ5RnJvbVVybCwgb2JqZWN0LnF1ZXJ5KTtcblx0bGV0IHF1ZXJ5U3RyaW5nID0gZXhwb3J0cy5zdHJpbmdpZnkocXVlcnksIG9wdGlvbnMpO1xuXHRpZiAocXVlcnlTdHJpbmcpIHtcblx0XHRxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gO1xuXHR9XG5cblx0bGV0IGhhc2ggPSBnZXRIYXNoKG9iamVjdC51cmwpO1xuXHRpZiAob2JqZWN0LmZyYWdtZW50SWRlbnRpZmllcikge1xuXHRcdGhhc2ggPSBgIyR7ZW5jb2RlKG9iamVjdC5mcmFnbWVudElkZW50aWZpZXIsIG9wdGlvbnMpfWA7XG5cdH1cblxuXHRyZXR1cm4gYCR7dXJsfSR7cXVlcnlTdHJpbmd9JHtoYXNofWA7XG59O1xuXG5leHBvcnRzLnBpY2sgPSAoaW5wdXQsIGZpbHRlciwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0cGFyc2VGcmFnbWVudElkZW50aWZpZXI6IHRydWVcblx0fSwgb3B0aW9ucyk7XG5cblx0Y29uc3Qge3VybCwgcXVlcnksIGZyYWdtZW50SWRlbnRpZmllcn0gPSBleHBvcnRzLnBhcnNlVXJsKGlucHV0LCBvcHRpb25zKTtcblx0cmV0dXJuIGV4cG9ydHMuc3RyaW5naWZ5VXJsKHtcblx0XHR1cmwsXG5cdFx0cXVlcnk6IGZpbHRlck9iamVjdChxdWVyeSwgZmlsdGVyKSxcblx0XHRmcmFnbWVudElkZW50aWZpZXJcblx0fSwgb3B0aW9ucyk7XG59O1xuXG5leHBvcnRzLmV4Y2x1ZGUgPSAoaW5wdXQsIGZpbHRlciwgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBleGNsdXNpb25GaWx0ZXIgPSBBcnJheS5pc0FycmF5KGZpbHRlcikgPyBrZXkgPT4gIWZpbHRlci5pbmNsdWRlcyhrZXkpIDogKGtleSwgdmFsdWUpID0+ICFmaWx0ZXIoa2V5LCB2YWx1ZSk7XG5cblx0cmV0dXJuIGV4cG9ydHMucGljayhpbnB1dCwgZXhjbHVzaW9uRmlsdGVyLCBvcHRpb25zKTtcbn07XG4iLCIvKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5leHBvcnQgeyBERUJVR19CVUlMRCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctYnVpbGQuanMubWFwXG4iLCIvKiogSW50ZXJuYWwgZ2xvYmFsIHdpdGggY29tbW9uIHByb3BlcnRpZXMgYW5kIFNlbnRyeSBleHRlbnNpb25zICAqL1xuXG4vKiogR2V0J3MgdGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgcnVudGltZSAqL1xuY29uc3QgR0xPQkFMX09CSiA9IGdsb2JhbFRoaXMgO1xuXG5leHBvcnQgeyBHTE9CQUxfT0JKIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JsZHdpZGUuanMubWFwXG4iLCIvKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5leHBvcnQgeyBERUJVR19CVUlMRCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctYnVpbGQuanMubWFwXG4iLCIvLyBUaGlzIGlzIGEgbWFnaWMgc3RyaW5nIHJlcGxhY2VkIGJ5IHJvbGx1cFxuXG5jb25zdCBTREtfVkVSU0lPTiA9IFwiOS4xNC4wXCIgO1xuXG5leHBvcnQgeyBTREtfVkVSU0lPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXBcbiIsImltcG9ydCB7IFNES19WRVJTSU9OIH0gZnJvbSAnLi91dGlscy1ob2lzdC92ZXJzaW9uLmpzJztcbmltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3V0aWxzLWhvaXN0L3dvcmxkd2lkZS5qcyc7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBwcm9wZXJ0aWVzIGFuZCBtYWludGFpbnMgYSBzY29wZSBzdGFjay5cbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBzaGltIHJlZ2lzdHJ5LlxuICpcbiAqIEZJWE1FOiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JsZW1hdGljLCBiZWNhdXNlIGRlc3BpdGUgYWx3YXlzIHJldHVybmluZyBhIHZhbGlkIENhcnJpZXIsXG4gKiBpdCBoYXMgYW4gb3B0aW9uYWwgYF9fU0VOVFJZX19gIHByb3BlcnR5LCB3aGljaCB0aGVuIGluIHR1cm4gcmVxdWlyZXMgdXMgdG8gYWx3YXlzIHBlcmZvcm0gYW4gdW5uZWNlc3NhcnkgY2hlY2tcbiAqIGF0IHRoZSBjYWxsLXNpdGUuIFdlIGFsd2F5cyBhY2Nlc3MgdGhlIGNhcnJpZXIgdGhyb3VnaCB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgYF9fU0VOVFJZX19gIGlzIHRoZXJlLlxuICoqL1xuZnVuY3Rpb24gZ2V0TWFpbkNhcnJpZXIoKSB7XG4gIC8vIFRoaXMgZW5zdXJlcyBhIFNlbnRyeSBjYXJyaWVyIGV4aXN0c1xuICBnZXRTZW50cnlDYXJyaWVyKEdMT0JBTF9PQkopO1xuICByZXR1cm4gR0xPQkFMX09CSjtcbn1cblxuLyoqIFdpbGwgZWl0aGVyIGdldCB0aGUgZXhpc3Rpbmcgc2VudHJ5IGNhcnJpZXIsIG9yIGNyZWF0ZSBhIG5ldyBvbmUuICovXG5mdW5jdGlvbiBnZXRTZW50cnlDYXJyaWVyKGNhcnJpZXIpIHtcbiAgY29uc3QgX19TRU5UUllfXyA9IChjYXJyaWVyLl9fU0VOVFJZX18gPSBjYXJyaWVyLl9fU0VOVFJZX18gfHwge30pO1xuXG4gIC8vIEZvciBub3c6IEZpcnN0IFNESyB0aGF0IHNldHMgdGhlIC52ZXJzaW9uIHByb3BlcnR5IHdpbnNcbiAgX19TRU5UUllfXy52ZXJzaW9uID0gX19TRU5UUllfXy52ZXJzaW9uIHx8IFNES19WRVJTSU9OO1xuXG4gIC8vIEludGVudGlvbmFsbHkgcG9wdWxhdGluZyBhbmQgcmV0dXJuaW5nIHRoZSB2ZXJzaW9uIG9mIFwidGhpc1wiIFNESyBpbnN0YW5jZVxuICAvLyByYXRoZXIgdGhhbiB3aGF0J3Mgc2V0IGluIC52ZXJzaW9uIHNvIHRoYXQgXCJ0aGlzXCIgU0RLIGFsd2F5cyBnZXRzIGl0cyBjYXJyaWVyXG4gIHJldHVybiAoX19TRU5UUllfX1tTREtfVkVSU0lPTl0gPSBfX1NFTlRSWV9fW1NES19WRVJTSU9OXSB8fCB7fSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGdsb2JhbCBzaW5nbGV0b24gY29udGFpbmVkIGluIHRoZSBnbG9iYWwgYF9fU0VOVFJZX19bXWAgb2JqZWN0LlxuICpcbiAqIElmIHRoZSBzaW5nbGV0b24gZG9lc24ndCBhbHJlYWR5IGV4aXN0IGluIGBfX1NFTlRSWV9fYCwgaXQgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZSBnaXZlbiBmYWN0b3J5XG4gKiBmdW5jdGlvbiBhbmQgYWRkZWQgdG8gdGhlIGBfX1NFTlRSWV9fYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgZ2xvYmFsIHNpbmdsZXRvbiBvbiBfX1NFTlRSWV9fXG4gKiBAcGFyYW0gY3JlYXRvciBjcmVhdG9yIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBzaW5nbGV0b24gaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9uIGBfX1NFTlRSWV9fYFxuICogQHBhcmFtIG9iaiAoT3B0aW9uYWwpIFRoZSBnbG9iYWwgb2JqZWN0IG9uIHdoaWNoIHRvIGxvb2sgZm9yIGBfX1NFTlRSWV9fYCwgaWYgbm90IGBHTE9CQUxfT0JKYCdzIHJldHVybiB2YWx1ZVxuICogQHJldHVybnMgdGhlIHNpbmdsZXRvblxuICovXG5mdW5jdGlvbiBnZXRHbG9iYWxTaW5nbGV0b24oXG4gIG5hbWUsXG4gIGNyZWF0b3IsXG4gIG9iaiA9IEdMT0JBTF9PQkosXG4pIHtcbiAgY29uc3QgX19TRU5UUllfXyA9IChvYmouX19TRU5UUllfXyA9IG9iai5fX1NFTlRSWV9fIHx8IHt9KTtcbiAgY29uc3QgY2FycmllciA9IChfX1NFTlRSWV9fW1NES19WRVJTSU9OXSA9IF9fU0VOVFJZX19bU0RLX1ZFUlNJT05dIHx8IHt9KTtcbiAgLy8gTm90ZTogV2UgZG8gbm90IHdhbnQgdG8gc2V0IGBjYXJyaWVyLnZlcnNpb25gIGhlcmUsIGFzIHRoaXMgbWF5IGJlIGNhbGxlZCBiZWZvcmUgYW55IGBpbml0YCBpcyBjYWxsZWQsIGUuZy4gZm9yIHRoZSBkZWZhdWx0IHNjb3Blc1xuICByZXR1cm4gY2FycmllcltuYW1lXSB8fCAoY2FycmllcltuYW1lXSA9IGNyZWF0b3IoKSk7XG59XG5cbmV4cG9ydCB7IGdldEdsb2JhbFNpbmdsZXRvbiwgZ2V0TWFpbkNhcnJpZXIsIGdldFNlbnRyeUNhcnJpZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcnJpZXIuanMubWFwXG4iLCJpbXBvcnQgeyBnZXRHbG9iYWxTaW5nbGV0b24gfSBmcm9tICcuLi9jYXJyaWVyLmpzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG4vKiogUHJlZml4IGZvciBsb2dnaW5nIHN0cmluZ3MgKi9cbmNvbnN0IFBSRUZJWCA9ICdTZW50cnkgTG9nZ2VyICc7XG5cbmNvbnN0IENPTlNPTEVfTEVWRUxTID0gW1xuICAnZGVidWcnLFxuICAnaW5mbycsXG4gICd3YXJuJyxcbiAgJ2Vycm9yJyxcbiAgJ2xvZycsXG4gICdhc3NlcnQnLFxuICAndHJhY2UnLFxuXSA7XG5cbi8qKiBUaGlzIG1heSBiZSBtdXRhdGVkIGJ5IHRoZSBjb25zb2xlIGluc3RydW1lbnRhdGlvbi4gKi9cbmNvbnN0IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNcblxuID0ge307XG5cbi8qKiBBIFNlbnRyeSBMb2dnZXIgaW5zdGFuY2UuICovXG5cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZSBzZW50cnkgY29uc29sZSBpbnN0cnVtZW50YXRpb25zLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gcnVuIGFnYWluc3QgdGhlIG9yaWdpbmFsIGBjb25zb2xlYCBtZXNzYWdlc1xuICogQHJldHVybnMgVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGNvbnNvbGVTYW5kYm94KGNhbGxiYWNrKSB7XG4gIGlmICghKCdjb25zb2xlJyBpbiBHTE9CQUxfT0JKKSkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgY29uc29sZSA9IEdMT0JBTF9PQkouY29uc29sZSA7XG4gIGNvbnN0IHdyYXBwZWRGdW5jcyA9IHt9O1xuXG4gIGNvbnN0IHdyYXBwZWRMZXZlbHMgPSBPYmplY3Qua2V5cyhvcmlnaW5hbENvbnNvbGVNZXRob2RzKSA7XG5cbiAgLy8gUmVzdG9yZSBhbGwgd3JhcHBlZCBjb25zb2xlIG1ldGhvZHNcbiAgd3JhcHBlZExldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVNZXRob2QgPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW2xldmVsXSA7XG4gICAgd3JhcHBlZEZ1bmNzW2xldmVsXSA9IGNvbnNvbGVbbGV2ZWxdIDtcbiAgICBjb25zb2xlW2xldmVsXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZDtcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBSZXZlcnQgcmVzdG9yYXRpb24gdG8gd3JhcHBlZCBzdGF0ZVxuICAgIHdyYXBwZWRMZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zb2xlW2xldmVsXSA9IHdyYXBwZWRGdW5jc1tsZXZlbF0gO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2dnZXIoKSB7XG4gIGxldCBlbmFibGVkID0gZmFsc2U7XG4gIGNvbnN0IGxvZ2dlciA9IHtcbiAgICBlbmFibGU6ICgpID0+IHtcbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgZGlzYWJsZTogKCkgPT4ge1xuICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgaXNFbmFibGVkOiAoKSA9PiBlbmFibGVkLFxuICB9O1xuXG4gIGlmIChERUJVR19CVUlMRCkge1xuICAgIENPTlNPTEVfTEVWRUxTLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBsb2dnZXJbbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgIGNvbnNvbGVTYW5kYm94KCgpID0+IHtcbiAgICAgICAgICAgIEdMT0JBTF9PQkouY29uc29sZVtuYW1lXShgJHtQUkVGSVh9WyR7bmFtZX1dOmAsIC4uLmFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIENPTlNPTEVfTEVWRUxTLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBsb2dnZXJbbmFtZV0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9nZ2VyIDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgbG9nZ2VyIHNpbmdsZXRvbiB3aGljaCBlaXRoZXIgbG9ncyB0aGluZ3Mgb3Igbm8tb3BzIGlmIGxvZ2dpbmcgaXMgbm90IGVuYWJsZWQuXG4gKiBUaGUgbG9nZ2VyIGlzIGEgc2luZ2xldG9uIG9uIHRoZSBjYXJyaWVyLCB0byBlbnN1cmUgdGhhdCBhIGNvbnNpc3RlbnQgbG9nZ2VyIGlzIHVzZWQgdGhyb3VnaG91dCB0aGUgU0RLLlxuICovXG5jb25zdCBsb2dnZXIgPSBnZXRHbG9iYWxTaW5nbGV0b24oJ2xvZ2dlcicsIG1ha2VMb2dnZXIpO1xuXG5leHBvcnQgeyBDT05TT0xFX0xFVkVMUywgY29uc29sZVNhbmRib3gsIGxvZ2dlciwgb3JpZ2luYWxDb25zb2xlTWV0aG9kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcFxuIiwiY29uc3QgU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCA9IDUwO1xuY29uc3QgVU5LTk9XTl9GVU5DVElPTiA9ICc/Jztcbi8vIFVzZWQgdG8gc2FuaXRpemUgd2VicGFjayAoZXJyb3I6ICopIHdyYXBwZWQgc3RhY2sgZXJyb3JzXG5jb25zdCBXRUJQQUNLX0VSUk9SX1JFR0VYUCA9IC9cXChlcnJvcjogKC4qKVxcKS87XG5jb25zdCBTVFJJUF9GUkFNRV9SRUdFWFAgPSAvY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIHBhcnNlciB3aXRoIHRoZSBzdXBwbGllZCBsaW5lIHBhcnNlcnNcbiAqXG4gKiBTdGFja0ZyYW1lcyBhcmUgcmV0dXJuZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgZm9yIFNlbnRyeSBFeGNlcHRpb25cbiAqIGZyYW1lcyBhbmQgd2l0aCBTZW50cnkgU0RLIGludGVybmFsIGZyYW1lcyByZW1vdmVkIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGFja1BhcnNlciguLi5wYXJzZXJzKSB7XG4gIGNvbnN0IHNvcnRlZFBhcnNlcnMgPSBwYXJzZXJzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKS5tYXAocCA9PiBwWzFdKTtcblxuICByZXR1cm4gKHN0YWNrLCBza2lwRmlyc3RMaW5lcyA9IDAsIGZyYW1lc1RvUG9wID0gMCkgPT4ge1xuICAgIGNvbnN0IGZyYW1lcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgZm9yIChsZXQgaSA9IHNraXBGaXJzdExpbmVzOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXSA7XG4gICAgICAvLyBJZ25vcmUgbGluZXMgb3ZlciAxa2IgYXMgdGhleSBhcmUgdW5saWtlbHkgdG8gYmUgc3RhY2sgZnJhbWVzLlxuICAgICAgLy8gTWFueSBvZiB0aGUgcmVndWxhciBleHByZXNzaW9ucyB1c2UgYmFja3RyYWNraW5nIHdoaWNoIHJlc3VsdHMgaW4gcnVuIHRpbWUgdGhhdCBpbmNyZWFzZXMgZXhwb25lbnRpYWxseSB3aXRoXG4gICAgICAvLyBpbnB1dCBzaXplLiBIdWdlIHN0cmluZ3MgY2FuIHJlc3VsdCBpbiBoYW5ncy9EZW5pYWwgb2YgU2VydmljZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzIyODZcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzU0NTlcbiAgICAgIC8vIFJlbW92ZSB3ZWJwYWNrIChlcnJvcjogKikgd3JhcHBlcnNcbiAgICAgIGNvbnN0IGNsZWFuZWRMaW5lID0gV0VCUEFDS19FUlJPUl9SRUdFWFAudGVzdChsaW5lKSA/IGxpbmUucmVwbGFjZShXRUJQQUNLX0VSUk9SX1JFR0VYUCwgJyQxJykgOiBsaW5lO1xuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy83ODEzXG4gICAgICAvLyBTa2lwIEVycm9yOiBsaW5lc1xuICAgICAgaWYgKGNsZWFuZWRMaW5lLm1hdGNoKC9cXFMqRXJyb3I6IC8pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHBhcnNlciBvZiBzb3J0ZWRQYXJzZXJzKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gcGFyc2VyKGNsZWFuZWRMaW5lKTtcblxuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyYW1lcy5sZW5ndGggPj0gU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCArIGZyYW1lc1RvUG9wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2UoZnJhbWVzLnNsaWNlKGZyYW1lc1RvUG9wKSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyBhIHN0YWNrIHBhcnNlciBpbXBsZW1lbnRhdGlvbiBmcm9tIE9wdGlvbnMuc3RhY2tQYXJzZXJcbiAqIEBzZWUgT3B0aW9uc1xuICpcbiAqIElmIG9wdGlvbnMgY29udGFpbnMgYW4gYXJyYXkgb2YgbGluZSBwYXJzZXJzLCBpdCBpcyBjb252ZXJ0ZWQgaW50byBhIHBhcnNlclxuICovXG5mdW5jdGlvbiBzdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnMoc3RhY2tQYXJzZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhY2tQYXJzZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0YWNrUGFyc2VyKC4uLnN0YWNrUGFyc2VyKTtcbiAgfVxuICByZXR1cm4gc3RhY2tQYXJzZXI7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBTZW50cnkgZnJhbWVzIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRoZSBzdGFjayBpZiBwcmVzZW50IGFuZCBlbmZvcmNlcyBhIGxpbWl0IG9mIG1heCBudW1iZXIgb2YgZnJhbWVzLlxuICogQXNzdW1lcyBzdGFjayBpbnB1dCBpcyBvcmRlcmVkIGZyb20gdG9wIHRvIGJvdHRvbSBhbmQgcmV0dXJucyB0aGUgcmV2ZXJzZSByZXByZXNlbnRhdGlvbiBzbyBjYWxsIHNpdGUgb2YgdGhlXG4gKiBmdW5jdGlvbiB0aGF0IGNhdXNlZCB0aGUgY3Jhc2ggaXMgdGhlIGxhc3QgZnJhbWUgaW4gdGhlIGFycmF5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2Uoc3RhY2spIHtcbiAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsb2NhbFN0YWNrID0gQXJyYXkuZnJvbShzdGFjayk7XG5cbiAgLy8gSWYgc3RhY2sgc3RhcnRzIHdpdGggb25lIG9mIG91ciBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoc3RhcnRzLCBtZWFuaW5nIGl0J3MgdGhlIHRvcCBvZiB0aGUgc3RhY2sgLSBha2EgbGFzdCBjYWxsKVxuICBpZiAoL3NlbnRyeVdyYXBwZWQvLnRlc3QoZ2V0TGFzdFN0YWNrRnJhbWUobG9jYWxTdGFjaykuZnVuY3Rpb24gfHwgJycpKSB7XG4gICAgbG9jYWxTdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIFJldmVyc2luZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwcm9jZWR1cmUgYWxsb3dzIHVzIHRvIGp1c3QgcG9wIHRoZSB2YWx1ZXMgb2ZmIHRoZSBzdGFja1xuICBsb2NhbFN0YWNrLnJldmVyc2UoKTtcblxuICAvLyBJZiBzdGFjayBlbmRzIHdpdGggb25lIG9mIG91ciBpbnRlcm5hbCBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoZW5kcywgbWVhbmluZyBpdCdzIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIC0gYWthIHRvcC1tb3N0IGNhbGwpXG4gIGlmIChTVFJJUF9GUkFNRV9SRUdFWFAudGVzdChnZXRMYXN0U3RhY2tGcmFtZShsb2NhbFN0YWNrKS5mdW5jdGlvbiB8fCAnJykpIHtcbiAgICBsb2NhbFN0YWNrLnBvcCgpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBzeW50aGV0aWMgZXZlbnRzLCB3ZSB3aWxsIGhhdmUgYSAyIGxldmVscyBkZWVwIHN0YWNrLCBhcyBgbmV3IEVycm9yKCdTZW50cnkgc3ludGhldGljRXhjZXB0aW9uJylgXG4gICAgLy8gaXMgcHJvZHVjZWQgd2l0aGluIHRoZSBzY29wZSBpdHNlbGYsIG1ha2luZyBpdDpcbiAgICAvL1xuICAgIC8vICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oKVxuICAgIC8vICAgc2NvcGUuY2FwdHVyZUV4Y2VwdGlvbigpXG4gICAgLy9cbiAgICAvLyBpbnN0ZWFkIG9mIGp1c3QgdGhlIHRvcCBgU2VudHJ5YCBjYWxsIGl0c2VsZi5cbiAgICAvLyBUaGlzIGZvcmNlcyB1cyB0byBwb3NzaWJseSBzdHJpcCBhbiBhZGRpdGlvbmFsIGZyYW1lIGluIHRoZSBleGFjdCBzYW1lIHdhcyBhcyBhYm92ZS5cbiAgICBpZiAoU1RSSVBfRlJBTUVfUkVHRVhQLnRlc3QoZ2V0TGFzdFN0YWNrRnJhbWUobG9jYWxTdGFjaykuZnVuY3Rpb24gfHwgJycpKSB7XG4gICAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhbFN0YWNrLnNsaWNlKDAsIFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQpLm1hcChmcmFtZSA9PiAoe1xuICAgIC4uLmZyYW1lLFxuICAgIGZpbGVuYW1lOiBmcmFtZS5maWxlbmFtZSB8fCBnZXRMYXN0U3RhY2tGcmFtZShsb2NhbFN0YWNrKS5maWxlbmFtZSxcbiAgICBmdW5jdGlvbjogZnJhbWUuZnVuY3Rpb24gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0U3RhY2tGcmFtZShhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV0gfHwge307XG59XG5cbmNvbnN0IGRlZmF1bHRGdW5jdGlvbk5hbWUgPSAnPGFub255bW91cz4nO1xuXG4vKipcbiAqIFNhZmVseSBleHRyYWN0IGZ1bmN0aW9uIG5hbWUgZnJvbSBpdHNlbGZcbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0RnVuY3Rpb25OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gZm4ubmFtZSB8fCBkZWZhdWx0RnVuY3Rpb25OYW1lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSnVzdCBhY2Nlc3NpbmcgY3VzdG9tIHByb3BzIGluIHNvbWUgU2VsZW5pdW0gZW52aXJvbm1lbnRzXG4gICAgLy8gY2FuIGNhdXNlIGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGV4Y2VwdGlvbiAoc2VlIHJhdmVuLWpzIzQ5NSkuXG4gICAgcmV0dXJuIGRlZmF1bHRGdW5jdGlvbk5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQncyBzdGFjayBmcmFtZXMgZnJvbSBhbiBldmVudCB3aXRob3V0IG5lZWRpbmcgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRGcmFtZXNGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZXhjZXB0aW9uID0gZXZlbnQuZXhjZXB0aW9uO1xuXG4gIGlmIChleGNlcHRpb24pIHtcbiAgICBjb25zdCBmcmFtZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBPYmplY3QgY291bGQgYmUgdW5kZWZpbmVkXG4gICAgICBleGNlcHRpb24udmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFZhbHVlIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICBpZiAodmFsdWUuc3RhY2t0cmFjZS5mcmFtZXMpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFZhbHVlIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgIGZyYW1lcy5wdXNoKC4uLnZhbHVlLnN0YWNrdHJhY2UuZnJhbWVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnJhbWVzO1xuICAgIH0gY2F0Y2ggKF9vTykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgVU5LTk9XTl9GVU5DVElPTiwgY3JlYXRlU3RhY2tQYXJzZXIsIGdldEZyYW1lc0Zyb21FdmVudCwgZ2V0RnVuY3Rpb25OYW1lLCBzdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnMsIHN0cmlwU2VudHJ5RnJhbWVzQW5kUmV2ZXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2t0cmFjZS5qcy5tYXBcbiIsImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZ1bmN0aW9uTmFtZSB9IGZyb20gJy4uL3N0YWNrdHJhY2UuanMnO1xuXG4vLyBXZSBrZWVwIHRoZSBoYW5kbGVycyBnbG9iYWxseVxuY29uc3QgaGFuZGxlcnMgPSB7fTtcbmNvbnN0IGluc3RydW1lbnRlZCA9IHt9O1xuXG4vKiogQWRkIGEgaGFuZGxlciBmdW5jdGlvbi4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZXIodHlwZSwgaGFuZGxlcikge1xuICBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAoaGFuZGxlcnNbdHlwZV0gKS5wdXNoKGhhbmRsZXIpO1xufVxuXG4vKipcbiAqIFJlc2V0IGFsbCBpbnN0cnVtZW50YXRpb24gaGFuZGxlcnMuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIGJ5IHRlc3RzIHRvIGVuc3VyZSB3ZSBoYXZlIGEgY2xlYW4gc2xhdGUgb2YgaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXJzLlxuICovXG5mdW5jdGlvbiByZXNldEluc3RydW1lbnRhdGlvbkhhbmRsZXJzKCkge1xuICBPYmplY3Qua2V5cyhoYW5kbGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGhhbmRsZXJzW2tleSBdID0gdW5kZWZpbmVkO1xuICB9KTtcbn1cblxuLyoqIE1heWJlIHJ1biBhbiBpbnN0cnVtZW50YXRpb24gZnVuY3Rpb24sIHVubGVzcyBpdCB3YXMgYWxyZWFkeSBjYWxsZWQuICovXG5mdW5jdGlvbiBtYXliZUluc3RydW1lbnQodHlwZSwgaW5zdHJ1bWVudEZuKSB7XG4gIGlmICghaW5zdHJ1bWVudGVkW3R5cGVdKSB7XG4gICAgaW5zdHJ1bWVudGVkW3R5cGVdID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaW5zdHJ1bWVudEZuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKGBFcnJvciB3aGlsZSBpbnN0cnVtZW50aW5nICR7dHlwZX1gLCBlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIFRyaWdnZXIgaGFuZGxlcnMgZm9yIGEgZ2l2ZW4gaW5zdHJ1bWVudGF0aW9uIHR5cGUuICovXG5mdW5jdGlvbiB0cmlnZ2VySGFuZGxlcnModHlwZSwgZGF0YSkge1xuICBjb25zdCB0eXBlSGFuZGxlcnMgPSB0eXBlICYmIGhhbmRsZXJzW3R5cGVdO1xuICBpZiAoIXR5cGVIYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3QgaGFuZGxlciBvZiB0eXBlSGFuZGxlcnMpIHtcbiAgICB0cnkge1xuICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgYEVycm9yIHdoaWxlIHRyaWdnZXJpbmcgaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXIuXFxuVHlwZTogJHt0eXBlfVxcbk5hbWU6ICR7Z2V0RnVuY3Rpb25OYW1lKGhhbmRsZXIpfVxcbkVycm9yOmAsXG4gICAgICAgICAgZSxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgYWRkSGFuZGxlciwgbWF5YmVJbnN0cnVtZW50LCByZXNldEluc3RydW1lbnRhdGlvbkhhbmRsZXJzLCB0cmlnZ2VySGFuZGxlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbmRsZXJzLmpzLm1hcFxuIiwiaW1wb3J0IHsgR0xPQkFMX09CSiB9IGZyb20gJy4uL3dvcmxkd2lkZS5qcyc7XG5pbXBvcnQgeyBhZGRIYW5kbGVyLCBtYXliZUluc3RydW1lbnQsIHRyaWdnZXJIYW5kbGVycyB9IGZyb20gJy4vaGFuZGxlcnMuanMnO1xuXG5sZXQgX29sZE9uRXJyb3JIYW5kbGVyID0gbnVsbDtcblxuLyoqXG4gKiBBZGQgYW4gaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXIgZm9yIHdoZW4gYW4gZXJyb3IgaXMgY2FwdHVyZWQgYnkgdGhlIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICpcbiAqIFVzZSBhdCB5b3VyIG93biByaXNrLCB0aGlzIG1pZ2h0IGJyZWFrIHdpdGhvdXQgY2hhbmdlbG9nIG5vdGljZSwgb25seSB1c2VkIGludGVybmFsbHkuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFkZEdsb2JhbEVycm9ySW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gIGNvbnN0IHR5cGUgPSAnZXJyb3InO1xuICBhZGRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICBtYXliZUluc3RydW1lbnQodHlwZSwgaW5zdHJ1bWVudEVycm9yKTtcbn1cblxuZnVuY3Rpb24gaW5zdHJ1bWVudEVycm9yKCkge1xuICBfb2xkT25FcnJvckhhbmRsZXIgPSBHTE9CQUxfT0JKLm9uZXJyb3I7XG5cbiAgLy8gTm90ZTogVGhlIHJlYXNvbiB3ZSBhcmUgZG9pbmcgd2luZG93Lm9uZXJyb3IgaW5zdGVhZCBvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InKVxuICAvLyBpcyB0aGF0IHdlIGFyZSB1c2luZyB0aGlzIGhhbmRsZXIgaW4gdGhlIExvYWRlciBTY3JpcHQsIHRvIGhhbmRsZSBidWZmZXJlZCBlcnJvcnMgY29uc2lzdGVudGx5XG4gIEdMT0JBTF9PQkoub25lcnJvciA9IGZ1bmN0aW9uIChcbiAgICBtc2csXG4gICAgdXJsLFxuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICAgIGVycm9yLFxuICApIHtcbiAgICBjb25zdCBoYW5kbGVyRGF0YSA9IHtcbiAgICAgIGNvbHVtbixcbiAgICAgIGVycm9yLFxuICAgICAgbGluZSxcbiAgICAgIG1zZyxcbiAgICAgIHVybCxcbiAgICB9O1xuICAgIHRyaWdnZXJIYW5kbGVycygnZXJyb3InLCBoYW5kbGVyRGF0YSk7XG5cbiAgICBpZiAoX29sZE9uRXJyb3JIYW5kbGVyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICByZXR1cm4gX29sZE9uRXJyb3JIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIEdMT0JBTF9PQkoub25lcnJvci5fX1NFTlRSWV9JTlNUUlVNRU5URURfXyA9IHRydWU7XG59XG5cbmV4cG9ydCB7IGFkZEdsb2JhbEVycm9ySW5zdHJ1bWVudGF0aW9uSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFsRXJyb3IuanMubWFwXG4iLCJpbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi4vd29ybGR3aWRlLmpzJztcbmltcG9ydCB7IGFkZEhhbmRsZXIsIG1heWJlSW5zdHJ1bWVudCwgdHJpZ2dlckhhbmRsZXJzIH0gZnJvbSAnLi9oYW5kbGVycy5qcyc7XG5cbmxldCBfb2xkT25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyID0gbnVsbDtcblxuLyoqXG4gKiBBZGQgYW4gaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXIgZm9yIHdoZW4gYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIGlzIGNhcHR1cmVkLlxuICpcbiAqIFVzZSBhdCB5b3VyIG93biByaXNrLCB0aGlzIG1pZ2h0IGJyZWFrIHdpdGhvdXQgY2hhbmdlbG9nIG5vdGljZSwgb25seSB1c2VkIGludGVybmFsbHkuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFkZEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkluc3RydW1lbnRhdGlvbkhhbmRsZXIoXG4gIGhhbmRsZXIsXG4pIHtcbiAgY29uc3QgdHlwZSA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xuICBhZGRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICBtYXliZUluc3RydW1lbnQodHlwZSwgaW5zdHJ1bWVudFVuaGFuZGxlZFJlamVjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluc3RydW1lbnRVbmhhbmRsZWRSZWplY3Rpb24oKSB7XG4gIF9vbGRPblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXIgPSBHTE9CQUxfT0JKLm9udW5oYW5kbGVkcmVqZWN0aW9uO1xuXG4gIC8vIE5vdGU6IFRoZSByZWFzb24gd2UgYXJlIGRvaW5nIHdpbmRvdy5vbnVuaGFuZGxlZHJlamVjdGlvbiBpbnN0ZWFkIG9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nKVxuICAvLyBpcyB0aGF0IHdlIGFyZSB1c2luZyB0aGlzIGhhbmRsZXIgaW4gdGhlIExvYWRlciBTY3JpcHQsIHRvIGhhbmRsZSBidWZmZXJlZCByZWplY3Rpb25zIGNvbnNpc3RlbnRseVxuICBHTE9CQUxfT0JKLm9udW5oYW5kbGVkcmVqZWN0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zdCBoYW5kbGVyRGF0YSA9IGU7XG4gICAgdHJpZ2dlckhhbmRsZXJzKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVyRGF0YSk7XG5cbiAgICBpZiAoX29sZE9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgcmV0dXJuIF9vbGRPblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHTE9CQUxfT0JKLm9udW5oYW5kbGVkcmVqZWN0aW9uLl9fU0VOVFJZX0lOU1RSVU1FTlRFRF9fID0gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgYWRkR2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uSW5zdHJ1bWVudGF0aW9uSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uLmpzLm1hcFxuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBvbmUgb2YgYSBmZXcgRXJyb3Igb3IgRXJyb3ItbGlrZVxuICoge0BsaW5rIGlzRXJyb3J9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHdhdCkge1xuICBzd2l0Y2ggKG9iamVjdFRvU3RyaW5nLmNhbGwod2F0KSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEV4Y2VwdGlvbl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRE9NRXhjZXB0aW9uXSc6XG4gICAgY2FzZSAnW29iamVjdCBXZWJBc3NlbWJseS5FeGNlcHRpb25dJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gaXNJbnN0YW5jZU9mKHdhdCwgRXJyb3IpO1xuICB9XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBidWlsdC1pbiBjbGFzcy5cbiAqXG4gKiBAcGFyYW0gd2F0IFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkXG4gKiBAcGFyYW0gY2xhc3NOYW1lXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzQnVpbHRpbih3YXQsIGNsYXNzTmFtZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh3YXQpID09PSBgW29iamVjdCAke2NsYXNzTmFtZX1dYDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgRXJyb3JFdmVudFxuICoge0BsaW5rIGlzRXJyb3JFdmVudH0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JFdmVudCh3YXQpIHtcbiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdFcnJvckV2ZW50Jyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIERPTUVycm9yXG4gKiB7QGxpbmsgaXNET01FcnJvcn0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRE9NRXJyb3Iod2F0KSB7XG4gIHJldHVybiBpc0J1aWx0aW4od2F0LCAnRE9NRXJyb3InKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgRE9NRXhjZXB0aW9uXG4gKiB7QGxpbmsgaXNET01FeGNlcHRpb259LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0RPTUV4Y2VwdGlvbih3YXQpIHtcbiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdET01FeGNlcHRpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYSBzdHJpbmdcbiAqIHtAbGluayBpc1N0cmluZ30uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHdhdCkge1xuICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ1N0cmluZycpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHN0cmluZyBpcyBwYXJhbWV0ZXJpemVkXG4gKiB7QGxpbmsgaXNQYXJhbWV0ZXJpemVkU3RyaW5nfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNQYXJhbWV0ZXJpemVkU3RyaW5nKHdhdCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3YXQgPT09ICdvYmplY3QnICYmXG4gICAgd2F0ICE9PSBudWxsICYmXG4gICAgJ19fc2VudHJ5X3RlbXBsYXRlX3N0cmluZ19fJyBpbiB3YXQgJiZcbiAgICAnX19zZW50cnlfdGVtcGxhdGVfdmFsdWVzX18nIGluIHdhdFxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIGEgcHJpbWl0aXZlICh1bmRlZmluZWQsIG51bGwsIG51bWJlciwgYm9vbGVhbiwgc3RyaW5nLCBiaWdpbnQsIHN5bWJvbClcbiAqIHtAbGluayBpc1ByaW1pdGl2ZX0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHdhdCkge1xuICByZXR1cm4gd2F0ID09PSBudWxsIHx8IGlzUGFyYW1ldGVyaXplZFN0cmluZyh3YXQpIHx8ICh0eXBlb2Ygd2F0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygd2F0ICE9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gb2JqZWN0IGxpdGVyYWwsIG9yIGEgY2xhc3MgaW5zdGFuY2UuXG4gKiB7QGxpbmsgaXNQbGFpbk9iamVjdH0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qod2F0KSB7XG4gIHJldHVybiBpc0J1aWx0aW4od2F0LCAnT2JqZWN0Jyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIEV2ZW50IGluc3RhbmNlXG4gKiB7QGxpbmsgaXNFdmVudH0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnQod2F0KSB7XG4gIHJldHVybiB0eXBlb2YgRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIGlzSW5zdGFuY2VPZih3YXQsIEV2ZW50KTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gRWxlbWVudCBpbnN0YW5jZVxuICoge0BsaW5rIGlzRWxlbWVudH0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudCh3YXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2Yod2F0LCBFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gcmVnZXhwXG4gKiB7QGxpbmsgaXNSZWdFeHB9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc1JlZ0V4cCh3YXQpIHtcbiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdSZWdFeHAnKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBoYXMgYSB0aGVuIGZ1bmN0aW9uLlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzVGhlbmFibGUod2F0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgcmV0dXJuIEJvb2xlYW4od2F0Py50aGVuICYmIHR5cGVvZiB3YXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGEgU3ludGhldGljRXZlbnRcbiAqIHtAbGluayBpc1N5bnRoZXRpY0V2ZW50fS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudCh3YXQpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3Qod2F0KSAmJiAnbmF0aXZlRXZlbnQnIGluIHdhdCAmJiAncHJldmVudERlZmF1bHQnIGluIHdhdCAmJiAnc3RvcFByb3BhZ2F0aW9uJyBpbiB3YXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIGluc3RhbmNlIG9mIHByb3ZpZGVkIGNvbnN0cnVjdG9yLlxuICoge0BsaW5rIGlzSW5zdGFuY2VPZn0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gYmFzZSBBIGNvbnN0cnVjdG9yIHRvIGJlIHVzZWQgaW4gYSBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNJbnN0YW5jZU9mKHdhdCwgYmFzZSkge1xuICB0cnkge1xuICAgIHJldHVybiB3YXQgaW5zdGFuY2VvZiBiYXNlO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhIFZ1ZSBWaWV3TW9kZWwuXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzVnVlVmlld01vZGVsKHdhdCkge1xuICAvLyBOb3QgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBiZWNhdXNlIGluIFZ1ZSAzIGl0IHdvdWxkIHJlYWQgdGhlIGluc3RhbmNlJ3MgU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZykgcHJvcGVydHkuXG4gIHJldHVybiAhISh0eXBlb2Ygd2F0ID09PSAnb2JqZWN0JyAmJiB3YXQgIT09IG51bGwgJiYgKCh3YXQgKS5fX2lzVnVlIHx8ICh3YXQgKS5faXNWdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgU3RhbmRhcmQgV2ViIEFQSSBSZXF1ZXN0IGluc3RhbmNlLlxuICpcbiAqIFJldHVybnMgZmFsc2UgaWYgUmVxdWVzdCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIGlzUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiB0eXBlb2YgUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHJlcXVlc3QsIFJlcXVlc3QpO1xufVxuXG5leHBvcnQgeyBpc0RPTUVycm9yLCBpc0RPTUV4Y2VwdGlvbiwgaXNFbGVtZW50LCBpc0Vycm9yLCBpc0Vycm9yRXZlbnQsIGlzRXZlbnQsIGlzSW5zdGFuY2VPZiwgaXNQYXJhbWV0ZXJpemVkU3RyaW5nLCBpc1BsYWluT2JqZWN0LCBpc1ByaW1pdGl2ZSwgaXNSZWdFeHAsIGlzUmVxdWVzdCwgaXNTdHJpbmcsIGlzU3ludGhldGljRXZlbnQsIGlzVGhlbmFibGUsIGlzVnVlVmlld01vZGVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy5qcy5tYXBcbiIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi9pcy5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG5jb25zdCBXSU5ET1cgPSBHTE9CQUxfT0JKIDtcblxuY29uc3QgREVGQVVMVF9NQVhfU1RSSU5HX0xFTkdUSCA9IDgwO1xuXG4vKipcbiAqIEdpdmVuIGEgY2hpbGQgRE9NIGVsZW1lbnQsIHJldHVybnMgYSBxdWVyeS1zZWxlY3RvciBzdGF0ZW1lbnQgZGVzY3JpYmluZyB0aGF0XG4gKiBhbmQgaXRzIGFuY2VzdG9yc1xuICogZS5nLiBbSFRNTEVsZW1lbnRdID0+IGJvZHkgPiBkaXYgPiBpbnB1dCNmb28uYnRuW25hbWU9YmF6XVxuICogQHJldHVybnMgZ2VuZXJhdGVkIERPTSBwYXRoXG4gKi9cbmZ1bmN0aW9uIGh0bWxUcmVlQXNTdHJpbmcoXG4gIGVsZW0sXG4gIG9wdGlvbnMgPSB7fSxcbikge1xuICBpZiAoIWVsZW0pIHtcbiAgICByZXR1cm4gJzx1bmtub3duPic7XG4gIH1cblxuICAvLyB0cnkvY2F0Y2ggYm90aDpcbiAgLy8gLSBhY2Nlc3NpbmcgZXZlbnQudGFyZ2V0IChzZWUgZ2V0c2VudHJ5L3JhdmVuLWpzIzgzOCwgIzc2OClcbiAgLy8gLSBgaHRtbFRyZWVBc1N0cmluZ2AgYmVjYXVzZSBpdCdzIGNvbXBsZXgsIGFuZCBqdXN0IGFjY2Vzc2luZyB0aGUgRE9NIGluY29ycmVjdGx5XG4gIC8vIC0gY2FuIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBzb21lIGNpcmN1bXN0YW5jZXMuXG4gIHRyeSB7XG4gICAgbGV0IGN1cnJlbnRFbGVtID0gZWxlbSA7XG4gICAgY29uc3QgTUFYX1RSQVZFUlNFX0hFSUdIVCA9IDU7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IGhlaWdodCA9IDA7XG4gICAgbGV0IGxlbiA9IDA7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gJyA+ICc7XG4gICAgY29uc3Qgc2VwTGVuZ3RoID0gc2VwYXJhdG9yLmxlbmd0aDtcbiAgICBsZXQgbmV4dFN0cjtcbiAgICBjb25zdCBrZXlBdHRycyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucykgPyBvcHRpb25zIDogb3B0aW9ucy5rZXlBdHRycztcbiAgICBjb25zdCBtYXhTdHJpbmdMZW5ndGggPSAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucy5tYXhTdHJpbmdMZW5ndGgpIHx8IERFRkFVTFRfTUFYX1NUUklOR19MRU5HVEg7XG5cbiAgICB3aGlsZSAoY3VycmVudEVsZW0gJiYgaGVpZ2h0KysgPCBNQVhfVFJBVkVSU0VfSEVJR0hUKSB7XG4gICAgICBuZXh0U3RyID0gX2h0bWxFbGVtZW50QXNTdHJpbmcoY3VycmVudEVsZW0sIGtleUF0dHJzKTtcbiAgICAgIC8vIGJhaWwgb3V0IGlmXG4gICAgICAvLyAtIG5leHRTdHIgaXMgdGhlICdodG1sJyBlbGVtZW50XG4gICAgICAvLyAtIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgZXhjZWVkcyBtYXhTdHJpbmdMZW5ndGhcbiAgICAgIC8vICAgKGlnbm9yZSB0aGlzIGxpbWl0IGlmIHdlIGFyZSBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgaWYgKG5leHRTdHIgPT09ICdodG1sJyB8fCAoaGVpZ2h0ID4gMSAmJiBsZW4gKyBvdXQubGVuZ3RoICogc2VwTGVuZ3RoICsgbmV4dFN0ci5sZW5ndGggPj0gbWF4U3RyaW5nTGVuZ3RoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgb3V0LnB1c2gobmV4dFN0cik7XG5cbiAgICAgIGxlbiArPSBuZXh0U3RyLmxlbmd0aDtcbiAgICAgIGN1cnJlbnRFbGVtID0gY3VycmVudEVsZW0ucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnJldmVyc2UoKS5qb2luKHNlcGFyYXRvcik7XG4gIH0gY2F0Y2ggKF9vTykge1xuICAgIHJldHVybiAnPHVua25vd24+JztcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaW1wbGUsIHF1ZXJ5LXNlbGVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIGEgRE9NIGVsZW1lbnRcbiAqIGUuZy4gW0hUTUxFbGVtZW50XSA9PiBpbnB1dCNmb28uYnRuW25hbWU9YmF6XVxuICogQHJldHVybnMgZ2VuZXJhdGVkIERPTSBwYXRoXG4gKi9cbmZ1bmN0aW9uIF9odG1sRWxlbWVudEFzU3RyaW5nKGVsLCBrZXlBdHRycykge1xuICBjb25zdCBlbGVtID0gZWxcblxuO1xuXG4gIGNvbnN0IG91dCA9IFtdO1xuXG4gIGlmICghZWxlbT8udGFnTmFtZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgV0lORE9XIGhhcyBIVE1MRWxlbWVudFxuICBpZiAoV0lORE9XLkhUTUxFbGVtZW50KSB7XG4gICAgLy8gSWYgdXNpbmcgdGhlIGNvbXBvbmVudCBuYW1lIGFubm90YXRpb24gcGx1Z2luLCB0aGlzIHZhbHVlIG1heSBiZSBhdmFpbGFibGUgb24gdGhlIERPTSBub2RlXG4gICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbGVtLmRhdGFzZXQpIHtcbiAgICAgIGlmIChlbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW0uZGF0YXNldFsnc2VudHJ5RWxlbWVudCddKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmRhdGFzZXRbJ3NlbnRyeUVsZW1lbnQnXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvdXQucHVzaChlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgLy8gUGFpcnMgb2YgYXR0cmlidXRlIGtleXMgZGVmaW5lZCBpbiBgc2VyaWFsaXplQXR0cmlidXRlYCBhbmQgdGhlaXIgdmFsdWVzIG9uIGVsZW1lbnQuXG4gIGNvbnN0IGtleUF0dHJQYWlycyA9IGtleUF0dHJzPy5sZW5ndGhcbiAgICA/IGtleUF0dHJzLmZpbHRlcihrZXlBdHRyID0+IGVsZW0uZ2V0QXR0cmlidXRlKGtleUF0dHIpKS5tYXAoa2V5QXR0ciA9PiBba2V5QXR0ciwgZWxlbS5nZXRBdHRyaWJ1dGUoa2V5QXR0cildKVxuICAgIDogbnVsbDtcblxuICBpZiAoa2V5QXR0clBhaXJzPy5sZW5ndGgpIHtcbiAgICBrZXlBdHRyUGFpcnMuZm9yRWFjaChrZXlBdHRyUGFpciA9PiB7XG4gICAgICBvdXQucHVzaChgWyR7a2V5QXR0clBhaXJbMF19PVwiJHtrZXlBdHRyUGFpclsxXX1cIl1gKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWxlbS5pZCkge1xuICAgICAgb3V0LnB1c2goYCMke2VsZW0uaWR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWU7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiBpc1N0cmluZyhjbGFzc05hbWUpKSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IgKGNvbnN0IGMgb2YgY2xhc3Nlcykge1xuICAgICAgICBvdXQucHVzaChgLiR7Y31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYWxsb3dlZEF0dHJzID0gWydhcmlhLWxhYmVsJywgJ3R5cGUnLCAnbmFtZScsICd0aXRsZScsICdhbHQnXTtcbiAgZm9yIChjb25zdCBrIG9mIGFsbG93ZWRBdHRycykge1xuICAgIGNvbnN0IGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShrKTtcbiAgICBpZiAoYXR0cikge1xuICAgICAgb3V0LnB1c2goYFske2t9PVwiJHthdHRyfVwiXWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQuam9pbignJyk7XG59XG5cbi8qKlxuICogQSBzYWZlIGZvcm0gb2YgbG9jYXRpb24uaHJlZlxuICovXG5mdW5jdGlvbiBnZXRMb2NhdGlvbkhyZWYoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFdJTkRPVy5kb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICB9IGNhdGNoIChvTykge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIGVsZW1lbnQsIHRyYXZlcnNlcyB1cCB0aGUgdHJlZSB1bnRpbCBpdCBmaW5kcyB0aGUgZmlyc3QgYW5jZXN0b3Igbm9kZVxuICogdGhhdCBoYXMgdGhlIGBkYXRhLXNlbnRyeS1jb21wb25lbnRgIG9yIGBkYXRhLXNlbnRyeS1lbGVtZW50YCBhdHRyaWJ1dGUgd2l0aCBgZGF0YS1zZW50cnktY29tcG9uZW50YCB0YWtpbmdcbiAqIHByZWNlZGVuY2UuIFRoaXMgYXR0cmlidXRlIGlzIGFkZGVkIGF0IGJ1aWxkLXRpbWUgYnkgcHJvamVjdHMgdGhhdCBoYXZlIHRoZSBjb21wb25lbnQgbmFtZSBhbm5vdGF0aW9uIHBsdWdpbiBpbnN0YWxsZWQuXG4gKlxuICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudCBmb3IgdGhlIHByb3ZpZGVkIERPTSBlbGVtZW50LCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoZWxlbSkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIFdJTkRPVyBoYXMgSFRNTEVsZW1lbnRcbiAgaWYgKCFXSU5ET1cuSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBjdXJyZW50RWxlbSA9IGVsZW0gO1xuICBjb25zdCBNQVhfVFJBVkVSU0VfSEVJR0hUID0gNTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfVFJBVkVSU0VfSEVJR0hUOyBpKyspIHtcbiAgICBpZiAoIWN1cnJlbnRFbGVtKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudEVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgaWYgKGN1cnJlbnRFbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbS5kYXRhc2V0WydzZW50cnlDb21wb25lbnQnXTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RWxlbS5kYXRhc2V0WydzZW50cnlFbGVtZW50J10pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtLmRhdGFzZXRbJ3NlbnRyeUVsZW1lbnQnXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50RWxlbSA9IGN1cnJlbnRFbGVtLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50TmFtZSwgZ2V0TG9jYXRpb25IcmVmLCBodG1sVHJlZUFzU3RyaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLmpzLm1hcFxuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIGlzUmVnRXhwLCBpc1Z1ZVZpZXdNb2RlbCB9IGZyb20gJy4vaXMuanMnO1xuXG4vKipcbiAqIFRydW5jYXRlcyBnaXZlbiBzdHJpbmcgdG8gdGhlIG1heGltdW0gY2hhcmFjdGVycyBjb3VudFxuICpcbiAqIEBwYXJhbSBzdHIgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgc2VyaWFsaXphYmxlIHZhbHVlc1xuICogQHBhcmFtIG1heCBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRydW5jYXRlZCBzdHJpbmcgKDAgPSB1bmxpbWl0ZWQpXG4gKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZFxuICovXG5mdW5jdGlvbiB0cnVuY2F0ZShzdHIsIG1heCA9IDApIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IG1heCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gbWF4ID8gc3RyIDogYCR7c3RyLnNsaWNlKDAsIG1heCl9Li4uYDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IGB0cmltX2xpbmVgIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5L2Jsb2IvbWFzdGVyL3NyYy9zZW50cnkvbGFuZy9qYXZhc2NyaXB0L3Byb2Nlc3Nvci5weSNMNjdcbiAqXG4gKiBAcGFyYW0gc3RyIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNlcmlhbGl6YWJsZSB2YWx1ZXNcbiAqIEBwYXJhbSBtYXggTWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0cnVuY2F0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZFxuICovXG5mdW5jdGlvbiBzbmlwTGluZShsaW5lLCBjb2xubykge1xuICBsZXQgbmV3TGluZSA9IGxpbmU7XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBuZXdMaW5lLmxlbmd0aDtcbiAgaWYgKGxpbmVMZW5ndGggPD0gMTUwKSB7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH1cbiAgaWYgKGNvbG5vID4gbGluZUxlbmd0aCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNvbG5vID0gbGluZUxlbmd0aDtcbiAgfVxuXG4gIGxldCBzdGFydCA9IE1hdGgubWF4KGNvbG5vIC0gNjAsIDApO1xuICBpZiAoc3RhcnQgPCA1KSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgbGV0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgMTQwLCBsaW5lTGVuZ3RoKTtcbiAgaWYgKGVuZCA+IGxpbmVMZW5ndGggLSA1KSB7XG4gICAgZW5kID0gbGluZUxlbmd0aDtcbiAgfVxuICBpZiAoZW5kID09PSBsaW5lTGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBNYXRoLm1heChlbmQgLSAxNDAsIDApO1xuICB9XG5cbiAgbmV3TGluZSA9IG5ld0xpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChzdGFydCA+IDApIHtcbiAgICBuZXdMaW5lID0gYCd7c25pcH0gJHtuZXdMaW5lfWA7XG4gIH1cbiAgaWYgKGVuZCA8IGxpbmVMZW5ndGgpIHtcbiAgICBuZXdMaW5lICs9ICcge3NuaXB9JztcbiAgfVxuXG4gIHJldHVybiBuZXdMaW5lO1xufVxuXG4vKipcbiAqIEpvaW4gdmFsdWVzIGluIGFycmF5XG4gKiBAcGFyYW0gaW5wdXQgYXJyYXkgb2YgdmFsdWVzIHRvIGJlIGpvaW5lZCB0b2dldGhlclxuICogQHBhcmFtIGRlbGltaXRlciBzdHJpbmcgdG8gYmUgcGxhY2VkIGluLWJldHdlZW4gdmFsdWVzXG4gKiBAcmV0dXJucyBKb2luZWQgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHNhZmVKb2luKGlucHV0LCBkZWxpbWl0ZXIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXRbaV07XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIGZpeCBhIFZ1ZTMtc3BlY2lmaWMgYnVnIHRoYXQgY2F1c2VzIGFuIGluZmluaXRlIGxvb3Agb2ZcbiAgICAgIC8vIGNvbnNvbGUgd2FybmluZ3MuIFRoaXMgaGFwcGVucyB3aGVuIGEgVnVlIHRlbXBsYXRlIGlzIHJlbmRlcmVkIHdpdGhcbiAgICAgIC8vIGFuIHVuZGVjbGFyZWQgdmFyaWFibGUsIHdoaWNoIHdlIHRyeSB0byBzdHJpbmdpZnksIHVsdGltYXRlbHkgY2F1c2luZ1xuICAgICAgLy8gVnVlIHRvIGlzc3VlIGFub3RoZXIgd2FybmluZyB3aGljaCByZXBlYXRzIGluZGVmaW5pdGVseS5cbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9wdWxsLzg5ODFcbiAgICAgIGlmIChpc1Z1ZVZpZXdNb2RlbCh2YWx1ZSkpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJ1tWdWVWaWV3TW9kZWxdJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvdXRwdXQucHVzaCgnW3ZhbHVlIGNhbm5vdCBiZSBzZXJpYWxpemVkXScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbihkZWxpbWl0ZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgbWF0Y2hlcyBhIHJlZ2V4IG9yIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIHRlc3RcbiAqIEBwYXJhbSBwYXR0ZXJuIEVpdGhlciBhIHJlZ2V4IG9yIGEgc3RyaW5nIGFnYWluc3Qgd2hpY2ggYHZhbHVlYCB3aWxsIGJlIG1hdGNoZWRcbiAqIEBwYXJhbSByZXF1aXJlRXhhY3RTdHJpbmdNYXRjaCBJZiB0cnVlLCBgdmFsdWVgIG11c3QgbWF0Y2ggYHBhdHRlcm5gIGV4YWN0bHkuIElmIGZhbHNlLCBgdmFsdWVgIHdpbGwgbWF0Y2hcbiAqIGBwYXR0ZXJuYCBpZiBpdCBjb250YWlucyBgcGF0dGVybmAuIE9ubHkgYXBwbGllcyB0byBzdHJpbmctdHlwZSBwYXR0ZXJucy5cbiAqL1xuZnVuY3Rpb24gaXNNYXRjaGluZ1BhdHRlcm4oXG4gIHZhbHVlLFxuICBwYXR0ZXJuLFxuICByZXF1aXJlRXhhY3RTdHJpbmdNYXRjaCA9IGZhbHNlLFxuKSB7XG4gIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdCh2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVFeGFjdFN0cmluZ01hdGNoID8gdmFsdWUgPT09IHBhdHRlcm4gOiB2YWx1ZS5pbmNsdWRlcyhwYXR0ZXJuKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUZXN0IHRoZSBnaXZlbiBzdHJpbmcgYWdhaW5zdCBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCByZWdleGVzLiBCeSBkZWZhdWx0LCBzdHJpbmcgbWF0Y2hpbmcgaXMgZG9uZSBvbiBhXG4gKiBzdWJzdHJpbmctaW5jbHVzaW9uIGJhc2lzIHJhdGhlciB0aGFuIGEgc3RyaWN0IGVxdWFsaXR5IGJhc2lzXG4gKlxuICogQHBhcmFtIHRlc3RTdHJpbmcgVGhlIHN0cmluZyB0byB0ZXN0XG4gKiBAcGFyYW0gcGF0dGVybnMgVGhlIHBhdHRlcm5zIGFnYWluc3Qgd2hpY2ggdG8gdGVzdCB0aGUgc3RyaW5nXG4gKiBAcGFyYW0gcmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2ggSWYgdHJ1ZSwgYHRlc3RTdHJpbmdgIG11c3QgbWF0Y2ggb25lIG9mIHRoZSBnaXZlbiBzdHJpbmcgcGF0dGVybnMgZXhhY3RseSBpbiBvcmRlciB0b1xuICogY291bnQuIElmIGZhbHNlLCBgdGVzdFN0cmluZ2Agd2lsbCBtYXRjaCBhIHN0cmluZyBwYXR0ZXJuIGlmIGl0IGNvbnRhaW5zIHRoYXQgcGF0dGVybi5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ01hdGNoZXNTb21lUGF0dGVybihcbiAgdGVzdFN0cmluZyxcbiAgcGF0dGVybnMgPSBbXSxcbiAgcmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2ggPSBmYWxzZSxcbikge1xuICByZXR1cm4gcGF0dGVybnMuc29tZShwYXR0ZXJuID0+IGlzTWF0Y2hpbmdQYXR0ZXJuKHRlc3RTdHJpbmcsIHBhdHRlcm4sIHJlcXVpcmVFeGFjdFN0cmluZ01hdGNoKSk7XG59XG5cbmV4cG9ydCB7IGlzTWF0Y2hpbmdQYXR0ZXJuLCBzYWZlSm9pbiwgc25pcExpbmUsIHN0cmluZ01hdGNoZXNTb21lUGF0dGVybiwgdHJ1bmNhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXBcbiIsImltcG9ydCB7IGh0bWxUcmVlQXNTdHJpbmcgfSBmcm9tICcuL2Jyb3dzZXIuanMnO1xuaW1wb3J0IHsgREVCVUdfQlVJTEQgfSBmcm9tICcuL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IGlzRXJyb3IsIGlzRXZlbnQsIGlzSW5zdGFuY2VPZiwgaXNQcmltaXRpdmUsIGlzRWxlbWVudCB9IGZyb20gJy4vaXMuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgdHJ1bmNhdGUgfSBmcm9tICcuL3N0cmluZy5qcyc7XG5cbi8qKlxuICogUmVwbGFjZSBhIG1ldGhvZCBpbiBhbiBvYmplY3Qgd2l0aCBhIHdyYXBwZWQgdmVyc2lvbiBvZiBpdHNlbGYuXG4gKlxuICogSWYgdGhlIG1ldGhvZCBvbiB0aGUgcGFzc2VkIG9iamVjdCBpcyBub3QgYSBmdW5jdGlvbiwgdGhlIHdyYXBwZXIgd2lsbCBub3QgYmUgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0gc291cmNlIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbWV0aG9kIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gcmVwbGFjZW1lbnRGYWN0b3J5IEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIG9yaWdpbmFsIHZlcnNpb24gb2YgdGhlIGdpdmVuIG1ldGhvZCBhbmQgcmV0dXJucyBhXG4gKiB3cmFwcGVkIHZlcnNpb24uIE5vdGU6IFRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBgcmVwbGFjZW1lbnRGYWN0b3J5YCBuZWVkcyB0byBiZSBhIG5vbi1hcnJvdyBmdW5jdGlvbiwgaW4gb3JkZXIgdG9cbiAqIHByZXNlcnZlIHRoZSBjb3JyZWN0IHZhbHVlIG9mIGB0aGlzYCwgYW5kIHRoZSBvcmlnaW5hbCBtZXRob2QgbXVzdCBiZSBjYWxsZWQgdXNpbmcgYG9yaWdNZXRob2QuY2FsbCh0aGlzLCA8b3RoZXJcbiAqIGFyZ3M+KWAgb3IgYG9yaWdNZXRob2QuYXBwbHkodGhpcywgWzxvdGhlciBhcmdzPl0pYCAocmF0aGVyIHRoYW4gYmVpbmcgY2FsbGVkIGRpcmVjdGx5KSwgYWdhaW4gdG8gcHJlc2VydmUgYHRoaXNgLlxuICogQHJldHVybnMgdm9pZFxuICovXG5mdW5jdGlvbiBmaWxsKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnRGYWN0b3J5KSB7XG4gIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGV4cGxpY2l0bHkgY2FzdGluZyB0byB1bmtub3duIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiB0aGUgbWV0aG9kIGluaXRpYWxseSBhdCBhbGxcbiAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV0gO1xuXG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB3cmFwcGVkID0gcmVwbGFjZW1lbnRGYWN0b3J5KG9yaWdpbmFsKSA7XG5cbiAgLy8gTWFrZSBzdXJlIGl0J3MgYSBmdW5jdGlvbiBmaXJzdCwgYXMgd2UgbmVlZCB0byBhdHRhY2ggYW4gZW1wdHkgcHJvdG90eXBlIGZvciBgZGVmaW5lUHJvcGVydGllc2AgdG8gd29ya1xuICAvLyBvdGhlcndpc2UgaXQnbGwgdGhyb3cgXCJUeXBlRXJyb3I6IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIGNhbGxlZCBvbiBub24tb2JqZWN0XCJcbiAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWFya0Z1bmN0aW9uV3JhcHBlZCh3cmFwcGVkLCBvcmlnaW5hbCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNvdXJjZVtuYW1lXSA9IHdyYXBwZWQ7XG4gIH0gY2F0Y2gge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2coYEZhaWxlZCB0byByZXBsYWNlIG1ldGhvZCBcIiR7bmFtZX1cIiBpbiBvYmplY3RgLCBzb3VyY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBzZXRcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gd2hpY2ggdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLCAvLyB0aGUgZGVmYXVsdCwgc28gd2UgY2FuIHNhdmUgb24gYnVuZGxlIHNpemUgYnkgbm90IGV4cGxpY2l0bHkgc2V0dGluZyBpdFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKG9fTykge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2coYEZhaWxlZCB0byBhZGQgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgXCIke25hbWV9XCIgdG8gb2JqZWN0YCwgb2JqKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbWVtYmVycyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gb24gdGhlIHdyYXBwZWQgZnVuY3Rpb24gYW5kXG4gKiBwYXRjaGVzIHVwIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHdyYXBwZWQgdGhlIHdyYXBwZXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBvcmlnaW5hbCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gdGhhdCBnZXRzIHdyYXBwZWRcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uV3JhcHBlZCh3cmFwcGVkLCBvcmlnaW5hbCkge1xuICB0cnkge1xuICAgIGNvbnN0IHByb3RvID0gb3JpZ2luYWwucHJvdG90eXBlIHx8IHt9O1xuICAgIHdyYXBwZWQucHJvdG90eXBlID0gb3JpZ2luYWwucHJvdG90eXBlID0gcHJvdG87XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHdyYXBwZWQsICdfX3NlbnRyeV9vcmlnaW5hbF9fJywgb3JpZ2luYWwpO1xuICB9IGNhdGNoIChvX08pIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbn1cblxuLyoqXG4gKiBUaGlzIGV4dHJhY3RzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpZiBhdmFpbGFibGUuICBTZWVcbiAqIGBtYXJrRnVuY3Rpb25XcmFwcGVkYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gdG8gdW53cmFwXG4gKiBAcmV0dXJucyB0aGUgdW53cmFwcGVkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGdldE9yaWdpbmFsRnVuY3Rpb24oZnVuYykge1xuICByZXR1cm4gZnVuYy5fX3NlbnRyeV9vcmlnaW5hbF9fO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW55IGBFcnJvcmAgb3IgYEV2ZW50YCBpbnRvIGEgcGxhaW4gb2JqZWN0IHdpdGggYWxsIG9mIHRoZWlyIGVudW1lcmFibGUgcHJvcGVydGllcywgYW5kIHNvbWUgb2YgdGhlaXJcbiAqIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXR0YWNoZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEluaXRpYWwgc291cmNlIHRoYXQgd2UgaGF2ZSB0byB0cmFuc2Zvcm0gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHVzYWJsZSBieSB0aGUgc2VyaWFsaXplclxuICogQHJldHVybnMgQW4gRXZlbnQgb3IgRXJyb3IgdHVybmVkIGludG8gYW4gb2JqZWN0IC0gb3IgdGhlIHZhbHVlIGFyZ3VtZW50IGl0c2VsZiwgd2hlbiB2YWx1ZSBpcyBuZWl0aGVyIGFuIEV2ZW50IG5vclxuICogIGFuIEVycm9yLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9QbGFpbk9iamVjdCh2YWx1ZSlcblxuIHtcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgLi4uZ2V0T3duUHJvcGVydGllcyh2YWx1ZSksXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc0V2ZW50KHZhbHVlKSkge1xuICAgIGNvbnN0IG5ld09ialxuXG4gPSB7XG4gICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgdGFyZ2V0OiBzZXJpYWxpemVFdmVudFRhcmdldCh2YWx1ZS50YXJnZXQpLFxuICAgICAgY3VycmVudFRhcmdldDogc2VyaWFsaXplRXZlbnRUYXJnZXQodmFsdWUuY3VycmVudFRhcmdldCksXG4gICAgICAuLi5nZXRPd25Qcm9wZXJ0aWVzKHZhbHVlKSxcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHZhbHVlLCBDdXN0b21FdmVudCkpIHtcbiAgICAgIG5ld09iai5kZXRhaWwgPSB2YWx1ZS5kZXRhaWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRhcmdldCBvZiBhbiBgRXZlbnRgIG9iamVjdCAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXQpID8gaHRtbFRyZWVBc1N0cmluZyh0YXJnZXQpIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldCk7XG4gIH0gY2F0Y2ggKF9vTykge1xuICAgIHJldHVybiAnPHVua25vd24+JztcbiAgfVxufVxuXG4vKiogRmlsdGVycyBvdXQgYWxsIGJ1dCBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyAqL1xuZnVuY3Rpb24gZ2V0T3duUHJvcGVydGllcyhvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGV4dHJhY3RlZFByb3BzID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgZXh0cmFjdGVkUHJvcHNbcHJvcGVydHldID0gKG9iaiApW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZFByb3BzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFueSBjYXB0dXJlZCBleGNlcHRpb24sIGV4dHJhY3QgaXRzIGtleXMgYW5kIGNyZWF0ZSBhIHNvcnRlZFxuICogYW5kIHRydW5jYXRlZCBsaXN0IHRoYXQgd2lsbCBiZSB1c2VkIGluc2lkZSB0aGUgZXZlbnQgbWVzc2FnZS5cbiAqIGVnLiBgTm9uLWVycm9yIGV4Y2VwdGlvbiBjYXB0dXJlZCB3aXRoIGtleXM6IGZvbywgYmFyLCBiYXpgXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFeGNlcHRpb25LZXlzRm9yTWVzc2FnZShleGNlcHRpb24sIG1heExlbmd0aCA9IDQwKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjb252ZXJ0VG9QbGFpbk9iamVjdChleGNlcHRpb24pKTtcbiAga2V5cy5zb3J0KCk7XG5cbiAgY29uc3QgZmlyc3RLZXkgPSBrZXlzWzBdO1xuXG4gIGlmICghZmlyc3RLZXkpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgaGFzIG5vIGtleXNdJztcbiAgfVxuXG4gIGlmIChmaXJzdEtleS5sZW5ndGggPj0gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydW5jYXRlKGZpcnN0S2V5LCBtYXhMZW5ndGgpO1xuICB9XG5cbiAgZm9yIChsZXQgaW5jbHVkZWRLZXlzID0ga2V5cy5sZW5ndGg7IGluY2x1ZGVkS2V5cyA+IDA7IGluY2x1ZGVkS2V5cy0tKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGtleXMuc2xpY2UoMCwgaW5jbHVkZWRLZXlzKS5qb2luKCcsICcpO1xuICAgIGlmIChzZXJpYWxpemVkLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZEtleXMgPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgcmV0dXJuIHRydW5jYXRlKHNlcmlhbGl6ZWQsIG1heExlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG9iamVjdCwgcmV0dXJuIGEgbmV3IG9iamVjdCBoYXZpbmcgcmVtb3ZlZCBhbGwgZmllbGRzIHdob3NlIHZhbHVlIHdhcyBgdW5kZWZpbmVkYC5cbiAqIFdvcmtzIHJlY3Vyc2l2ZWx5IG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqXG4gKiBBdHRlbnRpb246IFRoaXMgZnVuY3Rpb24ga2VlcHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICpcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gaXMgbm8gbG9uZ2VyIHVzZWQgYnkgdGhlIFNESyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGRyb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWUpIHtcbiAgLy8gVGhpcyBtYXAga2VlcHMgdHJhY2sgb2Ygd2hhdCBhbHJlYWR5IHZpc2l0ZWQgbm9kZXMgbWFwIHRvLlxuICAvLyBPdXIgU2V0IC0gYmFzZWQgbWVtb0J1aWxkZXIgZG9lc24ndCB3b3JrIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvIHRoZSBvdXRwdXQgb2JqZWN0IHRvIGhhdmUgdGhlIHNhbWUgY2lyY3VsYXJcbiAgLy8gcmVmZXJlbmNlcyBhcyB0aGUgaW5wdXQgb2JqZWN0LlxuICBjb25zdCBtZW1vaXphdGlvbk1hcCA9IG5ldyBNYXAoKTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGp1c3QgcHJveGllcyBgX2Ryb3BVbmRlZmluZWRLZXlzYCB0byBrZWVwIHRoZSBgbWVtb0J1aWxkZXJgIG91dCBvZiB0aGlzIGZ1bmN0aW9uJ3MgQVBJXG4gIHJldHVybiBfZHJvcFVuZGVmaW5lZEtleXMoaW5wdXRWYWx1ZSwgbWVtb2l6YXRpb25NYXApO1xufVxuXG5mdW5jdGlvbiBfZHJvcFVuZGVmaW5lZEtleXMoaW5wdXRWYWx1ZSwgbWVtb2l6YXRpb25NYXApIHtcbiAgLy8gRWFybHkgcmV0dXJuIGZvciBwcmltaXRpdmUgdmFsdWVzXG4gIGlmIChpbnB1dFZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dFZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICB9XG5cbiAgLy8gQ2hlY2sgbWVtbyBtYXAgZmlyc3QgZm9yIGFsbCBvYmplY3QgdHlwZXNcbiAgY29uc3QgbWVtb1ZhbCA9IG1lbW9pemF0aW9uTWFwLmdldChpbnB1dFZhbHVlKTtcbiAgaWYgKG1lbW9WYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBtZW1vVmFsIDtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhcnJheXNcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkpIHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IFtdO1xuICAgIC8vIFN0b3JlIG1hcHBpbmcgdG8gaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICBtZW1vaXphdGlvbk1hcC5zZXQoaW5wdXRWYWx1ZSwgcmV0dXJuVmFsdWUpO1xuXG4gICAgaW5wdXRWYWx1ZS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIHJldHVyblZhbHVlLnB1c2goX2Ryb3BVbmRlZmluZWRLZXlzKHZhbHVlLCBtZW1vaXphdGlvbk1hcCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlIDtcbiAgfVxuXG4gIGlmIChpc1Bvam8oaW5wdXRWYWx1ZSkpIHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHt9O1xuICAgIC8vIFN0b3JlIG1hcHBpbmcgdG8gaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICBtZW1vaXphdGlvbk1hcC5zZXQoaW5wdXRWYWx1ZSwgcmV0dXJuVmFsdWUpO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0VmFsdWUpO1xuXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBpbnB1dFZhbHVlW2tleV07XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IF9kcm9wVW5kZWZpbmVkS2V5cyh2YWwsIG1lbW9pemF0aW9uTWFwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZSA7XG4gIH1cblxuICAvLyBGb3Igb3RoZXIgb2JqZWN0IHR5cGVzLCByZXR1cm4gYXMgaXNcbiAgcmV0dXJuIGlucHV0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzUG9qbyhpbnB1dCkge1xuICAvLyBQbGFpbiBvYmplY3RzIGhhdmUgT2JqZWN0IGFzIGNvbnN0cnVjdG9yIG9yIG5vIGNvbnN0cnVjdG9yXG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gKGlucHV0ICkuY29uc3RydWN0b3I7XG4gIHJldHVybiBjb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IGNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBUdXJucyBgdW5kZWZpbmVkYCBhbmQgYG51bGxgIGludG8gYFN0cmluZ2BzIGFuZCBhbGwgb3RoZXIgcHJpbWl0aXZlcyBpbnRvIGluc3RhbmNlcyBvZiB0aGVpciByZXNwZWN0aXZlIHdyYXBwZXJcbiAqIGNsYXNzZXMgKFN0cmluZywgQm9vbGVhbiwgTnVtYmVyLCBldGMuKS4gQWN0cyBhcyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gb24gbm9uLXByaW1pdGl2ZXMuXG4gKlxuICogQHBhcmFtIHdhdCBUaGUgc3ViamVjdCBvZiB0aGUgb2JqZWN0aWZpY2F0aW9uXG4gKiBAcmV0dXJucyBBIHZlcnNpb24gb2YgYHdhdGAgd2hpY2ggY2FuIHNhZmVseSBiZSB1c2VkIHdpdGggYE9iamVjdGAgY2xhc3MgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBvYmplY3RpZnkod2F0KSB7XG4gIGxldCBvYmplY3RpZmllZDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgLy8gdGhpcyB3aWxsIGNhdGNoIGJvdGggdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgY2FzZSB3YXQgPT0gdW5kZWZpbmVkOlxuICAgICAgb2JqZWN0aWZpZWQgPSBuZXcgU3RyaW5nKHdhdCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIFRob3VnaCBzeW1ib2xzIGFuZCBiaWdpbnRzIGRvIGhhdmUgd3JhcHBlciBjbGFzc2VzIChgU3ltYm9sYCBhbmQgYEJpZ0ludGAsIHJlc3BlY3RpdmVseSksIGZvciB3aGF0ZXZlciByZWFzb25cbiAgICAvLyB0aG9zZSBjbGFzc2VzIGRvbid0IGhhdmUgY29uc3RydWN0b3JzIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuIFdlIHRoZXJlZm9yZSBuZWVkIHRvIGNhc3QgZWFjaCBhc1xuICAgIC8vIGFuIG9iamVjdCBpbiBvcmRlciB0byB3cmFwIGl0LlxuICAgIGNhc2UgdHlwZW9mIHdhdCA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHdhdCA9PT0gJ2JpZ2ludCc6XG4gICAgICBvYmplY3RpZmllZCA9IE9iamVjdCh3YXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyB0aGlzIHdpbGwgY2F0Y2ggdGhlIHJlbWFpbmluZyBwcmltaXRpdmVzOiBgU3RyaW5nYCwgYE51bWJlcmAsIGFuZCBgQm9vbGVhbmBcbiAgICBjYXNlIGlzUHJpbWl0aXZlKHdhdCk6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICBvYmplY3RpZmllZCA9IG5ldyAod2F0ICkuY29uc3RydWN0b3Iod2F0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gYnkgcHJvY2VzcyBvZiBlbGltaW5hdGlvbiwgYXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgYHdhdGAgbXVzdCBhbHJlYWR5IGJlIGFuIG9iamVjdFxuICAgIGRlZmF1bHQ6XG4gICAgICBvYmplY3RpZmllZCA9IHdhdDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBvYmplY3RpZmllZDtcbn1cblxuZXhwb3J0IHsgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5LCBjb252ZXJ0VG9QbGFpbk9iamVjdCwgZHJvcFVuZGVmaW5lZEtleXMsIGV4dHJhY3RFeGNlcHRpb25LZXlzRm9yTWVzc2FnZSwgZmlsbCwgZ2V0T3JpZ2luYWxGdW5jdGlvbiwgbWFya0Z1bmN0aW9uV3JhcHBlZCwgb2JqZWN0aWZ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwXG4iLCJpbXBvcnQgeyBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkgfSBmcm9tICcuL29iamVjdC5qcyc7XG5pbXBvcnQgeyBzbmlwTGluZSB9IGZyb20gJy4vc3RyaW5nLmpzJztcbmltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbmZ1bmN0aW9uIGdldENyeXB0bygpIHtcbiAgY29uc3QgZ2JsID0gR0xPQkFMX09CSiA7XG4gIHJldHVybiBnYmwuY3J5cHRvIHx8IGdibC5tc0NyeXB0bztcbn1cblxuLyoqXG4gKiBVVUlENCBnZW5lcmF0b3JcbiAqIEBwYXJhbSBjcnlwdG8gT2JqZWN0IHRoYXQgcHJvdmlkZXMgdGhlIGNyeXB0byBBUEkuXG4gKiBAcmV0dXJucyBzdHJpbmcgR2VuZXJhdGVkIFVVSUQ0LlxuICovXG5mdW5jdGlvbiB1dWlkNChjcnlwdG8gPSBnZXRDcnlwdG8oKSkge1xuICBsZXQgZ2V0UmFuZG9tQnl0ZSA9ICgpID0+IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgdHJ5IHtcbiAgICBpZiAoY3J5cHRvPy5yYW5kb21VVUlEKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKS5yZXBsYWNlKC8tL2csICcnKTtcbiAgICB9XG4gICAgaWYgKGNyeXB0bz8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICBnZXRSYW5kb21CeXRlID0gKCkgPT4ge1xuICAgICAgICAvLyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG1pZ2h0IHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiB0aGUgdHlwZWQgYXJyYXlcbiAgICAgICAgLy8gaW4gb2xkIENocm9taXVtIHZlcnNpb25zIChlLmcuIDIzLjAuMTIzNS4wICgxNTE0MjIpKVxuICAgICAgICAvLyBIb3dldmVyLCBgdHlwZWRBcnJheWAgaXMgc3RpbGwgZmlsbGVkIGluLXBsYWNlLlxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzI3R5cGVkYXJyYXlcbiAgICAgICAgY29uc3QgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHR5cGVkQXJyYXkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICByZXR1cm4gdHlwZWRBcnJheVswXTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gc29tZSBydW50aW1lcyBjYW4gY3Jhc2ggaW52b2tpbmcgY3J5cHRvXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvODkzNVxuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxMTc1MjMjMjExNzUyM1xuICAvLyBDb25jYXRlbmF0aW5nIHRoZSBmb2xsb3dpbmcgbnVtYmVycyBhcyBzdHJpbmdzIHJlc3VsdHMgaW4gJzEwMDAwMDAwMTAwMDQwMDA4MDAwMTAwMDAwMDAwMDAwJ1xuICByZXR1cm4gKChbMWU3XSApICsgMWUzICsgNGUzICsgOGUzICsgMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgYyA9PlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgKChjICkgXiAoKGdldFJhbmRvbUJ5dGUoKSAmIDE1KSA+PiAoKGMgKSAvIDQpKSkudG9TdHJpbmcoMTYpLFxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEV4Y2VwdGlvbihldmVudCkge1xuICByZXR1cm4gZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXM/LlswXTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBlaXRoZXIgbWVzc2FnZSBvciB0eXBlK3ZhbHVlIGZyb20gYW4gZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdXNlci1mYWNpbmcgbG9nc1xuICogQHJldHVybnMgZXZlbnQncyBkZXNjcmlwdGlvblxuICovXG5mdW5jdGlvbiBnZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSB7XG4gIGNvbnN0IHsgbWVzc2FnZSwgZXZlbnRfaWQ6IGV2ZW50SWQgfSA9IGV2ZW50O1xuICBpZiAobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RFeGNlcHRpb24gPSBnZXRGaXJzdEV4Y2VwdGlvbihldmVudCk7XG4gIGlmIChmaXJzdEV4Y2VwdGlvbikge1xuICAgIGlmIChmaXJzdEV4Y2VwdGlvbi50eXBlICYmIGZpcnN0RXhjZXB0aW9uLnZhbHVlKSB7XG4gICAgICByZXR1cm4gYCR7Zmlyc3RFeGNlcHRpb24udHlwZX06ICR7Zmlyc3RFeGNlcHRpb24udmFsdWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0RXhjZXB0aW9uLnR5cGUgfHwgZmlyc3RFeGNlcHRpb24udmFsdWUgfHwgZXZlbnRJZCB8fCAnPHVua25vd24+JztcbiAgfVxuICByZXR1cm4gZXZlbnRJZCB8fCAnPHVua25vd24+Jztcbn1cblxuLyoqXG4gKiBBZGRzIGV4Y2VwdGlvbiB2YWx1ZXMsIHR5cGUgYW5kIHZhbHVlIHRvIGFuIHN5bnRoZXRpYyBFeGNlcHRpb24uXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiB0aGUgZXhjZXB0aW9uLlxuICogQHBhcmFtIHR5cGUgVHlwZSBvZiB0aGUgZXhjZXB0aW9uLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRFeGNlcHRpb25UeXBlVmFsdWUoZXZlbnQsIHZhbHVlLCB0eXBlKSB7XG4gIGNvbnN0IGV4Y2VwdGlvbiA9IChldmVudC5leGNlcHRpb24gPSBldmVudC5leGNlcHRpb24gfHwge30pO1xuICBjb25zdCB2YWx1ZXMgPSAoZXhjZXB0aW9uLnZhbHVlcyA9IGV4Y2VwdGlvbi52YWx1ZXMgfHwgW10pO1xuICBjb25zdCBmaXJzdEV4Y2VwdGlvbiA9ICh2YWx1ZXNbMF0gPSB2YWx1ZXNbMF0gfHwge30pO1xuICBpZiAoIWZpcnN0RXhjZXB0aW9uLnZhbHVlKSB7XG4gICAgZmlyc3RFeGNlcHRpb24udmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgfVxuICBpZiAoIWZpcnN0RXhjZXB0aW9uLnR5cGUpIHtcbiAgICBmaXJzdEV4Y2VwdGlvbi50eXBlID0gdHlwZSB8fCAnRXJyb3InO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBleGNlcHRpb24gbWVjaGFuaXNtIGRhdGEgdG8gYSBnaXZlbiBldmVudC4gVXNlcyBkZWZhdWx0cyBpZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLlxuICpcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIG5ld01lY2hhbmlzbSBNZWNoYW5pc20gZGF0YSB0byBhZGQgdG8gdGhlIGV2ZW50LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRFeGNlcHRpb25NZWNoYW5pc20oZXZlbnQsIG5ld01lY2hhbmlzbSkge1xuICBjb25zdCBmaXJzdEV4Y2VwdGlvbiA9IGdldEZpcnN0RXhjZXB0aW9uKGV2ZW50KTtcbiAgaWYgKCFmaXJzdEV4Y2VwdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRNZWNoYW5pc20gPSB7IHR5cGU6ICdnZW5lcmljJywgaGFuZGxlZDogdHJ1ZSB9O1xuICBjb25zdCBjdXJyZW50TWVjaGFuaXNtID0gZmlyc3RFeGNlcHRpb24ubWVjaGFuaXNtO1xuICBmaXJzdEV4Y2VwdGlvbi5tZWNoYW5pc20gPSB7IC4uLmRlZmF1bHRNZWNoYW5pc20sIC4uLmN1cnJlbnRNZWNoYW5pc20sIC4uLm5ld01lY2hhbmlzbSB9O1xuXG4gIGlmIChuZXdNZWNoYW5pc20gJiYgJ2RhdGEnIGluIG5ld01lY2hhbmlzbSkge1xuICAgIGNvbnN0IG1lcmdlZERhdGEgPSB7IC4uLmN1cnJlbnRNZWNoYW5pc20/LmRhdGEsIC4uLm5ld01lY2hhbmlzbS5kYXRhIH07XG4gICAgZmlyc3RFeGNlcHRpb24ubWVjaGFuaXNtLmRhdGEgPSBtZXJnZWREYXRhO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vc2VtdmVyLm9yZy8jaXMtdGhlcmUtYS1zdWdnZXN0ZWQtcmVndWxhci1leHByZXNzaW9uLXJlZ2V4LXRvLWNoZWNrLWEtc2VtdmVyLXN0cmluZ1xuY29uc3QgU0VNVkVSX1JFR0VYUCA9XG4gIC9eKDB8WzEtOV1cXGQqKVxcLigwfFsxLTldXFxkKilcXC4oMHxbMS05XVxcZCopKD86LSgoPzowfFsxLTldXFxkKnxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikoPzpcXC4oPzowfFsxLTldXFxkKnxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikpKikpPyg/OlxcKyhbMC05YS16QS1aLV0rKD86XFwuWzAtOWEtekEtWi1dKykqKSk/JC87XG5cbi8qKlxuICogUmVwcmVzZW50cyBTZW1hbnRpYyBWZXJzaW9uaW5nIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIF9wYXJzZUludChpbnB1dCkge1xuICByZXR1cm4gcGFyc2VJbnQoaW5wdXQgfHwgJycsIDEwKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgaW5wdXQgaW50byBhIFNlbVZlciBpbnRlcmZhY2VcbiAqIEBwYXJhbSBpbnB1dCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZW12ZXIgdmVyc2lvblxuICovXG5mdW5jdGlvbiBwYXJzZVNlbXZlcihpbnB1dCkge1xuICBjb25zdCBtYXRjaCA9IGlucHV0Lm1hdGNoKFNFTVZFUl9SRUdFWFApIHx8IFtdO1xuICBjb25zdCBtYWpvciA9IF9wYXJzZUludChtYXRjaFsxXSk7XG4gIGNvbnN0IG1pbm9yID0gX3BhcnNlSW50KG1hdGNoWzJdKTtcbiAgY29uc3QgcGF0Y2ggPSBfcGFyc2VJbnQobWF0Y2hbM10pO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkbWV0YWRhdGE6IG1hdGNoWzVdLFxuICAgIG1ham9yOiBpc05hTihtYWpvcikgPyB1bmRlZmluZWQgOiBtYWpvcixcbiAgICBtaW5vcjogaXNOYU4obWlub3IpID8gdW5kZWZpbmVkIDogbWlub3IsXG4gICAgcGF0Y2g6IGlzTmFOKHBhdGNoKSA/IHVuZGVmaW5lZCA6IHBhdGNoLFxuICAgIHByZXJlbGVhc2U6IG1hdGNoWzRdLFxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjb250ZXh0IChwcmUvcG9zdC9saW5lKSBsaW5lcyB0byB0aGUgcHJvdmlkZWQgZnJhbWVcbiAqXG4gKiBAcGFyYW0gbGluZXMgc3RyaW5nW10gY29udGFpbmluZyBhbGwgbGluZXNcbiAqIEBwYXJhbSBmcmFtZSBTdGFja0ZyYW1lIHRoYXQgd2lsbCBiZSBtdXRhdGVkXG4gKiBAcGFyYW0gbGluZXNPZkNvbnRleHQgbnVtYmVyIG9mIGNvbnRleHQgbGluZXMgd2Ugd2FudCB0byBhZGQgcHJlL3Bvc3RcbiAqL1xuZnVuY3Rpb24gYWRkQ29udGV4dFRvRnJhbWUobGluZXMsIGZyYW1lLCBsaW5lc09mQ29udGV4dCA9IDUpIHtcbiAgLy8gV2hlbiB0aGVyZSBpcyBubyBsaW5lIG51bWJlciBpbiB0aGUgZnJhbWUsIGF0dGFjaGluZyBjb250ZXh0IGlzIG5vbnNlbnNpY2FsIGFuZCB3aWxsIGV2ZW4gYnJlYWsgZ3JvdXBpbmdcbiAgaWYgKGZyYW1lLmxpbmVubyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbWF4TGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gIGNvbnN0IHNvdXJjZUxpbmUgPSBNYXRoLm1heChNYXRoLm1pbihtYXhMaW5lcyAtIDEsIGZyYW1lLmxpbmVubyAtIDEpLCAwKTtcblxuICBmcmFtZS5wcmVfY29udGV4dCA9IGxpbmVzXG4gICAgLnNsaWNlKE1hdGgubWF4KDAsIHNvdXJjZUxpbmUgLSBsaW5lc09mQ29udGV4dCksIHNvdXJjZUxpbmUpXG4gICAgLm1hcCgobGluZSkgPT4gc25pcExpbmUobGluZSwgMCkpO1xuXG4gIC8vIFdlIGd1YXJkIGhlcmUgdG8gZW5zdXJlIHRoaXMgaXMgbm90IGxhcmdlciB0aGFuIHRoZSBleGlzdGluZyBudW1iZXIgb2YgbGluZXNcbiAgY29uc3QgbGluZUluZGV4ID0gTWF0aC5taW4obWF4TGluZXMgLSAxLCBzb3VyY2VMaW5lKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICBmcmFtZS5jb250ZXh0X2xpbmUgPSBzbmlwTGluZShsaW5lc1tsaW5lSW5kZXhdLCBmcmFtZS5jb2xubyB8fCAwKTtcblxuICBmcmFtZS5wb3N0X2NvbnRleHQgPSBsaW5lc1xuICAgIC5zbGljZShNYXRoLm1pbihzb3VyY2VMaW5lICsgMSwgbWF4TGluZXMpLCBzb3VyY2VMaW5lICsgMSArIGxpbmVzT2ZDb250ZXh0KVxuICAgIC5tYXAoKGxpbmUpID0+IHNuaXBMaW5lKGxpbmUsIDApKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3Qgd2UndmUgYWxyZWFkeSBjYXB0dXJlZCB0aGUgZ2l2ZW4gZXhjZXB0aW9uIChub3RlOiBub3QgYW4gaWRlbnRpY2FsIGV4Y2VwdGlvbiAtIHRoZSB2ZXJ5IG9iamVjdFxuICogaW4gcXVlc3Rpb24pLCBhbmQgbWFya3MgaXQgY2FwdHVyZWQgaWYgbm90LlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBmb3IgYW4gZXJyb3IgdG8gZ2V0IGNhcHR1cmVkIGJ5IG1vcmUgdGhhbiBvbmUgbWVjaGFuaXNtLiBBZnRlciB3ZSBpbnRlcmNlcHQgYW5kXG4gKiByZWNvcmQgYW4gZXJyb3IsIHdlIHJldGhyb3cgaXQgKGFzc3VtaW5nIHdlJ3ZlIGludGVyY2VwdGVkIGl0IGJlZm9yZSBpdCdzIHJlYWNoZWQgdGhlIHRvcC1sZXZlbCBnbG9iYWwgaGFuZGxlcnMpLCBzb1xuICogdGhhdCB3ZSBkb24ndCBpbnRlcmZlcmUgd2l0aCB3aGF0ZXZlciBlZmZlY3RzIHRoZSBlcnJvciBtaWdodCBoYXZlIGhhZCB3ZXJlIHRoZSBTREsgbm90IHRoZXJlLiBBdCB0aGF0IHBvaW50LCBiZWNhdXNlXG4gKiB0aGUgZXJyb3IgaGFzIGJlZW4gcmV0aHJvd24sIGl0J3MgcG9zc2libGUgZm9yIGl0IHRvIGJ1YmJsZSB1cCB0byBzb21lIG90aGVyIGNvZGUgd2UndmUgaW5zdHJ1bWVudGVkLiBJZiBpdCdzIG5vdFxuICogY2F1Z2h0IGFmdGVyIHRoYXQsIGl0IHdpbGwgYnViYmxlIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBnbG9iYWwgaGFuZGxlcnMgKHdoaWNoIG9mIGNvdXJzZSB3ZSBhbHNvIGluc3RydW1lbnQpLiBUaGlzXG4gKiBmdW5jdGlvbiBoZWxwcyB1cyBlbnN1cmUgdGhhdCBldmVuIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZSBlcnJvciBtb3JlIHRoYW4gb25jZSwgd2Ugb25seSByZWNvcmQgaXQgdGhlIGZpcnN0IHRpbWUgd2VcbiAqIHNlZSBpdC5cbiAqXG4gKiBOb3RlOiBJdCB3aWxsIGlnbm9yZSBwcmltaXRpdmVzIChhbHdheXMgcmV0dXJuIGBmYWxzZWAgYW5kIG5vdCBtYXJrIHRoZW0gYXMgc2VlbiksIGFzIHByb3BlcnRpZXMgY2FuJ3QgYmUgc2V0IG9uXG4gKiB0aGVtLiB7QGxpbms6IE9iamVjdC5vYmplY3RpZnl9IGNhbiBiZSB1c2VkIG9uIGV4Y2VwdGlvbnMgdG8gY29udmVydCBhbnkgdGhhdCBhcmUgcHJpbWl0aXZlcyBpbnRvIHRoZWlyIGVxdWl2YWxlbnRcbiAqIG9iamVjdCB3cmFwcGVyIGZvcm1zIHNvIHRoYXQgdGhpcyBjaGVjayB3aWxsIGFsd2F5cyB3b3JrLiBIb3dldmVyLCBiZWNhdXNlIHdlIG5lZWQgdG8gZmxhZyB0aGUgZXhhY3Qgb2JqZWN0IHdoaWNoXG4gKiB3aWxsIGdldCByZXRocm93biwgYW5kIGJlY2F1c2UgdGhhdCByZXRocm93aW5nIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgZXZlbnQgcHJvY2Vzc2luZyBwaXBlbGluZSwgdGhlIG9iamVjdGlmaWNhdGlvblxuICogbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgZXhjZXB0aW9uIGNhcHR1cmVkLlxuICpcbiAqIEBwYXJhbSBBIHRocm93biBleGNlcHRpb24gdG8gY2hlY2sgb3IgZmxhZyBhcyBoYXZpbmcgYmVlbiBzZWVuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV4Y2VwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkLCBgZmFsc2VgIGlmIG5vdCAod2l0aCB0aGUgc2lkZSBlZmZlY3Qgb2YgbWFya2luZyBpdCBzZWVuKVxuICovXG5mdW5jdGlvbiBjaGVja09yU2V0QWxyZWFkeUNhdWdodChleGNlcHRpb24pIHtcbiAgaWYgKGlzQWxyZWFkeUNhcHR1cmVkKGV4Y2VwdGlvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc2V0IGl0IHRoaXMgd2F5IHJhdGhlciB0aGFuIGJ5IGFzc2lnbm1lbnQgc28gdGhhdCBpdCdzIG5vdCBlbm51bWVyYWJsZSBhbmQgdGhlcmVmb3JlIGlzbid0IHJlY29yZGVkIGJ5IHRoZVxuICAgIC8vIGBFeHRyYUVycm9yRGF0YWAgaW50ZWdyYXRpb25cbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoZXhjZXB0aW9uICwgJ19fc2VudHJ5X2NhcHR1cmVkX18nLCB0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gYGV4Y2VwdGlvbmAgaXMgYSBwcmltaXRpdmUsIHNvIHdlIGNhbid0IG1hcmsgaXQgc2VlblxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlDYXB0dXJlZChleGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGV4Y2VwdGlvbiApLl9fc2VudHJ5X2NhcHR1cmVkX187XG4gIH0gY2F0Y2gge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxufVxuXG5leHBvcnQgeyBhZGRDb250ZXh0VG9GcmFtZSwgYWRkRXhjZXB0aW9uTWVjaGFuaXNtLCBhZGRFeGNlcHRpb25UeXBlVmFsdWUsIGNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0LCBnZXRFdmVudERlc2NyaXB0aW9uLCBwYXJzZVNlbXZlciwgdXVpZDQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwXG4iLCJpbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG5jb25zdCBPTkVfU0VDT05EX0lOX01TID0gMTAwMDtcblxuLyoqXG4gKiBBIHBhcnRpYWwgZGVmaW5pdGlvbiBvZiB0aGUgW1BlcmZvcm1hbmNlIFdlYiBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZX1cbiAqIGZvciBhY2Nlc3NpbmcgYSBoaWdoLXJlc29sdXRpb24gbW9ub3RvbmljIGNsb2NrLlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIHRoZSBEYXRlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGF0ZVRpbWVzdGFtcEluU2Vjb25kcygpIHtcbiAgcmV0dXJuIERhdGUubm93KCkgLyBPTkVfU0VDT05EX0lOX01TO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIFBlcmZvcm1hbmNlIEFQSSBicm93c2VyIGltcGxlbWVudGF0aW9uLCBvciB1bmRlZmluZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90XG4gKiBzdXBwb3J0IHRoZSBBUEkuXG4gKlxuICogV3JhcHBpbmcgdGhlIG5hdGl2ZSBBUEkgd29ya3MgYXJvdW5kIGRpZmZlcmVuY2VzIGluIGJlaGF2aW9yIGZyb20gZGlmZmVyZW50IGJyb3dzZXJzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVbml4VGltZXN0YW1wSW5TZWNvbmRzRnVuYygpIHtcbiAgY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gR0xPQkFMX09CSiA7XG4gIGlmICghcGVyZm9ybWFuY2U/Lm5vdykge1xuICAgIHJldHVybiBkYXRlVGltZXN0YW1wSW5TZWNvbmRzO1xuICB9XG5cbiAgLy8gU29tZSBicm93c2VyIGFuZCBlbnZpcm9ubWVudHMgZG9uJ3QgaGF2ZSBhIHRpbWVPcmlnaW4sIHNvIHdlIGZhbGxiYWNrIHRvXG4gIC8vIHVzaW5nIERhdGUubm93KCkgdG8gY29tcHV0ZSB0aGUgc3RhcnRpbmcgdGltZS5cbiAgY29uc3QgYXBwcm94U3RhcnRpbmdUaW1lT3JpZ2luID0gRGF0ZS5ub3coKSAtIHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCB0aW1lT3JpZ2luID0gcGVyZm9ybWFuY2UudGltZU9yaWdpbiA9PSB1bmRlZmluZWQgPyBhcHByb3hTdGFydGluZ1RpbWVPcmlnaW4gOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luO1xuXG4gIC8vIHBlcmZvcm1hbmNlLm5vdygpIGlzIGEgbW9ub3RvbmljIGNsb2NrLCB3aGljaCBtZWFucyBpdCBzdGFydHMgYXQgMCB3aGVuIHRoZSBwcm9jZXNzIGJlZ2lucy4gVG8gZ2V0IHRoZSBjdXJyZW50XG4gIC8vIHdhbGwgY2xvY2sgdGltZSAoYWN0dWFsIFVOSVggdGltZXN0YW1wKSwgd2UgbmVlZCB0byBhZGQgdGhlIHN0YXJ0aW5nIHRpbWUgb3JpZ2luIGFuZCB0aGUgY3VycmVudCB0aW1lIGVsYXBzZWQuXG4gIC8vXG4gIC8vIFRPRE86IFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIG1vbm90b25pYyBjbG9jayB0aGF0IHBvd2VycyBwZXJmb3JtYW5jZS5ub3coKSBkcmlmdHMgZnJvbSB0aGVcbiAgLy8gd2FsbCBjbG9jayB0aW1lLCB3aGljaCBjYXVzZXMgdGhlIHJldHVybmVkIHRpbWVzdGFtcCB0byBiZSBpbmFjY3VyYXRlLiBXZSBzaG91bGQgaW52ZXN0aWdhdGUgaG93IHRvIGRldGVjdCBhbmRcbiAgLy8gY29ycmVjdCBmb3IgdGhpcy5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yNTkwXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21kbi9jb250ZW50L2lzc3Vlcy80NzEzXG4gIC8vIFNlZTogaHR0cHM6Ly9kZXYudG8vbm9hbXIvd2hlbi1hLW1pbGxpc2Vjb25kLWlzLW5vdC1hLW1pbGxpc2Vjb25kLTNoNlxuICByZXR1cm4gKCkgPT4ge1xuICAgIHJldHVybiAodGltZU9yaWdpbiArIHBlcmZvcm1hbmNlLm5vdygpKSAvIE9ORV9TRUNPTkRfSU5fTVM7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIGVpdGhlciB0aGUgUGVyZm9ybWFuY2Ugb3IgRGF0ZSBBUElzLCBkZXBlbmRpbmcgb24gdGhlXG4gKiBhdmFpbGFiaWxpdHkgb2YgdGhlIFBlcmZvcm1hbmNlIEFQSS5cbiAqXG4gKiBCVUc6IE5vdGUgdGhhdCBiZWNhdXNlIG9mIGhvdyBicm93c2VycyBpbXBsZW1lbnQgdGhlIFBlcmZvcm1hbmNlIEFQSSwgdGhlIGNsb2NrIG1pZ2h0IHN0b3Agd2hlbiB0aGUgY29tcHV0ZXIgaXNcbiAqIGFzbGVlcC4gVGhpcyBjcmVhdGVzIGEgc2tldyBiZXR3ZWVuIGBkYXRlVGltZXN0YW1wSW5TZWNvbmRzYCBhbmQgYHRpbWVzdGFtcEluU2Vjb25kc2AuIFRoZVxuICogc2tldyBjYW4gZ3JvdyB0byBhcmJpdHJhcnkgYW1vdW50cyBsaWtlIGRheXMsIHdlZWtzIG9yIG1vbnRocy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yNTkwLlxuICovXG5jb25zdCB0aW1lc3RhbXBJblNlY29uZHMgPSBjcmVhdGVVbml4VGltZXN0YW1wSW5TZWNvbmRzRnVuYygpO1xuXG4vKipcbiAqIENhY2hlZCByZXN1bHQgb2YgZ2V0QnJvd3NlclRpbWVPcmlnaW4uXG4gKi9cbmxldCBjYWNoZWRUaW1lT3JpZ2luO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWUgb3JpZ2luIGFuZCB0aGUgbW9kZSB1c2VkIHRvIGRldGVybWluZSBpdC5cbiAqL1xuZnVuY3Rpb24gZ2V0QnJvd3NlclRpbWVPcmlnaW4oKSB7XG4gIC8vIFVuZm9ydHVuYXRlbHkgYnJvd3NlcnMgbWF5IHJlcG9ydCBhbiBpbmFjY3VyYXRlIHRpbWUgb3JpZ2luIGRhdGEsIHRocm91Z2ggZWl0aGVyIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gb3JcbiAgLy8gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCwgd2hpY2ggcmVzdWx0cyBpbiBwb29yIHJlc3VsdHMgaW4gcGVyZm9ybWFuY2UgZGF0YS4gV2Ugb25seSB0cmVhdCB0aW1lIG9yaWdpblxuICAvLyBkYXRhIGFzIHJlbGlhYmxlIGlmIHRoZXkgYXJlIHdpdGhpbiBhIHJlYXNvbmFibGUgdGhyZXNob2xkIG9mIHRoZSBjdXJyZW50IHRpbWUuXG5cbiAgY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gR0xPQkFMX09CSiA7XG4gIGlmICghcGVyZm9ybWFuY2U/Lm5vdykge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCAnbm9uZSddO1xuICB9XG5cbiAgY29uc3QgdGhyZXNob2xkID0gMzYwMCAqIDEwMDA7XG4gIGNvbnN0IHBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGRhdGVOb3cgPSBEYXRlLm5vdygpO1xuXG4gIC8vIGlmIHRpbWVPcmlnaW4gaXNuJ3QgYXZhaWxhYmxlIHNldCBkZWx0YSB0byB0aHJlc2hvbGQgc28gaXQgaXNuJ3QgdXNlZFxuICBjb25zdCB0aW1lT3JpZ2luRGVsdGEgPSBwZXJmb3JtYW5jZS50aW1lT3JpZ2luXG4gICAgPyBNYXRoLmFicyhwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgcGVyZm9ybWFuY2VOb3cgLSBkYXRlTm93KVxuICAgIDogdGhyZXNob2xkO1xuICBjb25zdCB0aW1lT3JpZ2luSXNSZWxpYWJsZSA9IHRpbWVPcmlnaW5EZWx0YSA8IHRocmVzaG9sZDtcblxuICAvLyBXaGlsZSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0IGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgcGVyZm9ybWFuY2UudGltZU9yaWdpbiwgcGVyZm9ybWFuY2UudGltZU9yaWdpblxuICAvLyBpcyBub3QgYXMgd2lkZWx5IHN1cHBvcnRlZC4gTmFtZWx5LCBwZXJmb3JtYW5jZS50aW1lT3JpZ2luIGlzIHVuZGVmaW5lZCBpbiBTYWZhcmkgYXMgb2Ygd3JpdGluZy5cbiAgLy8gQWxzbyBhcyBvZiB3cml0aW5nLCBwZXJmb3JtYW5jZS50aW1pbmcgaXMgbm90IGF2YWlsYWJsZSBpbiBXZWIgV29ya2VycyBpbiBtYWluc3RyZWFtIGJyb3dzZXJzLCBzbyBpdCBpcyBub3QgYWx3YXlzXG4gIC8vIGEgdmFsaWQgZmFsbGJhY2suIEluIHRoZSBhYnNlbmNlIG9mIGFuIGluaXRpYWwgdGltZSBwcm92aWRlZCBieSB0aGUgYnJvd3NlciwgZmFsbGJhY2sgdG8gdGhlIGN1cnJlbnQgdGltZSBmcm9tIHRoZVxuICAvLyBEYXRlIEFQSS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IG5hdmlnYXRpb25TdGFydCA9IHBlcmZvcm1hbmNlLnRpbWluZz8ubmF2aWdhdGlvblN0YXJ0O1xuICBjb25zdCBoYXNOYXZpZ2F0aW9uU3RhcnQgPSB0eXBlb2YgbmF2aWdhdGlvblN0YXJ0ID09PSAnbnVtYmVyJztcbiAgLy8gaWYgbmF2aWdhdGlvblN0YXJ0IGlzbid0IGF2YWlsYWJsZSBzZXQgZGVsdGEgdG8gdGhyZXNob2xkIHNvIGl0IGlzbid0IHVzZWRcbiAgY29uc3QgbmF2aWdhdGlvblN0YXJ0RGVsdGEgPSBoYXNOYXZpZ2F0aW9uU3RhcnQgPyBNYXRoLmFicyhuYXZpZ2F0aW9uU3RhcnQgKyBwZXJmb3JtYW5jZU5vdyAtIGRhdGVOb3cpIDogdGhyZXNob2xkO1xuICBjb25zdCBuYXZpZ2F0aW9uU3RhcnRJc1JlbGlhYmxlID0gbmF2aWdhdGlvblN0YXJ0RGVsdGEgPCB0aHJlc2hvbGQ7XG5cbiAgaWYgKHRpbWVPcmlnaW5Jc1JlbGlhYmxlIHx8IG5hdmlnYXRpb25TdGFydElzUmVsaWFibGUpIHtcbiAgICAvLyBVc2UgdGhlIG1vcmUgcmVsaWFibGUgdGltZSBvcmlnaW5cbiAgICBpZiAodGltZU9yaWdpbkRlbHRhIDw9IG5hdmlnYXRpb25TdGFydERlbHRhKSB7XG4gICAgICByZXR1cm4gW3BlcmZvcm1hbmNlLnRpbWVPcmlnaW4sICd0aW1lT3JpZ2luJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbmF2aWdhdGlvblN0YXJ0LCAnbmF2aWdhdGlvblN0YXJ0J107XG4gICAgfVxuICB9XG5cbiAgLy8gRWl0aGVyIGJvdGggdGltZU9yaWdpbiBhbmQgbmF2aWdhdGlvblN0YXJ0IGFyZSBza2V3ZWQgb3IgbmVpdGhlciBpcyBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIERhdGUuXG4gIHJldHVybiBbZGF0ZU5vdywgJ2RhdGVOb3cnXTtcbn1cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaC4gVGhpcyB2YWx1ZSBpcyBvbmx5IHVzYWJsZSBpbiBhIGJyb3dzZXIsIGFuZCBvbmx5IHdoZW4gdGhlXG4gKiBwZXJmb3JtYW5jZSBBUEkgaXMgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luKCkge1xuICBpZiAoIWNhY2hlZFRpbWVPcmlnaW4pIHtcbiAgICBjYWNoZWRUaW1lT3JpZ2luID0gZ2V0QnJvd3NlclRpbWVPcmlnaW4oKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZWRUaW1lT3JpZ2luWzBdO1xufVxuXG5leHBvcnQgeyBicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luLCBkYXRlVGltZXN0YW1wSW5TZWNvbmRzLCB0aW1lc3RhbXBJblNlY29uZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUuanMubWFwXG4iLCJpbXBvcnQgeyB1dWlkNCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbWlzYy5qcyc7XG5pbXBvcnQgeyB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuL3V0aWxzLWhvaXN0L3RpbWUuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFNlc3Npb25gIG9iamVjdCBieSBzZXR0aW5nIGNlcnRhaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLiBJZiBvcHRpb25hbCBAcGFyYW0gY29udGV4dFxuICogaXMgcGFzc2VkLCB0aGUgcGFzc2VkIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIHNlc3Npb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IChvcHRpb25hbCkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHNlc3Npb24gb2JqZWN0XG4gKlxuICogQHJldHVybnMgYSBuZXcgYFNlc3Npb25gIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYWtlU2Vzc2lvbihjb250ZXh0KSB7XG4gIC8vIEJvdGggdGltZXN0YW1wIGFuZCBzdGFydGVkIGFyZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLlxuICBjb25zdCBzdGFydGluZ1RpbWUgPSB0aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICBjb25zdCBzZXNzaW9uID0ge1xuICAgIHNpZDogdXVpZDQoKSxcbiAgICBpbml0OiB0cnVlLFxuICAgIHRpbWVzdGFtcDogc3RhcnRpbmdUaW1lLFxuICAgIHN0YXJ0ZWQ6IHN0YXJ0aW5nVGltZSxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBzdGF0dXM6ICdvaycsXG4gICAgZXJyb3JzOiAwLFxuICAgIGlnbm9yZUR1cmF0aW9uOiBmYWxzZSxcbiAgICB0b0pTT046ICgpID0+IHNlc3Npb25Ub0pTT04oc2Vzc2lvbiksXG4gIH07XG5cbiAgaWYgKGNvbnRleHQpIHtcbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNlc3Npb24gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcGFzc2VkIGluIHRoZSBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBvYmplY3QgYW5kIHJldHVybnMgdm9pZC5cbiAqIChIYWQgdG8gZG8gdGhpcyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBhbmQgdXBkYXRlZCBzZXNzaW9uIGJlY2F1c2UgY2xvc2luZyBhbmQgc2VuZGluZyBhIHNlc3Npb25cbiAqIG1ha2VzIGFuIHVwZGF0ZSB0byB0aGUgc2Vzc2lvbiBhZnRlciBpdCB3YXMgcGFzc2VkIHRvIHRoZSBzZW5kaW5nIGxvZ2ljLlxuICogQHNlZSBDbGllbnQuY2FwdHVyZVNlc3Npb24gKVxuICpcbiAqIEBwYXJhbSBzZXNzaW9uIHRoZSBgU2Vzc2lvbmAgdG8gdXBkYXRlXG4gKiBAcGFyYW0gY29udGV4dCB0aGUgYFNlc3Npb25Db250ZXh0YCBob2xkaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQgaW4gQHBhcmFtIHNlc3Npb25cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwgY29udGV4dCA9IHt9KSB7XG4gIGlmIChjb250ZXh0LnVzZXIpIHtcbiAgICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQudXNlci5pcF9hZGRyZXNzKSB7XG4gICAgICBzZXNzaW9uLmlwQWRkcmVzcyA9IGNvbnRleHQudXNlci5pcF9hZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICghc2Vzc2lvbi5kaWQgJiYgIWNvbnRleHQuZGlkKSB7XG4gICAgICBzZXNzaW9uLmRpZCA9IGNvbnRleHQudXNlci5pZCB8fCBjb250ZXh0LnVzZXIuZW1haWwgfHwgY29udGV4dC51c2VyLnVzZXJuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb24udGltZXN0YW1wID0gY29udGV4dC50aW1lc3RhbXAgfHwgdGltZXN0YW1wSW5TZWNvbmRzKCk7XG5cbiAgaWYgKGNvbnRleHQuYWJub3JtYWxfbWVjaGFuaXNtKSB7XG4gICAgc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20gPSBjb250ZXh0LmFibm9ybWFsX21lY2hhbmlzbTtcbiAgfVxuXG4gIGlmIChjb250ZXh0Lmlnbm9yZUR1cmF0aW9uKSB7XG4gICAgc2Vzc2lvbi5pZ25vcmVEdXJhdGlvbiA9IGNvbnRleHQuaWdub3JlRHVyYXRpb247XG4gIH1cbiAgaWYgKGNvbnRleHQuc2lkKSB7XG4gICAgLy8gR29vZCBlbm91Z2ggdXVpZCB2YWxpZGF0aW9uLiDigJQgS2FtaWxcbiAgICBzZXNzaW9uLnNpZCA9IGNvbnRleHQuc2lkLmxlbmd0aCA9PT0gMzIgPyBjb250ZXh0LnNpZCA6IHV1aWQ0KCk7XG4gIH1cbiAgaWYgKGNvbnRleHQuaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2Vzc2lvbi5pbml0ID0gY29udGV4dC5pbml0O1xuICB9XG4gIGlmICghc2Vzc2lvbi5kaWQgJiYgY29udGV4dC5kaWQpIHtcbiAgICBzZXNzaW9uLmRpZCA9IGAke2NvbnRleHQuZGlkfWA7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0LnN0YXJ0ZWQgPT09ICdudW1iZXInKSB7XG4gICAgc2Vzc2lvbi5zdGFydGVkID0gY29udGV4dC5zdGFydGVkO1xuICB9XG4gIGlmIChzZXNzaW9uLmlnbm9yZUR1cmF0aW9uKSB7XG4gICAgc2Vzc2lvbi5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICBzZXNzaW9uLmR1cmF0aW9uID0gY29udGV4dC5kdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNlc3Npb24udGltZXN0YW1wIC0gc2Vzc2lvbi5zdGFydGVkO1xuICAgIHNlc3Npb24uZHVyYXRpb24gPSBkdXJhdGlvbiA+PSAwID8gZHVyYXRpb24gOiAwO1xuICB9XG4gIGlmIChjb250ZXh0LnJlbGVhc2UpIHtcbiAgICBzZXNzaW9uLnJlbGVhc2UgPSBjb250ZXh0LnJlbGVhc2U7XG4gIH1cbiAgaWYgKGNvbnRleHQuZW52aXJvbm1lbnQpIHtcbiAgICBzZXNzaW9uLmVudmlyb25tZW50ID0gY29udGV4dC5lbnZpcm9ubWVudDtcbiAgfVxuICBpZiAoIXNlc3Npb24uaXBBZGRyZXNzICYmIGNvbnRleHQuaXBBZGRyZXNzKSB7XG4gICAgc2Vzc2lvbi5pcEFkZHJlc3MgPSBjb250ZXh0LmlwQWRkcmVzcztcbiAgfVxuICBpZiAoIXNlc3Npb24udXNlckFnZW50ICYmIGNvbnRleHQudXNlckFnZW50KSB7XG4gICAgc2Vzc2lvbi51c2VyQWdlbnQgPSBjb250ZXh0LnVzZXJBZ2VudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRleHQuZXJyb3JzID09PSAnbnVtYmVyJykge1xuICAgIHNlc3Npb24uZXJyb3JzID0gY29udGV4dC5lcnJvcnM7XG4gIH1cbiAgaWYgKGNvbnRleHQuc3RhdHVzKSB7XG4gICAgc2Vzc2lvbi5zdGF0dXMgPSBjb250ZXh0LnN0YXR1cztcbiAgfVxufVxuXG4vKipcbiAqIENsb3NlcyBhIHNlc3Npb24gYnkgc2V0dGluZyBpdHMgc3RhdHVzIGFuZCB1cGRhdGluZyB0aGUgc2Vzc2lvbiBvYmplY3Qgd2l0aCBpdC5cbiAqIEludGVybmFsbHkgY2FsbHMgYHVwZGF0ZVNlc3Npb25gIHRvIHVwZGF0ZSB0aGUgcGFzc2VkIHNlc3Npb24gb2JqZWN0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBzZXNzaW9uIChAc2VlIHVwZGF0ZVNlc3Npb24gZm9yIGV4cGxhbmF0aW9uKS5cbiAqXG4gKiBAcGFyYW0gc2Vzc2lvbiB0aGUgYFNlc3Npb25gIG9iamVjdCB0byBiZSBjbG9zZWRcbiAqIEBwYXJhbSBzdGF0dXMgdGhlIGBTZXNzaW9uU3RhdHVzYCB3aXRoIHdoaWNoIHRoZSBzZXNzaW9uIHdhcyBjbG9zZWQuIElmIHlvdSBkb24ndCBwYXNzIGEgc3RhdHVzLFxuICogICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uIHdpbGwga2VlcCB0aGUgcHJldmlvdXNseSBzZXQgc3RhdHVzLCB1bmxlc3MgaXQgd2FzIGAnb2snYCBpbiB3aGljaCBjYXNlXG4gKiAgICAgICAgICAgICAgIGl0IGlzIGNoYW5nZWQgdG8gYCdleGl0ZWQnYC5cbiAqL1xuZnVuY3Rpb24gY2xvc2VTZXNzaW9uKHNlc3Npb24sIHN0YXR1cykge1xuICBsZXQgY29udGV4dCA9IHt9O1xuICBpZiAoc3RhdHVzKSB7XG4gICAgY29udGV4dCA9IHsgc3RhdHVzIH07XG4gIH0gZWxzZSBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09ICdvaycpIHtcbiAgICBjb250ZXh0ID0geyBzdGF0dXM6ICdleGl0ZWQnIH07XG4gIH1cblxuICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYSBwYXNzZWQgc2Vzc2lvbiBvYmplY3QgdG8gYSBKU09OIG9iamVjdCB3aXRoIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHN0cnVjdHVyZS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIFNlbnRyeSBiYWNrZW5kIHJlcXVpcmVzIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHNjaGVtYSBvZiBhIHNlc3Npb25cbiAqIHRoYW4gdGhlIG9uZSB0aGUgSlMgU0RLcyB1c2UgaW50ZXJuYWxseS5cbiAqXG4gKiBAcGFyYW0gc2Vzc2lvbiB0aGUgc2Vzc2lvbiB0byBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAcmV0dXJucyBhIEpTT04gb2JqZWN0IG9mIHRoZSBwYXNzZWQgc2Vzc2lvblxuICovXG5mdW5jdGlvbiBzZXNzaW9uVG9KU09OKHNlc3Npb24pIHtcbiAgcmV0dXJuIHtcbiAgICBzaWQ6IGAke3Nlc3Npb24uc2lkfWAsXG4gICAgaW5pdDogc2Vzc2lvbi5pbml0LFxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHNlYyBpcyBjb252ZXJ0ZWQgdG8gbXMgZm9yIGRhdGUgY29uc3RydWN0b3JcbiAgICBzdGFydGVkOiBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0ZWQgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoc2Vzc2lvbi50aW1lc3RhbXAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIHN0YXR1czogc2Vzc2lvbi5zdGF0dXMsXG4gICAgZXJyb3JzOiBzZXNzaW9uLmVycm9ycyxcbiAgICBkaWQ6IHR5cGVvZiBzZXNzaW9uLmRpZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNlc3Npb24uZGlkID09PSAnc3RyaW5nJyA/IGAke3Nlc3Npb24uZGlkfWAgOiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IHNlc3Npb24uZHVyYXRpb24sXG4gICAgYWJub3JtYWxfbWVjaGFuaXNtOiBzZXNzaW9uLmFibm9ybWFsX21lY2hhbmlzbSxcbiAgICBhdHRyczoge1xuICAgICAgcmVsZWFzZTogc2Vzc2lvbi5yZWxlYXNlLFxuICAgICAgZW52aXJvbm1lbnQ6IHNlc3Npb24uZW52aXJvbm1lbnQsXG4gICAgICBpcF9hZGRyZXNzOiBzZXNzaW9uLmlwQWRkcmVzcyxcbiAgICAgIHVzZXJfYWdlbnQ6IHNlc3Npb24udXNlckFnZW50LFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCB7IGNsb3NlU2Vzc2lvbiwgbWFrZVNlc3Npb24sIHVwZGF0ZVNlc3Npb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwXG4iLCJpbXBvcnQgeyB1dWlkNCB9IGZyb20gJy4vbWlzYy5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20sIHZhbGlkIHRyYWNlIElELlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRyYWNlSWQoKSB7XG4gIHJldHVybiB1dWlkNCgpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tLCB2YWxpZCBzcGFuIElELlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNwYW5JZCgpIHtcbiAgcmV0dXJuIHV1aWQ0KCkuc3Vic3RyaW5nKDE2KTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVTcGFuSWQsIGdlbmVyYXRlVHJhY2VJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGFnYXRpb25Db250ZXh0LmpzLm1hcFxuIiwiLyoqXG4gKiBTaGFsbG93IG1lcmdlIHR3byBvYmplY3RzLlxuICogRG9lcyBub3QgbXV0YXRlIHRoZSBwYXNzZWQgaW4gb2JqZWN0cy5cbiAqIFVuZGVmaW5lZC9lbXB0eSB2YWx1ZXMgaW4gdGhlIG1lcmdlIG9iamVjdCB3aWxsIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhpcyBtZXJnZXMgMiBsZXZlbHMgZGVlcC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2UoaW5pdGlhbE9iaiwgbWVyZ2VPYmosIGxldmVscyA9IDIpIHtcbiAgLy8gSWYgdGhlIG1lcmdlIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QsIG9yIHdlIGhhdmUgbm8gbWVyZ2UgbGV2ZWxzIGxlZnQsXG4gIC8vIHdlIGp1c3Qgc2V0IHRoZSB2YWx1ZSB0byB0aGUgbWVyZ2UgdmFsdWVcbiAgaWYgKCFtZXJnZU9iaiB8fCB0eXBlb2YgbWVyZ2VPYmogIT09ICdvYmplY3QnIHx8IGxldmVscyA8PSAwKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqO1xuICB9XG5cbiAgLy8gSWYgdGhlIG1lcmdlIG9iamVjdCBpcyBhbiBlbXB0eSBvYmplY3QsIGFuZCB0aGUgaW5pdGlhbCBvYmplY3QgaXMgbm90IHVuZGVmaW5lZCwgd2UgcmV0dXJuIHRoZSBpbml0aWFsIG9iamVjdFxuICBpZiAoaW5pdGlhbE9iaiAmJiBPYmplY3Qua2V5cyhtZXJnZU9iaikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGluaXRpYWxPYmo7XG4gIH1cblxuICAvLyBDbG9uZSBvYmplY3RcbiAgY29uc3Qgb3V0cHV0ID0geyAuLi5pbml0aWFsT2JqIH07XG5cbiAgLy8gTWVyZ2UgdmFsdWVzIGludG8gb3V0cHV0LCByZXN1cnNpdmVseVxuICBmb3IgKGNvbnN0IGtleSBpbiBtZXJnZU9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWVyZ2VPYmosIGtleSkpIHtcbiAgICAgIG91dHB1dFtrZXldID0gbWVyZ2Uob3V0cHV0W2tleV0sIG1lcmdlT2JqW2tleV0sIGxldmVscyAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmV4cG9ydCB7IG1lcmdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS5qcy5tYXBcbiIsImltcG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcyc7XG5cbmNvbnN0IFNDT1BFX1NQQU5fRklFTEQgPSAnX3NlbnRyeVNwYW4nO1xuXG4vKipcbiAqIFNldCB0aGUgYWN0aXZlIHNwYW4gZm9yIGEgZ2l2ZW4gc2NvcGUuXG4gKiBOT1RFOiBUaGlzIHNob3VsZCBOT1QgYmUgdXNlZCBkaXJlY3RseSwgYnV0IGlzIG9ubHkgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSB0cmFjZSBtZXRob2RzLlxuICovXG5mdW5jdGlvbiBfc2V0U3BhbkZvclNjb3BlKHNjb3BlLCBzcGFuKSB7XG4gIGlmIChzcGFuKSB7XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNjb3BlICwgU0NPUEVfU1BBTl9GSUVMRCwgc3Bhbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgIGRlbGV0ZSAoc2NvcGUgKVtTQ09QRV9TUEFOX0ZJRUxEXTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgYWN0aXZlIHNwYW4gZm9yIGEgZ2l2ZW4gc2NvcGUuXG4gKiBOT1RFOiBUaGlzIHNob3VsZCBOT1QgYmUgdXNlZCBkaXJlY3RseSwgYnV0IGlzIG9ubHkgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSB0cmFjZSBtZXRob2RzLlxuICovXG5mdW5jdGlvbiBfZ2V0U3BhbkZvclNjb3BlKHNjb3BlKSB7XG4gIHJldHVybiBzY29wZVtTQ09QRV9TUEFOX0ZJRUxEXTtcbn1cblxuZXhwb3J0IHsgX2dldFNwYW5Gb3JTY29wZSwgX3NldFNwYW5Gb3JTY29wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Bhbk9uU2NvcGUuanMubWFwXG4iLCJpbXBvcnQgeyB1cGRhdGVTZXNzaW9uIH0gZnJvbSAnLi9zZXNzaW9uLmpzJztcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2lzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHV1aWQ0IH0gZnJvbSAnLi91dGlscy1ob2lzdC9taXNjLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVHJhY2VJZCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvcHJvcGFnYXRpb25Db250ZXh0LmpzJztcbmltcG9ydCB7IHRydW5jYXRlIH0gZnJvbSAnLi91dGlscy1ob2lzdC9zdHJpbmcuanMnO1xuaW1wb3J0IHsgZGF0ZVRpbWVzdGFtcEluU2Vjb25kcyB9IGZyb20gJy4vdXRpbHMtaG9pc3QvdGltZS5qcyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJy4vdXRpbHMvbWVyZ2UuanMnO1xuaW1wb3J0IHsgX3NldFNwYW5Gb3JTY29wZSwgX2dldFNwYW5Gb3JTY29wZSB9IGZyb20gJy4vdXRpbHMvc3Bhbk9uU2NvcGUuanMnO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWUgZm9yIG1heGltdW0gbnVtYmVyIG9mIGJyZWFkY3J1bWJzIGFkZGVkIHRvIGFuIGV2ZW50LlxuICovXG5jb25zdCBERUZBVUxUX01BWF9CUkVBRENSVU1CUyA9IDEwMDtcblxuLyoqXG4gKiBBIGNvbnRleHQgdG8gYmUgdXNlZCBmb3IgY2FwdHVyaW5nIGFuIGV2ZW50LlxuICogVGhpcyBjYW4gZWl0aGVyIGJlIGEgU2NvcGUsIG9yIGEgcGFydGlhbCBTY29wZUNvbnRleHQsXG4gKiBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHJldHVybnMgYSBuZXcgc2NvcGUgdG8gdXNlLlxuICovXG5cbi8qKlxuICogSG9sZHMgYWRkaXRpb25hbCBldmVudCBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgU2NvcGUge1xuICAvKiogRmxhZyBpZiBub3RpZnlpbmcgaXMgaGFwcGVuaW5nLiAqL1xuXG4gIC8qKiBDYWxsYmFjayBmb3IgY2xpZW50IHRvIHJlY2VpdmUgc2NvcGUgY2hhbmdlcy4gKi9cblxuICAvKiogQ2FsbGJhY2sgbGlzdCB0aGF0IHdpbGwgYmUgY2FsbGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nLiAqL1xuXG4gIC8qKiBBcnJheSBvZiBicmVhZGNydW1icy4gKi9cblxuICAvKiogVXNlciAqL1xuXG4gIC8qKiBUYWdzICovXG5cbiAgLyoqIEV4dHJhICovXG5cbiAgLyoqIENvbnRleHRzICovXG5cbiAgLyoqIEF0dGFjaG1lbnRzICovXG5cbiAgLyoqIFByb3BhZ2F0aW9uIENvbnRleHQgZm9yIGRpc3RyaWJ1dGVkIHRyYWNpbmcgKi9cblxuICAvKipcbiAgICogQSBwbGFjZSB0byBzdGFzaCBkYXRhIHdoaWNoIGlzIG5lZWRlZCBhdCBzb21lIHBvaW50IGluIHRoZSBTREsncyBldmVudCBwcm9jZXNzaW5nIHBpcGVsaW5lIGJ1dCB3aGljaCBzaG91bGRuJ3QgZ2V0XG4gICAqIHNlbnQgdG8gU2VudHJ5XG4gICAqL1xuXG4gIC8qKiBGaW5nZXJwcmludCAqL1xuXG4gIC8qKiBTZXZlcml0eSAqL1xuXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBOYW1lXG4gICAqXG4gICAqIElNUE9SVEFOVDogVGhlIHRyYW5zYWN0aW9uIG5hbWUgb24gdGhlIHNjb3BlIGhhcyBub3RoaW5nIHRvIGRvIHdpdGggcm9vdCBzcGFucy90cmFuc2FjdGlvbiBvYmplY3RzLlxuICAgKiBJdCdzIHB1cnBvc2UgaXMgdG8gYXNzaWduIGEgdHJhbnNhY3Rpb24gdG8gdGhlIHNjb3BlIHRoYXQncyBhZGRlZCB0byBub24tdHJhbnNhY3Rpb24gZXZlbnRzLlxuICAgKi9cblxuICAvKiogU2Vzc2lvbiAqL1xuXG4gIC8qKiBUaGUgY2xpZW50IG9uIHRoaXMgc2NvcGUgKi9cblxuICAvKiogQ29udGFpbnMgdGhlIGxhc3QgZXZlbnQgaWQgb2YgYSBjYXB0dXJlZCBldmVudC4gICovXG5cbiAgLy8gTk9URTogQW55IGZpZWxkIHdoaWNoIGdldHMgYWRkZWQgaGVyZSBzaG91bGQgZ2V0IGFkZGVkIG5vdCBvbmx5IHRvIHRoZSBjb25zdHJ1Y3RvciBidXQgYWxzbyB0byB0aGUgYGNsb25lYCBtZXRob2QuXG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IGZhbHNlO1xuICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdO1xuICAgIHRoaXMuX3VzZXIgPSB7fTtcbiAgICB0aGlzLl90YWdzID0ge307XG4gICAgdGhpcy5fZXh0cmEgPSB7fTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHt9O1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHtcbiAgICAgIHRyYWNlSWQ6IGdlbmVyYXRlVHJhY2VJZCgpLFxuICAgICAgc2FtcGxlUmFuZDogTWF0aC5yYW5kb20oKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIGFsbCBkYXRhIGZyb20gdGhpcyBzY29wZSBpbnRvIGEgbmV3IHNjb3BlLlxuICAgKi9cbiAgIGNsb25lKCkge1xuICAgIGNvbnN0IG5ld1Njb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgbmV3U2NvcGUuX2JyZWFkY3J1bWJzID0gWy4uLnRoaXMuX2JyZWFkY3J1bWJzXTtcbiAgICBuZXdTY29wZS5fdGFncyA9IHsgLi4udGhpcy5fdGFncyB9O1xuICAgIG5ld1Njb3BlLl9leHRyYSA9IHsgLi4udGhpcy5fZXh0cmEgfTtcbiAgICBuZXdTY29wZS5fY29udGV4dHMgPSB7IC4uLnRoaXMuX2NvbnRleHRzIH07XG4gICAgaWYgKHRoaXMuX2NvbnRleHRzLmZsYWdzKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNvcHkgdGhlIGB2YWx1ZXNgIGFycmF5IHNvIGluc2VydGlvbnMgb24gYSBjbG9uZWQgc2NvcGVcbiAgICAgIC8vIHdvbid0IGFmZmVjdCB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gICAgICBuZXdTY29wZS5fY29udGV4dHMuZmxhZ3MgPSB7XG4gICAgICAgIHZhbHVlczogWy4uLnRoaXMuX2NvbnRleHRzLmZsYWdzLnZhbHVlc10sXG4gICAgICB9O1xuICAgIH1cblxuICAgIG5ld1Njb3BlLl91c2VyID0gdGhpcy5fdXNlcjtcbiAgICBuZXdTY29wZS5fbGV2ZWwgPSB0aGlzLl9sZXZlbDtcbiAgICBuZXdTY29wZS5fc2Vzc2lvbiA9IHRoaXMuX3Nlc3Npb247XG4gICAgbmV3U2NvcGUuX3RyYW5zYWN0aW9uTmFtZSA9IHRoaXMuX3RyYW5zYWN0aW9uTmFtZTtcbiAgICBuZXdTY29wZS5fZmluZ2VycHJpbnQgPSB0aGlzLl9maW5nZXJwcmludDtcbiAgICBuZXdTY29wZS5fZXZlbnRQcm9jZXNzb3JzID0gWy4uLnRoaXMuX2V2ZW50UHJvY2Vzc29yc107XG4gICAgbmV3U2NvcGUuX2F0dGFjaG1lbnRzID0gWy4uLnRoaXMuX2F0dGFjaG1lbnRzXTtcbiAgICBuZXdTY29wZS5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0geyAuLi50aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgfTtcbiAgICBuZXdTY29wZS5fcHJvcGFnYXRpb25Db250ZXh0ID0geyAuLi50aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgfTtcbiAgICBuZXdTY29wZS5fY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuICAgIG5ld1Njb3BlLl9sYXN0RXZlbnRJZCA9IHRoaXMuX2xhc3RFdmVudElkO1xuXG4gICAgX3NldFNwYW5Gb3JTY29wZShuZXdTY29wZSwgX2dldFNwYW5Gb3JTY29wZSh0aGlzKSk7XG5cbiAgICByZXR1cm4gbmV3U2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjbGllbnQgYXNzaWduZWQgdG8gdGhpcyBzY29wZS5cbiAgICogTm90ZSB0aGF0IG5vdCBldmVyeSBzY29wZSB3aWxsIGhhdmUgYSBjbGllbnQgYXNzaWduZWQgLSBpc29sYXRpb24gc2NvcGVzICYgdGhlIGdsb2JhbCBzY29wZSB3aWxsIGdlbmVyYWxseSBub3QgaGF2ZSBhIGNsaWVudCxcbiAgICogYXMgd2VsbCBhcyBtYW51YWxseSBjcmVhdGVkIHNjb3Blcy5cbiAgICovXG4gICBzZXRDbGllbnQoY2xpZW50KSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgSUQgb2YgdGhlIGxhc3QgY2FwdHVyZWQgZXJyb3IgZXZlbnQuXG4gICAqIFRoaXMgaXMgZ2VuZXJhbGx5IG9ubHkgY2FwdHVyZWQgb24gdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAgICovXG4gICBzZXRMYXN0RXZlbnRJZChsYXN0RXZlbnRJZCkge1xuICAgIHRoaXMuX2xhc3RFdmVudElkID0gbGFzdEV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjbGllbnQgYXNzaWduZWQgdG8gdGhpcyBzY29wZS5cbiAgICovXG4gICBnZXRDbGllbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudCA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBJRCBvZiB0aGUgbGFzdCBjYXB0dXJlZCBlcnJvciBldmVudC5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgb25seSBhdmFpbGFibGUgb24gdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAgICovXG4gICBsYXN0RXZlbnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdEV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBhZGRTY29wZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fc2NvcGVMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IHByb2Nlc3NvciB0aGF0IHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhbiBldmVudCBpcyBzZW50LlxuICAgKi9cbiAgIGFkZEV2ZW50UHJvY2Vzc29yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlciBmb3IgdGhpcyBzY29wZS5cbiAgICogU2V0IHRvIGBudWxsYCB0byB1bnNldCB0aGUgdXNlci5cbiAgICovXG4gICBzZXRVc2VyKHVzZXIpIHtcbiAgICAvLyBJZiBudWxsIGlzIHBhc3NlZCB3ZSB3YW50IHRvIHVuc2V0IGV2ZXJ5dGhpbmcsIGJ1dCBzdGlsbCBkZWZpbmUga2V5cyxcbiAgICAvLyBzbyB0aGF0IGxhdGVyIGRvd24gaW4gdGhlIHBpcGVsaW5lIGFueSBleGlzdGluZyB2YWx1ZXMgYXJlIGNsZWFyZWQuXG4gICAgdGhpcy5fdXNlciA9IHVzZXIgfHwge1xuICAgICAgZW1haWw6IHVuZGVmaW5lZCxcbiAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICBpcF9hZGRyZXNzOiB1bmRlZmluZWQsXG4gICAgICB1c2VybmFtZTogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fc2Vzc2lvbikge1xuICAgICAgdXBkYXRlU2Vzc2lvbih0aGlzLl9zZXNzaW9uLCB7IHVzZXIgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgZnJvbSB0aGlzIHNjb3BlLlxuICAgKi9cbiAgIGdldFVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludG8gZXhpc3RpbmcgdGFncyBvbiB0aGUgc2NvcGUsXG4gICAqIGFuZCB3aWxsIGJlIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgIHNldFRhZ3ModGFncykge1xuICAgIHRoaXMuX3RhZ3MgPSB7XG4gICAgICAuLi50aGlzLl90YWdzLFxuICAgICAgLi4udGFncyxcbiAgICB9O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgc2luZ2xlIHRhZyB0aGF0IHdpbGwgYmUgc2VudCBhcyB0YWdzIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICAgc2V0VGFnKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl90YWdzID0geyAuLi50aGlzLl90YWdzLCBba2V5XTogdmFsdWUgfTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCBpbnRvIGV4aXN0aW5nIGV4dHJhIG9uIHRoZSBzY29wZSxcbiAgICogYW5kIHdpbGwgYmUgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICAgKi9cbiAgIHNldEV4dHJhcyhleHRyYXMpIHtcbiAgICB0aGlzLl9leHRyYSA9IHtcbiAgICAgIC4uLnRoaXMuX2V4dHJhLFxuICAgICAgLi4uZXh0cmFzLFxuICAgIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBzaW5nbGUga2V5OnZhbHVlIGV4dHJhIGVudHJ5IHRoYXQgd2lsbCBiZSBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gICAqL1xuICAgc2V0RXh0cmEoa2V5LCBleHRyYSkge1xuICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgW2tleV06IGV4dHJhIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaW5nZXJwcmludCBvbiB0aGUgc2NvcGUgdG8gc2VuZCB3aXRoIHRoZSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbmdlcnByaW50IEZpbmdlcnByaW50IHRvIGdyb3VwIGV2ZW50cyBpbiBTZW50cnkuXG4gICAqL1xuICAgc2V0RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGV2ZWwgb24gdGhlIHNjb3BlIGZvciBmdXR1cmUgZXZlbnRzLlxuICAgKi9cbiAgIHNldExldmVsKGxldmVsKSB7XG4gICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRyYW5zYWN0aW9uIG5hbWUgb24gdGhlIHNjb3BlIHNvIHRoYXQgdGhlIG5hbWUgb2YgZS5nLiB0YWtlbiBzZXJ2ZXIgcm91dGUgb3JcbiAgICogdGhlIHBhZ2UgbG9jYXRpb24gaXMgYXR0YWNoZWQgdG8gZnV0dXJlIGV2ZW50cy5cbiAgICpcbiAgICogSU1QT1JUQU5UOiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBOT1QgY2hhbmdlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICAqIHJvb3Qgc3Bhbi4gSWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBuYW1lIG9mIHRoZSBhY3RpdmUgcm9vdCBzcGFuLCB1c2VcbiAgICogYFNlbnRyeS51cGRhdGVTcGFuTmFtZShyb290U3BhbiwgJ25ldyBuYW1lJylgIGluc3RlYWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBTREsgdXBkYXRlcyB0aGUgc2NvcGUncyB0cmFuc2FjdGlvbiBuYW1lIGF1dG9tYXRpY2FsbHkgb24gc2Vuc2libGVcbiAgICogb2NjYXNpb25zLCBzdWNoIGFzIGEgcGFnZSBuYXZpZ2F0aW9uIG9yIHdoZW4gaGFuZGxpbmcgYSBuZXcgcmVxdWVzdCBvbiB0aGUgc2VydmVyLlxuICAgKi9cbiAgIHNldFRyYW5zYWN0aW9uTmFtZShuYW1lKSB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25OYW1lID0gbmFtZTtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgY29udGV4dCBkYXRhIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqIERhdGEgcGFzc2VkIGFzIGNvbnRleHQgd2lsbCBiZSBub3JtYWxpemVkLiBZb3UgY2FuIGFsc28gcGFzcyBgbnVsbGAgdG8gdW5zZXQgdGhlIGNvbnRleHQuXG4gICAqIE5vdGUgdGhhdCBjb250ZXh0IGRhdGEgd2lsbCBub3QgYmUgbWVyZ2VkIC0gY2FsbGluZyBgc2V0Q29udGV4dGAgd2lsbCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgY29udGV4dCB3aXRoIHRoZSBzYW1lIGtleS5cbiAgICovXG4gICBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICBkZWxldGUgdGhpcy5fY29udGV4dHNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29udGV4dHNba2V5XSA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlc3Npb24gZm9yIHRoZSBzY29wZS5cbiAgICovXG4gICBzZXRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgc2NvcGUuXG4gICAqL1xuICAgZ2V0U2Vzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzY29wZSB3aXRoIHByb3ZpZGVkIGRhdGEuIENhbiB3b3JrIGluIHRocmVlIHZhcmlhdGlvbnM6XG4gICAqIC0gcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdXBkYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICogLSBTY29wZSBpbnN0YW5jZSB0aGF0J2xsIGV4dHJhY3QgdGhlIGF0dHJpYnV0ZXMgZnJvbVxuICAgKiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQnbGwgcmVjZWl2ZSB0aGUgY3VycmVudCBzY29wZSBhcyBhbiBhcmd1bWVudCBhbmQgYWxsb3cgZm9yIG1vZGlmaWNhdGlvbnNcbiAgICovXG4gICB1cGRhdGUoY2FwdHVyZUNvbnRleHQpIHtcbiAgICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZVRvTWVyZ2UgPSB0eXBlb2YgY2FwdHVyZUNvbnRleHQgPT09ICdmdW5jdGlvbicgPyBjYXB0dXJlQ29udGV4dCh0aGlzKSA6IGNhcHR1cmVDb250ZXh0O1xuXG4gICAgY29uc3Qgc2NvcGVJbnN0YW5jZSA9XG4gICAgICBzY29wZVRvTWVyZ2UgaW5zdGFuY2VvZiBTY29wZVxuICAgICAgICA/IHNjb3BlVG9NZXJnZS5nZXRTY29wZURhdGEoKVxuICAgICAgICA6IGlzUGxhaW5PYmplY3Qoc2NvcGVUb01lcmdlKVxuICAgICAgICAgID8gKGNhcHR1cmVDb250ZXh0IClcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHsgdGFncywgZXh0cmEsIHVzZXIsIGNvbnRleHRzLCBsZXZlbCwgZmluZ2VycHJpbnQgPSBbXSwgcHJvcGFnYXRpb25Db250ZXh0IH0gPSBzY29wZUluc3RhbmNlIHx8IHt9O1xuXG4gICAgdGhpcy5fdGFncyA9IHsgLi4udGhpcy5fdGFncywgLi4udGFncyB9O1xuICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgLi4uZXh0cmEgfTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHsgLi4udGhpcy5fY29udGV4dHMsIC4uLmNvbnRleHRzIH07XG5cbiAgICBpZiAodXNlciAmJiBPYmplY3Qua2V5cyh1c2VyKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgIH1cblxuICAgIGlmIChsZXZlbCkge1xuICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICB9XG5cbiAgICBpZiAoZmluZ2VycHJpbnQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuICAgIH1cblxuICAgIGlmIChwcm9wYWdhdGlvbkNvbnRleHQpIHtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHByb3BhZ2F0aW9uQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHJlc2V0cyBpdHMgcHJvcGVydGllcy5cbiAgICogTm90ZTogVGhlIGNsaWVudCB3aWxsIG5vdCBiZSBjbGVhcmVkLlxuICAgKi9cbiAgIGNsZWFyKCkge1xuICAgIC8vIGNsaWVudCBpcyBub3QgY2xlYXJlZCBoZXJlIG9uIHB1cnBvc2UhXG4gICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICB0aGlzLl90YWdzID0ge307XG4gICAgdGhpcy5fZXh0cmEgPSB7fTtcbiAgICB0aGlzLl91c2VyID0ge307XG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9sZXZlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90cmFuc2FjdGlvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICBfc2V0U3BhbkZvclNjb3BlKHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fYXR0YWNobWVudHMgPSBbXTtcbiAgICB0aGlzLnNldFByb3BhZ2F0aW9uQ29udGV4dCh7IHRyYWNlSWQ6IGdlbmVyYXRlVHJhY2VJZCgpLCBzYW1wbGVSYW5kOiBNYXRoLnJhbmRvbSgpIH0pO1xuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgYnJlYWRjcnVtYiB0byB0aGUgc2NvcGUuXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBsYXN0IDEwMCBicmVhZGNydW1icyBhcmUga2VwdC5cbiAgICovXG4gICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIG1heEJyZWFkY3J1bWJzKSB7XG4gICAgY29uc3QgbWF4Q3J1bWJzID0gdHlwZW9mIG1heEJyZWFkY3J1bWJzID09PSAnbnVtYmVyJyA/IG1heEJyZWFkY3J1bWJzIDogREVGQVVMVF9NQVhfQlJFQURDUlVNQlM7XG5cbiAgICAvLyBObyBkYXRhIGhhcyBiZWVuIGNoYW5nZWQsIHNvIGRvbid0IG5vdGlmeSBzY29wZSBsaXN0ZW5lcnNcbiAgICBpZiAobWF4Q3J1bWJzIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWIgPSB7XG4gICAgICB0aW1lc3RhbXA6IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgICAgIC4uLmJyZWFkY3J1bWIsXG4gICAgICAvLyBCcmVhZGNydW1iIG1lc3NhZ2VzIGNhbiB0aGVvcmV0aWNhbGx5IGJlIGluZmluaXRlbHkgbGFyZ2UgYW5kIHRoZXkncmUgaGVsZCBpbiBtZW1vcnkgc28gd2UgdHJ1bmNhdGUgdGhlbSBub3QgdG8gbGVhayAodG9vIG11Y2gpIG1lbW9yeVxuICAgICAgbWVzc2FnZTogYnJlYWRjcnVtYi5tZXNzYWdlID8gdHJ1bmNhdGUoYnJlYWRjcnVtYi5tZXNzYWdlLCAyMDQ4KSA6IGJyZWFkY3J1bWIubWVzc2FnZSxcbiAgICB9O1xuXG4gICAgdGhpcy5fYnJlYWRjcnVtYnMucHVzaChtZXJnZWRCcmVhZGNydW1iKTtcbiAgICBpZiAodGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoID4gbWF4Q3J1bWJzKSB7XG4gICAgICB0aGlzLl9icmVhZGNydW1icyA9IHRoaXMuX2JyZWFkY3J1bWJzLnNsaWNlKC1tYXhDcnVtYnMpO1xuICAgICAgdGhpcy5fY2xpZW50Py5yZWNvcmREcm9wcGVkRXZlbnQoJ2J1ZmZlcl9vdmVyZmxvdycsICdsb2dfaXRlbScpO1xuICAgIH1cblxuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3QgYnJlYWRjcnVtYiBvZiB0aGUgc2NvcGUuXG4gICAqL1xuICAgZ2V0TGFzdEJyZWFkY3J1bWIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyZWFkY3J1bWJzW3RoaXMuX2JyZWFkY3J1bWJzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBicmVhZGNydW1icyBmcm9tIHRoZSBzY29wZS5cbiAgICovXG4gICBjbGVhckJyZWFkY3J1bWJzKCkge1xuICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gW107XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gYXR0YWNobWVudCB0byB0aGUgc2NvcGUuXG4gICAqL1xuICAgYWRkQXR0YWNobWVudChhdHRhY2htZW50KSB7XG4gICAgdGhpcy5fYXR0YWNobWVudHMucHVzaChhdHRhY2htZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgYXR0YWNobWVudHMgZnJvbSB0aGUgc2NvcGUuXG4gICAqL1xuICAgY2xlYXJBdHRhY2htZW50cygpIHtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSBvZiB0aGlzIHNjb3BlLCB3aGljaCBzaG91bGQgYmUgYXBwbGllZCB0byBhbiBldmVudCBkdXJpbmcgcHJvY2Vzc2luZy5cbiAgICovXG4gICBnZXRTY29wZURhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyZWFkY3J1bWJzOiB0aGlzLl9icmVhZGNydW1icyxcbiAgICAgIGF0dGFjaG1lbnRzOiB0aGlzLl9hdHRhY2htZW50cyxcbiAgICAgIGNvbnRleHRzOiB0aGlzLl9jb250ZXh0cyxcbiAgICAgIHRhZ3M6IHRoaXMuX3RhZ3MsXG4gICAgICBleHRyYTogdGhpcy5fZXh0cmEsXG4gICAgICB1c2VyOiB0aGlzLl91c2VyLFxuICAgICAgbGV2ZWw6IHRoaXMuX2xldmVsLFxuICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuX2ZpbmdlcnByaW50IHx8IFtdLFxuICAgICAgZXZlbnRQcm9jZXNzb3JzOiB0aGlzLl9ldmVudFByb2Nlc3NvcnMsXG4gICAgICBwcm9wYWdhdGlvbkNvbnRleHQ6IHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCxcbiAgICAgIHNka1Byb2Nlc3NpbmdNZXRhZGF0YTogdGhpcy5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgICAgdHJhbnNhY3Rpb25OYW1lOiB0aGlzLl90cmFuc2FjdGlvbk5hbWUsXG4gICAgICBzcGFuOiBfZ2V0U3BhbkZvclNjb3BlKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGRhdGEgd2hpY2ggd2lsbCBiZSBhY2Nlc3NpYmxlIGR1cmluZyBldmVudCBwcm9jZXNzaW5nIGJ1dCB3b24ndCBnZXQgc2VudCB0byBTZW50cnkuXG4gICAqL1xuICAgc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKG5ld0RhdGEpIHtcbiAgICB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSBtZXJnZSh0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEsIG5ld0RhdGEsIDIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwcm9wYWdhdGlvbiBjb250ZXh0IHRvIHRoZSBzY29wZSwgdXNlZCBmb3IgZGlzdHJpYnV0ZWQgdHJhY2luZ1xuICAgKi9cbiAgIHNldFByb3BhZ2F0aW9uQ29udGV4dChjb250ZXh0KSB7XG4gICAgdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHJvcGFnYXRpb24gY29udGV4dCBmcm9tIHRoZSBzY29wZSwgdXNlZCBmb3IgZGlzdHJpYnV0ZWQgdHJhY2luZ1xuICAgKi9cbiAgIGdldFByb3BhZ2F0aW9uQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYW4gZXhjZXB0aW9uIGZvciB0aGlzIHNjb3BlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIGNhcHR1cmVkIFNlbnRyeSBldmVudC5cbiAgICovXG4gICBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50Py5ldmVudF9pZCB8fCB1dWlkNCgpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGllbnQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXhjZXB0aW9uIScpO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ludGhldGljRXhjZXB0aW9uID0gbmV3IEVycm9yKCdTZW50cnkgc3ludGhldGljRXhjZXB0aW9uJyk7XG5cbiAgICB0aGlzLl9jbGllbnQuY2FwdHVyZUV4Y2VwdGlvbihcbiAgICAgIGV4Y2VwdGlvbixcbiAgICAgIHtcbiAgICAgICAgb3JpZ2luYWxFeGNlcHRpb246IGV4Y2VwdGlvbixcbiAgICAgICAgc3ludGhldGljRXhjZXB0aW9uLFxuICAgICAgICAuLi5oaW50LFxuICAgICAgICBldmVudF9pZDogZXZlbnRJZCxcbiAgICAgIH0sXG4gICAgICB0aGlzLFxuICAgICk7XG5cbiAgICByZXR1cm4gZXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGEgbWVzc2FnZSBmb3IgdGhpcyBzY29wZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBtZXNzYWdlLlxuICAgKi9cbiAgIGNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGxldmVsLCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGhpbnQ/LmV2ZW50X2lkIHx8IHV1aWQ0KCk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBtZXNzYWdlIScpO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ludGhldGljRXhjZXB0aW9uID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5fY2xpZW50LmNhcHR1cmVNZXNzYWdlKFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGxldmVsLFxuICAgICAge1xuICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogbWVzc2FnZSxcbiAgICAgICAgc3ludGhldGljRXhjZXB0aW9uLFxuICAgICAgICAuLi5oaW50LFxuICAgICAgICBldmVudF9pZDogZXZlbnRJZCxcbiAgICAgIH0sXG4gICAgICB0aGlzLFxuICAgICk7XG5cbiAgICByZXR1cm4gZXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGEgU2VudHJ5IGV2ZW50IGZvciB0aGlzIHNjb3BlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIGNhcHR1cmVkIGV2ZW50LlxuICAgKi9cbiAgIGNhcHR1cmVFdmVudChldmVudCwgaGludCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50Py5ldmVudF9pZCB8fCB1dWlkNCgpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGllbnQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXZlbnQhJyk7XG4gICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnQuY2FwdHVyZUV2ZW50KGV2ZW50LCB7IC4uLmhpbnQsIGV2ZW50X2lkOiBldmVudElkIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIGV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBzZXQgY2FsbC5cbiAgICovXG4gICBfbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKSB7XG4gICAgLy8gV2UgbmVlZCB0aGlzIGNoZWNrIGZvciB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgdG8gYmUgYWJsZSB0byB3b3JrIG9uIHNjb3BlIGR1cmluZyB1cGRhdGVzXG4gICAgLy8gSWYgdGhpcyBjaGVjayBpcyBub3QgaGVyZSB3ZSdsbCBwcm9kdWNlIGVuZGxlc3MgcmVjdXJzaW9uIHdoZW4gc29tZXRoaW5nIGlzIGRvbmUgd2l0aCB0aGUgc2NvcGVcbiAgICAvLyBkdXJpbmcgdGhlIGNhbGxiYWNrLlxuICAgIGlmICghdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgdGhpcy5fc2NvcGVMaXN0ZW5lcnMuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgU2NvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0R2xvYmFsU2luZ2xldG9uIH0gZnJvbSAnLi9jYXJyaWVyLmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi9zY29wZS5qcyc7XG5cbi8qKiBHZXQgdGhlIGRlZmF1bHQgY3VycmVudCBzY29wZS4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBnZXRHbG9iYWxTaW5nbGV0b24oJ2RlZmF1bHRDdXJyZW50U2NvcGUnLCAoKSA9PiBuZXcgU2NvcGUoKSk7XG59XG5cbi8qKiBHZXQgdGhlIGRlZmF1bHQgaXNvbGF0aW9uIHNjb3BlLiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCkge1xuICByZXR1cm4gZ2V0R2xvYmFsU2luZ2xldG9uKCdkZWZhdWx0SXNvbGF0aW9uU2NvcGUnLCAoKSA9PiBuZXcgU2NvcGUoKSk7XG59XG5cbmV4cG9ydCB7IGdldERlZmF1bHRDdXJyZW50U2NvcGUsIGdldERlZmF1bHRJc29sYXRpb25TY29wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdFNjb3Blcy5qcy5tYXBcbiIsImltcG9ydCB7IGdldERlZmF1bHRDdXJyZW50U2NvcGUsIGdldERlZmF1bHRJc29sYXRpb25TY29wZSB9IGZyb20gJy4uL2RlZmF1bHRTY29wZXMuanMnO1xuaW1wb3J0IHsgU2NvcGUgfSBmcm9tICcuLi9zY29wZS5qcyc7XG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvaXMuanMnO1xuaW1wb3J0IHsgZ2V0TWFpbkNhcnJpZXIsIGdldFNlbnRyeUNhcnJpZXIgfSBmcm9tICcuLi9jYXJyaWVyLmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIGFuIG9iamVjdCB0aGF0IGhvbGRzIGEgc3RhY2sgb2Ygc2NvcGVzLlxuICovXG5jbGFzcyBBc3luY0NvbnRleHRTdGFjayB7XG5cbiAgIGNvbnN0cnVjdG9yKHNjb3BlLCBpc29sYXRpb25TY29wZSkge1xuICAgIGxldCBhc3NpZ25lZFNjb3BlO1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGFzc2lnbmVkU2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduZWRTY29wZSA9IHNjb3BlO1xuICAgIH1cblxuICAgIGxldCBhc3NpZ25lZElzb2xhdGlvblNjb3BlO1xuICAgIGlmICghaXNvbGF0aW9uU2NvcGUpIHtcbiAgICAgIGFzc2lnbmVkSXNvbGF0aW9uU2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduZWRJc29sYXRpb25TY29wZSA9IGlzb2xhdGlvblNjb3BlO1xuICAgIH1cblxuICAgIC8vIHNjb3BlIHN0YWNrIGZvciBkb21haW5zIG9yIHRoZSBwcm9jZXNzXG4gICAgdGhpcy5fc3RhY2sgPSBbeyBzY29wZTogYXNzaWduZWRTY29wZSB9XTtcbiAgICB0aGlzLl9pc29sYXRpb25TY29wZSA9IGFzc2lnbmVkSXNvbGF0aW9uU2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogRm9yayBhIHNjb3BlIGZvciB0aGUgc3RhY2suXG4gICAqL1xuICAgd2l0aFNjb3BlKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLl9wdXNoU2NvcGUoKTtcblxuICAgIGxldCBtYXliZVByb21pc2VSZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIG1heWJlUHJvbWlzZVJlc3VsdCA9IGNhbGxiYWNrKHNjb3BlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLl9wb3BTY29wZSgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoaXNUaGVuYWJsZShtYXliZVByb21pc2VSZXN1bHQpKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaXNUaGVuYWJsZSByZXR1cm5zIHRoZSB3cm9uZyB0eXBlXG4gICAgICByZXR1cm4gbWF5YmVQcm9taXNlUmVzdWx0LnRoZW4oXG4gICAgICAgIHJlcyA9PiB7XG4gICAgICAgICAgdGhpcy5fcG9wU2NvcGUoKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICB0aGlzLl9wb3BTY29wZSgpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BvcFNjb3BlKCk7XG4gICAgcmV0dXJuIG1heWJlUHJvbWlzZVJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsaWVudCBvZiB0aGUgc3RhY2suXG4gICAqL1xuICAgZ2V0Q2xpZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YWNrVG9wKCkuY2xpZW50IDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY29wZSBvZiB0aGUgdG9wIHN0YWNrLlxuICAgKi9cbiAgIGdldFNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0YWNrVG9wKCkuc2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpc29sYXRpb24gc2NvcGUgZm9yIHRoZSBzdGFjay5cbiAgICovXG4gICBnZXRJc29sYXRpb25TY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNvbGF0aW9uU2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wbW9zdCBzY29wZSBsYXllciBpbiB0aGUgb3JkZXIgZG9tYWluID4gbG9jYWwgPiBwcm9jZXNzLlxuICAgKi9cbiAgIGdldFN0YWNrVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAxXSA7XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIHNjb3BlIHRvIHRoZSBzdGFjay5cbiAgICovXG4gICBfcHVzaFNjb3BlKCkge1xuICAgIC8vIFdlIHdhbnQgdG8gY2xvbmUgdGhlIGNvbnRlbnQgb2YgcHJldiBzY29wZVxuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5nZXRTY29wZSgpLmNsb25lKCk7XG4gICAgdGhpcy5fc3RhY2sucHVzaCh7XG4gICAgICBjbGllbnQ6IHRoaXMuZ2V0Q2xpZW50KCksXG4gICAgICBzY29wZSxcbiAgICB9KTtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogUG9wIGEgc2NvcGUgZnJvbSB0aGUgc3RhY2suXG4gICAqL1xuICAgX3BvcFNjb3BlKCkge1xuICAgIGlmICh0aGlzLl9zdGFjay5sZW5ndGggPD0gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAhIXRoaXMuX3N0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBnbG9iYWwgYXN5bmMgY29udGV4dCBzdGFjay5cbiAqIFRoaXMgd2lsbCBiZSByZW1vdmVkIGR1cmluZyB0aGUgdjggY3ljbGUgYW5kIGlzIG9ubHkgaGVyZSB0byBtYWtlIG1pZ3JhdGlvbiBlYXNpZXIuXG4gKi9cbmZ1bmN0aW9uIGdldEFzeW5jQ29udGV4dFN0YWNrKCkge1xuICBjb25zdCByZWdpc3RyeSA9IGdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IHNlbnRyeSA9IGdldFNlbnRyeUNhcnJpZXIocmVnaXN0cnkpO1xuXG4gIHJldHVybiAoc2VudHJ5LnN0YWNrID0gc2VudHJ5LnN0YWNrIHx8IG5ldyBBc3luY0NvbnRleHRTdGFjayhnZXREZWZhdWx0Q3VycmVudFNjb3BlKCksIGdldERlZmF1bHRJc29sYXRpb25TY29wZSgpKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhTY29wZShjYWxsYmFjaykge1xuICByZXR1cm4gZ2V0QXN5bmNDb250ZXh0U3RhY2soKS53aXRoU2NvcGUoY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiB3aXRoU2V0U2NvcGUoc2NvcGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHN0YWNrID0gZ2V0QXN5bmNDb250ZXh0U3RhY2soKSA7XG4gIHJldHVybiBzdGFjay53aXRoU2NvcGUoKCkgPT4ge1xuICAgIHN0YWNrLmdldFN0YWNrVG9wKCkuc2NvcGUgPSBzY29wZTtcbiAgICByZXR1cm4gY2FsbGJhY2soc2NvcGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKSB7XG4gIHJldHVybiBnZXRBc3luY0NvbnRleHRTdGFjaygpLndpdGhTY29wZSgoKSA9PiB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGdldEFzeW5jQ29udGV4dFN0YWNrKCkuZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3RhY2stYmFzZWQgYXN5bmMgY29udGV4dCBzdHJhdGVneS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhY2tBc3luY0NvbnRleHRTdHJhdGVneSgpIHtcbiAgcmV0dXJuIHtcbiAgICB3aXRoSXNvbGF0aW9uU2NvcGUsXG4gICAgd2l0aFNjb3BlLFxuICAgIHdpdGhTZXRTY29wZSxcbiAgICB3aXRoU2V0SXNvbGF0aW9uU2NvcGU6IChfaXNvbGF0aW9uU2NvcGUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICByZXR1cm4gd2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnRTY29wZTogKCkgPT4gZ2V0QXN5bmNDb250ZXh0U3RhY2soKS5nZXRTY29wZSgpLFxuICAgIGdldElzb2xhdGlvblNjb3BlOiAoKSA9PiBnZXRBc3luY0NvbnRleHRTdGFjaygpLmdldElzb2xhdGlvblNjb3BlKCksXG4gIH07XG59XG5cbmV4cG9ydCB7IEFzeW5jQ29udGV4dFN0YWNrLCBnZXRTdGFja0FzeW5jQ29udGV4dFN0cmF0ZWd5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFja1N0cmF0ZWd5LmpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0TWFpbkNhcnJpZXIsIGdldFNlbnRyeUNhcnJpZXIgfSBmcm9tICcuLi9jYXJyaWVyLmpzJztcbmltcG9ydCB7IGdldFN0YWNrQXN5bmNDb250ZXh0U3RyYXRlZ3kgfSBmcm9tICcuL3N0YWNrU3RyYXRlZ3kuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlIFByaXZhdGUgQVBJIHdpdGggbm8gc2VtdmVyIGd1YXJhbnRlZXMhXG4gKlxuICogU2V0cyB0aGUgZ2xvYmFsIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3lcbiAqL1xuZnVuY3Rpb24gc2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgLy8gR2V0IG1haW4gY2FycmllciAoZ2xvYmFsIGZvciBldmVyeSBlbnZpcm9ubWVudClcbiAgY29uc3QgcmVnaXN0cnkgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBzZW50cnkgPSBnZXRTZW50cnlDYXJyaWVyKHJlZ2lzdHJ5KTtcbiAgc2VudHJ5LmFjcyA9IHN0cmF0ZWd5O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBhc3luYyBjb250ZXh0IHN0cmF0ZWd5LlxuICogSWYgbm9uZSBoYXMgYmVlbiBzZXR1cCwgdGhlIGRlZmF1bHQgd2lsbCBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBnZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyKSB7XG4gIGNvbnN0IHNlbnRyeSA9IGdldFNlbnRyeUNhcnJpZXIoY2Fycmllcik7XG5cbiAgaWYgKHNlbnRyeS5hY3MpIHtcbiAgICByZXR1cm4gc2VudHJ5LmFjcztcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBkZWZhdWx0IG9uZSAoc3RhY2spXG4gIHJldHVybiBnZXRTdGFja0FzeW5jQ29udGV4dFN0cmF0ZWd5KCk7XG59XG5cbmV4cG9ydCB7IGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5LCBzZXRBc3luY0NvbnRleHRTdHJhdGVneSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJpbXBvcnQgeyBnZXRBc3luY0NvbnRleHRTdHJhdGVneSB9IGZyb20gJy4vYXN5bmNDb250ZXh0L2luZGV4LmpzJztcbmltcG9ydCB7IGdldE1haW5DYXJyaWVyLCBnZXRHbG9iYWxTaW5nbGV0b24gfSBmcm9tICcuL2NhcnJpZXIuanMnO1xuaW1wb3J0IHsgU2NvcGUgfSBmcm9tICcuL3Njb3BlLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlU3BhbklkIH0gZnJvbSAnLi91dGlscy1ob2lzdC9wcm9wYWdhdGlvbkNvbnRleHQuanMnO1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICBjb25zdCBjYXJyaWVyID0gZ2V0TWFpbkNhcnJpZXIoKTtcbiAgY29uc3QgYWNzID0gZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koY2Fycmllcik7XG4gIHJldHVybiBhY3MuZ2V0Q3VycmVudFNjb3BlKCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGlzb2xhdGlvbiBzY29wZS5cbiAqIFRoZSBpc29sYXRpb24gc2NvcGUgaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0SXNvbGF0aW9uU2NvcGUoKSB7XG4gIGNvbnN0IGNhcnJpZXIgPSBnZXRNYWluQ2FycmllcigpO1xuICBjb25zdCBhY3MgPSBnZXRBc3luY0NvbnRleHRTdHJhdGVneShjYXJyaWVyKTtcbiAgcmV0dXJuIGFjcy5nZXRJc29sYXRpb25TY29wZSgpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZ2xvYmFsIHNjb3BlLlxuICogVGhpcyBzY29wZSBpcyBhcHBsaWVkIHRvIF9hbGxfIGV2ZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2V0R2xvYmFsU2NvcGUoKSB7XG4gIHJldHVybiBnZXRHbG9iYWxTaW5nbGV0b24oJ2dsb2JhbFNjb3BlJywgKCkgPT4gbmV3IFNjb3BlKCkpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2NvcGUgd2l0aCBhbmQgZXhlY3V0ZXMgdGhlIGdpdmVuIG9wZXJhdGlvbiB3aXRoaW4uXG4gKiBUaGUgc2NvcGUgaXMgYXV0b21hdGljYWxseSByZW1vdmVkIG9uY2UgdGhlIG9wZXJhdGlvblxuICogZmluaXNoZXMgb3IgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRWl0aGVyIGNyZWF0ZXMgYSBuZXcgYWN0aXZlIHNjb3BlLCBvciBzZXRzIHRoZSBnaXZlbiBzY29wZSBhcyBhY3RpdmUgc2NvcGUgaW4gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiB3aXRoU2NvcGUoXG4gIC4uLnJlc3Rcbikge1xuICBjb25zdCBjYXJyaWVyID0gZ2V0TWFpbkNhcnJpZXIoKTtcbiAgY29uc3QgYWNzID0gZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koY2Fycmllcik7XG5cbiAgLy8gSWYgYSBzY29wZSBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIG1ha2UgdGhpcyB0aGUgYWN0aXZlIHNjb3BlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lXG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFtzY29wZSwgY2FsbGJhY2tdID0gcmVzdDtcblxuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIHJldHVybiBhY3Mud2l0aFNjb3BlKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNzLndpdGhTZXRTY29wZShzY29wZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGFjcy53aXRoU2NvcGUocmVzdFswXSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZm9yayB0aGUgY3VycmVudCBpc29sYXRpb24gc2NvcGUgYW5kIHRoZSBjdXJyZW50IHNjb3BlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kuIElmIG5vXG4gKiBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IGlzIHNldCwgdGhlIGlzb2xhdGlvbiBzY29wZSBhbmQgdGhlIGN1cnJlbnQgc2NvcGUgd2lsbCBub3QgYmUgZm9ya2VkICh0aGlzIGlzIGN1cnJlbnRseSB0aGVcbiAqIGNhc2UsIGZvciBleGFtcGxlLCBpbiB0aGUgYnJvd3NlcikuXG4gKlxuICogVXNhZ2Ugb2YgdGhpcyBmdW5jdGlvbiBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IGlzIGRpc2NvdXJhZ2VkIGFuZCBtYXkgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW91ci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIGZvciBTZW50cnkgU0RLIGFuZCBTREsgaW50ZWdyYXRpb24gZGV2ZWxvcG1lbnQuIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBiZSB1c2VkIGluIFwibm9ybWFsXCJcbiAqIGFwcGxpY2F0aW9ucyBkaXJlY3RseSBiZWNhdXNlIGl0IGNvbWVzIHdpdGggcGl0ZmFsbHMuIFVzZSBhdCB5b3VyIG93biByaXNrIVxuICovXG5cbi8qKlxuICogRWl0aGVyIGNyZWF0ZXMgYSBuZXcgYWN0aXZlIGlzb2xhdGlvbiBzY29wZSwgb3Igc2V0cyB0aGUgZ2l2ZW4gaXNvbGF0aW9uIHNjb3BlIGFzIGFjdGl2ZSBzY29wZSBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhJc29sYXRpb25TY29wZShcbiAgLi4ucmVzdFxuXG4pIHtcbiAgY29uc3QgY2FycmllciA9IGdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IGFjcyA9IGdldEFzeW5jQ29udGV4dFN0cmF0ZWd5KGNhcnJpZXIpO1xuXG4gIC8vIElmIGEgc2NvcGUgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byBtYWtlIHRoaXMgdGhlIGFjdGl2ZSBzY29wZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9uZVxuICBpZiAocmVzdC5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBbaXNvbGF0aW9uU2NvcGUsIGNhbGxiYWNrXSA9IHJlc3Q7XG5cbiAgICBpZiAoIWlzb2xhdGlvblNjb3BlKSB7XG4gICAgICByZXR1cm4gYWNzLndpdGhJc29sYXRpb25TY29wZShjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjcy53aXRoU2V0SXNvbGF0aW9uU2NvcGUoaXNvbGF0aW9uU2NvcGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBhY3Mud2l0aElzb2xhdGlvblNjb3BlKHJlc3RbMF0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBjbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudCgpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnRTY29wZSgpLmdldENsaWVudCgpO1xufVxuXG4vKipcbiAqIEdldCBhIHRyYWNlIGNvbnRleHQgZm9yIHRoZSBnaXZlbiBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKHNjb3BlKSB7XG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpO1xuXG4gIGNvbnN0IHsgdHJhY2VJZCwgcGFyZW50U3BhbklkLCBwcm9wYWdhdGlvblNwYW5JZCB9ID0gcHJvcGFnYXRpb25Db250ZXh0O1xuXG4gIGNvbnN0IHRyYWNlQ29udGV4dCA9IHtcbiAgICB0cmFjZV9pZDogdHJhY2VJZCxcbiAgICBzcGFuX2lkOiBwcm9wYWdhdGlvblNwYW5JZCB8fCBnZW5lcmF0ZVNwYW5JZCgpLFxuICB9O1xuXG4gIGlmIChwYXJlbnRTcGFuSWQpIHtcbiAgICB0cmFjZUNvbnRleHQucGFyZW50X3NwYW5faWQgPSBwYXJlbnRTcGFuSWQ7XG4gIH1cblxuICByZXR1cm4gdHJhY2VDb250ZXh0O1xufVxuXG5leHBvcnQgeyBnZXRDbGllbnQsIGdldEN1cnJlbnRTY29wZSwgZ2V0R2xvYmFsU2NvcGUsIGdldElzb2xhdGlvblNjb3BlLCBnZXRUcmFjZUNvbnRleHRGcm9tU2NvcGUsIHdpdGhJc29sYXRpb25TY29wZSwgd2l0aFNjb3BlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJyZW50U2NvcGVzLmpzLm1hcFxuIiwiLyoqXG4gKiBVc2UgdGhpcyBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBzb3VyY2Ugb2YgYSBzcGFuLlxuICogU2hvdWxkIGJlIG9uZSBvZjogY3VzdG9tLCB1cmwsIHJvdXRlLCB2aWV3LCBjb21wb25lbnQsIHRhc2ssIHVua25vd25cbiAqXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFID0gJ3NlbnRyeS5zb3VyY2UnO1xuXG4vKipcbiAqIEF0dHJpYnV0ZXMgdGhhdCBob2xkcyB0aGUgc2FtcGxlIHJhdGUgdGhhdCB3YXMgbG9jYWxseSBhcHBsaWVkIHRvIGEgc3Bhbi5cbiAqIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkLCBpdCBtZWFucyB0aGF0IHRoZSBzcGFuIGluaGVyaXRlZCBhIHNhbXBsaW5nIGRlY2lzaW9uLlxuICpcbiAqIE5PVEU6IElzIG9ubHkgZGVmaW5lZCBvbiByb290IHNwYW5zLlxuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFID0gJ3NlbnRyeS5zYW1wbGVfcmF0ZSc7XG5cbi8qKlxuICogVXNlIHRoaXMgYXR0cmlidXRlIHRvIHJlcHJlc2VudCB0aGUgb3BlcmF0aW9uIG9mIGEgc3Bhbi5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCA9ICdzZW50cnkub3AnO1xuXG4vKipcbiAqIFVzZSB0aGlzIGF0dHJpYnV0ZSB0byByZXByZXNlbnQgdGhlIG9yaWdpbiBvZiBhIHNwYW4uXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOID0gJ3NlbnRyeS5vcmlnaW4nO1xuXG4vKiogVGhlIHJlYXNvbiB3aHkgYW4gaWRsZSBzcGFuIGZpbmlzaGVkLiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9JRExFX1NQQU5fRklOSVNIX1JFQVNPTiA9ICdzZW50cnkuaWRsZV9zcGFuX2ZpbmlzaF9yZWFzb24nO1xuXG4vKiogVGhlIHVuaXQgb2YgYSBtZWFzdXJlbWVudCwgd2hpY2ggbWF5IGJlIHN0b3JlZCBhcyBhIFRpbWVkRXZlbnQuICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVQgPSAnc2VudHJ5Lm1lYXN1cmVtZW50X3VuaXQnO1xuXG4vKiogVGhlIHZhbHVlIG9mIGEgbWVhc3VyZW1lbnQsIHdoaWNoIG1heSBiZSBzdG9yZWQgYXMgYSBUaW1lZEV2ZW50LiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9NRUFTVVJFTUVOVF9WQUxVRSA9ICdzZW50cnkubWVhc3VyZW1lbnRfdmFsdWUnO1xuXG4vKipcbiAqIEEgY3VzdG9tIHNwYW4gbmFtZSBzZXQgYnkgdXNlcnMgZ3VhcmFudGVlZCB0byBiZSB0YWtlbiBvdmVyIGFueSBhdXRvbWF0aWNhbGx5XG4gKiBpbmZlcnJlZCBuYW1lLiBUaGlzIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGJlZm9yZSB0aGUgc3BhbiBpcyBzZW50LlxuICpcbiAqIEBpbnRlcm5hbCBvbmx5IG1lYW50IGZvciBpbnRlcm5hbCBTREsgdXNhZ2VcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FID0gJ3NlbnRyeS5jdXN0b21fc3Bhbl9uYW1lJztcblxuLyoqXG4gKiBUaGUgaWQgb2YgdGhlIHByb2ZpbGUgdGhhdCB0aGlzIHNwYW4gb2NjdXJyZWQgaW4uXG4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEID0gJ3NlbnRyeS5wcm9maWxlX2lkJztcblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0VYQ0xVU0lWRV9USU1FID0gJ3NlbnRyeS5leGNsdXNpdmVfdGltZSc7XG5cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9DQUNIRV9ISVQgPSAnY2FjaGUuaGl0JztcblxuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX0NBQ0hFX0tFWSA9ICdjYWNoZS5rZXknO1xuXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSVRFTV9TSVpFID0gJ2NhY2hlLml0ZW1fc2l6ZSc7XG5cbi8qKiBUT0RPOiBSZW1vdmUgdGhlc2Ugb25jZSB3ZSB1cGRhdGUgdG8gbGF0ZXN0IHNlbWFudGljIGNvbnZlbnRpb25zICovXG5jb25zdCBTRU1BTlRJQ19BVFRSSUJVVEVfSFRUUF9SRVFVRVNUX01FVEhPRCA9ICdodHRwLnJlcXVlc3QubWV0aG9kJztcbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9VUkxfRlVMTCA9ICd1cmwuZnVsbCc7XG5cbi8qKlxuICogQSBzcGFuIGxpbmsgYXR0cmlidXRlIHRvIG1hcmsgdGhlIGxpbmsgYXMgYSBzcGVjaWFsIHNwYW4gbGluay5cbiAqXG4gKiBLbm93biB2YWx1ZXM6XG4gKiAtIGBwcmV2aW91c190cmFjZWA6IFRoZSBzcGFuIGxpbmtzIHRvIHRoZSBmcm9udGVuZCByb290IHNwYW4gb2YgdGhlIHByZXZpb3VzIHRyYWNlLlxuICogLSBgbmV4dF90cmFjZWA6IFRoZSBzcGFuIGxpbmtzIHRvIHRoZSBmcm9udGVuZCByb290IHNwYW4gb2YgdGhlIG5leHQgdHJhY2UuIChOb3Qgc2V0IGJ5IHRoZSBTREspXG4gKlxuICogT3RoZXIgdmFsdWVzIG1heSBiZSBzZXQgYXMgYXBwcm9wcmlhdGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay90ZWxlbWV0cnkvdHJhY2VzL3NwYW4tbGlua3MvI2xpbmstdHlwZXNcbiAqL1xuY29uc3QgU0VNQU5USUNfTElOS19BVFRSSUJVVEVfTElOS19UWVBFID0gJ3NlbnRyeS5saW5rLnR5cGUnO1xuXG5leHBvcnQgeyBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSElULCBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfSVRFTV9TSVpFLCBTRU1BTlRJQ19BVFRSSUJVVEVfQ0FDSEVfS0VZLCBTRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUUsIFNFTUFOVElDX0FUVFJJQlVURV9IVFRQX1JFUVVFU1RfTUVUSE9ELCBTRU1BTlRJQ19BVFRSSUJVVEVfUFJPRklMRV9JRCwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0lETEVfU1BBTl9GSU5JU0hfUkVBU09OLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX01FQVNVUkVNRU5UX1VOSVQsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfTUVBU1VSRU1FTlRfVkFMVUUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1AsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSwgU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMLCBTRU1BTlRJQ19MSU5LX0FUVFJJQlVURV9MSU5LX1RZUEUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbWFudGljQXR0cmlidXRlcy5qcy5tYXBcbiIsImNvbnN0IFNQQU5fU1RBVFVTX1VOU0VUID0gMDtcbmNvbnN0IFNQQU5fU1RBVFVTX09LID0gMTtcbmNvbnN0IFNQQU5fU1RBVFVTX0VSUk9SID0gMjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEhUVFAgc3RhdHVzIGNvZGUgaW50byBhIHNlbnRyeSBzdGF0dXMgd2l0aCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGh0dHBTdGF0dXMgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gKiBAcmV0dXJucyBUaGUgc3BhbiBzdGF0dXMgb3IgdW5rbm93bl9lcnJvci5cbiAqL1xuLy8gaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL2V2ZW50LXBheWxvYWRzL3NwYW4vXG5mdW5jdGlvbiBnZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKGh0dHBTdGF0dXMpIHtcbiAgaWYgKGh0dHBTdGF0dXMgPCA0MDAgJiYgaHR0cFN0YXR1cyA+PSAxMDApIHtcbiAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19PSyB9O1xuICB9XG5cbiAgaWYgKGh0dHBTdGF0dXMgPj0gNDAwICYmIGh0dHBTdGF0dXMgPCA1MDApIHtcbiAgICBzd2l0Y2ggKGh0dHBTdGF0dXMpIHtcbiAgICAgIGNhc2UgNDAxOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3VuYXV0aGVudGljYXRlZCcgfTtcbiAgICAgIGNhc2UgNDAzOlxuICAgICAgICByZXR1cm4geyBjb2RlOiBTUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Blcm1pc3Npb25fZGVuaWVkJyB9O1xuICAgICAgY2FzZSA0MDQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnbm90X2ZvdW5kJyB9O1xuICAgICAgY2FzZSA0MDk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnYWxyZWFkeV9leGlzdHMnIH07XG4gICAgICBjYXNlIDQxMzpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdmYWlsZWRfcHJlY29uZGl0aW9uJyB9O1xuICAgICAgY2FzZSA0Mjk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAncmVzb3VyY2VfZXhoYXVzdGVkJyB9O1xuICAgICAgY2FzZSA0OTk6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnY2FuY2VsbGVkJyB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdpbnZhbGlkX2FyZ3VtZW50JyB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChodHRwU3RhdHVzID49IDUwMCAmJiBodHRwU3RhdHVzIDwgNjAwKSB7XG4gICAgc3dpdGNoIChodHRwU3RhdHVzKSB7XG4gICAgICBjYXNlIDUwMTpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmltcGxlbWVudGVkJyB9O1xuICAgICAgY2FzZSA1MDM6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5hdmFpbGFibGUnIH07XG4gICAgICBjYXNlIDUwNDpcbiAgICAgICAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICdkZWFkbGluZV9leGNlZWRlZCcgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGNvZGU6IFNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAnaW50ZXJuYWxfZXJyb3InIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgY29kZTogU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIEh0dHAgc3RhdHVzIGF0dHJpYnV0ZXMgb24gdGhlIGN1cnJlbnQgc3BhbiBiYXNlZCBvbiB0aGUgaHR0cCBjb2RlLlxuICogQWRkaXRpb25hbGx5LCB0aGUgc3BhbidzIHN0YXR1cyBpcyB1cGRhdGVkLCBkZXBlbmRpbmcgb24gdGhlIGh0dHAgY29kZS5cbiAqL1xuZnVuY3Rpb24gc2V0SHR0cFN0YXR1cyhzcGFuLCBodHRwU3RhdHVzKSB7XG4gIHNwYW4uc2V0QXR0cmlidXRlKCdodHRwLnJlc3BvbnNlLnN0YXR1c19jb2RlJywgaHR0cFN0YXR1cyk7XG5cbiAgY29uc3Qgc3BhblN0YXR1cyA9IGdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUoaHR0cFN0YXR1cyk7XG4gIGlmIChzcGFuU3RhdHVzLm1lc3NhZ2UgIT09ICd1bmtub3duX2Vycm9yJykge1xuICAgIHNwYW4uc2V0U3RhdHVzKHNwYW5TdGF0dXMpO1xuICB9XG59XG5cbmV4cG9ydCB7IFNQQU5fU1RBVFVTX0VSUk9SLCBTUEFOX1NUQVRVU19PSywgU1BBTl9TVEFUVVNfVU5TRVQsIGdldFNwYW5TdGF0dXNGcm9tSHR0cENvZGUsIHNldEh0dHBTdGF0dXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwYW5zdGF0dXMuanMubWFwXG4iLCJpbXBvcnQgeyBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkgfSBmcm9tICcuLi91dGlscy1ob2lzdC9vYmplY3QuanMnO1xuXG5jb25zdCBTQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxEID0gJ19zZW50cnlTY29wZSc7XG5jb25zdCBJU09MQVRJT05fU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRCA9ICdfc2VudHJ5SXNvbGF0aW9uU2NvcGUnO1xuXG4vKiogU3RvcmUgdGhlIHNjb3BlICYgaXNvbGF0aW9uIHNjb3BlIGZvciBhIHNwYW4sIHdoaWNoIGNhbiB0aGUgYmUgdXNlZCB3aGVuIGl0IGlzIGZpbmlzaGVkLiAqL1xuZnVuY3Rpb24gc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbiwgc2NvcGUsIGlzb2xhdGlvblNjb3BlKSB7XG4gIGlmIChzcGFuKSB7XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW4sIElTT0xBVElPTl9TQ09QRV9PTl9TVEFSVF9TUEFOX0ZJRUxELCBpc29sYXRpb25TY29wZSk7XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW4sIFNDT1BFX09OX1NUQVJUX1NQQU5fRklFTEQsIHNjb3BlKTtcbiAgfVxufVxuXG4vKipcbiAqIEdyYWJzIHRoZSBzY29wZSBhbmQgaXNvbGF0aW9uIHNjb3BlIG9mZiBhIHNwYW4gdGhhdCB3ZXJlIGFjdGl2ZSB3aGVuIHRoZSBzcGFuIHdhcyBzdGFydGVkLlxuICovXG5mdW5jdGlvbiBnZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuKSB7XG4gIHJldHVybiB7XG4gICAgc2NvcGU6IChzcGFuIClbU0NPUEVfT05fU1RBUlRfU1BBTl9GSUVMRF0sXG4gICAgaXNvbGF0aW9uU2NvcGU6IChzcGFuIClbSVNPTEFUSU9OX1NDT1BFX09OX1NUQVJUX1NQQU5fRklFTERdLFxuICB9O1xufVxuXG5leHBvcnQgeyBnZXRDYXB0dXJlZFNjb3Blc09uU3Bhbiwgc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIiwiLyoqXG4gKiBQYXJzZSBhIHNhbXBsZSByYXRlIGZyb20gYSBnaXZlbiB2YWx1ZS5cbiAqIFRoaXMgd2lsbCBlaXRoZXIgcmV0dXJuIGEgYm9vbGVhbiBvciBudW1iZXIgc2FtcGxlIHJhdGUsIGlmIHRoZSBzYW1wbGUgcmF0ZSBpcyB2YWxpZCAoYmV0d2VlbiAwIGFuZCAxKS5cbiAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgd2UgdHJ5IHRvIGNvbnZlcnQgaXQgdG8gYSBudW1iZXIuXG4gKlxuICogQW55IGludmFsaWQgc2FtcGxlIHJhdGUgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2FtcGxlUmF0ZShzYW1wbGVSYXRlKSB7XG4gIGlmICh0eXBlb2Ygc2FtcGxlUmF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIE51bWJlcihzYW1wbGVSYXRlKTtcbiAgfVxuXG4gIGNvbnN0IHJhdGUgPSB0eXBlb2Ygc2FtcGxlUmF0ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHNhbXBsZVJhdGUpIDogc2FtcGxlUmF0ZTtcbiAgaWYgKHR5cGVvZiByYXRlICE9PSAnbnVtYmVyJyB8fCBpc05hTihyYXRlKSB8fCByYXRlIDwgMCB8fCByYXRlID4gMSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gcmF0ZTtcbn1cblxuZXhwb3J0IHsgcGFyc2VTYW1wbGVSYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVNhbXBsZVJhdGUuanMubWFwXG4iLCJpbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL2lzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLmpzJztcblxuY29uc3QgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCA9ICdzZW50cnktJztcblxuY29uc3QgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCA9IC9ec2VudHJ5LS87XG5cbi8qKlxuICogTWF4IGxlbmd0aCBvZiBhIHNlcmlhbGl6ZWQgYmFnZ2FnZSBzdHJpbmdcbiAqXG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvYmFnZ2FnZS8jbGltaXRzXG4gKi9cbmNvbnN0IE1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEggPSA4MTkyO1xuXG4vKipcbiAqIFRha2VzIGEgYmFnZ2FnZSBoZWFkZXIgYW5kIHR1cm5zIGl0IGludG8gRHluYW1pYyBTYW1wbGluZyBDb250ZXh0LCBieSBleHRyYWN0aW5nIGFsbCB0aGUgXCJzZW50cnktXCIgcHJlZml4ZWQgdmFsdWVzXG4gKiBmcm9tIGl0LlxuICpcbiAqIEBwYXJhbSBiYWdnYWdlSGVhZGVyIEEgdmVyeSBicmVhZCBkZWZpbml0aW9uIG9mIGEgYmFnZ2FnZSBoZWFkZXIgYXMgaXQgbWlnaHQgYXBwZWFyIGluIHZhcmlvdXMgZnJhbWV3b3Jrcy5cbiAqIEByZXR1cm5zIFRoZSBEeW5hbWljIFNhbXBsaW5nIENvbnRleHQgdGhhdCB3YXMgZm91bmQgb24gYGJhZ2dhZ2VIZWFkZXJgLCBpZiB0aGVyZSB3YXMgYW55LCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoXG4gIC8vIFZlcnkgbGliZXJhbCBkZWZpbml0aW9uIG9mIHdoYXQgYW55IGluY29taW5nIGhlYWRlciBtaWdodCBsb29rIGxpa2VcbiAgYmFnZ2FnZUhlYWRlcixcbikge1xuICBjb25zdCBiYWdnYWdlT2JqZWN0ID0gcGFyc2VCYWdnYWdlSGVhZGVyKGJhZ2dhZ2VIZWFkZXIpO1xuXG4gIGlmICghYmFnZ2FnZU9iamVjdCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBSZWFkIGFsbCBcInNlbnRyeS1cIiBwcmVmaXhlZCB2YWx1ZXMgb3V0IG9mIHRoZSBiYWdnYWdlIG9iamVjdCBhbmQgcHV0IGl0IG9udG8gYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgb2JqZWN0LlxuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gT2JqZWN0LmVudHJpZXMoYmFnZ2FnZU9iamVjdCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkubWF0Y2goU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCkpIHtcbiAgICAgIGNvbnN0IG5vblByZWZpeGVkS2V5ID0ga2V5LnNsaWNlKFNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVgubGVuZ3RoKTtcbiAgICAgIGFjY1tub25QcmVmaXhlZEtleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIC8vIE9ubHkgcmV0dXJuIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IG9iamVjdCBpZiB0aGVyZSBhcmUga2V5cyBpbiBpdC5cbiAgLy8gQSBrZXlsZXNzIG9iamVjdCBtZWFucyB0aGVyZSB3ZXJlIG5vIHNlbnRyeSB2YWx1ZXMgb24gdGhlIGhlYWRlciwgd2hpY2ggbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBEU0MuXG4gIGlmIChPYmplY3Qua2V5cyhkeW5hbWljU2FtcGxpbmdDb250ZXh0KS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUdXJucyBhIER5bmFtaWMgU2FtcGxpbmcgT2JqZWN0IGludG8gYSBiYWdnYWdlIGhlYWRlciBieSBwcmVmaXhpbmcgYWxsIHRoZSBrZXlzIG9uIHRoZSBvYmplY3Qgd2l0aCBcInNlbnRyeS1cIi5cbiAqXG4gKiBAcGFyYW0gZHluYW1pY1NhbXBsaW5nQ29udGV4dCBUaGUgRHluYW1pYyBTYW1wbGluZyBDb250ZXh0IHRvIHR1cm4gaW50byBhIGhlYWRlci4gRm9yIGNvbnZlbmllbmNlIGFuZCBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIHRoZSBgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dGAgbWV0aG9kIG9uIHRoZSBUcmFuc2FjdGlvbiBjbGFzcyAsdGhpcyBhcmd1bWVudCBjYW4gYWxzbyBiZSBgdW5kZWZpbmVkYC4gSWYgaXQgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqIEByZXR1cm5zIGEgYmFnZ2FnZSBoZWFkZXIsIGNyZWF0ZWQgZnJvbSBgZHluYW1pY1NhbXBsaW5nQ29udGV4dGAsIG9yIGB1bmRlZmluZWRgIGVpdGhlciBpZiBgZHluYW1pY1NhbXBsaW5nQ29udGV4dGBcbiAqIHdhcyBgdW5kZWZpbmVkYCwgb3IgaWYgYGR5bmFtaWNTYW1wbGluZ0NvbnRleHRgIGRpZG4ndCBjb250YWluIGFueSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoXG4gIC8vIHRoaXMgYWxzbyB0YWtlcyB1bmRlZmluZWQgZm9yIGNvbnZlbmllbmNlIGFuZCBidW5kbGUgc2l6ZSBpbiBvdGhlciBwbGFjZXNcbiAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbikge1xuICBpZiAoIWR5bmFtaWNTYW1wbGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gUHJlZml4IGFsbCBEU0Mga2V5cyB3aXRoIFwic2VudHJ5LVwiIGFuZCBwdXQgdGhlbSBpbnRvIGEgbmV3IG9iamVjdFxuICBjb25zdCBzZW50cnlQcmVmaXhlZERTQyA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLnJlZHVjZShcbiAgICAoYWNjLCBbZHNjS2V5LCBkc2NWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChkc2NWYWx1ZSkge1xuICAgICAgICBhY2NbYCR7U0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWH0ke2RzY0tleX1gXSA9IGRzY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9LFxuICApO1xuXG4gIHJldHVybiBvYmplY3RUb0JhZ2dhZ2VIZWFkZXIoc2VudHJ5UHJlZml4ZWREU0MpO1xufVxuXG4vKipcbiAqIFRha2UgYSBiYWdnYWdlIGhlYWRlciBhbmQgcGFyc2UgaXQgaW50byBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQmFnZ2FnZUhlYWRlcihcbiAgYmFnZ2FnZUhlYWRlcixcbikge1xuICBpZiAoIWJhZ2dhZ2VIZWFkZXIgfHwgKCFpc1N0cmluZyhiYWdnYWdlSGVhZGVyKSAmJiAhQXJyYXkuaXNBcnJheShiYWdnYWdlSGVhZGVyKSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFnZ2FnZUhlYWRlcikpIHtcbiAgICAvLyBDb21iaW5lIGFsbCBiYWdnYWdlIGhlYWRlcnMgaW50byBvbmUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGJhZ2dhZ2UgdmFsdWVzIHNvIHdlIGNhbiBsYXRlciByZWFkIHRoZSBTZW50cnktRFNDLXZhbHVlcyBmcm9tIGl0XG4gICAgcmV0dXJuIGJhZ2dhZ2VIZWFkZXIucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJCYWdnYWdlT2JqZWN0ID0gYmFnZ2FnZUhlYWRlclRvT2JqZWN0KGN1cnIpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoY3VyckJhZ2dhZ2VPYmplY3QpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIHJldHVybiBiYWdnYWdlSGVhZGVyVG9PYmplY3QoYmFnZ2FnZUhlYWRlcik7XG59XG5cbi8qKlxuICogV2lsbCBwYXJzZSBhIGJhZ2dhZ2UgaGVhZGVyLCB3aGljaCBpcyBhIHNpbXBsZSBrZXktdmFsdWUgbWFwLCBpbnRvIGEgZmxhdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGJhZ2dhZ2VIZWFkZXIgVGhlIGJhZ2dhZ2UgaGVhZGVyIHRvIHBhcnNlLlxuICogQHJldHVybnMgYSBmbGF0IG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUga2V5LXZhbHVlIHBhaXJzIGZyb20gYGJhZ2dhZ2VIZWFkZXJgLlxuICovXG5mdW5jdGlvbiBiYWdnYWdlSGVhZGVyVG9PYmplY3QoYmFnZ2FnZUhlYWRlcikge1xuICByZXR1cm4gYmFnZ2FnZUhlYWRlclxuICAgIC5zcGxpdCgnLCcpXG4gICAgLm1hcChiYWdnYWdlRW50cnkgPT4gYmFnZ2FnZUVudHJ5LnNwbGl0KCc9JykubWFwKGtleU9yVmFsdWUgPT4gZGVjb2RlVVJJQ29tcG9uZW50KGtleU9yVmFsdWUudHJpbSgpKSkpXG4gICAgLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuXG4vKipcbiAqIFR1cm5zIGEgZmxhdCBvYmplY3QgKGtleS12YWx1ZSBwYWlycykgaW50byBhIGJhZ2dhZ2UgaGVhZGVyLCB3aGljaCBpcyBhbHNvIGp1c3Qga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byB0dXJuIGludG8gYSBiYWdnYWdlIGhlYWRlci5cbiAqIEByZXR1cm5zIGEgYmFnZ2FnZSBoZWFkZXIgc3RyaW5nLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgb2JqZWN0IGRpZG4ndCBoYXZlIGFueSB2YWx1ZXMsIHNpbmNlIGFuIGVtcHR5IGJhZ2dhZ2UgaGVhZGVyXG4gKiBpcyBub3Qgc3BlYyBjb21wbGlhbnQuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvQmFnZ2FnZUhlYWRlcihvYmplY3QpIHtcbiAgaWYgKE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQW4gZW1wdHkgYmFnZ2FnZSBoZWFkZXIgaXMgbm90IHNwZWMgY29tcGxpYW50OiBXZSByZXR1cm4gdW5kZWZpbmVkLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0KS5yZWR1Y2UoKGJhZ2dhZ2VIZWFkZXIsIFtvYmplY3RLZXksIG9iamVjdFZhbHVlXSwgY3VycmVudEluZGV4KSA9PiB7XG4gICAgY29uc3QgYmFnZ2FnZUVudHJ5ID0gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdFZhbHVlKX1gO1xuICAgIGNvbnN0IG5ld0JhZ2dhZ2VIZWFkZXIgPSBjdXJyZW50SW5kZXggPT09IDAgPyBiYWdnYWdlRW50cnkgOiBgJHtiYWdnYWdlSGVhZGVyfSwke2JhZ2dhZ2VFbnRyeX1gO1xuICAgIGlmIChuZXdCYWdnYWdlSGVhZGVyLmxlbmd0aCA+IE1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEgpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBOb3QgYWRkaW5nIGtleTogJHtvYmplY3RLZXl9IHdpdGggdmFsOiAke29iamVjdFZhbHVlfSB0byBiYWdnYWdlIGhlYWRlciBkdWUgdG8gZXhjZWVkaW5nIGJhZ2dhZ2Ugc2l6ZSBsaW1pdHMuYCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBiYWdnYWdlSGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3QmFnZ2FnZUhlYWRlcjtcbiAgICB9XG4gIH0sICcnKTtcbn1cblxuZXhwb3J0IHsgTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSCwgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCwgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCwgYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dCwgZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlciwgb2JqZWN0VG9CYWdnYWdlSGVhZGVyLCBwYXJzZUJhZ2dhZ2VIZWFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhZ2dhZ2UuanMubWFwXG4iLCJpbXBvcnQgeyBnZXRBc3luY0NvbnRleHRTdHJhdGVneSB9IGZyb20gJy4uL2FzeW5jQ29udGV4dC9pbmRleC5qcyc7XG5pbXBvcnQgeyBnZXRNYWluQ2FycmllciB9IGZyb20gJy4uL2NhcnJpZXIuanMnO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFNjb3BlIH0gZnJvbSAnLi4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTiwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9DVVNUT01fU1BBTl9OQU1FLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSB9IGZyb20gJy4uL3NlbWFudGljQXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBTUEFOX1NUQVRVU19VTlNFVCwgU1BBTl9TVEFUVVNfT0sgfSBmcm9tICcuLi90cmFjaW5nL3NwYW5zdGF0dXMuanMnO1xuaW1wb3J0IHsgZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gfSBmcm9tICcuLi90cmFjaW5nL3V0aWxzLmpzJztcbmltcG9ydCB7IGNvbnNvbGVTYW5kYm94IH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVNwYW5JZCB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L3Byb3BhZ2F0aW9uQ29udGV4dC5qcyc7XG5pbXBvcnQgeyB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuLi91dGlscy1ob2lzdC90aW1lLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIgfSBmcm9tICcuLi91dGlscy1ob2lzdC90cmFjaW5nLmpzJztcbmltcG9ydCB7IF9nZXRTcGFuRm9yU2NvcGUgfSBmcm9tICcuL3NwYW5PblNjb3BlLmpzJztcblxuLy8gVGhlc2UgYXJlIGFsaWduZWQgd2l0aCBPcGVuVGVsZW1ldHJ5IHRyYWNlIGZsYWdzXG5jb25zdCBUUkFDRV9GTEFHX05PTkUgPSAweDA7XG5jb25zdCBUUkFDRV9GTEFHX1NBTVBMRUQgPSAweDE7XG5cbmxldCBoYXNTaG93blNwYW5Ecm9wV2FybmluZyA9IGZhbHNlO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzcGFuIHRvIGEgdHJhY2UgY29udGV4dCwgd2hpY2ggY2FuIGJlIHNlbnQgYXMgdGhlIGB0cmFjZWAgY29udGV4dCBpbiBhbiBldmVudC5cbiAqIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCBvbmx5IGluY2x1ZGUgdHJhY2VfaWQsIHNwYW5faWQgJiBwYXJlbnRfc3Bhbl9pZC5cbiAqIElmIGBpbmNsdWRlQWxsRGF0YWAgaXMgdHJ1ZSwgaXQgd2lsbCBhbHNvIGluY2x1ZGUgZGF0YSwgb3AsIHN0YXR1cyAmIG9yaWdpbi5cbiAqL1xuZnVuY3Rpb24gc3BhblRvVHJhbnNhY3Rpb25UcmFjZUNvbnRleHQoc3Bhbikge1xuICBjb25zdCB7IHNwYW5JZDogc3Bhbl9pZCwgdHJhY2VJZDogdHJhY2VfaWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3QgeyBkYXRhLCBvcCwgcGFyZW50X3NwYW5faWQsIHN0YXR1cywgb3JpZ2luLCBsaW5rcyB9ID0gc3BhblRvSlNPTihzcGFuKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmVudF9zcGFuX2lkLFxuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YSxcbiAgICBvcCxcbiAgICBzdGF0dXMsXG4gICAgb3JpZ2luLFxuICAgIGxpbmtzLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzcGFuIHRvIGEgdHJhY2UgY29udGV4dCwgd2hpY2ggY2FuIGJlIHNlbnQgYXMgdGhlIGB0cmFjZWAgY29udGV4dCBpbiBhIG5vbi10cmFuc2FjdGlvbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pIHtcbiAgY29uc3QgeyBzcGFuSWQsIHRyYWNlSWQ6IHRyYWNlX2lkLCBpc1JlbW90ZSB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuXG4gIC8vIElmIHRoZSBzcGFuIGlzIHJlbW90ZSwgd2UgdXNlIGEgcmFuZG9tL3ZpcnR1YWwgc3BhbiBhcyBzcGFuX2lkIHRvIHRoZSB0cmFjZSBjb250ZXh0LFxuICAvLyBhbmQgdGhlIHJlbW90ZSBzcGFuIGFzIHBhcmVudF9zcGFuX2lkXG4gIGNvbnN0IHBhcmVudF9zcGFuX2lkID0gaXNSZW1vdGUgPyBzcGFuSWQgOiBzcGFuVG9KU09OKHNwYW4pLnBhcmVudF9zcGFuX2lkO1xuICBjb25zdCBzY29wZSA9IGdldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4pLnNjb3BlO1xuXG4gIGNvbnN0IHNwYW5faWQgPSBpc1JlbW90ZSA/IHNjb3BlPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5wcm9wYWdhdGlvblNwYW5JZCB8fCBnZW5lcmF0ZVNwYW5JZCgpIDogc3BhbklkO1xuXG4gIHJldHVybiB7XG4gICAgcGFyZW50X3NwYW5faWQsXG4gICAgc3Bhbl9pZCxcbiAgICB0cmFjZV9pZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgU3BhbiB0byBhIFNlbnRyeSB0cmFjZSBoZWFkZXIuXG4gKi9cbmZ1bmN0aW9uIHNwYW5Ub1RyYWNlSGVhZGVyKHNwYW4pIHtcbiAgY29uc3QgeyB0cmFjZUlkLCBzcGFuSWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3Qgc2FtcGxlZCA9IHNwYW5Jc1NhbXBsZWQoc3Bhbik7XG4gIHJldHVybiBnZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyKHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCk7XG59XG5cbi8qKlxuICogIENvbnZlcnRzIHRoZSBzcGFuIGxpbmtzIGFycmF5IHRvIGEgZmxhdHRlbmVkIHZlcnNpb24gdG8gYmUgc2VudCB3aXRoaW4gYW4gZW52ZWxvcGUuXG4gKlxuICogIElmIHRoZSBsaW5rcyBhcnJheSBpcyBlbXB0eSwgaXQgcmV0dXJucyBgdW5kZWZpbmVkYCBzbyB0aGUgZW1wdHkgdmFsdWUgY2FuIGJlIGRyb3BwZWQgYmVmb3JlIGl0J3Mgc2VudC5cbiAqL1xuZnVuY3Rpb24gY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlKGxpbmtzKSB7XG4gIGlmIChsaW5rcyAmJiBsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGxpbmtzLm1hcCgoeyBjb250ZXh0OiB7IHNwYW5JZCwgdHJhY2VJZCwgdHJhY2VGbGFncywgLi4ucmVzdENvbnRleHQgfSwgYXR0cmlidXRlcyB9KSA9PiAoe1xuICAgICAgc3Bhbl9pZDogc3BhbklkLFxuICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQsXG4gICAgICBzYW1wbGVkOiB0cmFjZUZsYWdzID09PSBUUkFDRV9GTEFHX1NBTVBMRUQsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgLi4ucmVzdENvbnRleHQsXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3BhbiB0aW1lIGlucHV0IGludG8gYSB0aW1lc3RhbXAgaW4gc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBlbnN1cmVUaW1lc3RhbXBJblNlY29uZHMoaW5wdXQpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgLy8gU2VlIHtAbGluayBIclRpbWV9IGZvciB0aGUgYXJyYXktYmFzZWQgdGltZSBmb3JtYXRcbiAgICByZXR1cm4gaW5wdXRbMF0gKyBpbnB1dFsxXSAvIDFlOTtcbiAgfVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gZW5zdXJlVGltZXN0YW1wSW5TZWNvbmRzKGlucHV0LmdldFRpbWUoKSk7XG4gIH1cblxuICByZXR1cm4gdGltZXN0YW1wSW5TZWNvbmRzKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSB0aW1lc3RhbXAgdG8gc2Vjb25kLCBpZiBpdCB3YXMgaW4gbWlsbGlzZWNvbmRzLCBvciBrZWVwcyBpdCBhcyBzZWNvbmQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVRpbWVzdGFtcEluU2Vjb25kcyh0aW1lc3RhbXApIHtcbiAgY29uc3QgaXNNcyA9IHRpbWVzdGFtcCA+IDk5OTk5OTk5OTk7XG4gIHJldHVybiBpc01zID8gdGltZXN0YW1wIC8gMTAwMCA6IHRpbWVzdGFtcDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3BhbiB0byBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gKi9cbi8vIE5vdGU6IEJlY2F1c2Ugb2YgdGhpcywgd2UgY3VycmVudGx5IGhhdmUgYSBjaXJjdWxhciB0eXBlIGRlcGVuZGVuY3kgKHdoaWNoIHdlIG9wdGVkIG91dCBvZiBpbiBwYWNrYWdlLmpzb24pLlxuLy8gVGhpcyBpcyBub3QgYXZvaWRhYmxlIGFzIHdlIG5lZWQgYHNwYW5Ub0pTT05gIGluIGBzcGFuVXRpbHMudHNgLCB3aGljaCBpbiB0dXJuIGlzIG5lZWRlZCBieSBgc3Bhbi50c2AgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuLy8gQW5kIGBzcGFuVG9KU09OYCBuZWVkcyB0aGUgU3BhbiBjbGFzcyBmcm9tIGBzcGFuLnRzYCB0byBjaGVjayBoZXJlLlxuZnVuY3Rpb24gc3BhblRvSlNPTihzcGFuKSB7XG4gIGlmIChzcGFuSXNTZW50cnlTcGFuKHNwYW4pKSB7XG4gICAgcmV0dXJuIHNwYW4uZ2V0U3BhbkpTT04oKTtcbiAgfVxuXG4gIGNvbnN0IHsgc3BhbklkOiBzcGFuX2lkLCB0cmFjZUlkOiB0cmFjZV9pZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuXG4gIC8vIEhhbmRsZSBhIHNwYW4gZnJvbSBAb3BlbnRlbGVtZXRyeS9zZGstYmFzZS10cmFjZSdzIGBTcGFuYCBjbGFzc1xuICBpZiAoc3BhbklzT3BlblRlbGVtZXRyeVNka1RyYWNlQmFzZVNwYW4oc3BhbikpIHtcbiAgICBjb25zdCB7IGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgbmFtZSwgZW5kVGltZSwgcGFyZW50U3BhbklkLCBzdGF0dXMsIGxpbmtzIH0gPSBzcGFuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwYW5faWQsXG4gICAgICB0cmFjZV9pZCxcbiAgICAgIGRhdGE6IGF0dHJpYnV0ZXMsXG4gICAgICBkZXNjcmlwdGlvbjogbmFtZSxcbiAgICAgIHBhcmVudF9zcGFuX2lkOiBwYXJlbnRTcGFuSWQsXG4gICAgICBzdGFydF90aW1lc3RhbXA6IHNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3RhcnRUaW1lKSxcbiAgICAgIC8vIFRoaXMgaXMgWzAsMF0gYnkgZGVmYXVsdCBpbiBPVEVMLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gaW50ZXJwcmV0IHRoaXMgYXMgbm8gZW5kIHRpbWVcbiAgICAgIHRpbWVzdGFtcDogc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhlbmRUaW1lKSB8fCB1bmRlZmluZWQsXG4gICAgICBzdGF0dXM6IGdldFN0YXR1c01lc3NhZ2Uoc3RhdHVzKSxcbiAgICAgIG9wOiBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdLFxuICAgICAgb3JpZ2luOiBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXSAsXG4gICAgICBsaW5rczogY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlKGxpbmtzKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gRmluYWxseSwgYXQgbGVhc3Qgd2UgaGF2ZSBgc3BhbkNvbnRleHQoKWAuLi4uXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBhY3R1YWxseSBoYXBwZW4gaW4gcmVhbGl0eSwgYnV0IHdlIG5lZWQgdG8gaGFuZGxlIGl0IGZvciB0eXBlIHNhZmV0eS5cbiAgcmV0dXJuIHtcbiAgICBzcGFuX2lkLFxuICAgIHRyYWNlX2lkLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogMCxcbiAgICBkYXRhOiB7fSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3BhbklzT3BlblRlbGVtZXRyeVNka1RyYWNlQmFzZVNwYW4oc3Bhbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5hdHRyaWJ1dGVzICYmICEhY2FzdFNwYW4uc3RhcnRUaW1lICYmICEhY2FzdFNwYW4ubmFtZSAmJiAhIWNhc3RTcGFuLmVuZFRpbWUgJiYgISFjYXN0U3Bhbi5zdGF0dXM7XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cblxuLyoqXG4gKiBTYWRseSwgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY3kgY2hlY2tzIHdlIGNhbm5vdCBhY3R1YWxseSBpbXBvcnQgdGhlIFNwYW4gY2xhc3MgaGVyZSBhbmQgY2hlY2sgZm9yIGluc3RhbmNlb2YuXG4gKiA6KCBTbyBpbnN0ZWFkIHdlIGFwcHJveGltYXRlIHRoaXMgYnkgY2hlY2tpbmcgaWYgaXQgaGFzIHRoZSBgZ2V0U3BhbkpTT05gIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gc3BhbklzU2VudHJ5U3BhbihzcGFuKSB7XG4gIHJldHVybiB0eXBlb2YgKHNwYW4gKS5nZXRTcGFuSlNPTiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBzcGFuIGlzIHNhbXBsZWQuXG4gKiBJbiBtb3N0IGNhc2VzLCB5b3Ugc2hvdWxkIGp1c3QgdXNlIGBzcGFuLmlzUmVjb3JkaW5nKClgIGluc3RlYWQuXG4gKiBIb3dldmVyLCB0aGlzIGhhcyBhIHNsaWdodGx5IGRpZmZlcmVudCBzZW1hbnRpYywgYXMgaXQgYWxzbyByZXR1cm5zIGZhbHNlIGlmIHRoZSBzcGFuIGlzIGZpbmlzaGVkLlxuICogU28gaW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBkaXN0aW5jdGlvbiBpcyBpbXBvcnRhbnQsIHVzZSB0aGlzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gc3BhbklzU2FtcGxlZChzcGFuKSB7XG4gIC8vIFdlIGFsaWduIG91ciB0cmFjZSBmbGFncyB3aXRoIHRoZSBvbmVzIE9wZW5UZWxlbWV0cnkgdXNlXG4gIC8vIFNvIHdlIGFsc28gY2hlY2sgZm9yIHNhbXBsZWQgdGhlIHNhbWUgd2F5IHRoZXkgZG8uXG4gIGNvbnN0IHsgdHJhY2VGbGFncyB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICByZXR1cm4gdHJhY2VGbGFncyA9PT0gVFJBQ0VfRkxBR19TQU1QTEVEO1xufVxuXG4vKiogR2V0IHRoZSBzdGF0dXMgbWVzc2FnZSB0byB1c2UgZm9yIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHNwYW4uICovXG5mdW5jdGlvbiBnZXRTdGF0dXNNZXNzYWdlKHN0YXR1cykge1xuICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMuY29kZSA9PT0gU1BBTl9TVEFUVVNfVU5TRVQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHN0YXR1cy5jb2RlID09PSBTUEFOX1NUQVRVU19PSykge1xuICAgIHJldHVybiAnb2snO1xuICB9XG5cbiAgcmV0dXJuIHN0YXR1cy5tZXNzYWdlIHx8ICd1bmtub3duX2Vycm9yJztcbn1cblxuY29uc3QgQ0hJTERfU1BBTlNfRklFTEQgPSAnX3NlbnRyeUNoaWxkU3BhbnMnO1xuY29uc3QgUk9PVF9TUEFOX0ZJRUxEID0gJ19zZW50cnlSb290U3Bhbic7XG5cbi8qKlxuICogQWRkcyBhbiBvcGFxdWUgY2hpbGQgc3BhbiByZWZlcmVuY2UgdG8gYSBzcGFuLlxuICovXG5mdW5jdGlvbiBhZGRDaGlsZFNwYW5Ub1NwYW4oc3BhbiwgY2hpbGRTcGFuKSB7XG4gIC8vIFdlIHN0b3JlIHRoZSByb290IHNwYW4gcmVmZXJlbmNlIG9uIHRoZSBjaGlsZCBzcGFuXG4gIC8vIFdlIG5lZWQgdGhpcyBmb3IgYGdldFJvb3RTcGFuKClgIHRvIHdvcmtcbiAgY29uc3Qgcm9vdFNwYW4gPSBzcGFuW1JPT1RfU1BBTl9GSUVMRF0gfHwgc3BhbjtcbiAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KGNoaWxkU3BhbiAsIFJPT1RfU1BBTl9GSUVMRCwgcm9vdFNwYW4pO1xuXG4gIC8vIFdlIHN0b3JlIGEgbGlzdCBvZiBjaGlsZCBzcGFucyBvbiB0aGUgcGFyZW50IHNwYW5cbiAgLy8gV2UgbmVlZCB0aGlzIGZvciBgZ2V0U3BhbkRlc2NlbmRhbnRzKClgIHRvIHdvcmtcbiAgaWYgKHNwYW5bQ0hJTERfU1BBTlNfRklFTERdKSB7XG4gICAgc3BhbltDSElMRF9TUEFOU19GSUVMRF0uYWRkKGNoaWxkU3Bhbik7XG4gIH0gZWxzZSB7XG4gICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHNwYW4sIENISUxEX1NQQU5TX0ZJRUxELCBuZXcgU2V0KFtjaGlsZFNwYW5dKSk7XG4gIH1cbn1cblxuLyoqIFRoaXMgaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgSWRsZSBTcGFucy4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkU3BhbkZyb21TcGFuKHNwYW4sIGNoaWxkU3Bhbikge1xuICBpZiAoc3BhbltDSElMRF9TUEFOU19GSUVMRF0pIHtcbiAgICBzcGFuW0NISUxEX1NQQU5TX0ZJRUxEXS5kZWxldGUoY2hpbGRTcGFuKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGdpdmVuIHNwYW4gYW5kIGFsbCBvZiBpdHMgZGVzY2VuZGFudHMuXG4gKi9cbmZ1bmN0aW9uIGdldFNwYW5EZXNjZW5kYW50cyhzcGFuKSB7XG4gIGNvbnN0IHJlc3VsdFNldCA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBhZGRTcGFuQ2hpbGRyZW4oc3Bhbikge1xuICAgIC8vIFRoaXMgZXhpdCBjb25kaXRpb24gaXMgcmVxdWlyZWQgdG8gbm90IGluZmluaXRlbHkgbG9vcCBpbiBjYXNlIG9mIGEgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICBpZiAocmVzdWx0U2V0LmhhcyhzcGFuKSkge1xuICAgICAgcmV0dXJuO1xuICAgICAgLy8gV2Ugd2FudCB0byBpZ25vcmUgdW5zYW1wbGVkIHNwYW5zIChlLmcuIG5vbiByZWNvcmRpbmcgc3BhbnMpXG4gICAgfSBlbHNlIGlmIChzcGFuSXNTYW1wbGVkKHNwYW4pKSB7XG4gICAgICByZXN1bHRTZXQuYWRkKHNwYW4pO1xuICAgICAgY29uc3QgY2hpbGRTcGFucyA9IHNwYW5bQ0hJTERfU1BBTlNfRklFTERdID8gQXJyYXkuZnJvbShzcGFuW0NISUxEX1NQQU5TX0ZJRUxEXSkgOiBbXTtcbiAgICAgIGZvciAoY29uc3QgY2hpbGRTcGFuIG9mIGNoaWxkU3BhbnMpIHtcbiAgICAgICAgYWRkU3BhbkNoaWxkcmVuKGNoaWxkU3Bhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkU3BhbkNoaWxkcmVuKHNwYW4pO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdFNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCBzcGFuIG9mIGEgZ2l2ZW4gc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdFNwYW4oc3Bhbikge1xuICByZXR1cm4gc3BhbltST09UX1NQQU5fRklFTERdIHx8IHNwYW47XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzcGFuLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuKCkge1xuICBjb25zdCBjYXJyaWVyID0gZ2V0TWFpbkNhcnJpZXIoKTtcbiAgY29uc3QgYWNzID0gZ2V0QXN5bmNDb250ZXh0U3RyYXRlZ3koY2Fycmllcik7XG4gIGlmIChhY3MuZ2V0QWN0aXZlU3Bhbikge1xuICAgIHJldHVybiBhY3MuZ2V0QWN0aXZlU3BhbigpO1xuICB9XG5cbiAgcmV0dXJuIF9nZXRTcGFuRm9yU2NvcGUoZ2V0Q3VycmVudFNjb3BlKCkpO1xufVxuXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIG9uY2UgaWYgYGJlZm9yZVNlbmRTcGFuYCBpcyB1c2VkIHRvIGRyb3Agc3BhbnMuXG4gKi9cbmZ1bmN0aW9uIHNob3dTcGFuRHJvcFdhcm5pbmcoKSB7XG4gIGlmICghaGFzU2hvd25TcGFuRHJvcFdhcm5pbmcpIHtcbiAgICBjb25zb2xlU2FuZGJveCgoKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnW1NlbnRyeV0gUmV0dXJuaW5nIG51bGwgZnJvbSBgYmVmb3JlU2VuZFNwYW5gIGlzIGRpc2FsbG93ZWQuIFRvIGRyb3AgY2VydGFpbiBzcGFucywgY29uZmlndXJlIHRoZSByZXNwZWN0aXZlIGludGVncmF0aW9ucyBkaXJlY3RseS4nLFxuICAgICAgKTtcbiAgICB9KTtcbiAgICBoYXNTaG93blNwYW5Ecm9wV2FybmluZyA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBzcGFuIGFuZCBlbnN1cmVzIHRoYXQgdGhlIHNwYW4gbmFtZSBpcyBub3RcbiAqIG92ZXJ3cml0dGVuIGJ5IHRoZSBTZW50cnkgU0RLLlxuICpcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHNwYW4udXBkYXRlTmFtZSgpYCBpZiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdFxuICogeW91ciBuYW1lIGlzIGtlcHQuIEZvciBzb21lIHNwYW5zLCBmb3IgZXhhbXBsZSByb290IGBodHRwLnNlcnZlcmAgc3BhbnMgdGhlXG4gKiBTZW50cnkgU0RLIHdvdWxkIG90aGVyd2lzZSBvdmVyd3JpdGUgdGhlIHNwYW4gbmFtZSB3aXRoIGEgaGlnaC1xdWFsaXR5IG5hbWVcbiAqIGl0IGluZmVycyB3aGVuIHRoZSBzcGFuIGVuZHMuXG4gKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gaW4gc2VydmVyIGNvZGUgb3Igd2hlbiB5b3VyIHNwYW4gaXMgc3RhcnRlZCBvbiB0aGUgc2VydmVyXG4gKiBhbmQgb24gdGhlIGNsaWVudCAoYnJvd3NlcikuIElmIHlvdSBvbmx5IHVwZGF0ZSBhIHNwYW4gbmFtZSBvbiB0aGUgY2xpZW50LFxuICogeW91IGNhbiBhbHNvIHVzZSBgc3Bhbi51cGRhdGVOYW1lKClgIHRoZSBTREsgZG9lcyBub3Qgb3ZlcndyaXRlIHRoZSBuYW1lLlxuICpcbiAqIEBwYXJhbSBzcGFuIC0gVGhlIHNwYW4gdG8gdXBkYXRlIHRoZSBuYW1lIG9mLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSB0byBzZXQgb24gdGhlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVNwYW5OYW1lKHNwYW4sIG5hbWUpIHtcbiAgc3Bhbi51cGRhdGVOYW1lKG5hbWUpO1xuICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICdjdXN0b20nLFxuICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX0NVU1RPTV9TUEFOX05BTUVdOiBuYW1lLFxuICB9KTtcbn1cblxuZXhwb3J0IHsgVFJBQ0VfRkxBR19OT05FLCBUUkFDRV9GTEFHX1NBTVBMRUQsIGFkZENoaWxkU3BhblRvU3BhbiwgY29udmVydFNwYW5MaW5rc0ZvckVudmVsb3BlLCBnZXRBY3RpdmVTcGFuLCBnZXRSb290U3BhbiwgZ2V0U3BhbkRlc2NlbmRhbnRzLCBnZXRTdGF0dXNNZXNzYWdlLCByZW1vdmVDaGlsZFNwYW5Gcm9tU3Bhbiwgc2hvd1NwYW5Ecm9wV2FybmluZywgc3BhbklzU2FtcGxlZCwgc3BhblRpbWVJbnB1dFRvU2Vjb25kcywgc3BhblRvSlNPTiwgc3BhblRvVHJhY2VDb250ZXh0LCBzcGFuVG9UcmFjZUhlYWRlciwgc3BhblRvVHJhbnNhY3Rpb25UcmFjZUNvbnRleHQsIHVwZGF0ZVNwYW5OYW1lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGFuVXRpbHMuanMubWFwXG4iLCJpbXBvcnQgeyBnZXRDbGllbnQgfSBmcm9tICcuLi9jdXJyZW50U2NvcGVzLmpzJztcblxuLy8gVHJlZXNoYWthYmxlIGd1YXJkIHRvIHJlbW92ZSBhbGwgY29kZSByZWxhdGVkIHRvIHRyYWNpbmdcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHNwYW4gcmVjb3JkaW5nIGlzIGN1cnJlbnRseSBlbmFibGVkLlxuICpcbiAqIFNwYW5zIGFyZSByZWNvcmRlZCB3aGVuIGF0IGxlYXN0IG9uZSBvZiBgdHJhY2VzU2FtcGxlUmF0ZWAgYW5kIGB0cmFjZXNTYW1wbGVyYFxuICogaXMgZGVmaW5lZCBpbiB0aGUgU0RLIGNvbmZpZy4gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBtYWtlIGFueSBhc3N1bXB0aW9uIGFib3V0XG4gKiBzYW1wbGluZyBkZWNpc2lvbnMsIGl0IG9ubHkgY2hlY2tzIGlmIHRoZSBTREsgaXMgY29uZmlndXJlZCB0byByZWNvcmQgc3BhbnMuXG4gKlxuICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIG9ubHkgZGV0ZXJtaW5lcyBpZiBzcGFuIHJlY29yZGluZyBpcyBlbmFibGVkLiBUcmFjZVxuICogY29udGludWF0aW9uIGFuZCBwcm9wYWdhdGlvbiBpcyBzZXBhcmF0ZWx5IGNvbnRyb2xsZWQgYW5kIG5vdCBjb3ZlcmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdHJhY2VzIGNhbiBzdGlsbCBiZSBwcm9wYWdhdGVkICh3aGljaCBpcyB3aGF0XG4gKiB3ZSByZWZlciB0byBieSBcIlRyYWNpbmcgd2l0aG91dCBQZXJmb3JtYW5jZVwiKVxuICogQHNlZSBodHRwczovL2RldmVsb3Auc2VudHJ5LmRldi9zZGsvdGVsZW1ldHJ5L3RyYWNlcy90cmFjaW5nLXdpdGhvdXQtcGVyZm9ybWFuY2UvXG4gKlxuICogQHBhcmFtIG1heWJlT3B0aW9ucyBBbiBTREsgb3B0aW9ucyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBJZiB0aGlzIG9wdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHVzZSB0aGUgY3VycmVudCBjbGllbnQncyBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBoYXNTcGFuc0VuYWJsZWQoXG4gIG1heWJlT3B0aW9ucyxcbikge1xuICBpZiAodHlwZW9mIF9fU0VOVFJZX1RSQUNJTkdfXyA9PT0gJ2Jvb2xlYW4nICYmICFfX1NFTlRSWV9UUkFDSU5HX18pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gbWF5YmVPcHRpb25zIHx8IGdldENsaWVudCgpPy5nZXRPcHRpb25zKCk7XG4gIHJldHVybiAoXG4gICAgISFvcHRpb25zICYmXG4gICAgLy8gTm90ZTogVGhpcyBjaGVjayBpcyBgIT0gbnVsbGAsIG1lYW5pbmcgXCJudWxsaXNoXCIuIGAwYCBpcyBub3QgXCJudWxsaXNoXCIsIGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgYXJlLiAoVGhpcyBjb21tZW50IHdhcyBicm91Z2h0IHRvIHlvdSBieSAxNSBtaW51dGVzIG9mIHF1ZXN0aW9uaW5nIGxpZmUpXG4gICAgKG9wdGlvbnMudHJhY2VzU2FtcGxlUmF0ZSAhPSBudWxsIHx8ICEhb3B0aW9ucy50cmFjZXNTYW1wbGVyKVxuICApO1xufVxuXG4vKipcbiAqIEBzZWUgSlNEb2Mgb2YgYGhhc1NwYW5zRW5hYmxlZGBcbiAqIEBkZXByZWNhdGVkIFVzZSBgaGFzU3BhbnNFbmFibGVkYCBpbnN0ZWFkLCB3aGljaCBpcyBhIG1vcmUgYWNjdXJhdGVseSBuYW1lZCB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIHRoZSBTREsuXG4gKi9cbi8vIFRPRE8odjEwKTogUmVtb3ZlIHRoaXMgZXhwb3J0XG5jb25zdCBoYXNUcmFjaW5nRW5hYmxlZCA9IGhhc1NwYW5zRW5hYmxlZDtcblxuZXhwb3J0IHsgaGFzU3BhbnNFbmFibGVkLCBoYXNUcmFjaW5nRW5hYmxlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzU3BhbnNFbmFibGVkLmpzLm1hcFxuIiwiY29uc3QgREVGQVVMVF9FTlZJUk9OTUVOVCA9ICdwcm9kdWN0aW9uJztcblxuZXhwb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIiwiaW1wb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRDbGllbnQgfSBmcm9tICcuLi9jdXJyZW50U2NvcGVzLmpzJztcbmltcG9ydCB7IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFIH0gZnJvbSAnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQsIGR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIgfSBmcm9tICcuLi91dGlscy1ob2lzdC9iYWdnYWdlLmpzJztcbmltcG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcyc7XG5pbXBvcnQgeyBoYXNTcGFuc0VuYWJsZWQgfSBmcm9tICcuLi91dGlscy9oYXNTcGFuc0VuYWJsZWQuanMnO1xuaW1wb3J0IHsgZ2V0Um9vdFNwYW4sIHNwYW5Ub0pTT04sIHNwYW5Jc1NhbXBsZWQgfSBmcm9tICcuLi91dGlscy9zcGFuVXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4gfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJZiB5b3UgY2hhbmdlIHRoaXMgdmFsdWUsIGFsc28gdXBkYXRlIHRoZSB0ZXJzZXIgcGx1Z2luIGNvbmZpZyB0b1xuICogYXZvaWQgbWluaWZpY2F0aW9uIG9mIHRoZSBvYmplY3QgcHJvcGVydHkhXG4gKi9cbmNvbnN0IEZST1pFTl9EU0NfRklFTEQgPSAnX2Zyb3plbkRzYyc7XG5cbi8qKlxuICogRnJlZXplIHRoZSBnaXZlbiBEU0Mgb24gdGhlIGdpdmVuIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGZyZWV6ZURzY09uU3BhbihzcGFuLCBkc2MpIHtcbiAgY29uc3Qgc3BhbldpdGhNYXliZURzYyA9IHNwYW4gO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc3BhbldpdGhNYXliZURzYywgRlJPWkVOX0RTQ19GSUVMRCwgZHNjKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IGZyb20gYSBjbGllbnQuXG4gKlxuICogRGlzcGF0Y2hlcyB0aGUgYGNyZWF0ZURzY2AgbGlmZWN5Y2xlIGhvb2sgYXMgYSBzaWRlIGVmZmVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQodHJhY2VfaWQsIGNsaWVudCkge1xuICBjb25zdCBvcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcblxuICBjb25zdCB7IHB1YmxpY0tleTogcHVibGljX2tleSB9ID0gY2xpZW50LmdldERzbigpIHx8IHt9O1xuXG4gIC8vIEluc3RlYWQgb2YgY29uZGl0aW9uYWxseSBhZGRpbmcgbm9uLXVuZGVmaW5lZCB2YWx1ZXMsIHdlIGFkZCB0aGVtIGFuZCB0aGVuIHJlbW92ZSB0aGVtIGlmIG5lZWRlZFxuICAvLyBvdGhlcndpc2UsIHRoZSBvcmRlciBvZiBiYWdnYWdlIGVudHJpZXMgY2hhbmdlcywgd2hpY2ggXCJicmVha3NcIiBhIGJ1bmNoIG9mIHRlc3RzIGV0Yy5cbiAgY29uc3QgZHNjID0ge1xuICAgIGVudmlyb25tZW50OiBvcHRpb25zLmVudmlyb25tZW50IHx8IERFRkFVTFRfRU5WSVJPTk1FTlQsXG4gICAgcmVsZWFzZTogb3B0aW9ucy5yZWxlYXNlLFxuICAgIHB1YmxpY19rZXksXG4gICAgdHJhY2VfaWQsXG4gIH07XG5cbiAgY2xpZW50LmVtaXQoJ2NyZWF0ZURzYycsIGRzYyk7XG5cbiAgcmV0dXJuIGRzYztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dCBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NvcGVzLlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlKGNsaWVudCwgc2NvcGUpIHtcbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG4gIHJldHVybiBwcm9wYWdhdGlvbkNvbnRleHQuZHNjIHx8IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHByb3BhZ2F0aW9uQ29udGV4dC50cmFjZUlkLCBjbGllbnQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgZnJvbSBhIHNwYW4gKGFuZCBjbGllbnQgYW5kIHNjb3BlKVxuICpcbiAqIEBwYXJhbSBzcGFuIHRoZSBzcGFuIGZyb20gd2hpY2ggYSBmZXcgdmFsdWVzIGxpa2UgdGhlIHJvb3Qgc3BhbiBuYW1lIGFuZCBzYW1wbGUgcmF0ZSBhcmUgZXh0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHJvb3RTcGFuID0gZ2V0Um9vdFNwYW4oc3Bhbik7XG4gIGNvbnN0IHJvb3RTcGFuSnNvbiA9IHNwYW5Ub0pTT04ocm9vdFNwYW4pO1xuICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSByb290U3Bhbkpzb24uZGF0YTtcbiAgY29uc3QgdHJhY2VTdGF0ZSA9IHJvb3RTcGFuLnNwYW5Db250ZXh0KCkudHJhY2VTdGF0ZTtcblxuICAvLyBUaGUgc3BhbiBzYW1wbGUgcmF0ZSB0aGF0IHdhcyBsb2NhbGx5IGFwcGxpZWQgdG8gdGhlIHJvb3Qgc3BhbiBzaG91bGQgYWxzbyBhbHdheXMgYmUgYXBwbGllZCB0byB0aGUgRFNDLCBldmVuIGlmIHRoZSBEU0MgaXMgZnJvemVuLlxuICAvLyBUaGlzIGlzIHNvIHRoYXQgdGhlIGRvd25zdHJlYW0gdHJhY2VzL3NlcnZpY2VzIGNhbiB1c2UgcGFyZW50U2FtcGxlUmF0ZSBpbiB0aGVpciBgdHJhY2VzU2FtcGxlcmAgdG8gbWFrZSBjb25zaXN0ZW50IHNhbXBsaW5nIGRlY2lzaW9ucyBhY3Jvc3MgdGhlIGVudGlyZSB0cmFjZS5cbiAgY29uc3Qgcm9vdFNwYW5TYW1wbGVSYXRlID1cbiAgICB0cmFjZVN0YXRlPy5nZXQoJ3NlbnRyeS5zYW1wbGVfcmF0ZScpID8/IHJvb3RTcGFuQXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTtcbiAgZnVuY3Rpb24gYXBwbHlMb2NhbFNhbXBsZVJhdGVUb0RzYyhkc2MpIHtcbiAgICBpZiAodHlwZW9mIHJvb3RTcGFuU2FtcGxlUmF0ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHJvb3RTcGFuU2FtcGxlUmF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRzYy5zYW1wbGVfcmF0ZSA9IGAke3Jvb3RTcGFuU2FtcGxlUmF0ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gZHNjO1xuICB9XG5cbiAgLy8gRm9yIGNvcmUgaW1wbGVtZW50YXRpb24sIHdlIGZyZWV6ZSB0aGUgRFNDIG9udG8gdGhlIHNwYW4gYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBjb25zdCBmcm96ZW5Ec2MgPSAocm9vdFNwYW4gKVtGUk9aRU5fRFNDX0ZJRUxEXTtcbiAgaWYgKGZyb3plbkRzYykge1xuICAgIHJldHVybiBhcHBseUxvY2FsU2FtcGxlUmF0ZVRvRHNjKGZyb3plbkRzYyk7XG4gIH1cblxuICAvLyBGb3IgT3BlblRlbGVtZXRyeSwgd2UgZnJlZXplIHRoZSBEU0Mgb24gdGhlIHRyYWNlIHN0YXRlXG4gIGNvbnN0IHRyYWNlU3RhdGVEc2MgPSB0cmFjZVN0YXRlPy5nZXQoJ3NlbnRyeS5kc2MnKTtcblxuICAvLyBJZiB0aGUgc3BhbiBoYXMgYSBEU0MsIHdlIHdhbnQgaXQgdG8gdGFrZSBwcmVjZWRlbmNlXG4gIGNvbnN0IGRzY09uVHJhY2VTdGF0ZSA9IHRyYWNlU3RhdGVEc2MgJiYgYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dCh0cmFjZVN0YXRlRHNjKTtcblxuICBpZiAoZHNjT25UcmFjZVN0YXRlKSB7XG4gICAgcmV0dXJuIGFwcGx5TG9jYWxTYW1wbGVSYXRlVG9Ec2MoZHNjT25UcmFjZVN0YXRlKTtcbiAgfVxuXG4gIC8vIEVsc2UsIHdlIGdlbmVyYXRlIGl0IGZyb20gdGhlIHNwYW5cbiAgY29uc3QgZHNjID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQoc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQsIGNsaWVudCk7XG5cbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYXZlIGEgdHJhbnNhY3Rpb24gbmFtZSBpbiB0aGUgRFNDIGlmIHRoZSBzb3VyY2UgaXMgXCJ1cmxcIiBiZWNhdXNlIFVSTHMgbWlnaHQgY29udGFpbiBQSUlcbiAgY29uc3Qgc291cmNlID0gcm9vdFNwYW5BdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTtcblxuICAvLyBhZnRlciBKU09OIGNvbnZlcnNpb24sIHR4bi5uYW1lIGJlY29tZXMganNvblNwYW4uZGVzY3JpcHRpb25cbiAgY29uc3QgbmFtZSA9IHJvb3RTcGFuSnNvbi5kZXNjcmlwdGlvbjtcbiAgaWYgKHNvdXJjZSAhPT0gJ3VybCcgJiYgbmFtZSkge1xuICAgIGRzYy50cmFuc2FjdGlvbiA9IG5hbWU7XG4gIH1cblxuICAvLyBIb3cgY2FuIHdlIGV2ZW4gbGFuZCBoZXJlIHdpdGggaGFzU3BhbnNFbmFibGVkKCkgcmV0dXJuaW5nIGZhbHNlP1xuICAvLyBPdGVsIGNyZWF0ZXMgYSBOb24tcmVjb3JkaW5nIHNwYW4gaW4gVHJhY2luZyBXaXRob3V0IFBlcmZvcm1hbmNlIG1vZGUgd2hlbiBoYW5kbGluZyBpbmNvbWluZyByZXF1ZXN0c1xuICAvLyBTbyB3ZSBlbmQgdXAgd2l0aCBhbiBhY3RpdmUgc3BhbiB0aGF0IGlzIG5vdCBzYW1wbGVkIChuZWl0aGVyIHBvc2l0aXZlbHkgbm9yIG5lZ2F0aXZlbHkpXG4gIGlmIChoYXNTcGFuc0VuYWJsZWQoKSkge1xuICAgIGRzYy5zYW1wbGVkID0gU3RyaW5nKHNwYW5Jc1NhbXBsZWQocm9vdFNwYW4pKTtcbiAgICBkc2Muc2FtcGxlX3JhbmQgPVxuICAgICAgLy8gSW4gT1RFTCB3ZSBzdG9yZSB0aGUgc2FtcGxlIHJhbmQgb24gdGhlIHRyYWNlIHN0YXRlIGJlY2F1c2Ugd2UgY2Fubm90IGFjY2VzcyBzY29wZXMgZm9yIE5vblJlY29yZGluZ1NwYW5zXG4gICAgICAvLyBUaGUgU2VudHJ5IE9URUwgU3BhblNhbXBsZXIgdGFrZXMgY2FyZSBvZiB3cml0aW5nIHRoZSBzYW1wbGUgcmFuZCBvbiB0aGUgcm9vdCBzcGFuXG4gICAgICB0cmFjZVN0YXRlPy5nZXQoJ3NlbnRyeS5zYW1wbGVfcmFuZCcpID8/XG4gICAgICAvLyBPbiBhbGwgb3RoZXIgcGxhdGZvcm1zIHdlIGNhbiBhY3R1YWxseSBnZXQgdGhlIHNjb3BlcyBmcm9tIGEgcm9vdCBzcGFuICh3ZSB1c2UgdGhpcyBhcyBhIGZhbGxiYWNrKVxuICAgICAgZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4ocm9vdFNwYW4pLnNjb3BlPy5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKS5zYW1wbGVSYW5kLnRvU3RyaW5nKCk7XG4gIH1cblxuICBhcHBseUxvY2FsU2FtcGxlUmF0ZVRvRHNjKGRzYyk7XG5cbiAgY2xpZW50LmVtaXQoJ2NyZWF0ZURzYycsIGRzYywgcm9vdFNwYW4pO1xuXG4gIHJldHVybiBkc2M7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFNwYW4gdG8gYSBiYWdnYWdlIGhlYWRlci5cbiAqL1xuZnVuY3Rpb24gc3BhblRvQmFnZ2FnZUhlYWRlcihzcGFuKSB7XG4gIGNvbnN0IGRzYyA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKTtcbiAgcmV0dXJuIGR5bmFtaWNTYW1wbGluZ0NvbnRleHRUb1NlbnRyeUJhZ2dhZ2VIZWFkZXIoZHNjKTtcbn1cblxuZXhwb3J0IHsgZnJlZXplRHNjT25TcGFuLCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudCwgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZSwgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuLCBzcGFuVG9CYWdnYWdlSGVhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzLm1hcFxuIiwiaW1wb3J0IHsgREVCVUdfQlVJTEQgfSBmcm9tICcuL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IGNvbnNvbGVTYW5kYm94LCBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlci5qcyc7XG5cbi8qKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBwYXJzZSBhIERzbi4gKi9cbmNvbnN0IERTTl9SRUdFWCA9IC9eKD86KFxcdyspOilcXC9cXC8oPzooXFx3KykoPzo6KFxcdyspPyk/QCkoW1xcdy4tXSspKD86OihcXGQrKSk/XFwvKC4rKS87XG5cbmZ1bmN0aW9uIGlzVmFsaWRQcm90b2NvbChwcm90b2NvbCkge1xuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwJyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzJztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEc24uXG4gKlxuICogQnkgZGVmYXVsdCwgdGhpcyB3aWxsIHJlbmRlciB0aGUgcHVibGljIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgdGhlIHBhc3N3b3JkXG4gKiBjb21wb25lbnQuIFRvIGdldCB0aGUgZGVwcmVjYXRlZCBwcml2YXRlIHJlcHJlc2VudGF0aW9uLCBzZXQgYHdpdGhQYXNzd29yZGBcbiAqIHRvIHRydWUuXG4gKlxuICogQHBhcmFtIHdpdGhQYXNzd29yZCBXaGVuIHNldCB0byB0cnVlLCB0aGUgcGFzc3dvcmQgd2lsbCBiZSBpbmNsdWRlZC5cbiAqL1xuZnVuY3Rpb24gZHNuVG9TdHJpbmcoZHNuLCB3aXRoUGFzc3dvcmQgPSBmYWxzZSkge1xuICBjb25zdCB7IGhvc3QsIHBhdGgsIHBhc3MsIHBvcnQsIHByb2plY3RJZCwgcHJvdG9jb2wsIHB1YmxpY0tleSB9ID0gZHNuO1xuICByZXR1cm4gKFxuICAgIGAke3Byb3RvY29sfTovLyR7cHVibGljS2V5fSR7d2l0aFBhc3N3b3JkICYmIHBhc3MgPyBgOiR7cGFzc31gIDogJyd9YCArXG4gICAgYEAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfS8ke3BhdGggPyBgJHtwYXRofS9gIDogcGF0aH0ke3Byb2plY3RJZH1gXG4gICk7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgRHNuIGZyb20gYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciBBIERzbiBhcyBzdHJpbmdcbiAqIEByZXR1cm5zIERzbiBhcyBEc25Db21wb25lbnRzIG9yIHVuZGVmaW5lZCBpZiBAcGFyYW0gc3RyIGlzIG5vdCBhIHZhbGlkIERTTiBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZHNuRnJvbVN0cmluZyhzdHIpIHtcbiAgY29uc3QgbWF0Y2ggPSBEU05fUkVHRVguZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGVcbiAgICBjb25zb2xlU2FuZGJveCgoKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBTZW50cnkgRHNuOiAke3N0cn1gKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgW3Byb3RvY29sLCBwdWJsaWNLZXksIHBhc3MgPSAnJywgaG9zdCA9ICcnLCBwb3J0ID0gJycsIGxhc3RQYXRoID0gJyddID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXRoID0gJyc7XG4gIGxldCBwcm9qZWN0SWQgPSBsYXN0UGF0aDtcblxuICBjb25zdCBzcGxpdCA9IHByb2plY3RJZC5zcGxpdCgnLycpO1xuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgIHBhdGggPSBzcGxpdC5zbGljZSgwLCAtMSkuam9pbignLycpO1xuICAgIHByb2plY3RJZCA9IHNwbGl0LnBvcCgpIDtcbiAgfVxuXG4gIGlmIChwcm9qZWN0SWQpIHtcbiAgICBjb25zdCBwcm9qZWN0TWF0Y2ggPSBwcm9qZWN0SWQubWF0Y2goL15cXGQrLyk7XG4gICAgaWYgKHByb2plY3RNYXRjaCkge1xuICAgICAgcHJvamVjdElkID0gcHJvamVjdE1hdGNoWzBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc25Gcm9tQ29tcG9uZW50cyh7IGhvc3QsIHBhc3MsIHBhdGgsIHByb2plY3RJZCwgcG9ydCwgcHJvdG9jb2w6IHByb3RvY29sICwgcHVibGljS2V5IH0pO1xufVxuXG5mdW5jdGlvbiBkc25Gcm9tQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IGNvbXBvbmVudHMucHJvdG9jb2wsXG4gICAgcHVibGljS2V5OiBjb21wb25lbnRzLnB1YmxpY0tleSB8fCAnJyxcbiAgICBwYXNzOiBjb21wb25lbnRzLnBhc3MgfHwgJycsXG4gICAgaG9zdDogY29tcG9uZW50cy5ob3N0LFxuICAgIHBvcnQ6IGNvbXBvbmVudHMucG9ydCB8fCAnJyxcbiAgICBwYXRoOiBjb21wb25lbnRzLnBhdGggfHwgJycsXG4gICAgcHJvamVjdElkOiBjb21wb25lbnRzLnByb2plY3RJZCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEc24oZHNuKSB7XG4gIGlmICghREVCVUdfQlVJTEQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHsgcG9ydCwgcHJvamVjdElkLCBwcm90b2NvbCB9ID0gZHNuO1xuXG4gIGNvbnN0IHJlcXVpcmVkQ29tcG9uZW50cyA9IFsncHJvdG9jb2wnLCAncHVibGljS2V5JywgJ2hvc3QnLCAncHJvamVjdElkJ107XG4gIGNvbnN0IGhhc01pc3NpbmdSZXF1aXJlZENvbXBvbmVudCA9IHJlcXVpcmVkQ29tcG9uZW50cy5maW5kKGNvbXBvbmVudCA9PiB7XG4gICAgaWYgKCFkc25bY29tcG9uZW50XSkge1xuICAgICAgbG9nZ2VyLmVycm9yKGBJbnZhbGlkIFNlbnRyeSBEc246ICR7Y29tcG9uZW50fSBtaXNzaW5nYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICBpZiAoaGFzTWlzc2luZ1JlcXVpcmVkQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFwcm9qZWN0SWQubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgbG9nZ2VyLmVycm9yKGBJbnZhbGlkIFNlbnRyeSBEc246IEludmFsaWQgcHJvamVjdElkICR7cHJvamVjdElkfWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZFByb3RvY29sKHByb3RvY29sKSkge1xuICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBTZW50cnkgRHNuOiBJbnZhbGlkIHByb3RvY29sICR7cHJvdG9jb2x9YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBvcnQgJiYgaXNOYU4ocGFyc2VJbnQocG9ydCwgMTApKSkge1xuICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBTZW50cnkgRHNuOiBJbnZhbGlkIHBvcnQgJHtwb3J0fWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB2YWxpZCBTZW50cnkgRHNuIG9iamVjdCwgaWRlbnRpZnlpbmcgYSBTZW50cnkgaW5zdGFuY2UgYW5kIHByb2plY3QuXG4gKiBAcmV0dXJucyBhIHZhbGlkIERzbkNvbXBvbmVudHMgb2JqZWN0IG9yIGB1bmRlZmluZWRgIGlmIEBwYXJhbSBmcm9tIGlzIGFuIGludmFsaWQgRFNOIHNvdXJjZVxuICovXG5mdW5jdGlvbiBtYWtlRHNuKGZyb20pIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IGRzbkZyb21TdHJpbmcoZnJvbSkgOiBkc25Gcm9tQ29tcG9uZW50cyhmcm9tKTtcbiAgaWYgKCFjb21wb25lbnRzIHx8ICF2YWxpZGF0ZURzbihjb21wb25lbnRzKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmV4cG9ydCB7IGRzbkZyb21TdHJpbmcsIGRzblRvU3RyaW5nLCBtYWtlRHNuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kc24uanMubWFwXG4iLCJpbXBvcnQgeyBpc1Z1ZVZpZXdNb2RlbCwgaXNTeW50aGV0aWNFdmVudCB9IGZyb20gJy4vaXMuanMnO1xuaW1wb3J0IHsgY29udmVydFRvUGxhaW5PYmplY3QgfSBmcm9tICcuL29iamVjdC5qcyc7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbk5hbWUgfSBmcm9tICcuL3N0YWNrdHJhY2UuanMnO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG5vcm1hbGl6ZXMgdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiAtIENyZWF0ZXMgYSBjb3B5IHRvIHByZXZlbnQgb3JpZ2luYWwgaW5wdXQgbXV0YXRpb25cbiAqIC0gU2tpcHMgbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICogLSBXaGVuIHN0cmluZ2lmeWluZywgY2FsbHMgYHRvSlNPTmAgaWYgaW1wbGVtZW50ZWRcbiAqIC0gUmVtb3ZlcyBjaXJjdWxhciByZWZlcmVuY2VzXG4gKiAtIFRyYW5zbGF0ZXMgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgKGB1bmRlZmluZWRgL2BOYU5gL2Z1bmN0aW9ucykgdG8gc2VyaWFsaXphYmxlIGZvcm1hdFxuICogLSBUcmFuc2xhdGVzIGtub3duIGdsb2JhbCBvYmplY3RzL2NsYXNzZXMgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25zXG4gKiAtIFRha2VzIGNhcmUgb2YgYEVycm9yYCBvYmplY3Qgc2VyaWFsaXphdGlvblxuICogLSBPcHRpb25hbGx5IGxpbWl0cyBkZXB0aCBvZiBmaW5hbCBvdXRwdXRcbiAqIC0gT3B0aW9uYWxseSBsaW1pdHMgbnVtYmVyIG9mIHByb3BlcnRpZXMvZWxlbWVudHMgaW5jbHVkZWQgaW4gYW55IHNpbmdsZSBvYmplY3QvYXJyYXlcbiAqXG4gKiBAcGFyYW0gaW5wdXQgVGhlIG9iamVjdCB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIGRlcHRoIFRoZSBtYXggZGVwdGggdG8gd2hpY2ggdG8gbm9ybWFsaXplIHRoZSBvYmplY3QuIChBbnl0aGluZyBkZWVwZXIgc3RyaW5naWZpZWQgd2hvbGUuKVxuICogQHBhcmFtIG1heFByb3BlcnRpZXMgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgb3IgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZCBpbiBhbnkgc2luZ2xlIGFycmF5IG9yXG4gKiBvYmplY3QgaW4gdGhlIG5vcm1hbGl6ZWQgb3V0cHV0LlxuICogQHJldHVybnMgQSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIG9iamVjdCwgb3IgYFwiKipub24tc2VyaWFsaXphYmxlKipcImAgaWYgYW55IGVycm9ycyBhcmUgdGhyb3duIGR1cmluZyBub3JtYWxpemF0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0LCBkZXB0aCA9IDEwMCwgbWF4UHJvcGVydGllcyA9ICtJbmZpbml0eSkge1xuICB0cnkge1xuICAgIC8vIHNpbmNlIHdlJ3JlIGF0IHRoZSBvdXRlcm1vc3QgbGV2ZWwsIHdlIGRvbid0IHByb3ZpZGUgYSBrZXlcbiAgICByZXR1cm4gdmlzaXQoJycsIGlucHV0LCBkZXB0aCwgbWF4UHJvcGVydGllcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IEVSUk9SOiBgKipub24tc2VyaWFsaXphYmxlKiogKCR7ZXJyfSlgIH07XG4gIH1cbn1cblxuLyoqIEpTRG9jICovXG5mdW5jdGlvbiBub3JtYWxpemVUb1NpemUoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIG9iamVjdCxcbiAgLy8gRGVmYXVsdCBOb2RlLmpzIFJFUEwgZGVwdGhcbiAgZGVwdGggPSAzLFxuICAvLyAxMDBrQiwgYXMgMjAwa0IgaXMgbWF4IHBheWxvYWQgc2l6ZSwgc28gaGFsZiBzb3VuZHMgcmVhc29uYWJsZVxuICBtYXhTaXplID0gMTAwICogMTAyNCxcbikge1xuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplKG9iamVjdCwgZGVwdGgpO1xuXG4gIGlmIChqc29uU2l6ZShub3JtYWxpemVkKSA+IG1heFNpemUpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVG9TaXplKG9iamVjdCwgZGVwdGggLSAxLCBtYXhTaXplKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkIDtcbn1cblxuLyoqXG4gKiBWaXNpdHMgYSBub2RlIHRvIHBlcmZvcm0gbm9ybWFsaXphdGlvbiBvbiBpdFxuICpcbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBub2RlXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG5vZGUgdG8gYmUgdmlzaXRlZFxuICogQHBhcmFtIGRlcHRoIE9wdGlvbmFsIG51bWJlciBpbmRpY2F0aW5nIHRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aFxuICogQHBhcmFtIG1heFByb3BlcnRpZXMgT3B0aW9uYWwgbWF4aW11bSBudW1iZXIgb2YgcHJvcGVydGllcy9lbGVtZW50cyBpbmNsdWRlZCBpbiBhbnkgc2luZ2xlIG9iamVjdC9hcnJheVxuICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgTWVtbyBjbGFzcyBoYW5kbGluZyBkZWN5Y2xpbmdcbiAqL1xuZnVuY3Rpb24gdmlzaXQoXG4gIGtleSxcbiAgdmFsdWUsXG4gIGRlcHRoID0gK0luZmluaXR5LFxuICBtYXhQcm9wZXJ0aWVzID0gK0luZmluaXR5LFxuICBtZW1vID0gbWVtb0J1aWxkZXIoKSxcbikge1xuICBjb25zdCBbbWVtb2l6ZSwgdW5tZW1vaXplXSA9IG1lbW87XG5cbiAgLy8gR2V0IHRoZSBzaW1wbGUgY2FzZXMgb3V0IG9mIHRoZSB3YXkgZmlyc3RcbiAgaWYgKFxuICAgIHZhbHVlID09IG51bGwgfHwgLy8gdGhpcyBtYXRjaGVzIG51bGwgYW5kIHVuZGVmaW5lZCAtPiBlcWVxIG5vdCBlcWVxZXFcbiAgICBbJ2Jvb2xlYW4nLCAnc3RyaW5nJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKSB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpXG4gICkge1xuICAgIHJldHVybiB2YWx1ZSA7XG4gIH1cblxuICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeVZhbHVlKGtleSwgdmFsdWUpO1xuXG4gIC8vIEFueXRoaW5nIHdlIGNvdWxkIHBvdGVudGlhbGx5IGRpZyBpbnRvIG1vcmUgKG9iamVjdHMgb3IgYXJyYXlzKSB3aWxsIGhhdmUgY29tZSBiYWNrIGFzIGBcIltvYmplY3QgWFhYWF1cImAuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHNlcmlhbGl6ZWQsIHNvIGlmIHdlIGRvbid0IHNlZSB0aGF0IHBhdHRlcm4sIHdlJ3JlIGRvbmUuXG4gIGlmICghc3RyaW5naWZpZWQuc3RhcnRzV2l0aCgnW29iamVjdCAnKSkge1xuICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgfVxuXG4gIC8vIEZyb20gaGVyZSBvbiwgd2UgY2FuIGFzc2VydCB0aGF0IGB2YWx1ZWAgaXMgZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cblxuICAvLyBEbyBub3Qgbm9ybWFsaXplIG9iamVjdHMgdGhhdCB3ZSBrbm93IGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQuIEFzIGEgZ2VuZXJhbCBydWxlLCB0aGVcbiAgLy8gXCJfX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fX1wiIHByb3BlcnR5IHNob3VsZCBvbmx5IGJlIHVzZWQgc3BhcmluZ2x5IGFuZCBvbmx5IHNob3VsZCBvbmx5IGJlIHNldCBvbiBvYmplY3RzIHRoYXRcbiAgLy8gaGF2ZSBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZC5cbiAgaWYgKCh2YWx1ZSApWydfX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fXyddKSB7XG4gICAgcmV0dXJuIHZhbHVlIDtcbiAgfVxuXG4gIC8vIFdlIGNhbiBzZXQgYF9fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfX2Agb24gYW4gb2JqZWN0IHRvIGVuc3VyZSB0aGF0IGZyb20gdGhlcmVcbiAgLy8gV2Uga2VlcCBhIGNlcnRhaW4gYW1vdW50IG9mIGRlcHRoLlxuICAvLyBUaGlzIHNob3VsZCBiZSB1c2VkIHNwYXJpbmdseSwgZS5nLiB3ZSB1c2UgaXQgZm9yIHRoZSByZWR1eCBpbnRlZ3JhdGlvbiB0byBlbnN1cmUgd2UgZ2V0IGEgY2VydGFpbiBhbW91bnQgb2Ygc3RhdGUuXG4gIGNvbnN0IHJlbWFpbmluZ0RlcHRoID1cbiAgICB0eXBlb2YgKHZhbHVlIClbJ19fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXyddID09PSAnbnVtYmVyJ1xuICAgICAgPyAoKHZhbHVlIClbJ19fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXyddIClcbiAgICAgIDogZGVwdGg7XG5cbiAgLy8gV2UncmUgYWxzbyBkb25lIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIG1heCBkZXB0aFxuICBpZiAocmVtYWluaW5nRGVwdGggPT09IDApIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYHNlcmlhbGl6ZWRgIGlzIGEgc3RyaW5nIG9mIHRoZSBmb3JtIGBcIltvYmplY3QgWFhYWF1cImAuIENsZWFuIGl0IHVwIHNvIGl0J3MganVzdCBgXCJbWFhYWF1cImAuXG4gICAgcmV0dXJuIHN0cmluZ2lmaWVkLnJlcGxhY2UoJ29iamVjdCAnLCAnJyk7XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhpcyBicmFuY2gsIGJhaWwgb3V0LCBhcyBpdCdzIGNpcmN1bGFyIHJlZmVyZW5jZS4gSWYgbm90LCBub3RlIHRoYXQgd2UncmUgc2VlaW5nIGl0IG5vdy5cbiAgaWYgKG1lbW9pemUodmFsdWUpKSB7XG4gICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nO1xuICB9XG5cbiAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIGB0b0pTT05gIG1ldGhvZCwgd2UgY2FsbCBpdCB0byBleHRyYWN0IG1vcmUgaW5mb3JtYXRpb25cbiAgY29uc3QgdmFsdWVXaXRoVG9KU09OID0gdmFsdWUgO1xuICBpZiAodmFsdWVXaXRoVG9KU09OICYmIHR5cGVvZiB2YWx1ZVdpdGhUb0pTT04udG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHZhbHVlV2l0aFRvSlNPTi50b0pTT04oKTtcbiAgICAgIC8vIFdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSByZXR1cm4gdmFsdWUgb2YgYC50b0pTT04oKWAgaW4gY2FzZSBpdCBoYXMgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgcmV0dXJuIHZpc2l0KCcnLCBqc29uVmFsdWUsIHJlbWFpbmluZ0RlcHRoIC0gMSwgbWF4UHJvcGVydGllcywgbWVtbyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBwYXNzIChUaGUgYnVpbHQtaW4gYHRvSlNPTmAgZmFpbGVkLCBidXQgd2UgY2FuIHN0aWxsIHRyeSB0byBkbyBpdCBvdXJzZWx2ZXMpXG4gICAgfVxuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IHdlIGVpdGhlciBoYXZlIGFuIG9iamVjdCBvciBhbiBhcnJheSwgd2UgaGF2ZW4ndCBzZWVuIGl0IGJlZm9yZSwgYW5kIHdlJ3JlIGdvaW5nIHRvIHJlY3Vyc2VcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlbid0IHlldCByZWFjaGVkIHRoZSBtYXggZGVwdGguIENyZWF0ZSBhbiBhY2N1bXVsYXRvciB0byBob2xkIHRoZSByZXN1bHRzIG9mIHZpc2l0aW5nIGVhY2hcbiAgLy8gcHJvcGVydHkvZW50cnksIGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgaXRlbXMgd2UgYWRkIHRvIGl0LlxuICBjb25zdCBub3JtYWxpemVkID0gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gW10gOiB7fSkgO1xuICBsZXQgbnVtQWRkZWQgPSAwO1xuXG4gIC8vIEJlZm9yZSB3ZSBiZWdpbiwgY29udmVydGBFcnJvcmAgYW5kYEV2ZW50YCBpbnN0YW5jZXMgaW50byBwbGFpbiBvYmplY3RzLCBzaW5jZSBzb21lIG9mIGVhY2ggb2YgdGhlaXIgcmVsZXZhbnRcbiAgLy8gcHJvcGVydGllcyBhcmUgbm9uLWVudW1lcmFibGUgYW5kIG90aGVyd2lzZSB3b3VsZCBnZXQgbWlzc2VkLlxuICBjb25zdCB2aXNpdGFibGUgPSBjb252ZXJ0VG9QbGFpbk9iamVjdCh2YWx1ZSApO1xuXG4gIGZvciAoY29uc3QgdmlzaXRLZXkgaW4gdmlzaXRhYmxlKSB7XG4gICAgLy8gQXZvaWQgaXRlcmF0aW5nIG92ZXIgZmllbGRzIGluIHRoZSBwcm90b3R5cGUgaWYgdGhleSd2ZSBzb21laG93IGJlZW4gZXhwb3NlZCB0byBlbnVtZXJhdGlvbi5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aXNpdGFibGUsIHZpc2l0S2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG51bUFkZGVkID49IG1heFByb3BlcnRpZXMpIHtcbiAgICAgIG5vcm1hbGl6ZWRbdmlzaXRLZXldID0gJ1tNYXhQcm9wZXJ0aWVzIH5dJztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFJlY3Vyc2l2ZWx5IHZpc2l0IGFsbCB0aGUgY2hpbGQgbm9kZXNcbiAgICBjb25zdCB2aXNpdFZhbHVlID0gdmlzaXRhYmxlW3Zpc2l0S2V5XTtcbiAgICBub3JtYWxpemVkW3Zpc2l0S2V5XSA9IHZpc2l0KHZpc2l0S2V5LCB2aXNpdFZhbHVlLCByZW1haW5pbmdEZXB0aCAtIDEsIG1heFByb3BlcnRpZXMsIG1lbW8pO1xuXG4gICAgbnVtQWRkZWQrKztcbiAgfVxuXG4gIC8vIE9uY2Ugd2UndmUgdmlzaXRlZCBhbGwgdGhlIGJyYW5jaGVzLCByZW1vdmUgdGhlIHBhcmVudCBmcm9tIG1lbW8gc3RvcmFnZVxuICB1bm1lbW9pemUodmFsdWUpO1xuXG4gIC8vIFJldHVybiBhY2N1bXVsYXRlZCB2YWx1ZXNcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiB2YWx1ZS4gSGFuZGxlcyB2YXJpb3VzIGtub3duIHNwZWNpYWwgdmFsdWVzIGFuZCB0eXBlcy5cbiAqXG4gKiBOb3QgbWVhbnQgdG8gYmUgdXNlZCBvbiBzaW1wbGUgcHJpbWl0aXZlcyB3aGljaCBhbHJlYWR5IGhhdmUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGFzIGl0IHdpbGwsIGZvciBleGFtcGxlLCB0dXJuXG4gKiB0aGUgbnVtYmVyIDEyMzEgaW50byBcIltPYmplY3QgTnVtYmVyXVwiLCBub3Igb24gYG51bGxgLCBhcyBpdCB3aWxsIHRocm93LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJucyBBIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZShcbiAga2V5LFxuICAvLyB0aGlzIHR5cGUgaXMgYSB0aW55IGJpdCBvZiBhIGNoZWF0LCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGRvZXMgaGFuZGxlIE5hTiAod2hpY2ggaXMgdGVjaG5pY2FsbHkgYSBudW1iZXIpLCBidXQgZm9yXG4gIC8vIG91ciBpbnRlcm5hbCB1c2UsIGl0J2xsIGRvXG4gIHZhbHVlLFxuKSB7XG4gIHRyeSB7XG4gICAgaWYgKGtleSA9PT0gJ2RvbWFpbicgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAodmFsdWUgKS5fZXZlbnRzKSB7XG4gICAgICByZXR1cm4gJ1tEb21haW5dJztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnZG9tYWluRW1pdHRlcicpIHtcbiAgICAgIHJldHVybiAnW0RvbWFpbkVtaXR0ZXJdJztcbiAgICB9XG5cbiAgICAvLyBJdCdzIHNhZmUgdG8gdXNlIGBnbG9iYWxgLCBgd2luZG93YCwgYW5kIGBkb2N1bWVudGAgaGVyZSBpbiB0aGlzIG1hbm5lciwgYXMgd2UgYXJlIGFzc2VydGluZyB1c2luZyBgdHlwZW9mYCBmaXJzdFxuICAgIC8vIHdoaWNoIHdvbid0IHRocm93IGlmIHRoZXkgYXJlIG5vdCBwcmVzZW50LlxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlID09PSBnbG9iYWwpIHtcbiAgICAgIHJldHVybiAnW0dsb2JhbF0nO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgPT09IHdpbmRvdykge1xuICAgICAgcmV0dXJuICdbV2luZG93XSc7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlID09PSBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuICdbRG9jdW1lbnRdJztcbiAgICB9XG5cbiAgICBpZiAoaXNWdWVWaWV3TW9kZWwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ1tWdWVWaWV3TW9kZWxdJztcbiAgICB9XG5cbiAgICAvLyBSZWFjdCdzIFN5bnRoZXRpY0V2ZW50IHRoaW5neVxuICAgIGlmIChpc1N5bnRoZXRpY0V2ZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuICdbU3ludGhldGljRXZlbnRdJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGBbJHt2YWx1ZX1dYDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYFtGdW5jdGlvbjogJHtnZXRGdW5jdGlvbk5hbWUodmFsdWUpfV1gO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gYFske1N0cmluZyh2YWx1ZSl9XWA7XG4gICAgfVxuXG4gICAgLy8gc3RyaW5naWZpZWQgQmlnSW50cyBhcmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSByZWd1bGFyIG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gbGFiZWwgdGhlbSB0byBhdm9pZCBjb25mdXNpb25cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIGBbQmlnSW50OiAke1N0cmluZyh2YWx1ZSl9XWA7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUga25vY2tlZCBvdXQgYWxsIHRoZSBzcGVjaWFsIGNhc2VzIGFuZCB0aGUgcHJpbWl0aXZlcywgYWxsIHdlIGhhdmUgbGVmdCBhcmUgb2JqZWN0cy4gU2ltcGx5IGNhc3RpbmdcbiAgICAvLyB0aGVtIHRvIHN0cmluZ3MgbWVhbnMgdGhhdCBpbnN0YW5jZXMgb2YgY2xhc3NlcyB3aGljaCBoYXZlbid0IGRlZmluZWQgdGhlaXIgYHRvU3RyaW5nVGFnYCB3aWxsIGp1c3QgY29tZSBvdXQgYXNcbiAgICAvLyBgXCJbb2JqZWN0IE9iamVjdF1cImAuIElmIHdlIGluc3RlYWQgbG9vayBhdCB0aGUgY29uc3RydWN0b3IncyBuYW1lICh3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgbmFtZSBvZiB0aGUgY2xhc3MpLFxuICAgIC8vIHdlIGNhbiBtYWtlIHN1cmUgdGhhdCBvbmx5IHBsYWluIG9iamVjdHMgY29tZSBvdXQgdGhhdCB3YXkuXG4gICAgY29uc3Qgb2JqTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSk7XG5cbiAgICAvLyBIYW5kbGUgSFRNTCBFbGVtZW50c1xuICAgIGlmICgvXkhUTUwoXFx3KilFbGVtZW50JC8udGVzdChvYmpOYW1lKSkge1xuICAgICAgcmV0dXJuIGBbSFRNTEVsZW1lbnQ6ICR7b2JqTmFtZX1dYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYFtvYmplY3QgJHtvYmpOYW1lfV1gO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke2Vycn0pYDtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSkge1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXG4gIHJldHVybiBwcm90b3R5cGU/LmNvbnN0cnVjdG9yID8gcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgOiAnbnVsbCBwcm90b3R5cGUnO1xufVxuXG4vKiogQ2FsY3VsYXRlcyBieXRlcyBzaXplIG9mIGlucHV0IHN0cmluZyAqL1xuZnVuY3Rpb24gdXRmOExlbmd0aCh2YWx1ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICByZXR1cm4gfi1lbmNvZGVVUkkodmFsdWUpLnNwbGl0KC8lLi58Li8pLmxlbmd0aDtcbn1cblxuLyoqIENhbGN1bGF0ZXMgYnl0ZXMgc2l6ZSBvZiBpbnB1dCBvYmplY3QgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBqc29uU2l6ZSh2YWx1ZSkge1xuICByZXR1cm4gdXRmOExlbmd0aChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgVVJMcyBpbiBleGNlcHRpb25zIGFuZCBzdGFja3RyYWNlcyB0byBhIGJhc2UgcGF0aCBzbyBTZW50cnkgY2FuIGZpbmdlcnByaW50XG4gKiBhY3Jvc3MgcGxhdGZvcm1zIGFuZCB3b3JraW5nIGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSBiYXNlUGF0aCBUaGUgYXBwbGljYXRpb24gYmFzZSBwYXRoLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgVVJMLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVVcmxUb0Jhc2UodXJsLCBiYXNlUGF0aCkge1xuICBjb25zdCBlc2NhcGVkQmFzZSA9IGJhc2VQYXRoXG4gICAgLy8gQmFja3NsYXNoIHRvIGZvcndhcmRcbiAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgLy8gRXNjYXBlIFJlZ0V4cCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy5dL2csICdcXFxcJCYnKTtcblxuICBsZXQgbmV3VXJsID0gdXJsO1xuICB0cnkge1xuICAgIG5ld1VybCA9IGRlY29kZVVSSSh1cmwpO1xuICB9IGNhdGNoIChfT28pIHtcbiAgICAvLyBTb21ldGltZSB0aGlzIGJyZWFrc1xuICB9XG4gIHJldHVybiAoXG4gICAgbmV3VXJsXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvd2VicGFjazpcXC8/L2csICcnKSAvLyBSZW1vdmUgaW50ZXJtZWRpYXRlIGJhc2UgcGF0aFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzZW50cnktaW50ZXJuYWwvc2RrL25vLXJlZ2V4cC1jb25zdHJ1Y3RvclxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgKGZpbGU6Ly8pPy8qJHtlc2NhcGVkQmFzZX0vKmAsICdpZycpLCAnYXBwOi8vLycpXG4gICk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGRlY3ljbGUganNvbiBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIG1lbW9CdWlsZGVyKCkge1xuICBjb25zdCBpbm5lciA9IG5ldyBXZWFrU2V0KCk7XG4gIGZ1bmN0aW9uIG1lbW9pemUob2JqKSB7XG4gICAgaWYgKGlubmVyLmhhcyhvYmopKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5uZXIuYWRkKG9iaik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5tZW1vaXplKG9iaikge1xuICAgIGlubmVyLmRlbGV0ZShvYmopO1xuICB9XG4gIHJldHVybiBbbWVtb2l6ZSwgdW5tZW1vaXplXTtcbn1cblxuZXhwb3J0IHsgbm9ybWFsaXplLCBub3JtYWxpemVUb1NpemUsIG5vcm1hbGl6ZVVybFRvQmFzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLmpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0U2VudHJ5Q2FycmllciB9IGZyb20gJy4uL2NhcnJpZXIuanMnO1xuaW1wb3J0IHsgZHNuVG9TdHJpbmcgfSBmcm9tICcuL2Rzbi5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuL25vcm1hbGl6ZS5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW52ZWxvcGUuXG4gKiBNYWtlIHN1cmUgdG8gYWx3YXlzIGV4cGxpY2l0bHkgcHJvdmlkZSB0aGUgZ2VuZXJpYyB0byB0aGlzIGZ1bmN0aW9uXG4gKiBzbyB0aGF0IHRoZSBlbnZlbG9wZSB0eXBlcyByZXNvbHZlIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGUoaGVhZGVycywgaXRlbXMgPSBbXSkge1xuICByZXR1cm4gW2hlYWRlcnMsIGl0ZW1zXSA7XG59XG5cbi8qKlxuICogQWRkIGFuIGl0ZW0gdG8gYW4gZW52ZWxvcGUuXG4gKiBNYWtlIHN1cmUgdG8gYWx3YXlzIGV4cGxpY2l0bHkgcHJvdmlkZSB0aGUgZ2VuZXJpYyB0byB0aGlzIGZ1bmN0aW9uXG4gKiBzbyB0aGF0IHRoZSBlbnZlbG9wZSB0eXBlcyByZXNvbHZlIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gYWRkSXRlbVRvRW52ZWxvcGUoZW52ZWxvcGUsIG5ld0l0ZW0pIHtcbiAgY29uc3QgW2hlYWRlcnMsIGl0ZW1zXSA9IGVudmVsb3BlO1xuICByZXR1cm4gW2hlYWRlcnMsIFsuLi5pdGVtcywgbmV3SXRlbV1dIDtcbn1cblxuLyoqXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBsb29wIHRocm91Z2ggdGhlIGl0ZW1zIGFuZCBpdGVtIHR5cGVzIG9mIGFuIGVudmVsb3BlLlxuICogKFRoaXMgZnVuY3Rpb24gd2FzIG1vc3RseSBjcmVhdGVkIGJlY2F1c2Ugd29ya2luZyB3aXRoIGVudmVsb3BlIHR5cGVzIGlzIHBhaW5mdWwgYXQgdGhlIG1vbWVudClcbiAqXG4gKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVlLCB0aGUgcmVzdCBvZiB0aGUgaXRlbXMgd2lsbCBiZSBza2lwcGVkLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRW52ZWxvcGVJdGVtKFxuICBlbnZlbG9wZSxcbiAgY2FsbGJhY2ssXG4pIHtcbiAgY29uc3QgZW52ZWxvcGVJdGVtcyA9IGVudmVsb3BlWzFdO1xuXG4gIGZvciAoY29uc3QgZW52ZWxvcGVJdGVtIG9mIGVudmVsb3BlSXRlbXMpIHtcbiAgICBjb25zdCBlbnZlbG9wZUl0ZW1UeXBlID0gZW52ZWxvcGVJdGVtWzBdLnR5cGU7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZW52ZWxvcGVJdGVtLCBlbnZlbG9wZUl0ZW1UeXBlKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVudmVsb3BlIGNvbnRhaW5zIGFueSBvZiB0aGUgZ2l2ZW4gZW52ZWxvcGUgaXRlbSB0eXBlc1xuICovXG5mdW5jdGlvbiBlbnZlbG9wZUNvbnRhaW5zSXRlbVR5cGUoZW52ZWxvcGUsIHR5cGVzKSB7XG4gIHJldHVybiBmb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlLCAoXywgdHlwZSkgPT4gdHlwZXMuaW5jbHVkZXModHlwZSkpO1xufVxuXG4vKipcbiAqIEVuY29kZSBhIHN0cmluZyB0byBVVEY4IGFycmF5LlxuICovXG5mdW5jdGlvbiBlbmNvZGVVVEY4KGlucHV0KSB7XG4gIGNvbnN0IGNhcnJpZXIgPSBnZXRTZW50cnlDYXJyaWVyKEdMT0JBTF9PQkopO1xuICByZXR1cm4gY2Fycmllci5lbmNvZGVQb2x5ZmlsbCA/IGNhcnJpZXIuZW5jb2RlUG9seWZpbGwoaW5wdXQpIDogbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGlucHV0KTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVVEY4IGFycmF5IHRvIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlVVRGOChpbnB1dCkge1xuICBjb25zdCBjYXJyaWVyID0gZ2V0U2VudHJ5Q2FycmllcihHTE9CQUxfT0JKKTtcbiAgcmV0dXJuIGNhcnJpZXIuZGVjb2RlUG9seWZpbGwgPyBjYXJyaWVyLmRlY29kZVBvbHlmaWxsKGlucHV0KSA6IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpbnB1dCk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyBhbiBlbnZlbG9wZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRW52ZWxvcGUoZW52ZWxvcGUpIHtcbiAgY29uc3QgW2VudkhlYWRlcnMsIGl0ZW1zXSA9IGVudmVsb3BlO1xuXG4gIC8vIEluaXRpYWxseSB3ZSBjb25zdHJ1Y3Qgb3VyIGVudmVsb3BlIGFzIGEgc3RyaW5nIGFuZCBvbmx5IGNvbnZlcnQgdG8gYmluYXJ5IGNodW5rcyBpZiB3ZSBlbmNvdW50ZXIgYmluYXJ5IGRhdGFcbiAgbGV0IHBhcnRzID0gSlNPTi5zdHJpbmdpZnkoZW52SGVhZGVycyk7XG5cbiAgZnVuY3Rpb24gYXBwZW5kKG5leHQpIHtcbiAgICBpZiAodHlwZW9mIHBhcnRzID09PSAnc3RyaW5nJykge1xuICAgICAgcGFydHMgPSB0eXBlb2YgbmV4dCA9PT0gJ3N0cmluZycgPyBwYXJ0cyArIG5leHQgOiBbZW5jb2RlVVRGOChwYXJ0cyksIG5leHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKHR5cGVvZiBuZXh0ID09PSAnc3RyaW5nJyA/IGVuY29kZVVURjgobmV4dCkgOiBuZXh0KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICBjb25zdCBbaXRlbUhlYWRlcnMsIHBheWxvYWRdID0gaXRlbTtcblxuICAgIGFwcGVuZChgXFxuJHtKU09OLnN0cmluZ2lmeShpdGVtSGVhZGVycyl9XFxuYCk7XG5cbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnIHx8IHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBhcHBlbmQocGF5bG9hZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzdHJpbmdpZmllZFBheWxvYWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzdHJpbmdpZmllZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSW4gY2FzZSwgZGVzcGl0ZSBhbGwgb3VyIGVmZm9ydHMgdG8ga2VlcCBgcGF5bG9hZGAgY2lyY3VsYXItZGVwZW5kZW5jeS1mcmVlLCBgSlNPTi5zdHJpbmdpZnkoKWAgc3RpbGxcbiAgICAgICAgLy8gZmFpbHMsIHdlIHRyeSBhZ2FpbiBhZnRlciBub3JtYWxpemluZyBpdCBhZ2FpbiB3aXRoIGluZmluaXRlIG5vcm1hbGl6YXRpb24gZGVwdGguIFRoaXMgb2YgY291cnNlIGhhcyBhXG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIGltcGFjdCBidXQgaW4gdGhpcyBjYXNlIGEgcGVyZm9ybWFuY2UgaGl0IGlzIGJldHRlciB0aGFuIHRocm93aW5nLlxuICAgICAgICBzdHJpbmdpZmllZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShub3JtYWxpemUocGF5bG9hZCkpO1xuICAgICAgfVxuICAgICAgYXBwZW5kKHN0cmluZ2lmaWVkUGF5bG9hZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBwYXJ0cyA9PT0gJ3N0cmluZycgPyBwYXJ0cyA6IGNvbmNhdEJ1ZmZlcnMocGFydHMpO1xufVxuXG5mdW5jdGlvbiBjb25jYXRCdWZmZXJzKGJ1ZmZlcnMpIHtcbiAgY29uc3QgdG90YWxMZW5ndGggPSBidWZmZXJzLnJlZHVjZSgoYWNjLCBidWYpID0+IGFjYyArIGJ1Zi5sZW5ndGgsIDApO1xuXG4gIGNvbnN0IG1lcmdlZCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICBtZXJnZWQuc2V0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmZmVyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGVudmVsb3BlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRW52ZWxvcGUoZW52KSB7XG4gIGxldCBidWZmZXIgPSB0eXBlb2YgZW52ID09PSAnc3RyaW5nJyA/IGVuY29kZVVURjgoZW52KSA6IGVudjtcblxuICBmdW5jdGlvbiByZWFkQmluYXJ5KGxlbmd0aCkge1xuICAgIGNvbnN0IGJpbiA9IGJ1ZmZlci5zdWJhcnJheSgwLCBsZW5ndGgpO1xuICAgIC8vIFJlcGxhY2UgdGhlIGJ1ZmZlciB3aXRoIHRoZSByZW1haW5pbmcgZGF0YSBleGNsdWRpbmcgdHJhaWxpbmcgbmV3bGluZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShsZW5ndGggKyAxKTtcbiAgICByZXR1cm4gYmluO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEpzb24oKSB7XG4gICAgbGV0IGkgPSBidWZmZXIuaW5kZXhPZigweGEpO1xuICAgIC8vIElmIHdlIGNvdWxkbid0IGZpbmQgYSBuZXdsaW5lLCB3ZSBtdXN0IGhhdmUgZm91bmQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBpID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVVEY4KHJlYWRCaW5hcnkoaSkpKSA7XG4gIH1cblxuICBjb25zdCBlbnZlbG9wZUhlYWRlciA9IHJlYWRKc29uKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgd2hpbGUgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBpdGVtSGVhZGVyID0gcmVhZEpzb24oKTtcbiAgICBjb25zdCBiaW5hcnlMZW5ndGggPSB0eXBlb2YgaXRlbUhlYWRlci5sZW5ndGggPT09ICdudW1iZXInID8gaXRlbUhlYWRlci5sZW5ndGggOiB1bmRlZmluZWQ7XG5cbiAgICBpdGVtcy5wdXNoKFtpdGVtSGVhZGVyLCBiaW5hcnlMZW5ndGggPyByZWFkQmluYXJ5KGJpbmFyeUxlbmd0aCkgOiByZWFkSnNvbigpXSk7XG4gIH1cblxuICByZXR1cm4gW2VudmVsb3BlSGVhZGVyLCBpdGVtc107XG59XG5cbi8qKlxuICogQ3JlYXRlcyBlbnZlbG9wZSBpdGVtIGZvciBhIHNpbmdsZSBzcGFuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNwYW5FbnZlbG9wZUl0ZW0oc3Bhbkpzb24pIHtcbiAgY29uc3Qgc3BhbkhlYWRlcnMgPSB7XG4gICAgdHlwZTogJ3NwYW4nLFxuICB9O1xuXG4gIHJldHVybiBbc3BhbkhlYWRlcnMsIHNwYW5Kc29uXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGF0dGFjaG1lbnQgZW52ZWxvcGUgaXRlbXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXR0YWNobWVudEVudmVsb3BlSXRlbShhdHRhY2htZW50KSB7XG4gIGNvbnN0IGJ1ZmZlciA9IHR5cGVvZiBhdHRhY2htZW50LmRhdGEgPT09ICdzdHJpbmcnID8gZW5jb2RlVVRGOChhdHRhY2htZW50LmRhdGEpIDogYXR0YWNobWVudC5kYXRhO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdHlwZTogJ2F0dGFjaG1lbnQnLFxuICAgICAgbGVuZ3RoOiBidWZmZXIubGVuZ3RoLFxuICAgICAgZmlsZW5hbWU6IGF0dGFjaG1lbnQuZmlsZW5hbWUsXG4gICAgICBjb250ZW50X3R5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUsXG4gICAgICBhdHRhY2htZW50X3R5cGU6IGF0dGFjaG1lbnQuYXR0YWNobWVudFR5cGUsXG4gICAgfSxcbiAgICBidWZmZXIsXG4gIF07XG59XG5cbmNvbnN0IElURU1fVFlQRV9UT19EQVRBX0NBVEVHT1JZX01BUCA9IHtcbiAgc2Vzc2lvbjogJ3Nlc3Npb24nLFxuICBzZXNzaW9uczogJ3Nlc3Npb24nLFxuICBhdHRhY2htZW50OiAnYXR0YWNobWVudCcsXG4gIHRyYW5zYWN0aW9uOiAndHJhbnNhY3Rpb24nLFxuICBldmVudDogJ2Vycm9yJyxcbiAgY2xpZW50X3JlcG9ydDogJ2ludGVybmFsJyxcbiAgdXNlcl9yZXBvcnQ6ICdkZWZhdWx0JyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICBwcm9maWxlX2NodW5rOiAncHJvZmlsZScsXG4gIHJlcGxheV9ldmVudDogJ3JlcGxheScsXG4gIHJlcGxheV9yZWNvcmRpbmc6ICdyZXBsYXknLFxuICBjaGVja19pbjogJ21vbml0b3InLFxuICBmZWVkYmFjazogJ2ZlZWRiYWNrJyxcbiAgc3BhbjogJ3NwYW4nLFxuICByYXdfc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIG90ZWxfbG9nOiAnbG9nX2l0ZW0nLFxufTtcblxuLyoqXG4gKiBNYXBzIHRoZSB0eXBlIG9mIGFuIGVudmVsb3BlIGl0ZW0gdG8gYSBkYXRhIGNhdGVnb3J5LlxuICovXG5mdW5jdGlvbiBlbnZlbG9wZUl0ZW1UeXBlVG9EYXRhQ2F0ZWdvcnkodHlwZSkge1xuICByZXR1cm4gSVRFTV9UWVBFX1RPX0RBVEFfQ0FURUdPUllfTUFQW3R5cGVdO1xufVxuXG4vKiogRXh0cmFjdHMgdGhlIG1pbmltYWwgU0RLIGluZm8gZnJvbSB0aGUgbWV0YWRhdGEgb3IgYW4gZXZlbnRzICovXG5mdW5jdGlvbiBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyKG1ldGFkYXRhT3JFdmVudCkge1xuICBpZiAoIW1ldGFkYXRhT3JFdmVudD8uc2RrKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgbmFtZSwgdmVyc2lvbiB9ID0gbWV0YWRhdGFPckV2ZW50LnNkaztcbiAgcmV0dXJuIHsgbmFtZSwgdmVyc2lvbiB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZXZlbnQgZW52ZWxvcGUgaGVhZGVycywgYmFzZWQgb24gZXZlbnQsIHNkayBpbmZvIGFuZCB0dW5uZWxcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBmcm9tIHRoZSBjb3JlIHBhY2thZ2UgdG8gbWFrZSBpdCBhdmFpbGFibGUgaW4gUmVwbGF5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzKFxuICBldmVudCxcbiAgc2RrSW5mbyxcbiAgdHVubmVsLFxuICBkc24sXG4pIHtcbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT8uZHluYW1pY1NhbXBsaW5nQ29udGV4dDtcbiAgcmV0dXJuIHtcbiAgICBldmVudF9pZDogZXZlbnQuZXZlbnRfaWQgLFxuICAgIHNlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAuLi4oc2RrSW5mbyAmJiB7IHNkazogc2RrSW5mbyB9KSxcbiAgICAuLi4oISF0dW5uZWwgJiYgZHNuICYmIHsgZHNuOiBkc25Ub1N0cmluZyhkc24pIH0pLFxuICAgIC4uLihkeW5hbWljU2FtcGxpbmdDb250ZXh0ICYmIHtcbiAgICAgIHRyYWNlOiBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgIH0pLFxuICB9O1xufVxuXG5leHBvcnQgeyBhZGRJdGVtVG9FbnZlbG9wZSwgY3JlYXRlQXR0YWNobWVudEVudmVsb3BlSXRlbSwgY3JlYXRlRW52ZWxvcGUsIGNyZWF0ZUV2ZW50RW52ZWxvcGVIZWFkZXJzLCBjcmVhdGVTcGFuRW52ZWxvcGVJdGVtLCBlbnZlbG9wZUNvbnRhaW5zSXRlbVR5cGUsIGVudmVsb3BlSXRlbVR5cGVUb0RhdGFDYXRlZ29yeSwgZm9yRWFjaEVudmVsb3BlSXRlbSwgZ2V0U2RrTWV0YWRhdGFGb3JFbnZlbG9wZUhlYWRlciwgcGFyc2VFbnZlbG9wZSwgc2VyaWFsaXplRW52ZWxvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmVsb3BlLmpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuIH0gZnJvbSAnLi90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnO1xuaW1wb3J0IHsgZHNuVG9TdHJpbmcgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2Rzbi5qcyc7XG5pbXBvcnQgeyBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyLCBjcmVhdGVFdmVudEVudmVsb3BlSGVhZGVycywgY3JlYXRlRW52ZWxvcGUsIGNyZWF0ZVNwYW5FbnZlbG9wZUl0ZW0gfSBmcm9tICcuL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJztcbmltcG9ydCAnLi91dGlscy1ob2lzdC9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHNwYW5Ub0pTT04sIHNob3dTcGFuRHJvcFdhcm5pbmcgfSBmcm9tICcuL3V0aWxzL3NwYW5VdGlscy5qcyc7XG5cbi8qKlxuICogQXBwbHkgU2RrSW5mbyAobmFtZSwgdmVyc2lvbiwgcGFja2FnZXMsIGludGVncmF0aW9ucykgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQga2V5LlxuICogTWVyZ2Ugd2l0aCBleGlzdGluZyBkYXRhIGlmIGFueS5cbiAqKi9cbmZ1bmN0aW9uIGVuaGFuY2VFdmVudFdpdGhTZGtJbmZvKGV2ZW50LCBzZGtJbmZvKSB7XG4gIGlmICghc2RrSW5mbykge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBldmVudC5zZGsgPSBldmVudC5zZGsgfHwge307XG4gIGV2ZW50LnNkay5uYW1lID0gZXZlbnQuc2RrLm5hbWUgfHwgc2RrSW5mby5uYW1lO1xuICBldmVudC5zZGsudmVyc2lvbiA9IGV2ZW50LnNkay52ZXJzaW9uIHx8IHNka0luZm8udmVyc2lvbjtcbiAgZXZlbnQuc2RrLmludGVncmF0aW9ucyA9IFsuLi4oZXZlbnQuc2RrLmludGVncmF0aW9ucyB8fCBbXSksIC4uLihzZGtJbmZvLmludGVncmF0aW9ucyB8fCBbXSldO1xuICBldmVudC5zZGsucGFja2FnZXMgPSBbLi4uKGV2ZW50LnNkay5wYWNrYWdlcyB8fCBbXSksIC4uLihzZGtJbmZvLnBhY2thZ2VzIHx8IFtdKV07XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqIENyZWF0ZXMgYW4gZW52ZWxvcGUgZnJvbSBhIFNlc3Npb24gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25FbnZlbG9wZShcbiAgc2Vzc2lvbixcbiAgZHNuLFxuICBtZXRhZGF0YSxcbiAgdHVubmVsLFxuKSB7XG4gIGNvbnN0IHNka0luZm8gPSBnZXRTZGtNZXRhZGF0YUZvckVudmVsb3BlSGVhZGVyKG1ldGFkYXRhKTtcbiAgY29uc3QgZW52ZWxvcGVIZWFkZXJzID0ge1xuICAgIHNlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAuLi4oc2RrSW5mbyAmJiB7IHNkazogc2RrSW5mbyB9KSxcbiAgICAuLi4oISF0dW5uZWwgJiYgZHNuICYmIHsgZHNuOiBkc25Ub1N0cmluZyhkc24pIH0pLFxuICB9O1xuXG4gIGNvbnN0IGVudmVsb3BlSXRlbSA9XG4gICAgJ2FnZ3JlZ2F0ZXMnIGluIHNlc3Npb24gPyBbeyB0eXBlOiAnc2Vzc2lvbnMnIH0sIHNlc3Npb25dIDogW3sgdHlwZTogJ3Nlc3Npb24nIH0sIHNlc3Npb24udG9KU09OKCldO1xuXG4gIHJldHVybiBjcmVhdGVFbnZlbG9wZShlbnZlbG9wZUhlYWRlcnMsIFtlbnZlbG9wZUl0ZW1dKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gRW52ZWxvcGUgZnJvbSBhbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbnZlbG9wZShcbiAgZXZlbnQsXG4gIGRzbixcbiAgbWV0YWRhdGEsXG4gIHR1bm5lbCxcbikge1xuICBjb25zdCBzZGtJbmZvID0gZ2V0U2RrTWV0YWRhdGFGb3JFbnZlbG9wZUhlYWRlcihtZXRhZGF0YSk7XG5cbiAgLypcbiAgICBOb3RlOiBEdWUgdG8gVFMsIGV2ZW50LnR5cGUgbWF5IGJlIGByZXBsYXlfZXZlbnRgLCB0aGVvcmV0aWNhbGx5LlxuICAgIEluIHByYWN0aWNlLCB3ZSBuZXZlciBjYWxsIGBjcmVhdGVFdmVudEVudmVsb3BlYCB3aXRoIGByZXBsYXlfZXZlbnRgIHR5cGUsXG4gICAgYW5kIHdlJ2QgaGF2ZSB0byBhZGp1c3QgYSBsb29vdCBvZiB0eXBlcyB0byBtYWtlIHRoaXMgd29yayBwcm9wZXJseS5cbiAgICBXZSB3YW50IHRvIGF2b2lkIGNhc3RpbmcgdGhpcyBhcm91bmQsIGFzIHRoYXQgY291bGQgbGVhZCB0byBidWdzIChlLmcuIHdoZW4gd2UgYWRkIGFub3RoZXIgdHlwZSlcbiAgICBTbyB0aGUgc2FmZSBjaG9pY2UgaXMgdG8gcmVhbGx5IGd1YXJkIGFnYWluc3QgdGhlIHJlcGxheV9ldmVudCB0eXBlIGhlcmUuXG4gICovXG4gIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGUgJiYgZXZlbnQudHlwZSAhPT0gJ3JlcGxheV9ldmVudCcgPyBldmVudC50eXBlIDogJ2V2ZW50JztcblxuICBlbmhhbmNlRXZlbnRXaXRoU2RrSW5mbyhldmVudCwgbWV0YWRhdGE/LnNkayk7XG5cbiAgY29uc3QgZW52ZWxvcGVIZWFkZXJzID0gY3JlYXRlRXZlbnRFbnZlbG9wZUhlYWRlcnMoZXZlbnQsIHNka0luZm8sIHR1bm5lbCwgZHNuKTtcblxuICAvLyBQcmV2ZW50IHRoaXMgZGF0YSAod2hpY2gsIGlmIGl0IGV4aXN0cywgd2FzIHVzZWQgaW4gZWFybGllciBzdGVwcyBpbiB0aGUgcHJvY2Vzc2luZyBwaXBlbGluZSkgZnJvbSBiZWluZyBzZW50IHRvXG4gIC8vIHNlbnRyeS4gKE5vdGU6IE91ciB1c2Ugb2YgdGhpcyBwcm9wZXJ0eSBjb21lcyBhbmQgZ29lcyB3aXRoIHdoYXRldmVyIHdlIG1pZ2h0IGJlIGRlYnVnZ2luZywgd2hhdGV2ZXIgaGFja3Mgd2UgbWF5XG4gIC8vIGhhdmUgdGVtcG9yYXJpbHkgYWRkZWQsIGV0Yy4gRXZlbiBpZiB3ZSBkb24ndCBoYXBwZW4gdG8gYmUgdXNpbmcgaXQgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCBsZXQncyBub3QgZ2V0IHJpZFxuICAvLyBvZiB0aGlzIGBkZWxldGVgLCBsZXN0IHdlIG1pc3MgcHV0dGluZyBpdCBiYWNrIGluIHRoZSBuZXh0IHRpbWUgdGhlIHByb3BlcnR5IGlzIGluIHVzZS4pXG4gIGRlbGV0ZSBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7XG5cbiAgY29uc3QgZXZlbnRJdGVtID0gW3sgdHlwZTogZXZlbnRUeXBlIH0sIGV2ZW50XTtcbiAgcmV0dXJuIGNyZWF0ZUVudmVsb3BlKGVudmVsb3BlSGVhZGVycywgW2V2ZW50SXRlbV0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBlbnZlbG9wZSBmcm9tIFNwYW4gaXRlbS5cbiAqXG4gKiBUYWtlcyBhbiBvcHRpb25hbCBjbGllbnQgYW5kIHJ1bnMgc3BhbnMgdGhyb3VnaCBgYmVmb3JlU2VuZFNwYW5gIGlmIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3BhbkVudmVsb3BlKHNwYW5zLCBjbGllbnQpIHtcbiAgZnVuY3Rpb24gZHNjSGFzUmVxdWlyZWRQcm9wcyhkc2MpIHtcbiAgICByZXR1cm4gISFkc2MudHJhY2VfaWQgJiYgISFkc2MucHVibGljX2tleTtcbiAgfVxuXG4gIC8vIEZvciB0aGUgbW9tZW50IHdlJ2xsIG9idGFpbiB0aGUgRFNDIGZyb20gdGhlIGZpcnN0IHNwYW4gaW4gdGhlIGFycmF5XG4gIC8vIFRoaXMgbWlnaHQgbmVlZCB0byBiZSBjaGFuZ2VkIGlmIHdlIHBlcm1pdCBzZW5kaW5nIG11bHRpcGxlIHNwYW5zIGZyb21cbiAgLy8gZGlmZmVyZW50IHNlZ21lbnRzIGluIG9uZSBlbnZlbG9wZVxuICBjb25zdCBkc2MgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbnNbMF0pO1xuXG4gIGNvbnN0IGRzbiA9IGNsaWVudD8uZ2V0RHNuKCk7XG4gIGNvbnN0IHR1bm5lbCA9IGNsaWVudD8uZ2V0T3B0aW9ucygpLnR1bm5lbDtcblxuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIHNlbnRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAuLi4oZHNjSGFzUmVxdWlyZWRQcm9wcyhkc2MpICYmIHsgdHJhY2U6IGRzYyB9KSxcbiAgICAuLi4oISF0dW5uZWwgJiYgZHNuICYmIHsgZHNuOiBkc25Ub1N0cmluZyhkc24pIH0pLFxuICB9O1xuXG4gIGNvbnN0IGJlZm9yZVNlbmRTcGFuID0gY2xpZW50Py5nZXRPcHRpb25zKCkuYmVmb3JlU2VuZFNwYW47XG4gIGNvbnN0IGNvbnZlcnRUb1NwYW5KU09OID0gYmVmb3JlU2VuZFNwYW5cbiAgICA/IChzcGFuKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwYW5Kc29uID0gc3BhblRvSlNPTihzcGFuKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkU3BhbiA9IGJlZm9yZVNlbmRTcGFuKHNwYW5Kc29uKTtcblxuICAgICAgICBpZiAoIXByb2Nlc3NlZFNwYW4pIHtcbiAgICAgICAgICBzaG93U3BhbkRyb3BXYXJuaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIHNwYW5Kc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZFNwYW47XG4gICAgICB9XG4gICAgOiBzcGFuVG9KU09OO1xuXG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgIGNvbnN0IHNwYW5Kc29uID0gY29udmVydFRvU3BhbkpTT04oc3Bhbik7XG4gICAgaWYgKHNwYW5Kc29uKSB7XG4gICAgICBpdGVtcy5wdXNoKGNyZWF0ZVNwYW5FbnZlbG9wZUl0ZW0oc3Bhbkpzb24pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRW52ZWxvcGUoaGVhZGVycywgaXRlbXMpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFdmVudEVudmVsb3BlLCBjcmVhdGVTZXNzaW9uRW52ZWxvcGUsIGNyZWF0ZVNwYW5FbnZlbG9wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52ZWxvcGUuanMubWFwXG4iLCJpbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi9pcy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuLyoqIFN5bmNQcm9taXNlIGludGVybmFsIHN0YXRlcyAqL1xudmFyIFN0YXRlczsgKGZ1bmN0aW9uIChTdGF0ZXMpIHtcbiAgLyoqIFBlbmRpbmcgKi9cbiAgY29uc3QgUEVORElORyA9IDA7IFN0YXRlc1tTdGF0ZXNbXCJQRU5ESU5HXCJdID0gUEVORElOR10gPSBcIlBFTkRJTkdcIjtcbiAgLyoqIFJlc29sdmVkIC8gT0sgKi9cbiAgY29uc3QgUkVTT0xWRUQgPSAxOyBTdGF0ZXNbU3RhdGVzW1wiUkVTT0xWRURcIl0gPSBSRVNPTFZFRF0gPSBcIlJFU09MVkVEXCI7XG4gIC8qKiBSZWplY3RlZCAvIEVycm9yICovXG4gIGNvbnN0IFJFSkVDVEVEID0gMjsgU3RhdGVzW1N0YXRlc1tcIlJFSkVDVEVEXCJdID0gUkVKRUNURURdID0gXCJSRUpFQ1RFRFwiO1xufSkoU3RhdGVzIHx8IChTdGF0ZXMgPSB7fSkpO1xuXG4vLyBPdmVybG9hZHMgc28gd2UgY2FuIGNhbGwgcmVzb2x2ZWRTeW5jUHJvbWlzZSB3aXRob3V0IGFyZ3VtZW50cyBhbmQgZ2VuZXJpYyBhcmd1bWVudFxuXG4vKipcbiAqIENyZWF0ZXMgYSByZXNvbHZlZCBzeW5jIHByb21pc2UuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGhcbiAqIEByZXR1cm5zIHRoZSByZXNvbHZlZCBzeW5jIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZWRTeW5jUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVqZWN0ZWQgc3luYyBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGhcbiAqIEByZXR1cm5zIHRoZSByZWplY3RlZCBzeW5jIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gcmVqZWN0ZWRTeW5jUHJvbWlzZShyZWFzb24pIHtcbiAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZW5hYmxlIGNsYXNzIHRoYXQgYmVoYXZlcyBsaWtlIGEgUHJvbWlzZSBhbmQgZm9sbG93cyBpdCdzIGludGVyZmFjZVxuICogYnV0IGlzIG5vdCBhc3luYyBpbnRlcm5hbGx5XG4gKi9cbmNsYXNzIFN5bmNQcm9taXNlIHtcblxuICAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlcy5QRU5ESU5HO1xuICAgIHRoaXMuX2hhbmRsZXJzID0gW107XG5cbiAgICB0aGlzLl9ydW5FeGVjdXRvcihleGVjdXRvcik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIHRoZW4oXG4gICAgb25mdWxmaWxsZWQsXG4gICAgb25yZWplY3RlZCxcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKFtcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgaWYgKCFvbmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIC8vIFRPRE86IEZJWE1FXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNvbHZlKG9uZnVsZmlsbGVkKHJlc3VsdCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgIGlmICghb25yZWplY3RlZCkge1xuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmUob25yZWplY3RlZChyZWFzb24pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIF0pO1xuICAgICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGNhdGNoKFxuICAgIG9ucmVqZWN0ZWQsXG4gICkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odmFsID0+IHZhbCwgb25yZWplY3RlZCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgdmFsO1xuICAgICAgbGV0IGlzUmVqZWN0ZWQ7XG5cbiAgICAgIHJldHVybiB0aGlzLnRoZW4oXG4gICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICBpc1JlamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG9uZmluYWxseSkge1xuICAgICAgICAgICAgb25maW5hbGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbCA9IHJlYXNvbjtcbiAgICAgICAgICBpZiAob25maW5hbGx5KSB7XG4gICAgICAgICAgICBvbmZpbmFsbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNSZWplY3RlZCkge1xuICAgICAgICAgIHJlamVjdCh2YWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUodmFsICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBFeGN1dGUgdGhlIHJlc29sdmUvcmVqZWN0IGhhbmRsZXJzLiAqL1xuICAgX2V4ZWN1dGVIYW5kbGVycygpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFN0YXRlcy5QRU5ESU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVkSGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVycy5zbGljZSgpO1xuICAgIHRoaXMuX2hhbmRsZXJzID0gW107XG5cbiAgICBjYWNoZWRIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgaWYgKGhhbmRsZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFN0YXRlcy5SRVNPTFZFRCkge1xuICAgICAgICBoYW5kbGVyWzFdKHRoaXMuX3ZhbHVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU3RhdGVzLlJFSkVDVEVEKSB7XG4gICAgICAgIGhhbmRsZXJbMl0odGhpcy5fdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVyWzBdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBSdW4gdGhlIGV4ZWN1dG9yIGZvciB0aGUgU3luY1Byb21pc2UuICovXG4gICBfcnVuRXhlY3V0b3IoZXhlY3V0b3IpIHtcbiAgICBjb25zdCBzZXRSZXN1bHQgPSAoc3RhdGUsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlcy5QRU5ESU5HKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICAgIHZvaWQgKHZhbHVlICkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICB0aGlzLl9leGVjdXRlSGFuZGxlcnMoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgc2V0UmVzdWx0KFN0YXRlcy5SRVNPTFZFRCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBjb25zdCByZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICBzZXRSZXN1bHQoU3RhdGVzLlJFSkVDVEVELCByZWFzb24pO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFN5bmNQcm9taXNlLCByZWplY3RlZFN5bmNQcm9taXNlLCByZXNvbHZlZFN5bmNQcm9taXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeW5jcHJvbWlzZS5qcy5tYXBcbiIsImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi91dGlscy1ob2lzdC9pcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBTeW5jUHJvbWlzZSB9IGZyb20gJy4vdXRpbHMtaG9pc3Qvc3luY3Byb21pc2UuanMnO1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gYXJyYXkgb2YgZXZlbnQgcHJvY2Vzc29ycywgcmV0dXJuaW5nIHRoZSBwcm9jZXNzZWQgZXZlbnQgKG9yIGBudWxsYCBpZiB0aGUgZXZlbnQgd2FzIGRyb3BwZWQpLlxuICovXG5mdW5jdGlvbiBub3RpZnlFdmVudFByb2Nlc3NvcnMoXG4gIHByb2Nlc3NvcnMsXG4gIGV2ZW50LFxuICBoaW50LFxuICBpbmRleCA9IDAsXG4pIHtcbiAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc29yID0gcHJvY2Vzc29yc1tpbmRleF07XG4gICAgaWYgKGV2ZW50ID09PSBudWxsIHx8IHR5cGVvZiBwcm9jZXNzb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzb3IoeyAuLi5ldmVudCB9LCBoaW50KSA7XG5cbiAgICAgIERFQlVHX0JVSUxEICYmIHByb2Nlc3Nvci5pZCAmJiByZXN1bHQgPT09IG51bGwgJiYgbG9nZ2VyLmxvZyhgRXZlbnQgcHJvY2Vzc29yIFwiJHtwcm9jZXNzb3IuaWR9XCIgZHJvcHBlZCBldmVudGApO1xuXG4gICAgICBpZiAoaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIHZvaWQgcmVzdWx0XG4gICAgICAgICAgLnRoZW4oZmluYWwgPT4gbm90aWZ5RXZlbnRQcm9jZXNzb3JzKHByb2Nlc3NvcnMsIGZpbmFsLCBoaW50LCBpbmRleCArIDEpLnRoZW4ocmVzb2x2ZSkpXG4gICAgICAgICAgLnRoZW4obnVsbCwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZvaWQgbm90aWZ5RXZlbnRQcm9jZXNzb3JzKHByb2Nlc3NvcnMsIHJlc3VsdCwgaGludCwgaW5kZXggKyAxKVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLnRoZW4obnVsbCwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBub3RpZnlFdmVudFByb2Nlc3NvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50UHJvY2Vzc29ycy5qcy5tYXBcbiIsImltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbmxldCBwYXJzZWRTdGFja1Jlc3VsdHM7XG5sZXQgbGFzdEtleXNDb3VudDtcbmxldCBjYWNoZWRGaWxlbmFtZURlYnVnSWRzO1xuXG4vKipcbiAqIFJldHVybnMgYSBtYXAgb2YgZmlsZW5hbWVzIHRvIGRlYnVnIGlkZW50aWZpZXJzLlxuICovXG5mdW5jdGlvbiBnZXRGaWxlbmFtZVRvRGVidWdJZE1hcChzdGFja1BhcnNlcikge1xuICBjb25zdCBkZWJ1Z0lkTWFwID0gR0xPQkFMX09CSi5fc2VudHJ5RGVidWdJZHM7XG4gIGlmICghZGVidWdJZE1hcCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IGRlYnVnSWRLZXlzID0gT2JqZWN0LmtleXMoZGVidWdJZE1hcCk7XG5cbiAgLy8gSWYgdGhlIGNvdW50IG9mIHJlZ2lzdGVyZWQgZ2xvYmFscyBoYXNuJ3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjYWxsLCB3ZVxuICAvLyBjYW4ganVzdCByZXR1cm4gdGhlIGNhY2hlZCByZXN1bHQuXG4gIGlmIChjYWNoZWRGaWxlbmFtZURlYnVnSWRzICYmIGRlYnVnSWRLZXlzLmxlbmd0aCA9PT0gbGFzdEtleXNDb3VudCkge1xuICAgIHJldHVybiBjYWNoZWRGaWxlbmFtZURlYnVnSWRzO1xuICB9XG5cbiAgbGFzdEtleXNDb3VudCA9IGRlYnVnSWRLZXlzLmxlbmd0aDtcblxuICAvLyBCdWlsZCBhIG1hcCBvZiBmaWxlbmFtZSAtPiBkZWJ1Z19pZC5cbiAgY2FjaGVkRmlsZW5hbWVEZWJ1Z0lkcyA9IGRlYnVnSWRLZXlzLnJlZHVjZSgoYWNjLCBzdGFja0tleSkgPT4ge1xuICAgIGlmICghcGFyc2VkU3RhY2tSZXN1bHRzKSB7XG4gICAgICBwYXJzZWRTdGFja1Jlc3VsdHMgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZWRTdGFja1Jlc3VsdHNbc3RhY2tLZXldO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYWNjW3Jlc3VsdFswXV0gPSByZXN1bHRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcnNlZFN0YWNrID0gc3RhY2tQYXJzZXIoc3RhY2tLZXkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gcGFyc2VkU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgc3RhY2tGcmFtZSA9IHBhcnNlZFN0YWNrW2ldO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHN0YWNrRnJhbWU/LmZpbGVuYW1lO1xuICAgICAgICBjb25zdCBkZWJ1Z0lkID0gZGVidWdJZE1hcFtzdGFja0tleV07XG5cbiAgICAgICAgaWYgKGZpbGVuYW1lICYmIGRlYnVnSWQpIHtcbiAgICAgICAgICBhY2NbZmlsZW5hbWVdID0gZGVidWdJZDtcbiAgICAgICAgICBwYXJzZWRTdGFja1Jlc3VsdHNbc3RhY2tLZXldID0gW2ZpbGVuYW1lLCBkZWJ1Z0lkXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gY2FjaGVkRmlsZW5hbWVEZWJ1Z0lkcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBkZWJ1ZyBpbWFnZXMgZm9yIHRoZSBnaXZlbiByZXNvdXJjZXMuXG4gKi9cbmZ1bmN0aW9uIGdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzKFxuICBzdGFja1BhcnNlcixcbiAgcmVzb3VyY2VfcGF0aHMsXG4pIHtcbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0gZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAoc3RhY2tQYXJzZXIpO1xuXG4gIGlmICghZmlsZW5hbWVEZWJ1Z0lkTWFwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgaW1hZ2VzID0gW107XG4gIGZvciAoY29uc3QgcGF0aCBvZiByZXNvdXJjZV9wYXRocykge1xuICAgIGlmIChwYXRoICYmIGZpbGVuYW1lRGVidWdJZE1hcFtwYXRoXSkge1xuICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAnc291cmNlbWFwJyxcbiAgICAgICAgY29kZV9maWxlOiBwYXRoLFxuICAgICAgICBkZWJ1Z19pZDogZmlsZW5hbWVEZWJ1Z0lkTWFwW3BhdGhdICxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbWFnZXM7XG59XG5cbmV4cG9ydCB7IGdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzLCBnZXRGaWxlbmFtZVRvRGVidWdJZE1hcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctaWRzLmpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuIH0gZnJvbSAnLi4vdHJhY2luZy9keW5hbWljU2FtcGxpbmdDb250ZXh0LmpzJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnLi9tZXJnZS5qcyc7XG5pbXBvcnQgeyBzcGFuVG9UcmFjZUNvbnRleHQsIGdldFJvb3RTcGFuLCBzcGFuVG9KU09OIH0gZnJvbSAnLi9zcGFuVXRpbHMuanMnO1xuXG4vKipcbiAqIEFwcGxpZXMgZGF0YSBmcm9tIHRoZSBzY29wZSB0byB0aGUgZXZlbnQgYW5kIHJ1bnMgYWxsIGV2ZW50IHByb2Nlc3NvcnMgb24gaXQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U2NvcGVEYXRhVG9FdmVudChldmVudCwgZGF0YSkge1xuICBjb25zdCB7IGZpbmdlcnByaW50LCBzcGFuLCBicmVhZGNydW1icywgc2RrUHJvY2Vzc2luZ01ldGFkYXRhIH0gPSBkYXRhO1xuXG4gIC8vIEFwcGx5IGdlbmVyYWwgZGF0YVxuICBhcHBseURhdGFUb0V2ZW50KGV2ZW50LCBkYXRhKTtcblxuICAvLyBXZSB3YW50IHRvIHNldCB0aGUgdHJhY2UgY29udGV4dCBmb3Igbm9ybWFsIGV2ZW50cyBvbmx5IGlmIHRoZXJlIGlzbid0IGFscmVhZHlcbiAgLy8gYSB0cmFjZSBjb250ZXh0IG9uIHRoZSBldmVudC4gVGhlcmUgaXMgYSBwcm9kdWN0IGZlYXR1cmUgaW4gcGxhY2Ugd2hlcmUgd2UgbGlua1xuICAvLyBlcnJvcnMgd2l0aCB0cmFuc2FjdGlvbiBhbmQgaXQgcmVsaWVzIG9uIHRoYXQuXG4gIGlmIChzcGFuKSB7XG4gICAgYXBwbHlTcGFuVG9FdmVudChldmVudCwgc3Bhbik7XG4gIH1cblxuICBhcHBseUZpbmdlcnByaW50VG9FdmVudChldmVudCwgZmluZ2VycHJpbnQpO1xuICBhcHBseUJyZWFkY3J1bWJzVG9FdmVudChldmVudCwgYnJlYWRjcnVtYnMpO1xuICBhcHBseVNka01ldGFkYXRhVG9FdmVudChldmVudCwgc2RrUHJvY2Vzc2luZ01ldGFkYXRhKTtcbn1cblxuLyoqIE1lcmdlIGRhdGEgb2YgdHdvIHNjb3BlcyB0b2dldGhlci4gKi9cbmZ1bmN0aW9uIG1lcmdlU2NvcGVEYXRhKGRhdGEsIG1lcmdlRGF0YSkge1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgdGFncyxcbiAgICB1c2VyLFxuICAgIGNvbnRleHRzLFxuICAgIGxldmVsLFxuICAgIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICBicmVhZGNydW1icyxcbiAgICBmaW5nZXJwcmludCxcbiAgICBldmVudFByb2Nlc3NvcnMsXG4gICAgYXR0YWNobWVudHMsXG4gICAgcHJvcGFnYXRpb25Db250ZXh0LFxuICAgIHRyYW5zYWN0aW9uTmFtZSxcbiAgICBzcGFuLFxuICB9ID0gbWVyZ2VEYXRhO1xuXG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICdleHRyYScsIGV4dHJhKTtcbiAgbWVyZ2VBbmRPdmVyd3JpdGVTY29wZURhdGEoZGF0YSwgJ3RhZ3MnLCB0YWdzKTtcbiAgbWVyZ2VBbmRPdmVyd3JpdGVTY29wZURhdGEoZGF0YSwgJ3VzZXInLCB1c2VyKTtcbiAgbWVyZ2VBbmRPdmVyd3JpdGVTY29wZURhdGEoZGF0YSwgJ2NvbnRleHRzJywgY29udGV4dHMpO1xuXG4gIGRhdGEuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0gbWVyZ2UoZGF0YS5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSwgMik7XG5cbiAgaWYgKGxldmVsKSB7XG4gICAgZGF0YS5sZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgaWYgKHRyYW5zYWN0aW9uTmFtZSkge1xuICAgIGRhdGEudHJhbnNhY3Rpb25OYW1lID0gdHJhbnNhY3Rpb25OYW1lO1xuICB9XG5cbiAgaWYgKHNwYW4pIHtcbiAgICBkYXRhLnNwYW4gPSBzcGFuO1xuICB9XG5cbiAgaWYgKGJyZWFkY3J1bWJzLmxlbmd0aCkge1xuICAgIGRhdGEuYnJlYWRjcnVtYnMgPSBbLi4uZGF0YS5icmVhZGNydW1icywgLi4uYnJlYWRjcnVtYnNdO1xuICB9XG5cbiAgaWYgKGZpbmdlcnByaW50Lmxlbmd0aCkge1xuICAgIGRhdGEuZmluZ2VycHJpbnQgPSBbLi4uZGF0YS5maW5nZXJwcmludCwgLi4uZmluZ2VycHJpbnRdO1xuICB9XG5cbiAgaWYgKGV2ZW50UHJvY2Vzc29ycy5sZW5ndGgpIHtcbiAgICBkYXRhLmV2ZW50UHJvY2Vzc29ycyA9IFsuLi5kYXRhLmV2ZW50UHJvY2Vzc29ycywgLi4uZXZlbnRQcm9jZXNzb3JzXTtcbiAgfVxuXG4gIGlmIChhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICBkYXRhLmF0dGFjaG1lbnRzID0gWy4uLmRhdGEuYXR0YWNobWVudHMsIC4uLmF0dGFjaG1lbnRzXTtcbiAgfVxuXG4gIGRhdGEucHJvcGFnYXRpb25Db250ZXh0ID0geyAuLi5kYXRhLnByb3BhZ2F0aW9uQ29udGV4dCwgLi4ucHJvcGFnYXRpb25Db250ZXh0IH07XG59XG5cbi8qKlxuICogTWVyZ2VzIGNlcnRhaW4gc2NvcGUgZGF0YS4gVW5kZWZpbmVkIHZhbHVlcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgdmFsdWVzLlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhXG5cbihkYXRhLCBwcm9wLCBtZXJnZVZhbCkge1xuICBkYXRhW3Byb3BdID0gbWVyZ2UoZGF0YVtwcm9wXSwgbWVyZ2VWYWwsIDEpO1xufVxuXG5mdW5jdGlvbiBhcHBseURhdGFUb0V2ZW50KGV2ZW50LCBkYXRhKSB7XG4gIGNvbnN0IHsgZXh0cmEsIHRhZ3MsIHVzZXIsIGNvbnRleHRzLCBsZXZlbCwgdHJhbnNhY3Rpb25OYW1lIH0gPSBkYXRhO1xuXG4gIGlmIChPYmplY3Qua2V5cyhleHRyYSkubGVuZ3RoKSB7XG4gICAgZXZlbnQuZXh0cmEgPSB7IC4uLmV4dHJhLCAuLi5ldmVudC5leHRyYSB9O1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHRhZ3MpLmxlbmd0aCkge1xuICAgIGV2ZW50LnRhZ3MgPSB7IC4uLnRhZ3MsIC4uLmV2ZW50LnRhZ3MgfTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyh1c2VyKS5sZW5ndGgpIHtcbiAgICBldmVudC51c2VyID0geyAuLi51c2VyLCAuLi5ldmVudC51c2VyIH07XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoY29udGV4dHMpLmxlbmd0aCkge1xuICAgIGV2ZW50LmNvbnRleHRzID0geyAuLi5jb250ZXh0cywgLi4uZXZlbnQuY29udGV4dHMgfTtcbiAgfVxuXG4gIGlmIChsZXZlbCkge1xuICAgIGV2ZW50LmxldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvLyB0cmFuc2FjdGlvbiBldmVudHMgZ2V0IHRoZWlyIGB0cmFuc2FjdGlvbmAgZnJvbSB0aGUgcm9vdCBzcGFuIG5hbWVcbiAgaWYgKHRyYW5zYWN0aW9uTmFtZSAmJiBldmVudC50eXBlICE9PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgZXZlbnQudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbk5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlCcmVhZGNydW1ic1RvRXZlbnQoZXZlbnQsIGJyZWFkY3J1bWJzKSB7XG4gIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWJzID0gWy4uLihldmVudC5icmVhZGNydW1icyB8fCBbXSksIC4uLmJyZWFkY3J1bWJzXTtcbiAgZXZlbnQuYnJlYWRjcnVtYnMgPSBtZXJnZWRCcmVhZGNydW1icy5sZW5ndGggPyBtZXJnZWRCcmVhZGNydW1icyA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYXBwbHlTZGtNZXRhZGF0YVRvRXZlbnQoZXZlbnQsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSkge1xuICBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgIC4uLnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlTcGFuVG9FdmVudChldmVudCwgc3Bhbikge1xuICBldmVudC5jb250ZXh0cyA9IHtcbiAgICB0cmFjZTogc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pLFxuICAgIC4uLmV2ZW50LmNvbnRleHRzLFxuICB9O1xuXG4gIGV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHtcbiAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbiksXG4gICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICB9O1xuXG4gIGNvbnN0IHJvb3RTcGFuID0gZ2V0Um9vdFNwYW4oc3Bhbik7XG4gIGNvbnN0IHRyYW5zYWN0aW9uTmFtZSA9IHNwYW5Ub0pTT04ocm9vdFNwYW4pLmRlc2NyaXB0aW9uO1xuICBpZiAodHJhbnNhY3Rpb25OYW1lICYmICFldmVudC50cmFuc2FjdGlvbiAmJiBldmVudC50eXBlID09PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgZXZlbnQudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbk5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBsaWVzIGZpbmdlcnByaW50IGZyb20gdGhlIHNjb3BlIHRvIHRoZSBldmVudCBpZiB0aGVyZSdzIG9uZSxcbiAqIHVzZXMgbWVzc2FnZSBpZiB0aGVyZSdzIG9uZSBpbnN0ZWFkIG9yIGdldCByaWQgb2YgZW1wdHkgZmluZ2VycHJpbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlGaW5nZXJwcmludFRvRXZlbnQoZXZlbnQsIGZpbmdlcnByaW50KSB7XG4gIC8vIE1ha2Ugc3VyZSBpdCdzIGFuIGFycmF5IGZpcnN0IGFuZCB3ZSBhY3R1YWxseSBoYXZlIHNvbWV0aGluZyBpbiBwbGFjZVxuICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50XG4gICAgPyBBcnJheS5pc0FycmF5KGV2ZW50LmZpbmdlcnByaW50KVxuICAgICAgPyBldmVudC5maW5nZXJwcmludFxuICAgICAgOiBbZXZlbnQuZmluZ2VycHJpbnRdXG4gICAgOiBbXTtcblxuICAvLyBJZiB3ZSBoYXZlIHNvbWV0aGluZyBvbiB0aGUgc2NvcGUsIHRoZW4gbWVyZ2UgaXQgd2l0aCBldmVudFxuICBpZiAoZmluZ2VycHJpbnQpIHtcbiAgICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50LmNvbmNhdChmaW5nZXJwcmludCk7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIG5vIGRhdGEgYXQgYWxsLCByZW1vdmUgZW1wdHkgYXJyYXkgZGVmYXVsdFxuICBpZiAoIWV2ZW50LmZpbmdlcnByaW50Lmxlbmd0aCkge1xuICAgIGRlbGV0ZSBldmVudC5maW5nZXJwcmludDtcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBseVNjb3BlRGF0YVRvRXZlbnQsIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhLCBtZXJnZVNjb3BlRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlTY29wZURhdGFUb0V2ZW50LmpzLm1hcFxuIiwiaW1wb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxTY29wZSB9IGZyb20gJy4uL2N1cnJlbnRTY29wZXMuanMnO1xuaW1wb3J0IHsgbm90aWZ5RXZlbnRQcm9jZXNzb3JzIH0gZnJvbSAnLi4vZXZlbnRQcm9jZXNzb3JzLmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi4vc2NvcGUuanMnO1xuaW1wb3J0IHsgZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAgfSBmcm9tICcuLi91dGlscy1ob2lzdC9kZWJ1Zy1pZHMuanMnO1xuaW1wb3J0IHsgdXVpZDQsIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L21pc2MuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvbm9ybWFsaXplLmpzJztcbmltcG9ydCB7IHRydW5jYXRlIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJztcbmltcG9ydCB7IGRhdGVUaW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuLi91dGlscy1ob2lzdC90aW1lLmpzJztcbmltcG9ydCB7IG1lcmdlU2NvcGVEYXRhLCBhcHBseVNjb3BlRGF0YVRvRXZlbnQgfSBmcm9tICcuL2FwcGx5U2NvcGVEYXRhVG9FdmVudC5qcyc7XG5cbi8qKlxuICogVGhpcyB0eXBlIG1ha2VzIHN1cmUgdGhhdCB3ZSBnZXQgZWl0aGVyIGEgQ2FwdHVyZUNvbnRleHQsIE9SIGFuIEV2ZW50SGludC5cbiAqIEl0IGRvZXMgbm90IGFsbG93IG1peGluZyB0aGVtLCB3aGljaCBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgb3V0Y29tZXMsIGUuZy4gdGhpcyBpcyBkaXNhbGxvd2VkOlxuICogeyB1c2VyOiB7IGlkOiAnMTIzJyB9LCBtZWNoYW5pc206IHsgaGFuZGxlZDogZmFsc2UgfSB9XG4gKi9cblxuLyoqXG4gKiBBZGRzIGNvbW1vbiBpbmZvcm1hdGlvbiB0byBldmVudHMuXG4gKlxuICogVGhlIGluZm9ybWF0aW9uIGluY2x1ZGVzIHJlbGVhc2UgYW5kIGVudmlyb25tZW50IGZyb20gYG9wdGlvbnNgLFxuICogYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQgKGV4dHJhLCB0YWdzIGFuZCB1c2VyKSBmcm9tIHRoZSBzY29wZS5cbiAqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZXZlbnQgaXMgbmV2ZXIgb3ZlcndyaXR0ZW4uIEZvclxuICogbmVzdGVkIG9iamVjdHMsIHN1Y2ggYXMgdGhlIGNvbnRleHQsIGtleXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHBhcmFtIGhpbnQgTWF5IGNvbnRhaW4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLlxuICogQHBhcmFtIHNjb3BlIEEgc2NvcGUgY29udGFpbmluZyBldmVudCBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIEEgbmV3IGV2ZW50IHdpdGggbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZUV2ZW50KFxuICBvcHRpb25zLFxuICBldmVudCxcbiAgaGludCxcbiAgc2NvcGUsXG4gIGNsaWVudCxcbiAgaXNvbGF0aW9uU2NvcGUsXG4pIHtcbiAgY29uc3QgeyBub3JtYWxpemVEZXB0aCA9IDMsIG5vcm1hbGl6ZU1heEJyZWFkdGggPSAxMDAwIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVwYXJlZCA9IHtcbiAgICAuLi5ldmVudCxcbiAgICBldmVudF9pZDogZXZlbnQuZXZlbnRfaWQgfHwgaGludC5ldmVudF9pZCB8fCB1dWlkNCgpLFxuICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wIHx8IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgfTtcbiAgY29uc3QgaW50ZWdyYXRpb25zID0gaGludC5pbnRlZ3JhdGlvbnMgfHwgb3B0aW9ucy5pbnRlZ3JhdGlvbnMubWFwKGkgPT4gaS5uYW1lKTtcblxuICBhcHBseUNsaWVudE9wdGlvbnMocHJlcGFyZWQsIG9wdGlvbnMpO1xuICBhcHBseUludGVncmF0aW9uc01ldGFkYXRhKHByZXBhcmVkLCBpbnRlZ3JhdGlvbnMpO1xuXG4gIGlmIChjbGllbnQpIHtcbiAgICBjbGllbnQuZW1pdCgnYXBwbHlGcmFtZU1ldGFkYXRhJywgZXZlbnQpO1xuICB9XG5cbiAgLy8gT25seSBwdXQgZGVidWcgSURzIG9udG8gZnJhbWVzIGZvciBlcnJvciBldmVudHMuXG4gIGlmIChldmVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBhcHBseURlYnVnSWRzKHByZXBhcmVkLCBvcHRpb25zLnN0YWNrUGFyc2VyKTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgc2NvcGUgZ2l2ZW4gdG8gdXMsIHVzZSBpdCBhcyB0aGUgYmFzZSBmb3IgZnVydGhlciBtb2RpZmljYXRpb25zLlxuICAvLyBUaGlzIGFsbG93cyB1cyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IGNvcHlpbmcgb2YgZGF0YSBpZiBgY2FwdHVyZUNvbnRleHRgIGlzIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgZmluYWxTY29wZSA9IGdldEZpbmFsU2NvcGUoc2NvcGUsIGhpbnQuY2FwdHVyZUNvbnRleHQpO1xuXG4gIGlmIChoaW50Lm1lY2hhbmlzbSkge1xuICAgIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbShwcmVwYXJlZCwgaGludC5tZWNoYW5pc20pO1xuICB9XG5cbiAgY29uc3QgY2xpZW50RXZlbnRQcm9jZXNzb3JzID0gY2xpZW50ID8gY2xpZW50LmdldEV2ZW50UHJvY2Vzc29ycygpIDogW107XG5cbiAgLy8gVGhpcyBzaG91bGQgYmUgdGhlIGxhc3QgdGhpbmcgY2FsbGVkLCBzaW5jZSB3ZSB3YW50IHRoYXRcbiAgLy8ge0BsaW5rIFNjb3BlLmFkZEV2ZW50UHJvY2Vzc29yfSBnZXRzIHRoZSBmaW5pc2hlZCBwcmVwYXJlZCBldmVudC5cbiAgLy8gTWVyZ2Ugc2NvcGUgZGF0YSB0b2dldGhlclxuICBjb25zdCBkYXRhID0gZ2V0R2xvYmFsU2NvcGUoKS5nZXRTY29wZURhdGEoKTtcblxuICBpZiAoaXNvbGF0aW9uU2NvcGUpIHtcbiAgICBjb25zdCBpc29sYXRpb25EYXRhID0gaXNvbGF0aW9uU2NvcGUuZ2V0U2NvcGVEYXRhKCk7XG4gICAgbWVyZ2VTY29wZURhdGEoZGF0YSwgaXNvbGF0aW9uRGF0YSk7XG4gIH1cblxuICBpZiAoZmluYWxTY29wZSkge1xuICAgIGNvbnN0IGZpbmFsU2NvcGVEYXRhID0gZmluYWxTY29wZS5nZXRTY29wZURhdGEoKTtcbiAgICBtZXJnZVNjb3BlRGF0YShkYXRhLCBmaW5hbFNjb3BlRGF0YSk7XG4gIH1cblxuICBjb25zdCBhdHRhY2htZW50cyA9IFsuLi4oaGludC5hdHRhY2htZW50cyB8fCBbXSksIC4uLmRhdGEuYXR0YWNobWVudHNdO1xuICBpZiAoYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgaGludC5hdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzO1xuICB9XG5cbiAgYXBwbHlTY29wZURhdGFUb0V2ZW50KHByZXBhcmVkLCBkYXRhKTtcblxuICBjb25zdCBldmVudFByb2Nlc3NvcnMgPSBbXG4gICAgLi4uY2xpZW50RXZlbnRQcm9jZXNzb3JzLFxuICAgIC8vIFJ1biBzY29wZSBldmVudCBwcm9jZXNzb3JzIF9hZnRlcl8gYWxsIG90aGVyIHByb2Nlc3NvcnNcbiAgICAuLi5kYXRhLmV2ZW50UHJvY2Vzc29ycyxcbiAgXTtcblxuICBjb25zdCByZXN1bHQgPSBub3RpZnlFdmVudFByb2Nlc3NvcnMoZXZlbnRQcm9jZXNzb3JzLCBwcmVwYXJlZCwgaGludCk7XG5cbiAgcmV0dXJuIHJlc3VsdC50aGVuKGV2dCA9PiB7XG4gICAgaWYgKGV2dCkge1xuICAgICAgLy8gV2UgYXBwbHkgdGhlIGRlYnVnX21ldGEgZmllbGQgb25seSBhZnRlciBhbGwgZXZlbnQgcHJvY2Vzc29ycyBoYXZlIHJhbiwgc28gdGhhdCBpZiBhbnkgZXZlbnQgcHJvY2Vzc29ycyBtb2RpZmllZFxuICAgICAgLy8gZmlsZSBuYW1lcyAoZS5nLnRoZSBSZXdyaXRlRnJhbWVzIGludGVncmF0aW9uKSB0aGUgZmlsZW5hbWUgLT4gZGVidWcgSUQgcmVsYXRpb25zaGlwIGlzbid0IGRlc3Ryb3llZC5cbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBjYXVzZSBhbnkgUElJIGlzc3Vlcywgc2luY2Ugd2UncmUgb25seSBtb3ZpbmcgZGF0YSB0aGF0IGlzIGFscmVhZHkgb24gdGhlIGV2ZW50IGFuZCBub3QgYWRkaW5nXG4gICAgICAvLyBhbnkgbmV3IGRhdGFcbiAgICAgIGFwcGx5RGVidWdNZXRhKGV2dCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBub3JtYWxpemVEZXB0aCA9PT0gJ251bWJlcicgJiYgbm9ybWFsaXplRGVwdGggPiAwKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplRXZlbnQoZXZ0LCBub3JtYWxpemVEZXB0aCwgbm9ybWFsaXplTWF4QnJlYWR0aCk7XG4gICAgfVxuICAgIHJldHVybiBldnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVuaGFuY2VzIGV2ZW50IHVzaW5nIHRoZSBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAqIEl0IHRha2VzIGNhcmUgb2YgYWxsIFwic3RhdGljXCIgdmFsdWVzIGxpa2UgZW52aXJvbm1lbnQsIHJlbGVhc2UgYW5kIGBkaXN0YCxcbiAqIGFzIHdlbGwgYXMgdHJ1bmNhdGluZyBvdmVybHkgbG9uZyB2YWx1ZXMuXG4gKlxuICogT25seSBleHBvcnRlZCBmb3IgdGVzdHMuXG4gKlxuICogQHBhcmFtIGV2ZW50IGV2ZW50IGluc3RhbmNlIHRvIGJlIGVuaGFuY2VkXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q2xpZW50T3B0aW9ucyhldmVudCwgb3B0aW9ucykge1xuICBjb25zdCB7IGVudmlyb25tZW50LCByZWxlYXNlLCBkaXN0LCBtYXhWYWx1ZUxlbmd0aCA9IDI1MCB9ID0gb3B0aW9ucztcblxuICAvLyBlbXB0eSBzdHJpbmdzIGRvIG5vdCBtYWtlIHNlbnNlIGZvciBlbnZpcm9ubWVudCwgcmVsZWFzZSwgYW5kIGRpc3RcbiAgLy8gc28gd2UgaGFuZGxlIHRoZW0gdGhlIHNhbWUgYXMgaWYgdGhleSB3ZXJlIG5vdCBwcm92aWRlZFxuICBldmVudC5lbnZpcm9ubWVudCA9IGV2ZW50LmVudmlyb25tZW50IHx8IGVudmlyb25tZW50IHx8IERFRkFVTFRfRU5WSVJPTk1FTlQ7XG5cbiAgaWYgKCFldmVudC5yZWxlYXNlICYmIHJlbGVhc2UpIHtcbiAgICBldmVudC5yZWxlYXNlID0gcmVsZWFzZTtcbiAgfVxuXG4gIGlmICghZXZlbnQuZGlzdCAmJiBkaXN0KSB7XG4gICAgZXZlbnQuZGlzdCA9IGRpc3Q7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0gZXZlbnQucmVxdWVzdDtcbiAgaWYgKHJlcXVlc3Q/LnVybCkge1xuICAgIHJlcXVlc3QudXJsID0gdHJ1bmNhdGUocmVxdWVzdC51cmwsIG1heFZhbHVlTGVuZ3RoKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1dHMgZGVidWcgSURzIGludG8gdGhlIHN0YWNrIGZyYW1lcyBvZiBhbiBlcnJvciBldmVudC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlEZWJ1Z0lkcyhldmVudCwgc3RhY2tQYXJzZXIpIHtcbiAgLy8gQnVpbGQgYSBtYXAgb2YgZmlsZW5hbWUgLT4gZGVidWdfaWRcbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0gZ2V0RmlsZW5hbWVUb0RlYnVnSWRNYXAoc3RhY2tQYXJzZXIpO1xuXG4gIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5mb3JFYWNoKGV4Y2VwdGlvbiA9PiB7XG4gICAgZXhjZXB0aW9uLnN0YWNrdHJhY2U/LmZyYW1lcz8uZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgICBpZiAoZnJhbWUuZmlsZW5hbWUpIHtcbiAgICAgICAgZnJhbWUuZGVidWdfaWQgPSBmaWxlbmFtZURlYnVnSWRNYXBbZnJhbWUuZmlsZW5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNb3ZlcyBkZWJ1ZyBJRHMgZnJvbSB0aGUgc3RhY2sgZnJhbWVzIG9mIGFuIGVycm9yIGV2ZW50IGludG8gdGhlIGRlYnVnX21ldGEgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVidWdNZXRhKGV2ZW50KSB7XG4gIC8vIEV4dHJhY3QgZGVidWcgSURzIGFuZCBmaWxlbmFtZXMgZnJvbSB0aGUgc3RhY2sgZnJhbWVzIG9uIHRoZSBldmVudC5cbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0ge307XG4gIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5mb3JFYWNoKGV4Y2VwdGlvbiA9PiB7XG4gICAgZXhjZXB0aW9uLnN0YWNrdHJhY2U/LmZyYW1lcz8uZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgICBpZiAoZnJhbWUuZGVidWdfaWQpIHtcbiAgICAgICAgaWYgKGZyYW1lLmFic19wYXRoKSB7XG4gICAgICAgICAgZmlsZW5hbWVEZWJ1Z0lkTWFwW2ZyYW1lLmFic19wYXRoXSA9IGZyYW1lLmRlYnVnX2lkO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLmZpbGVuYW1lKSB7XG4gICAgICAgICAgZmlsZW5hbWVEZWJ1Z0lkTWFwW2ZyYW1lLmZpbGVuYW1lXSA9IGZyYW1lLmRlYnVnX2lkO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBmcmFtZS5kZWJ1Z19pZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGZpbGVuYW1lRGVidWdJZE1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmlsbCBkZWJ1Z19tZXRhIGluZm9ybWF0aW9uXG4gIGV2ZW50LmRlYnVnX21ldGEgPSBldmVudC5kZWJ1Z19tZXRhIHx8IHt9O1xuICBldmVudC5kZWJ1Z19tZXRhLmltYWdlcyA9IGV2ZW50LmRlYnVnX21ldGEuaW1hZ2VzIHx8IFtdO1xuICBjb25zdCBpbWFnZXMgPSBldmVudC5kZWJ1Z19tZXRhLmltYWdlcztcbiAgT2JqZWN0LmVudHJpZXMoZmlsZW5hbWVEZWJ1Z0lkTWFwKS5mb3JFYWNoKChbZmlsZW5hbWUsIGRlYnVnX2lkXSkgPT4ge1xuICAgIGltYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdzb3VyY2VtYXAnLFxuICAgICAgY29kZV9maWxlOiBmaWxlbmFtZSxcbiAgICAgIGRlYnVnX2lkLFxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYWxsIHVzZWQgaW50ZWdyYXRpb25zIHRvIHRoZSBTREsgaW5mbyBpbiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBhbGwgaW50ZWdyYXRpb25zLlxuICovXG5mdW5jdGlvbiBhcHBseUludGVncmF0aW9uc01ldGFkYXRhKGV2ZW50LCBpbnRlZ3JhdGlvbk5hbWVzKSB7XG4gIGlmIChpbnRlZ3JhdGlvbk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBldmVudC5zZGsgPSBldmVudC5zZGsgfHwge307XG4gICAgZXZlbnQuc2RrLmludGVncmF0aW9ucyA9IFsuLi4oZXZlbnQuc2RrLmludGVncmF0aW9ucyB8fCBbXSksIC4uLmludGVncmF0aW9uTmFtZXNdO1xuICB9XG59XG5cbi8qKlxuICogQXBwbGllcyBgbm9ybWFsaXplYCBmdW5jdGlvbiBvbiBuZWNlc3NhcnkgYEV2ZW50YCBhdHRyaWJ1dGVzIHRvIG1ha2UgdGhlbSBzYWZlIGZvciBzZXJpYWxpemF0aW9uLlxuICogTm9ybWFsaXplZCBrZXlzOlxuICogLSBgYnJlYWRjcnVtYnMuZGF0YWBcbiAqIC0gYHVzZXJgXG4gKiAtIGBjb250ZXh0c2BcbiAqIC0gYGV4dHJhYFxuICogQHBhcmFtIGV2ZW50IEV2ZW50XG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGV2ZW50LCBkZXB0aCwgbWF4QnJlYWR0aCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgIC4uLmV2ZW50LFxuICAgIC4uLihldmVudC5icmVhZGNydW1icyAmJiB7XG4gICAgICBicmVhZGNydW1iczogZXZlbnQuYnJlYWRjcnVtYnMubWFwKGIgPT4gKHtcbiAgICAgICAgLi4uYixcbiAgICAgICAgLi4uKGIuZGF0YSAmJiB7XG4gICAgICAgICAgZGF0YTogbm9ybWFsaXplKGIuZGF0YSwgZGVwdGgsIG1heEJyZWFkdGgpLFxuICAgICAgICB9KSxcbiAgICAgIH0pKSxcbiAgICB9KSxcbiAgICAuLi4oZXZlbnQudXNlciAmJiB7XG4gICAgICB1c2VyOiBub3JtYWxpemUoZXZlbnQudXNlciwgZGVwdGgsIG1heEJyZWFkdGgpLFxuICAgIH0pLFxuICAgIC4uLihldmVudC5jb250ZXh0cyAmJiB7XG4gICAgICBjb250ZXh0czogbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLCBkZXB0aCwgbWF4QnJlYWR0aCksXG4gICAgfSksXG4gICAgLi4uKGV2ZW50LmV4dHJhICYmIHtcbiAgICAgIGV4dHJhOiBub3JtYWxpemUoZXZlbnQuZXh0cmEsIGRlcHRoLCBtYXhCcmVhZHRoKSxcbiAgICB9KSxcbiAgfTtcblxuICAvLyBldmVudC5jb250ZXh0cy50cmFjZSBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBUcmFuc2FjdGlvbi4gU2ltaWxhcmx5LFxuICAvLyBldmVudC5zcGFuc1tdIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBjaGlsZCBTcGFucy4gR2l2ZW4gdGhhdCBhXG4gIC8vIFRyYW5zYWN0aW9uIGlzIGNvbmNlcHR1YWxseSBhIFNwYW4sIG5vcm1hbGl6YXRpb24gc2hvdWxkIGFwcGx5IHRvIGJvdGhcbiAgLy8gVHJhbnNhY3Rpb25zIGFuZCBTcGFucyBjb25zaXN0ZW50bHkuXG4gIC8vIEZvciBub3cgdGhlIGRlY2lzaW9uIGlzIHRvIHNraXAgbm9ybWFsaXphdGlvbiBvZiBUcmFuc2FjdGlvbnMgYW5kIFNwYW5zLFxuICAvLyBzbyB0aGlzIGJsb2NrIG92ZXJ3cml0ZXMgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgdG8gYWRkIGJhY2sgdGhlIG9yaWdpbmFsXG4gIC8vIFRyYW5zYWN0aW9uIGluZm9ybWF0aW9uIHByaW9yIHRvIG5vcm1hbGl6YXRpb24uXG4gIGlmIChldmVudC5jb250ZXh0cz8udHJhY2UgJiYgbm9ybWFsaXplZC5jb250ZXh0cykge1xuICAgIG5vcm1hbGl6ZWQuY29udGV4dHMudHJhY2UgPSBldmVudC5jb250ZXh0cy50cmFjZTtcblxuICAgIC8vIGV2ZW50LmNvbnRleHRzLnRyYWNlLmRhdGEgbWF5IGNvbnRhaW4gY2lyY3VsYXIvZGFuZ2Vyb3VzIGRhdGEgc28gd2UgbmVlZCB0byBub3JtYWxpemUgaXRcbiAgICBpZiAoZXZlbnQuY29udGV4dHMudHJhY2UuZGF0YSkge1xuICAgICAgbm9ybWFsaXplZC5jb250ZXh0cy50cmFjZS5kYXRhID0gbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLnRyYWNlLmRhdGEsIGRlcHRoLCBtYXhCcmVhZHRoKTtcbiAgICB9XG4gIH1cblxuICAvLyBldmVudC5zcGFuc1tdLmRhdGEgbWF5IGNvbnRhaW4gY2lyY3VsYXIvZGFuZ2Vyb3VzIGRhdGEgc28gd2UgbmVlZCB0byBub3JtYWxpemUgaXRcbiAgaWYgKGV2ZW50LnNwYW5zKSB7XG4gICAgbm9ybWFsaXplZC5zcGFucyA9IGV2ZW50LnNwYW5zLm1hcChzcGFuID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNwYW4sXG4gICAgICAgIC4uLihzcGFuLmRhdGEgJiYge1xuICAgICAgICAgIGRhdGE6IG5vcm1hbGl6ZShzcGFuLmRhdGEsIGRlcHRoLCBtYXhCcmVhZHRoKSxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZXZlbnQuY29udGV4dHMuZmxhZ3MgKEZlYXR1cmVGbGFnQ29udGV4dCkgc3RvcmVzIGNvbnRleHQgZm9yIG91ciBmZWF0dXJlXG4gIC8vIGZsYWcgaW50ZWdyYXRpb25zLiBJdCBoYXMgYSBncmVhdGVyIG5lc3RpbmcgZGVwdGggdGhhbiBvdXIgb3RoZXIgdHlwZWRcbiAgLy8gQ29udGV4dHMsIHNvIHdlIHJlLW5vcm1hbGl6ZSB3aXRoIGEgZml4ZWQgZGVwdGggb2YgMyBoZXJlLiBXZSBkbyBub3Qgd2FudFxuICAvLyB0byBza2lwIHRoaXMgaW4gY2FzZSBvZiBjb25mbGljdGluZywgdXNlci1wcm92aWRlZCBjb250ZXh0LlxuICBpZiAoZXZlbnQuY29udGV4dHM/LmZsYWdzICYmIG5vcm1hbGl6ZWQuY29udGV4dHMpIHtcbiAgICBub3JtYWxpemVkLmNvbnRleHRzLmZsYWdzID0gbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLmZsYWdzLCAzLCBtYXhCcmVhZHRoKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5mdW5jdGlvbiBnZXRGaW5hbFNjb3BlKHNjb3BlLCBjYXB0dXJlQ29udGV4dCkge1xuICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgY29uc3QgZmluYWxTY29wZSA9IHNjb3BlID8gc2NvcGUuY2xvbmUoKSA6IG5ldyBTY29wZSgpO1xuICBmaW5hbFNjb3BlLnVwZGF0ZShjYXB0dXJlQ29udGV4dCk7XG4gIHJldHVybiBmaW5hbFNjb3BlO1xufVxuXG4vKipcbiAqIFBhcnNlIGVpdGhlciBhbiBgRXZlbnRIaW50YCBkaXJlY3RseSwgb3IgY29udmVydCBhIGBDYXB0dXJlQ29udGV4dGAgdG8gYW4gYEV2ZW50SGludGAuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxsb3cgdG8gdXBkYXRlIG1ldGhvZCBzaWduYXR1cmVzIHRoYXQgdXNlZCB0byBhY2NlcHQgYSBgQ2FwdHVyZUNvbnRleHRgIGJ1dCBzaG91bGQgbm93IGFjY2VwdCBhbiBgRXZlbnRIaW50YC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0KFxuICBoaW50LFxuKSB7XG4gIGlmICghaGludCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJZiB5b3UgcGFzcyBhIFNjb3BlIG9yIGAoKSA9PiBTY29wZWAgYXMgQ2FwdHVyZUNvbnRleHQsIHdlIGp1c3QgcmV0dXJuIHRoaXMgYXMgY2FwdHVyZUNvbnRleHRcbiAgaWYgKGhpbnRJc1Njb3BlT3JGdW5jdGlvbihoaW50KSkge1xuICAgIHJldHVybiB7IGNhcHR1cmVDb250ZXh0OiBoaW50IH07XG4gIH1cblxuICBpZiAoaGludElzU2NvcGVDb250ZXh0KGhpbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHR1cmVDb250ZXh0OiBoaW50LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGludDtcbn1cblxuZnVuY3Rpb24gaGludElzU2NvcGVPckZ1bmN0aW9uKGhpbnQpIHtcbiAgcmV0dXJuIGhpbnQgaW5zdGFuY2VvZiBTY29wZSB8fCB0eXBlb2YgaGludCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY29uc3QgY2FwdHVyZUNvbnRleHRLZXlzID0gW1xuICAndXNlcicsXG4gICdsZXZlbCcsXG4gICdleHRyYScsXG4gICdjb250ZXh0cycsXG4gICd0YWdzJyxcbiAgJ2ZpbmdlcnByaW50JyxcbiAgJ3Byb3BhZ2F0aW9uQ29udGV4dCcsXG5dIDtcblxuZnVuY3Rpb24gaGludElzU2NvcGVDb250ZXh0KGhpbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhpbnQpLnNvbWUoa2V5ID0+IGNhcHR1cmVDb250ZXh0S2V5cy5pbmNsdWRlcyhrZXkgKSk7XG59XG5cbmV4cG9ydCB7IGFwcGx5Q2xpZW50T3B0aW9ucywgYXBwbHlEZWJ1Z0lkcywgYXBwbHlEZWJ1Z01ldGEsIHBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dCwgcHJlcGFyZUV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVwYXJlRXZlbnQuanMubWFwXG4iLCJpbXBvcnQgeyBnZXRDdXJyZW50U2NvcGUsIGdldENsaWVudCwgd2l0aElzb2xhdGlvblNjb3BlLCBnZXRJc29sYXRpb25TY29wZSB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgbWFrZVNlc3Npb24sIHVwZGF0ZVNlc3Npb24sIGNsb3NlU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi91dGlscy1ob2lzdC9pcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2xvZ2dlci5qcyc7XG5pbXBvcnQgeyB1dWlkNCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbWlzYy5qcyc7XG5pbXBvcnQgeyB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuL3V0aWxzLWhvaXN0L3RpbWUuanMnO1xuaW1wb3J0IHsgR0xPQkFMX09CSiB9IGZyb20gJy4vdXRpbHMtaG9pc3Qvd29ybGR3aWRlLmpzJztcbmltcG9ydCB7IHBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dCB9IGZyb20gJy4vdXRpbHMvcHJlcGFyZUV2ZW50LmpzJztcblxuLyoqXG4gKiBDYXB0dXJlcyBhbiBleGNlcHRpb24gZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXhjZXB0aW9uIFRoZSBleGNlcHRpb24gdG8gY2FwdHVyZS5cbiAqIEBwYXJhbSBoaW50IE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIFNlbnRyeSBldmVudC5cbiAqIEByZXR1cm5zIHRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgU2VudHJ5IGV2ZW50LlxuICovXG5mdW5jdGlvbiBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICByZXR1cm4gZ2V0Q3VycmVudFNjb3BlKCkuY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIHBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dChoaW50KSk7XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgYSBtZXNzYWdlIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byBTZW50cnkuXG4gKiBAcGFyYW0gY2FwdHVyZUNvbnRleHQgRGVmaW5lIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZSBvciBwYXNzIGluIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGNhcHR1cmVDb250ZXh0KSB7XG4gIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgZXhwbGljaXQgc2NvcGVzIHVwZ3JhZGUsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG9yaWdpbmFsXG4gIC8vIGFyaXR5IG9mIHRoZSBgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwpYCBtZXRob2QuXG4gIGNvbnN0IGxldmVsID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ID09PSAnc3RyaW5nJyA/IGNhcHR1cmVDb250ZXh0IDogdW5kZWZpbmVkO1xuICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ICE9PSAnc3RyaW5nJyA/IHsgY2FwdHVyZUNvbnRleHQgfSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGdldEN1cnJlbnRTY29wZSgpLmNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGxldmVsLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlcyBhIG1hbnVhbGx5IGNyZWF0ZWQgZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gU2VudHJ5LlxuICogQHBhcmFtIGhpbnQgT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LlxuICogQHJldHVybnMgdGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBldmVudC5cbiAqL1xuZnVuY3Rpb24gY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KSB7XG4gIHJldHVybiBnZXRDdXJyZW50U2NvcGUoKS5jYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQpO1xufVxuXG4vKipcbiAqIFNldHMgY29udGV4dCBkYXRhIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKiBAcGFyYW0gbmFtZSBvZiB0aGUgY29udGV4dFxuICogQHBhcmFtIGNvbnRleHQgQW55IGtpbmQgb2YgZGF0YS4gVGhpcyBkYXRhIHdpbGwgYmUgbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIGV4dHJhcyBFeHRyYXMgb2JqZWN0IHRvIG1lcmdlIGludG8gY3VycmVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBzZXRFeHRyYXMoZXh0cmFzKSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0RXh0cmFzKGV4dHJhcyk7XG59XG5cbi8qKlxuICogU2V0IGtleTp2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBhcyBleHRyYSBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIGtleSBTdHJpbmcgb2YgZXh0cmFcbiAqIEBwYXJhbSBleHRyYSBBbnkga2luZCBvZiBkYXRhLiBUaGlzIGRhdGEgd2lsbCBiZSBub3JtYWxpemVkLlxuICovXG5mdW5jdGlvbiBzZXRFeHRyYShrZXksIGV4dHJhKSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0RXh0cmEoa2V5LCBleHRyYSk7XG59XG5cbi8qKlxuICogU2V0IGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgbWVyZ2VkIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIHRhZ3MgVGFncyBjb250ZXh0IG9iamVjdCB0byBtZXJnZSBpbnRvIGN1cnJlbnQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gc2V0VGFncyh0YWdzKSB7XG4gIGdldElzb2xhdGlvblNjb3BlKCkuc2V0VGFncyh0YWdzKTtcbn1cblxuLyoqXG4gKiBTZXQga2V5OnZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGFzIHRhZ3MgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHVuc2V0IGEgdGFnLCBieSBwYXNzaW5nIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBrZXkgU3RyaW5nIGtleSBvZiB0YWdcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiB0YWdcbiAqL1xuZnVuY3Rpb24gc2V0VGFnKGtleSwgdmFsdWUpIHtcbiAgZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRUYWcoa2V5LCB2YWx1ZSk7XG59XG5cbi8qKlxuICogVXBkYXRlcyB1c2VyIGNvbnRleHQgaW5mb3JtYXRpb24gZm9yIGZ1dHVyZSBldmVudHMuXG4gKlxuICogQHBhcmFtIHVzZXIgVXNlciBjb250ZXh0IG9iamVjdCB0byBiZSBzZXQgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gUGFzcyBgbnVsbGAgdG8gdW5zZXQgdGhlIHVzZXIuXG4gKi9cbmZ1bmN0aW9uIHNldFVzZXIodXNlcikge1xuICBnZXRJc29sYXRpb25TY29wZSgpLnNldFVzZXIodXNlcik7XG59XG5cbi8qKlxuICogVGhlIGxhc3QgZXJyb3IgZXZlbnQgaWQgb2YgdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIHJlYWxseSByZXR1cm5zIHRoZSBsYXN0IHJlY29yZGVkIGVycm9yIGV2ZW50IGlkIG9uIHRoZSBjdXJyZW50XG4gKiBpc29sYXRpb24gc2NvcGUuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgaGFuZGxpbmcgYSBjZXJ0YWluIGVycm9yIGFuZCBhbm90aGVyIGVycm9yXG4gKiBpcyBjYXB0dXJlZCBpbiBiZXR3ZWVuLCB0aGUgbGFzdCBvbmUgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aGUgb25lIHlvdSBtaWdodCBleHBlY3QuXG4gKiBBbHNvLCBpZHMgb2YgZXZlbnRzIHRoYXQgd2VyZSBuZXZlciBzZW50IHRvIFNlbnRyeSAoZm9yIGV4YW1wbGUgYmVjYXVzZVxuICogdGhleSB3ZXJlIGRyb3BwZWQgaW4gYGJlZm9yZVNlbmRgKSBjb3VsZCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbGFzdCBldmVudCBpZCBvZiB0aGUgaXNvbGF0aW9uIHNjb3BlLlxuICovXG5mdW5jdGlvbiBsYXN0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGdldElzb2xhdGlvblNjb3BlKCkubGFzdEV2ZW50SWQoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjcm9uIG1vbml0b3IgY2hlY2sgaW4gYW5kIHNlbmQgaXQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBjaGVja0luIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGNoZWNrIGluLlxuICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVDaGVja0luKGNoZWNrSW4sIHVwc2VydE1vbml0b3JDb25maWcpIHtcbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGlmICghY2xpZW50KSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBjYXB0dXJlIGNoZWNrLWluLiBObyBjbGllbnQgZGVmaW5lZC4nKTtcbiAgfSBlbHNlIGlmICghY2xpZW50LmNhcHR1cmVDaGVja0luKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBjYXB0dXJlIGNoZWNrLWluLiBDbGllbnQgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIGNoZWNrLWlucy4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2xpZW50LmNhcHR1cmVDaGVja0luKGNoZWNrSW4sIHVwc2VydE1vbml0b3JDb25maWcsIHNjb3BlKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkNCgpO1xufVxuXG4vKipcbiAqIFdyYXBzIGEgY2FsbGJhY2sgd2l0aCBhIGNyb24gbW9uaXRvciBjaGVjayBpbi4gVGhlIGNoZWNrIGluIHdpbGwgYmUgc2VudCB0byBTZW50cnkgd2hlbiB0aGUgY2FsbGJhY2sgZmluaXNoZXMuXG4gKlxuICogQHBhcmFtIG1vbml0b3JTbHVnIFRoZSBkaXN0aW5jdCBzbHVnIG9mIHRoZSBtb25pdG9yLlxuICogQHBhcmFtIHVwc2VydE1vbml0b3JDb25maWcgQW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbW9uaXRvciBjb25maWcuIFVzZSB0aGlzIGlmIHlvdSB3YW50XG4gKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gKi9cbmZ1bmN0aW9uIHdpdGhNb25pdG9yKFxuICBtb25pdG9yU2x1ZyxcbiAgY2FsbGJhY2ssXG4gIHVwc2VydE1vbml0b3JDb25maWcsXG4pIHtcbiAgY29uc3QgY2hlY2tJbklkID0gY2FwdHVyZUNoZWNrSW4oeyBtb25pdG9yU2x1Zywgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIH0sIHVwc2VydE1vbml0b3JDb25maWcpO1xuICBjb25zdCBub3cgPSB0aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICBmdW5jdGlvbiBmaW5pc2hDaGVja0luKHN0YXR1cykge1xuICAgIGNhcHR1cmVDaGVja0luKHsgbW9uaXRvclNsdWcsIHN0YXR1cywgY2hlY2tJbklkLCBkdXJhdGlvbjogdGltZXN0YW1wSW5TZWNvbmRzKCkgLSBub3cgfSk7XG4gIH1cblxuICByZXR1cm4gd2l0aElzb2xhdGlvblNjb3BlKCgpID0+IHtcbiAgICBsZXQgbWF5YmVQcm9taXNlUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBtYXliZVByb21pc2VSZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZpbmlzaENoZWNrSW4oJ2Vycm9yJyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChpc1RoZW5hYmxlKG1heWJlUHJvbWlzZVJlc3VsdCkpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2VSZXN1bHQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBmaW5pc2hDaGVja0luKCdvaycpO1xuICAgICAgICB9LFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICBmaW5pc2hDaGVja0luKCdlcnJvcicpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hDaGVja0luKCdvaycpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVByb21pc2VSZXN1bHQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGwgYGZsdXNoKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gKiB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgc3VjY2Vzc2Z1bGx5IGRyYWlucyBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgaXRcbiAqIGRvZXNuJ3QgKG9yIGlmIHRoZXJlJ3Mgbm8gY2xpZW50IGRlZmluZWQpLlxuICovXG5hc3luYyBmdW5jdGlvbiBmbHVzaCh0aW1lb3V0KSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBpZiAoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5mbHVzaCh0aW1lb3V0KTtcbiAgfVxuICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignQ2Fubm90IGZsdXNoIGV2ZW50cy4gTm8gY2xpZW50IGRlZmluZWQuJyk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xufVxuXG4vKipcbiAqIENhbGwgYGNsb3NlKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5jbG9zZX0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlIGJlZm9yZSBzaHV0dGluZyBkb3duLiBPbWl0dGluZyB0aGlzXG4gKiBwYXJhbWV0ZXIgd2lsbCBjYXVzZSB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgZGlzYWJsaW5nIGl0c2VsZi5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBgdHJ1ZWAgaWYgdGhlIHF1ZXVlIHN1Y2Nlc3NmdWxseSBkcmFpbnMgYmVmb3JlIHRoZSB0aW1lb3V0LCBvciBgZmFsc2VgIGlmIGl0XG4gKiBkb2Vzbid0IChvciBpZiB0aGVyZSdzIG5vIGNsaWVudCBkZWZpbmVkKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2xvc2UodGltZW91dCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgaWYgKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuY2xvc2UodGltZW91dCk7XG4gIH1cbiAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBmbHVzaCBldmVudHMgYW5kIGRpc2FibGUgU0RLLiBObyBjbGllbnQgZGVmaW5lZC4nKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIFNlbnRyeSBoYXMgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gaXNJbml0aWFsaXplZCgpIHtcbiAgcmV0dXJuICEhZ2V0Q2xpZW50KCk7XG59XG5cbi8qKiBJZiB0aGUgU0RLIGlzIGluaXRpYWxpemVkICYgZW5hYmxlZC4gKi9cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIHJldHVybiBjbGllbnQ/LmdldE9wdGlvbnMoKS5lbmFibGVkICE9PSBmYWxzZSAmJiAhIWNsaWVudD8uZ2V0VHJhbnNwb3J0KCk7XG59XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IHByb2Nlc3Nvci5cbiAqIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBpc29sYXRpb24gc2NvcGUsIGVuc3VyaW5nIGFueSBldmVudCB0aGF0IGlzIHByb2Nlc3NlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb25cbiAqIGNvbnRleHQgd2lsbCBoYXZlIHRoZSBwcm9jZXNzb3IgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRQcm9jZXNzb3IoY2FsbGJhY2spIHtcbiAgZ2V0SXNvbGF0aW9uU2NvcGUoKS5hZGRFdmVudFByb2Nlc3NvcihjYWxsYmFjayk7XG59XG5cbi8qKlxuICogU3RhcnQgYSBzZXNzaW9uIG9uIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZS5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCAob3B0aW9uYWwpIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBzZXNzaW9uIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHRoZSBuZXcgYWN0aXZlIHNlc3Npb25cbiAqL1xuZnVuY3Rpb24gc3RhcnRTZXNzaW9uKGNvbnRleHQpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcblxuICAvLyBXaWxsIGZldGNoIHVzZXJBZ2VudCBpZiBjYWxsZWQgZnJvbSBicm93c2VyIHNka1xuICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gR0xPQkFMX09CSi5uYXZpZ2F0b3IgfHwge307XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IG1ha2VTZXNzaW9uKHtcbiAgICB1c2VyOiBjdXJyZW50U2NvcGUuZ2V0VXNlcigpIHx8IGlzb2xhdGlvblNjb3BlLmdldFVzZXIoKSxcbiAgICAuLi4odXNlckFnZW50ICYmIHsgdXNlckFnZW50IH0pLFxuICAgIC4uLmNvbnRleHQsXG4gIH0pO1xuXG4gIC8vIEVuZCBleGlzdGluZyBzZXNzaW9uIGlmIHRoZXJlJ3Mgb25lXG4gIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gaXNvbGF0aW9uU2NvcGUuZ2V0U2Vzc2lvbigpO1xuICBpZiAoY3VycmVudFNlc3Npb24/LnN0YXR1cyA9PT0gJ29rJykge1xuICAgIHVwZGF0ZVNlc3Npb24oY3VycmVudFNlc3Npb24sIHsgc3RhdHVzOiAnZXhpdGVkJyB9KTtcbiAgfVxuXG4gIGVuZFNlc3Npb24oKTtcblxuICAvLyBBZnRlcndhcmRzIHdlIHNldCB0aGUgbmV3IHNlc3Npb24gb24gdGhlIHNjb3BlXG4gIGlzb2xhdGlvblNjb3BlLnNldFNlc3Npb24oc2Vzc2lvbik7XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogRW5kIHRoZSBzZXNzaW9uIG9uIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZW5kU2Vzc2lvbigpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcblxuICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gIGlmIChzZXNzaW9uKSB7XG4gICAgY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xuICB9XG4gIF9zZW5kU2Vzc2lvblVwZGF0ZSgpO1xuXG4gIC8vIHRoZSBzZXNzaW9uIGlzIG92ZXI7IHRha2UgaXQgb2ZmIG9mIHRoZSBzY29wZVxuICBpc29sYXRpb25TY29wZS5zZXRTZXNzaW9uKCk7XG59XG5cbi8qKlxuICogU2VuZHMgdGhlIGN1cnJlbnQgU2Vzc2lvbiBvbiB0aGUgc2NvcGVcbiAqL1xuZnVuY3Rpb24gX3NlbmRTZXNzaW9uVXBkYXRlKCkge1xuICBjb25zdCBpc29sYXRpb25TY29wZSA9IGdldElzb2xhdGlvblNjb3BlKCk7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBjb25zdCBzZXNzaW9uID0gaXNvbGF0aW9uU2NvcGUuZ2V0U2Vzc2lvbigpO1xuICBpZiAoc2Vzc2lvbiAmJiBjbGllbnQpIHtcbiAgICBjbGllbnQuY2FwdHVyZVNlc3Npb24oc2Vzc2lvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kcyB0aGUgY3VycmVudCBzZXNzaW9uIG9uIHRoZSBzY29wZSB0byBTZW50cnlcbiAqXG4gKiBAcGFyYW0gZW5kIElmIHNldCB0aGUgc2Vzc2lvbiB3aWxsIGJlIG1hcmtlZCBhcyBleGl0ZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgc2NvcGUuXG4gKiAgICAgICAgICAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVTZXNzaW9uKGVuZCA9IGZhbHNlKSB7XG4gIC8vIGJvdGggc2VuZCB0aGUgdXBkYXRlIGFuZCBwdWxsIHRoZSBzZXNzaW9uIGZyb20gdGhlIHNjb3BlXG4gIGlmIChlbmQpIHtcbiAgICBlbmRTZXNzaW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gb25seSBzZW5kIHRoZSB1cGRhdGVcbiAgX3NlbmRTZXNzaW9uVXBkYXRlKCk7XG59XG5cbmV4cG9ydCB7IGFkZEV2ZW50UHJvY2Vzc29yLCBjYXB0dXJlQ2hlY2tJbiwgY2FwdHVyZUV2ZW50LCBjYXB0dXJlRXhjZXB0aW9uLCBjYXB0dXJlTWVzc2FnZSwgY2FwdHVyZVNlc3Npb24sIGNsb3NlLCBlbmRTZXNzaW9uLCBmbHVzaCwgaXNFbmFibGVkLCBpc0luaXRpYWxpemVkLCBsYXN0RXZlbnRJZCwgc2V0Q29udGV4dCwgc2V0RXh0cmEsIHNldEV4dHJhcywgc2V0VGFnLCBzZXRUYWdzLCBzZXRVc2VyLCBzdGFydFNlc3Npb24sIHdpdGhNb25pdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBvcnRzLmpzLm1hcFxuIiwiaW1wb3J0IHsgbWFrZURzbiwgZHNuVG9TdHJpbmcgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2Rzbi5qcyc7XG5cbmNvbnN0IFNFTlRSWV9BUElfVkVSU0lPTiA9ICc3JztcblxuLyoqIFJldHVybnMgdGhlIHByZWZpeCB0byBjb25zdHJ1Y3QgU2VudHJ5IGluZ2VzdGlvbiBBUEkgZW5kcG9pbnRzLiAqL1xuZnVuY3Rpb24gZ2V0QmFzZUFwaUVuZHBvaW50KGRzbikge1xuICBjb25zdCBwcm90b2NvbCA9IGRzbi5wcm90b2NvbCA/IGAke2Rzbi5wcm90b2NvbH06YCA6ICcnO1xuICBjb25zdCBwb3J0ID0gZHNuLnBvcnQgPyBgOiR7ZHNuLnBvcnR9YCA6ICcnO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2Rzbi5ob3N0fSR7cG9ydH0ke2Rzbi5wYXRoID8gYC8ke2Rzbi5wYXRofWAgOiAnJ30vYXBpL2A7XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBpbmdlc3QgQVBJIGVuZHBvaW50IGZvciB0YXJnZXQuICovXG5mdW5jdGlvbiBfZ2V0SW5nZXN0RW5kcG9pbnQoZHNuKSB7XG4gIHJldHVybiBgJHtnZXRCYXNlQXBpRW5kcG9pbnQoZHNuKX0ke2Rzbi5wcm9qZWN0SWR9L2VudmVsb3BlL2A7XG59XG5cbi8qKiBSZXR1cm5zIGEgVVJMLWVuY29kZWQgc3RyaW5nIHdpdGggYXV0aCBjb25maWcgc3VpdGFibGUgZm9yIGEgcXVlcnkgc3RyaW5nLiAqL1xuZnVuY3Rpb24gX2VuY29kZWRBdXRoKGRzbiwgc2RrSW5mbykge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgc2VudHJ5X3ZlcnNpb246IFNFTlRSWV9BUElfVkVSU0lPTixcbiAgfTtcblxuICBpZiAoZHNuLnB1YmxpY0tleSkge1xuICAgIC8vIFdlIHNlbmQgb25seSB0aGUgbWluaW11bSBzZXQgb2YgcmVxdWlyZWQgaW5mb3JtYXRpb24uIFNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzI1NzIuXG4gICAgcGFyYW1zLnNlbnRyeV9rZXkgPSBkc24ucHVibGljS2V5O1xuICB9XG5cbiAgaWYgKHNka0luZm8pIHtcbiAgICBwYXJhbXMuc2VudHJ5X2NsaWVudCA9IGAke3Nka0luZm8ubmFtZX0vJHtzZGtJbmZvLnZlcnNpb259YDtcbiAgfVxuXG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbnZlbG9wZSBlbmRwb2ludCBVUkwgd2l0aCBhdXRoIGluIHRoZSBxdWVyeSBzdHJpbmcuXG4gKlxuICogU2VuZGluZyBhdXRoIGFzIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZyBhbmQgbm90IGFzIGN1c3RvbSBIVFRQIGhlYWRlcnMgYXZvaWRzIENPUlMgcHJlZmxpZ2h0IHJlcXVlc3RzLlxuICovXG5mdW5jdGlvbiBnZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoKGRzbiwgdHVubmVsLCBzZGtJbmZvKSB7XG4gIHJldHVybiB0dW5uZWwgPyB0dW5uZWwgOiBgJHtfZ2V0SW5nZXN0RW5kcG9pbnQoZHNuKX0/JHtfZW5jb2RlZEF1dGgoZHNuLCBzZGtJbmZvKX1gO1xufVxuXG4vKiogUmV0dXJucyB0aGUgdXJsIHRvIHRoZSByZXBvcnQgZGlhbG9nIGVuZHBvaW50LiAqL1xuZnVuY3Rpb24gZ2V0UmVwb3J0RGlhbG9nRW5kcG9pbnQoZHNuTGlrZSwgZGlhbG9nT3B0aW9ucykge1xuICBjb25zdCBkc24gPSBtYWtlRHNuKGRzbkxpa2UpO1xuICBpZiAoIWRzbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IGVuZHBvaW50ID0gYCR7Z2V0QmFzZUFwaUVuZHBvaW50KGRzbil9ZW1iZWQvZXJyb3ItcGFnZS9gO1xuXG4gIGxldCBlbmNvZGVkT3B0aW9ucyA9IGBkc249JHtkc25Ub1N0cmluZyhkc24pfWA7XG4gIGZvciAoY29uc3Qga2V5IGluIGRpYWxvZ09wdGlvbnMpIHtcbiAgICBpZiAoa2V5ID09PSAnZHNuJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ29uQ2xvc2UnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndXNlcicpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBkaWFsb2dPcHRpb25zLnVzZXI7XG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodXNlci5uYW1lKSB7XG4gICAgICAgIGVuY29kZWRPcHRpb25zICs9IGAmbmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudCh1c2VyLm5hbWUpfWA7XG4gICAgICB9XG4gICAgICBpZiAodXNlci5lbWFpbCkge1xuICAgICAgICBlbmNvZGVkT3B0aW9ucyArPSBgJmVtYWlsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVzZXIuZW1haWwpfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kZWRPcHRpb25zICs9IGAmJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQoZGlhbG9nT3B0aW9uc1trZXldICl9YDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYCR7ZW5kcG9pbnR9PyR7ZW5jb2RlZE9wdGlvbnN9YDtcbn1cblxuZXhwb3J0IHsgZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aCwgZ2V0UmVwb3J0RGlhbG9nRW5kcG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXBcbiIsImltcG9ydCB7IGdldENsaWVudCB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi91dGlscy1ob2lzdC9sb2dnZXIuanMnO1xuXG5jb25zdCBpbnN0YWxsZWRJbnRlZ3JhdGlvbnMgPSBbXTtcblxuLyoqIE1hcCBvZiBpbnRlZ3JhdGlvbnMgYXNzaWduZWQgdG8gYSBjbGllbnQgKi9cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBnaXZlbiBhcnJheSwgcHJlZmVycmluZyB0aGUgbGFzdCBpbnN0YW5jZSBvZiBhbnkgZHVwbGljYXRlLiBOb3QgZ3VhcmFudGVlZCB0b1xuICogcHJlc2VydmUgdGhlIG9yZGVyIG9mIGludGVncmF0aW9ucyBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmlsdGVyRHVwbGljYXRlcyhpbnRlZ3JhdGlvbnMpIHtcbiAgY29uc3QgaW50ZWdyYXRpb25zQnlOYW1lID0ge307XG5cbiAgaW50ZWdyYXRpb25zLmZvckVhY2goKGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gY3VycmVudEluc3RhbmNlO1xuXG4gICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IGludGVncmF0aW9uc0J5TmFtZVtuYW1lXTtcblxuICAgIC8vIFdlIHdhbnQgaW50ZWdyYXRpb25zIGxhdGVyIGluIHRoZSBhcnJheSB0byBvdmVyd3JpdGUgZWFybGllciBvbmVzIG9mIHRoZSBzYW1lIHR5cGUsIGV4Y2VwdCB0aGF0IHdlIG5ldmVyIHdhbnQgYVxuICAgIC8vIGRlZmF1bHQgaW5zdGFuY2UgdG8gb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHVzZXIgaW5zdGFuY2VcbiAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSAmJiAhZXhpc3RpbmdJbnN0YW5jZS5pc0RlZmF1bHRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2UuaXNEZWZhdWx0SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlZ3JhdGlvbnNCeU5hbWVbbmFtZV0gPSBjdXJyZW50SW5zdGFuY2U7XG4gIH0pO1xuXG4gIHJldHVybiBPYmplY3QudmFsdWVzKGludGVncmF0aW9uc0J5TmFtZSk7XG59XG5cbi8qKiBHZXRzIGludGVncmF0aW9ucyB0byBpbnN0YWxsICovXG5mdW5jdGlvbiBnZXRJbnRlZ3JhdGlvbnNUb1NldHVwKG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdEludGVncmF0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdEludGVncmF0aW9ucyB8fCBbXTtcbiAgY29uc3QgdXNlckludGVncmF0aW9ucyA9IG9wdGlvbnMuaW50ZWdyYXRpb25zO1xuXG4gIC8vIFdlIGZsYWcgZGVmYXVsdCBpbnN0YW5jZXMsIHNvIHRoYXQgbGF0ZXIgd2UgY2FuIHRlbGwgdGhlbSBhcGFydCBmcm9tIGFueSB1c2VyLWNyZWF0ZWQgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIGNsYXNzXG4gIGRlZmF1bHRJbnRlZ3JhdGlvbnMuZm9yRWFjaCgoaW50ZWdyYXRpb24pID0+IHtcbiAgICBpbnRlZ3JhdGlvbi5pc0RlZmF1bHRJbnN0YW5jZSA9IHRydWU7XG4gIH0pO1xuXG4gIGxldCBpbnRlZ3JhdGlvbnM7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodXNlckludGVncmF0aW9ucykpIHtcbiAgICBpbnRlZ3JhdGlvbnMgPSBbLi4uZGVmYXVsdEludGVncmF0aW9ucywgLi4udXNlckludGVncmF0aW9uc107XG4gIH0gZWxzZSBpZiAodHlwZW9mIHVzZXJJbnRlZ3JhdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByZXNvbHZlZFVzZXJJbnRlZ3JhdGlvbnMgPSB1c2VySW50ZWdyYXRpb25zKGRlZmF1bHRJbnRlZ3JhdGlvbnMpO1xuICAgIGludGVncmF0aW9ucyA9IEFycmF5LmlzQXJyYXkocmVzb2x2ZWRVc2VySW50ZWdyYXRpb25zKSA/IHJlc29sdmVkVXNlckludGVncmF0aW9ucyA6IFtyZXNvbHZlZFVzZXJJbnRlZ3JhdGlvbnNdO1xuICB9IGVsc2Uge1xuICAgIGludGVncmF0aW9ucyA9IGRlZmF1bHRJbnRlZ3JhdGlvbnM7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyRHVwbGljYXRlcyhpbnRlZ3JhdGlvbnMpO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBpbnRlZ3JhdGlvbiBpbnN0YW5jZXMgdGhpcyBpbnN0YWxscyB0aGVtIGFsbC4gV2hlbiBgd2l0aERlZmF1bHRzYCBpcyBzZXQgdG8gYHRydWVgIHRoZW4gYWxsIGRlZmF1bHRcbiAqIGludGVncmF0aW9ucyBhcmUgYWRkZWQgdW5sZXNzIHRoZXkgd2VyZSBhbHJlYWR5IHByb3ZpZGVkIGJlZm9yZS5cbiAqIEBwYXJhbSBpbnRlZ3JhdGlvbnMgYXJyYXkgb2YgaW50ZWdyYXRpb24gaW5zdGFuY2VzXG4gKiBAcGFyYW0gd2l0aERlZmF1bHQgc2hvdWxkIGVuYWJsZSBkZWZhdWx0IGludGVncmF0aW9uc1xuICovXG5mdW5jdGlvbiBzZXR1cEludGVncmF0aW9ucyhjbGllbnQsIGludGVncmF0aW9ucykge1xuICBjb25zdCBpbnRlZ3JhdGlvbkluZGV4ID0ge307XG5cbiAgaW50ZWdyYXRpb25zLmZvckVhY2goKGludGVncmF0aW9uKSA9PiB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBlbXB0eSBwcm92aWRlZCBpbnRlZ3JhdGlvbnNcbiAgICBpZiAoaW50ZWdyYXRpb24pIHtcbiAgICAgIHNldHVwSW50ZWdyYXRpb24oY2xpZW50LCBpbnRlZ3JhdGlvbiwgaW50ZWdyYXRpb25JbmRleCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaW50ZWdyYXRpb25JbmRleDtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBgYWZ0ZXJBbGxTZXR1cGAgaG9va3Mgb2YgdGhlIGdpdmVuIGludGVncmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYWZ0ZXJTZXR1cEludGVncmF0aW9ucyhjbGllbnQsIGludGVncmF0aW9ucykge1xuICBmb3IgKGNvbnN0IGludGVncmF0aW9uIG9mIGludGVncmF0aW9ucykge1xuICAgIC8vIGd1YXJkIGFnYWluc3QgZW1wdHkgcHJvdmlkZWQgaW50ZWdyYXRpb25zXG4gICAgaWYgKGludGVncmF0aW9uPy5hZnRlckFsbFNldHVwKSB7XG4gICAgICBpbnRlZ3JhdGlvbi5hZnRlckFsbFNldHVwKGNsaWVudCk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBTZXR1cCBhIHNpbmdsZSBpbnRlZ3JhdGlvbi4gICovXG5mdW5jdGlvbiBzZXR1cEludGVncmF0aW9uKGNsaWVudCwgaW50ZWdyYXRpb24sIGludGVncmF0aW9uSW5kZXgpIHtcbiAgaWYgKGludGVncmF0aW9uSW5kZXhbaW50ZWdyYXRpb24ubmFtZV0pIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nKGBJbnRlZ3JhdGlvbiBza2lwcGVkIGJlY2F1c2UgaXQgd2FzIGFscmVhZHkgaW5zdGFsbGVkOiAke2ludGVncmF0aW9uLm5hbWV9YCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGludGVncmF0aW9uSW5kZXhbaW50ZWdyYXRpb24ubmFtZV0gPSBpbnRlZ3JhdGlvbjtcblxuICAvLyBgc2V0dXBPbmNlYCBpcyBvbmx5IGNhbGxlZCB0aGUgZmlyc3QgdGltZVxuICBpZiAoaW5zdGFsbGVkSW50ZWdyYXRpb25zLmluZGV4T2YoaW50ZWdyYXRpb24ubmFtZSkgPT09IC0xICYmIHR5cGVvZiBpbnRlZ3JhdGlvbi5zZXR1cE9uY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnRlZ3JhdGlvbi5zZXR1cE9uY2UoKTtcbiAgICBpbnN0YWxsZWRJbnRlZ3JhdGlvbnMucHVzaChpbnRlZ3JhdGlvbi5uYW1lKTtcbiAgfVxuXG4gIC8vIGBzZXR1cGAgaXMgcnVuIGZvciBlYWNoIGNsaWVudFxuICBpZiAoaW50ZWdyYXRpb24uc2V0dXAgJiYgdHlwZW9mIGludGVncmF0aW9uLnNldHVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW50ZWdyYXRpb24uc2V0dXAoY2xpZW50KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW50ZWdyYXRpb24ucHJlcHJvY2Vzc0V2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBpbnRlZ3JhdGlvbi5wcmVwcm9jZXNzRXZlbnQuYmluZChpbnRlZ3JhdGlvbikgO1xuICAgIGNsaWVudC5vbigncHJlcHJvY2Vzc0V2ZW50JywgKGV2ZW50LCBoaW50KSA9PiBjYWxsYmFjayhldmVudCwgaGludCwgY2xpZW50KSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGludGVncmF0aW9uLnByb2Nlc3NFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gaW50ZWdyYXRpb24ucHJvY2Vzc0V2ZW50LmJpbmQoaW50ZWdyYXRpb24pIDtcblxuICAgIGNvbnN0IHByb2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oKGV2ZW50LCBoaW50KSA9PiBjYWxsYmFjayhldmVudCwgaGludCwgY2xpZW50KSwge1xuICAgICAgaWQ6IGludGVncmF0aW9uLm5hbWUsXG4gICAgfSk7XG5cbiAgICBjbGllbnQuYWRkRXZlbnRQcm9jZXNzb3IocHJvY2Vzc29yKTtcbiAgfVxuXG4gIERFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2coYEludGVncmF0aW9uIGluc3RhbGxlZDogJHtpbnRlZ3JhdGlvbi5uYW1lfWApO1xufVxuXG4vKiogQWRkIGFuIGludGVncmF0aW9uIHRvIHRoZSBjdXJyZW50IHNjb3BlJ3MgY2xpZW50LiAqL1xuZnVuY3Rpb24gYWRkSW50ZWdyYXRpb24oaW50ZWdyYXRpb24pIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG5cbiAgaWYgKCFjbGllbnQpIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybihgQ2Fubm90IGFkZCBpbnRlZ3JhdGlvbiBcIiR7aW50ZWdyYXRpb24ubmFtZX1cIiBiZWNhdXNlIG5vIFNESyBDbGllbnQgaXMgYXZhaWxhYmxlLmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNsaWVudC5hZGRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbik7XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGludGVncmF0aW9uIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGludGVncmF0aW9uIGluc3RhbmNlLlxuICogTm90ZSB0aGF0IHRoaXMgYnkgZGVzaWduIGhpZGVzIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9mIHRoZSBpbnRlZ3JhdGlvbiwgYXMgdGhleSBhcmUgY29uc2lkZXJlZCBpbnRlcm5hbC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lSW50ZWdyYXRpb24oZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBhZGRJbnRlZ3JhdGlvbiwgYWZ0ZXJTZXR1cEludGVncmF0aW9ucywgZGVmaW5lSW50ZWdyYXRpb24sIGdldEludGVncmF0aW9uc1RvU2V0dXAsIGluc3RhbGxlZEludGVncmF0aW9ucywgc2V0dXBJbnRlZ3JhdGlvbiwgc2V0dXBJbnRlZ3JhdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVncmF0aW9uLmpzLm1hcFxuIiwiaW1wb3J0IHsgY3JlYXRlRW52ZWxvcGUgfSBmcm9tICcuL2VudmVsb3BlLmpzJztcbmltcG9ydCB7IGRhdGVUaW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuL3RpbWUuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgY2xpZW50IHJlcG9ydCBlbnZlbG9wZVxuICogQHBhcmFtIGRpc2NhcmRlZF9ldmVudHMgQW4gYXJyYXkgb2YgZGlzY2FyZCBldmVudHNcbiAqIEBwYXJhbSBkc24gQSBEU04gdGhhdCBjYW4gYmUgc2V0IG9uIHRoZSBoZWFkZXIuIE9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSZXBvcnRFbnZlbG9wZShcbiAgZGlzY2FyZGVkX2V2ZW50cyxcbiAgZHNuLFxuICB0aW1lc3RhbXAsXG4pIHtcbiAgY29uc3QgY2xpZW50UmVwb3J0SXRlbSA9IFtcbiAgICB7IHR5cGU6ICdjbGllbnRfcmVwb3J0JyB9LFxuICAgIHtcbiAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wIHx8IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgICAgIGRpc2NhcmRlZF9ldmVudHMsXG4gICAgfSxcbiAgXTtcbiAgcmV0dXJuIGNyZWF0ZUVudmVsb3BlKGRzbiA/IHsgZHNuIH0gOiB7fSwgW2NsaWVudFJlcG9ydEl0ZW1dKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2xpZW50UmVwb3J0RW52ZWxvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudHJlcG9ydC5qcy5tYXBcbiIsIi8qKlxuICogR2V0IGEgbGlzdCBvZiBwb3NzaWJsZSBldmVudCBtZXNzYWdlcyBmcm9tIGEgU2VudHJ5IGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRQb3NzaWJsZUV2ZW50TWVzc2FnZXMoZXZlbnQpIHtcbiAgY29uc3QgcG9zc2libGVNZXNzYWdlcyA9IFtdO1xuXG4gIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgcG9zc2libGVNZXNzYWdlcy5wdXNoKGV2ZW50Lm1lc3NhZ2UpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRyeSBjYXRjaGluZyB0byBzYXZlIGJ1bmRsZSBzaXplXG4gICAgY29uc3QgbGFzdEV4Y2VwdGlvbiA9IGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbZXZlbnQuZXhjZXB0aW9uLnZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdEV4Y2VwdGlvbj8udmFsdWUpIHtcbiAgICAgIHBvc3NpYmxlTWVzc2FnZXMucHVzaChsYXN0RXhjZXB0aW9uLnZhbHVlKTtcbiAgICAgIGlmIChsYXN0RXhjZXB0aW9uLnR5cGUpIHtcbiAgICAgICAgcG9zc2libGVNZXNzYWdlcy5wdXNoKGAke2xhc3RFeGNlcHRpb24udHlwZX06ICR7bGFzdEV4Y2VwdGlvbi52YWx1ZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGhlcmVcbiAgfVxuXG4gIHJldHVybiBwb3NzaWJsZU1lc3NhZ2VzO1xufVxuXG5leHBvcnQgeyBnZXRQb3NzaWJsZUV2ZW50TWVzc2FnZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50VXRpbHMuanMubWFwXG4iLCJpbXBvcnQgeyBTRU1BTlRJQ19BVFRSSUJVVEVfRVhDTFVTSVZFX1RJTUUsIFNFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEIH0gZnJvbSAnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHRyYW5zYWN0aW9uIGV2ZW50IHRvIGEgc3BhbiBKU09OIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRyYW5zYWN0aW9uRXZlbnRUb1NwYW5Kc29uKGV2ZW50KSB7XG4gIGNvbnN0IHsgdHJhY2VfaWQsIHBhcmVudF9zcGFuX2lkLCBzcGFuX2lkLCBzdGF0dXMsIG9yaWdpbiwgZGF0YSwgb3AgfSA9IGV2ZW50LmNvbnRleHRzPy50cmFjZSA/PyB7fTtcblxuICByZXR1cm4ge1xuICAgIGRhdGE6IGRhdGEgPz8ge30sXG4gICAgZGVzY3JpcHRpb246IGV2ZW50LnRyYW5zYWN0aW9uLFxuICAgIG9wLFxuICAgIHBhcmVudF9zcGFuX2lkLFxuICAgIHNwYW5faWQ6IHNwYW5faWQgPz8gJycsXG4gICAgc3RhcnRfdGltZXN0YW1wOiBldmVudC5zdGFydF90aW1lc3RhbXAgPz8gMCxcbiAgICBzdGF0dXMsXG4gICAgdGltZXN0YW1wOiBldmVudC50aW1lc3RhbXAsXG4gICAgdHJhY2VfaWQ6IHRyYWNlX2lkID8/ICcnLFxuICAgIG9yaWdpbixcbiAgICBwcm9maWxlX2lkOiBkYXRhPy5bU0VNQU5USUNfQVRUUklCVVRFX1BST0ZJTEVfSURdICxcbiAgICBleGNsdXNpdmVfdGltZTogZGF0YT8uW1NFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRV0gLFxuICAgIG1lYXN1cmVtZW50czogZXZlbnQubWVhc3VyZW1lbnRzLFxuICAgIGlzX3NlZ21lbnQ6IHRydWUsXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzcGFuIEpTT04gb2JqZWN0IHRvIGEgdHJhbnNhY3Rpb24gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTcGFuSnNvblRvVHJhbnNhY3Rpb25FdmVudChzcGFuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3RyYW5zYWN0aW9uJyxcbiAgICB0aW1lc3RhbXA6IHNwYW4udGltZXN0YW1wLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogc3Bhbi5zdGFydF90aW1lc3RhbXAsXG4gICAgdHJhbnNhY3Rpb246IHNwYW4uZGVzY3JpcHRpb24sXG4gICAgY29udGV4dHM6IHtcbiAgICAgIHRyYWNlOiB7XG4gICAgICAgIHRyYWNlX2lkOiBzcGFuLnRyYWNlX2lkLFxuICAgICAgICBzcGFuX2lkOiBzcGFuLnNwYW5faWQsXG4gICAgICAgIHBhcmVudF9zcGFuX2lkOiBzcGFuLnBhcmVudF9zcGFuX2lkLFxuICAgICAgICBvcDogc3Bhbi5vcCxcbiAgICAgICAgc3RhdHVzOiBzcGFuLnN0YXR1cyxcbiAgICAgICAgb3JpZ2luOiBzcGFuLm9yaWdpbixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLnNwYW4uZGF0YSxcbiAgICAgICAgICAuLi4oc3Bhbi5wcm9maWxlX2lkICYmIHsgW1NFTUFOVElDX0FUVFJJQlVURV9QUk9GSUxFX0lEXTogc3Bhbi5wcm9maWxlX2lkIH0pLFxuICAgICAgICAgIC4uLihzcGFuLmV4Y2x1c2l2ZV90aW1lICYmIHsgW1NFTUFOVElDX0FUVFJJQlVURV9FWENMVVNJVkVfVElNRV06IHNwYW4uZXhjbHVzaXZlX3RpbWUgfSksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgbWVhc3VyZW1lbnRzOiBzcGFuLm1lYXN1cmVtZW50cyxcbiAgfTtcbn1cblxuZXhwb3J0IHsgY29udmVydFNwYW5Kc29uVG9UcmFuc2FjdGlvbkV2ZW50LCBjb252ZXJ0VHJhbnNhY3Rpb25FdmVudFRvU3Bhbkpzb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uRXZlbnQuanMubWFwXG4iLCJpbXBvcnQgeyBnZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoIH0gZnJvbSAnLi9hcGkuanMnO1xuaW1wb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldFRyYWNlQ29udGV4dEZyb21TY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBnZXRJc29sYXRpb25TY29wZSB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgY3JlYXRlRXZlbnRFbnZlbG9wZSwgY3JlYXRlU2Vzc2lvbkVudmVsb3BlIH0gZnJvbSAnLi9lbnZlbG9wZS5qcyc7XG5pbXBvcnQgeyBzZXR1cEludGVncmF0aW9uLCBhZnRlclNldHVwSW50ZWdyYXRpb25zLCBzZXR1cEludGVncmF0aW9ucyB9IGZyb20gJy4vaW50ZWdyYXRpb24uanMnO1xuaW1wb3J0IHsgdXBkYXRlU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlLCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4gfSBmcm9tICcuL3RyYWNpbmcvZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRSZXBvcnRFbnZlbG9wZSB9IGZyb20gJy4vdXRpbHMtaG9pc3QvY2xpZW50cmVwb3J0LmpzJztcbmltcG9ydCB7IG1ha2VEc24sIGRzblRvU3RyaW5nIH0gZnJvbSAnLi91dGlscy1ob2lzdC9kc24uanMnO1xuaW1wb3J0IHsgYWRkSXRlbVRvRW52ZWxvcGUsIGNyZWF0ZUF0dGFjaG1lbnRFbnZlbG9wZUl0ZW0gfSBmcm9tICcuL3V0aWxzLWhvaXN0L2VudmVsb3BlLmpzJztcbmltcG9ydCB7IGlzUHJpbWl0aXZlLCBpc1BhcmFtZXRlcml6ZWRTdHJpbmcsIGlzVGhlbmFibGUsIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL3V0aWxzLWhvaXN0L2lzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHV1aWQ0LCBjaGVja09yU2V0QWxyZWFkeUNhdWdodCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbWlzYy5qcyc7XG5pbXBvcnQgeyByZXNvbHZlZFN5bmNQcm9taXNlLCBTeW5jUHJvbWlzZSwgcmVqZWN0ZWRTeW5jUHJvbWlzZSB9IGZyb20gJy4vdXRpbHMtaG9pc3Qvc3luY3Byb21pc2UuanMnO1xuaW1wb3J0IHsgZ2V0UG9zc2libGVFdmVudE1lc3NhZ2VzIH0gZnJvbSAnLi91dGlscy9ldmVudFV0aWxzLmpzJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnLi91dGlscy9tZXJnZS5qcyc7XG5pbXBvcnQgeyBwYXJzZVNhbXBsZVJhdGUgfSBmcm9tICcuL3V0aWxzL3BhcnNlU2FtcGxlUmF0ZS5qcyc7XG5pbXBvcnQgeyBwcmVwYXJlRXZlbnQgfSBmcm9tICcuL3V0aWxzL3ByZXBhcmVFdmVudC5qcyc7XG5pbXBvcnQgeyBzaG93U3BhbkRyb3BXYXJuaW5nLCBzcGFuVG9UcmFjZUNvbnRleHQgfSBmcm9tICcuL3V0aWxzL3NwYW5VdGlscy5qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VHJhbnNhY3Rpb25FdmVudFRvU3Bhbkpzb24sIGNvbnZlcnRTcGFuSnNvblRvVHJhbnNhY3Rpb25FdmVudCB9IGZyb20gJy4vdXRpbHMvdHJhbnNhY3Rpb25FdmVudC5qcyc7XG5pbXBvcnQgeyBfZ2V0U3BhbkZvclNjb3BlIH0gZnJvbSAnLi91dGlscy9zcGFuT25TY29wZS5qcyc7XG5cbmNvbnN0IEFMUkVBRFlfU0VFTl9FUlJPUiA9IFwiTm90IGNhcHR1cmluZyBleGNlcHRpb24gYmVjYXVzZSBpdCdzIGFscmVhZHkgYmVlbiBjYXB0dXJlZC5cIjtcbmNvbnN0IE1JU1NJTkdfUkVMRUFTRV9GT1JfU0VTU0lPTl9FUlJPUiA9ICdEaXNjYXJkZWQgc2Vzc2lvbiBiZWNhdXNlIG9mIG1pc3Npbmcgb3Igbm9uLXN0cmluZyByZWxlYXNlJztcblxuY29uc3QgSU5URVJOQUxfRVJST1JfU1lNQk9MID0gU3ltYm9sLmZvcignU2VudHJ5SW50ZXJuYWxFcnJvcicpO1xuY29uc3QgRE9fTk9UX1NFTkRfRVZFTlRfU1lNQk9MID0gU3ltYm9sLmZvcignU2VudHJ5RG9Ob3RTZW5kRXZlbnRFcnJvcicpO1xuXG5mdW5jdGlvbiBfbWFrZUludGVybmFsRXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2UsXG4gICAgW0lOVEVSTkFMX0VSUk9SX1NZTUJPTF06IHRydWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZSxcbiAgICBbRE9fTk9UX1NFTkRfRVZFTlRfU1lNQk9MXTogdHJ1ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzSW50ZXJuYWxFcnJvcihlcnJvcikge1xuICByZXR1cm4gISFlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIElOVEVSTkFMX0VSUk9SX1NZTUJPTCBpbiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX2lzRG9Ob3RTZW5kRXZlbnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gISFlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIERPX05PVF9TRU5EX0VWRU5UX1NZTUJPTCBpbiBlcnJvcjtcbn1cblxuLyoqXG4gKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciBhbGwgSmF2YVNjcmlwdCBTREsgY2xpZW50cy5cbiAqXG4gKiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG9wdGlvbnNcbiAqIHNwZWNpZmljIHRvIHRoZSBjbGllbnQgc3ViY2xhc3MuIFRvIGFjY2VzcyB0aGVzZSBvcHRpb25zIGxhdGVyLCB1c2VcbiAqIHtAbGluayBDbGllbnQuZ2V0T3B0aW9uc30uXG4gKlxuICogSWYgYSBEc24gaXMgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLCBpdCB3aWxsIGJlIHBhcnNlZCBhbmQgc3RvcmVkLiBVc2VcbiAqIHtAbGluayBDbGllbnQuZ2V0RHNufSB0byByZXRyaWV2ZSB0aGUgRHNuIGF0IGFueSBtb21lbnQuIEluIGNhc2UgdGhlIERzbiBpc1xuICogaW52YWxpZCwgdGhlIGNvbnN0cnVjdG9yIHdpbGwgdGhyb3cgYSB7QGxpbmsgU2VudHJ5RXhjZXB0aW9ufS4gTm90ZSB0aGF0XG4gKiB3aXRob3V0IGEgdmFsaWQgRHNuLCB0aGUgU0RLIHdpbGwgbm90IHNlbmQgYW55IGV2ZW50cyB0byBTZW50cnkuXG4gKlxuICogQmVmb3JlIHNlbmRpbmcgYW4gZXZlbnQsIGl0IGlzIHBhc3NlZCB0aHJvdWdoXG4gKiB7QGxpbmsgQ2xpZW50Ll9wcmVwYXJlRXZlbnR9IHRvIGFkZCBTREsgaW5mb3JtYXRpb24gYW5kIHNjb3BlIGRhdGFcbiAqIChicmVhZGNydW1icyBhbmQgY29udGV4dCkuIFRvIGFkZCBtb3JlIGN1c3RvbSBpbmZvcm1hdGlvbiwgb3ZlcnJpZGUgdGhpc1xuICogbWV0aG9kIGFuZCBleHRlbmQgdGhlIHJlc3VsdGluZyBwcmVwYXJlZCBldmVudC5cbiAqXG4gKiBUbyBpc3N1ZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgZXZlbnRzIChlLmcuIHZpYSBpbnN0cnVtZW50YXRpb24pLCB1c2VcbiAqIHtAbGluayBDbGllbnQuY2FwdHVyZUV2ZW50fS4gSXQgd2lsbCBwcmVwYXJlIHRoZSBldmVudCBhbmQgcGFzcyBpdCB0aHJvdWdoXG4gKiB0aGUgY2FsbGJhY2sgbGlmZWN5Y2xlLiBUbyBpc3N1ZSBhdXRvLWJyZWFkY3J1bWJzLCB1c2VcbiAqIHtAbGluayBDbGllbnQuYWRkQnJlYWRjcnVtYn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNsYXNzIE5vZGVDbGllbnQgZXh0ZW5kcyBDbGllbnQ8Tm9kZU9wdGlvbnM+IHtcbiAqICAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE5vZGVPcHRpb25zKSB7XG4gKiAgICAgc3VwZXIob3B0aW9ucyk7XG4gKiAgIH1cbiAqXG4gKiAgIC8vIC4uLlxuICogfVxuICovXG5jbGFzcyBDbGllbnQge1xuICAvKiogT3B0aW9ucyBwYXNzZWQgdG8gdGhlIFNESy4gKi9cblxuICAvKiogVGhlIGNsaWVudCBEc24sIGlmIHNwZWNpZmllZCBpbiBvcHRpb25zLiBXaXRob3V0IHRoaXMgRHNuLCB0aGUgU0RLIHdpbGwgYmUgZGlzYWJsZWQuICovXG5cbiAgLyoqIEFycmF5IG9mIHNldCB1cCBpbnRlZ3JhdGlvbnMuICovXG5cbiAgLyoqIE51bWJlciBvZiBjYWxscyBiZWluZyBwcm9jZXNzZWQgKi9cblxuICAvKiogSG9sZHMgZmx1c2hhYmxlICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoaXMgY2xpZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgY2xpZW50LlxuICAgKi9cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9pbnRlZ3JhdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9udW1Qcm9jZXNzaW5nID0gMDtcbiAgICB0aGlzLl9vdXRjb21lcyA9IHt9O1xuICAgIHRoaXMuX2hvb2tzID0ge307XG4gICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5kc24pIHtcbiAgICAgIHRoaXMuX2RzbiA9IG1ha2VEc24ob3B0aW9ucy5kc24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignTm8gRFNOIHByb3ZpZGVkLCBjbGllbnQgd2lsbCBub3Qgc2VuZCBldmVudHMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Rzbikge1xuICAgICAgY29uc3QgdXJsID0gZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aChcbiAgICAgICAgdGhpcy5fZHNuLFxuICAgICAgICBvcHRpb25zLnR1bm5lbCxcbiAgICAgICAgb3B0aW9ucy5fbWV0YWRhdGEgPyBvcHRpb25zLl9tZXRhZGF0YS5zZGsgOiB1bmRlZmluZWQsXG4gICAgICApO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gb3B0aW9ucy50cmFuc3BvcnQoe1xuICAgICAgICB0dW5uZWw6IHRoaXMuX29wdGlvbnMudHVubmVsLFxuICAgICAgICByZWNvcmREcm9wcGVkRXZlbnQ6IHRoaXMucmVjb3JkRHJvcHBlZEV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgIC4uLm9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyxcbiAgICAgICAgdXJsLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmVzIGFuIGV4Y2VwdGlvbiBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBVbmxpa2UgYGNhcHR1cmVFeGNlcHRpb25gIGV4cG9ydGVkIGZyb20gZXZlcnkgU0RLLCB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IHlvdSBwYXNzIGl0IHRoZSBjdXJyZW50IHNjb3BlLlxuICAgKi9cbiAgIGNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50LCBzY29wZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSB1dWlkNCgpO1xuXG4gICAgLy8gZW5zdXJlIHdlIGhhdmVuJ3QgY2FwdHVyZWQgdGhpcyB2ZXJ5IG9iamVjdCBiZWZvcmVcbiAgICBpZiAoY2hlY2tPclNldEFscmVhZHlDYXVnaHQoZXhjZXB0aW9uKSkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZyhBTFJFQURZX1NFRU5fRVJST1IpO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaGludFdpdGhFdmVudElkID0ge1xuICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsXG4gICAgICAuLi5oaW50LFxuICAgIH07XG5cbiAgICB0aGlzLl9wcm9jZXNzKFxuICAgICAgdGhpcy5ldmVudEZyb21FeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50V2l0aEV2ZW50SWQpLnRoZW4oZXZlbnQgPT5cbiAgICAgICAgdGhpcy5fY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50V2l0aEV2ZW50SWQsIHNjb3BlKSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIHJldHVybiBoaW50V2l0aEV2ZW50SWQuZXZlbnRfaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZXMgYSBtZXNzYWdlIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gICAqXG4gICAqIFVubGlrZSBgY2FwdHVyZU1lc3NhZ2VgIGV4cG9ydGVkIGZyb20gZXZlcnkgU0RLLCB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IHlvdSBwYXNzIGl0IHRoZSBjdXJyZW50IHNjb3BlLlxuICAgKi9cbiAgIGNhcHR1cmVNZXNzYWdlKFxuICAgIG1lc3NhZ2UsXG4gICAgbGV2ZWwsXG4gICAgaGludCxcbiAgICBjdXJyZW50U2NvcGUsXG4gICkge1xuICAgIGNvbnN0IGhpbnRXaXRoRXZlbnRJZCA9IHtcbiAgICAgIGV2ZW50X2lkOiB1dWlkNCgpLFxuICAgICAgLi4uaGludCxcbiAgICB9O1xuXG4gICAgY29uc3QgZXZlbnRNZXNzYWdlID0gaXNQYXJhbWV0ZXJpemVkU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IFN0cmluZyhtZXNzYWdlKTtcblxuICAgIGNvbnN0IHByb21pc2VkRXZlbnQgPSBpc1ByaW1pdGl2ZShtZXNzYWdlKVxuICAgICAgPyB0aGlzLmV2ZW50RnJvbU1lc3NhZ2UoZXZlbnRNZXNzYWdlLCBsZXZlbCwgaGludFdpdGhFdmVudElkKVxuICAgICAgOiB0aGlzLmV2ZW50RnJvbUV4Y2VwdGlvbihtZXNzYWdlLCBoaW50V2l0aEV2ZW50SWQpO1xuXG4gICAgdGhpcy5fcHJvY2Vzcyhwcm9taXNlZEV2ZW50LnRoZW4oZXZlbnQgPT4gdGhpcy5fY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50V2l0aEV2ZW50SWQsIGN1cnJlbnRTY29wZSkpKTtcblxuICAgIHJldHVybiBoaW50V2l0aEV2ZW50SWQuZXZlbnRfaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZXMgYSBtYW51YWxseSBjcmVhdGVkIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gICAqXG4gICAqIFVubGlrZSBgY2FwdHVyZUV2ZW50YCBleHBvcnRlZCBmcm9tIGV2ZXJ5IFNESywgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCB5b3UgcGFzcyBpdCB0aGUgY3VycmVudCBzY29wZS5cbiAgICovXG4gICBjYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQsIGN1cnJlbnRTY29wZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSB1dWlkNCgpO1xuXG4gICAgLy8gZW5zdXJlIHdlIGhhdmVuJ3QgY2FwdHVyZWQgdGhpcyB2ZXJ5IG9iamVjdCBiZWZvcmVcbiAgICBpZiAoaGludD8ub3JpZ2luYWxFeGNlcHRpb24gJiYgY2hlY2tPclNldEFscmVhZHlDYXVnaHQoaGludC5vcmlnaW5hbEV4Y2VwdGlvbikpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2coQUxSRUFEWV9TRUVOX0VSUk9SKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IGhpbnRXaXRoRXZlbnRJZCA9IHtcbiAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgLi4uaGludCxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0gZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhIHx8IHt9O1xuICAgIGNvbnN0IGNhcHR1cmVkU3BhblNjb3BlID0gc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmNhcHR1cmVkU3BhblNjb3BlO1xuICAgIGNvbnN0IGNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlID0gc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlO1xuXG4gICAgdGhpcy5fcHJvY2VzcyhcbiAgICAgIHRoaXMuX2NhcHR1cmVFdmVudChldmVudCwgaGludFdpdGhFdmVudElkLCBjYXB0dXJlZFNwYW5TY29wZSB8fCBjdXJyZW50U2NvcGUsIGNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIGhpbnRXaXRoRXZlbnRJZC5ldmVudF9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlcyBhIHNlc3Npb24uXG4gICAqL1xuICAgY2FwdHVyZVNlc3Npb24oc2Vzc2lvbikge1xuICAgIHRoaXMuc2VuZFNlc3Npb24oc2Vzc2lvbik7XG4gICAgLy8gQWZ0ZXIgc2VuZGluZywgd2Ugc2V0IGluaXQgZmFsc2UgdG8gaW5kaWNhdGUgaXQncyBub3QgdGhlIGZpcnN0IG9jY3VycmVuY2VcbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIHsgaW5pdDogZmFsc2UgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY3JvbiBtb25pdG9yIGNoZWNrIGluIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS4gVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBvbiBhbGwgY2xpZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGNoZWNrSW4gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSB1cHNlcnRNb25pdG9yQ29uZmlnIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIG1vbml0b3IgY29uZmlnLiBVc2UgdGhpcyBpZiB5b3Ugd2FudFxuICAgKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSBzY29wZSBBbiBvcHRpb25hbCBzY29wZSBjb250YWluaW5nIGV2ZW50IG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGlkIG9mIHRoZSBjaGVjayBpbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBEc24uXG4gICAqL1xuICAgZ2V0RHNuKCkge1xuICAgIHJldHVybiB0aGlzLl9kc247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAqL1xuICAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFNESyBtZXRhZGF0YS5cbiAgICogQHNlZSBTZGtNZXRhZGF0YVxuICAgKi9cbiAgIGdldFNka01ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLl9tZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFuc3BvcnQgdGhhdCBpcyB1c2VkIGJ5IHRoZSBjbGllbnQuXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIHRyYW5zcG9ydCBnZXRzIGxhenkgaW5pdGlhbGl6ZWQgc28gaXQgd2lsbCBvbmx5IGJlIHRoZXJlIG9uY2UgdGhlIGZpcnN0IGV2ZW50IGhhcyBiZWVuIHNlbnQuXG4gICAqL1xuICAgZ2V0VHJhbnNwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgYWxsIGV2ZW50cyB0byBiZSBzZW50IG9yIHRoZSB0aW1lb3V0IHRvIGV4cGlyZSwgd2hpY2hldmVyIGNvbWVzIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dCBNYXhpbXVtIHRpbWUgaW4gbXMgdGhlIGNsaWVudCBzaG91bGQgd2FpdCBmb3IgZXZlbnRzIHRvIGJlIGZsdXNoZWQuIE9taXR0aW5nIHRoaXMgcGFyYW1ldGVyIHdpbGxcbiAgICogICBjYXVzZSB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCBgdHJ1ZWAgaWYgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgdGhlcmUgYXJlXG4gICAqIHN0aWxsIGV2ZW50cyBpbiB0aGUgcXVldWUgd2hlbiB0aGUgdGltZW91dCBpcyByZWFjaGVkLlxuICAgKi9cbiAgIGZsdXNoKHRpbWVvdXQpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQ7XG4gICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xpZW50RG9uZVByb2Nlc3NpbmcodGltZW91dCkudGhlbihjbGllbnRGaW5pc2hlZCA9PiB7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQuZmx1c2godGltZW91dCkudGhlbih0cmFuc3BvcnRGbHVzaGVkID0+IGNsaWVudEZpbmlzaGVkICYmIHRyYW5zcG9ydEZsdXNoZWQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgZXZlbnQgcXVldWUgYW5kIHNldCB0aGUgY2xpZW50IHRvIGBlbmFibGVkID0gZmFsc2VgLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IE1heGltdW0gdGltZSBpbiBtcyB0aGUgY2xpZW50IHNob3VsZCB3YWl0IGJlZm9yZSBzaHV0dGluZyBkb3duLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gICAqICAgdGhlIGNsaWVudCB0byB3YWl0IHVudGlsIGFsbCBldmVudHMgYXJlIHNlbnQgYmVmb3JlIGRpc2FibGluZyBpdHNlbGYuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYHRydWVgIGlmIHRoZSBmbHVzaCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5IGJlZm9yZSB0aGUgdGltZW91dCwgb3IgYGZhbHNlYCBpZlxuICAgKiBpdCBkb2Vzbid0LlxuICAgKi9cbiAgIGNsb3NlKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mbHVzaCh0aW1lb3V0KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLmdldE9wdGlvbnMoKS5lbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgaW5zdGFsbGVkIGV2ZW50IHByb2Nlc3NvcnMuXG4gICAqL1xuICAgZ2V0RXZlbnRQcm9jZXNzb3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudFByb2Nlc3NvcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBwcm9jZXNzb3IgdGhhdCBhcHBsaWVzIHRvIGFueSBldmVudCBwcm9jZXNzZWQgYnkgdGhpcyBjbGllbnQuXG4gICAqL1xuICAgYWRkRXZlbnRQcm9jZXNzb3IoZXZlbnRQcm9jZXNzb3IpIHtcbiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMucHVzaChldmVudFByb2Nlc3Nvcik7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGlzIGNsaWVudC5cbiAgICogQ2FsbCB0aGlzIGFmdGVyIHRoZSBjbGllbnQgd2FzIHNldCBvbiBhIHNjb3BlLlxuICAgKi9cbiAgIGluaXQoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5faXNFbmFibGVkKCkgfHxcbiAgICAgIC8vIEZvcmNlIGludGVncmF0aW9ucyB0byBiZSBzZXR1cCBldmVuIGlmIG5vIERTTiB3YXMgc2V0IHdoZW4gd2UgaGF2ZVxuICAgICAgLy8gU3BvdGxpZ2h0IGVuYWJsZWQuIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCBmb3IgYnJvd3NlciBhcyB3ZVxuICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGUgYHNwb3RsaWdodGAgb3B0aW9uIHRoZXJlIGFuZCByZWx5IG9uIHRoZSB1c2Vyc1xuICAgICAgLy8gYWRkaW5nIHRoZSBgc3BvdGxpZ2h0QnJvd3NlckludGVncmF0aW9uKClgIHRvIHRoZWlyIGludGVncmF0aW9ucyB3aGljaFxuICAgICAgLy8gd291bGRuJ3QgZ2V0IGluaXRpYWxpemVkIHdpdGggdGhlIGNoZWNrIGJlbG93IHdoZW4gdGhlcmUncyBubyBEU04gc2V0LlxuICAgICAgdGhpcy5fb3B0aW9ucy5pbnRlZ3JhdGlvbnMuc29tZSgoeyBuYW1lIH0pID0+IG5hbWUuc3RhcnRzV2l0aCgnU3BvdGxpZ2h0JykpXG4gICAgKSB7XG4gICAgICB0aGlzLl9zZXR1cEludGVncmF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGluc3RhbGxlZCBpbnRlZ3JhdGlvbiBieSBpdHMgbmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0ludGVncmF0aW9ufHVuZGVmaW5lZH0gVGhlIGluc3RhbGxlZCBpbnRlZ3JhdGlvbiBvciBgdW5kZWZpbmVkYCBpZiBubyBpbnRlZ3JhdGlvbiB3aXRoIHRoYXQgYG5hbWVgIHdhcyBpbnN0YWxsZWQuXG4gICAqL1xuICAgZ2V0SW50ZWdyYXRpb25CeU5hbWUoaW50ZWdyYXRpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVncmF0aW9uc1tpbnRlZ3JhdGlvbk5hbWVdIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW50ZWdyYXRpb24gdG8gdGhlIGNsaWVudC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBlLmcuIGxhenkgbG9hZCBpbnRlZ3JhdGlvbnMuXG4gICAqIEluIG1vc3QgY2FzZXMsIHRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnksXG4gICAqIGFuZCB5b3UncmUgYmV0dGVyIG9mZiBqdXN0IHBhc3NpbmcgdGhlIGludGVncmF0aW9ucyB2aWEgYGludGVncmF0aW9uczogW11gIGF0IGluaXRpYWxpemF0aW9uIHRpbWUuXG4gICAqIEhvd2V2ZXIsIGlmIHlvdSBmaW5kIHRoZSBuZWVkIHRvIGNvbmRpdGlvbmFsbHkgbG9hZCAmIGFkZCBhbiBpbnRlZ3JhdGlvbiwgeW91IGNhbiB1c2UgYGFkZEludGVncmF0aW9uYCB0byBkbyBzby5cbiAgICovXG4gICBhZGRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbikge1xuICAgIGNvbnN0IGlzQWxyZWFkeUluc3RhbGxlZCA9IHRoaXMuX2ludGVncmF0aW9uc1tpbnRlZ3JhdGlvbi5uYW1lXTtcblxuICAgIC8vIFRoaXMgaG9vayB0YWtlcyBjYXJlIG9mIG9ubHkgaW5zdGFsbGluZyBpZiBub3QgYWxyZWFkeSBpbnN0YWxsZWRcbiAgICBzZXR1cEludGVncmF0aW9uKHRoaXMsIGludGVncmF0aW9uLCB0aGlzLl9pbnRlZ3JhdGlvbnMpO1xuICAgIC8vIEhlcmUgd2UgbmVlZCB0byBjaGVjayBtYW51YWxseSB0byBtYWtlIHN1cmUgdG8gbm90IHJ1biB0aGlzIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKCFpc0FscmVhZHlJbnN0YWxsZWQpIHtcbiAgICAgIGFmdGVyU2V0dXBJbnRlZ3JhdGlvbnModGhpcywgW2ludGVncmF0aW9uXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBmdWxseSBwcmVwYXJlZCBldmVudCB0byBTZW50cnkuXG4gICAqL1xuICAgc2VuZEV2ZW50KGV2ZW50LCBoaW50ID0ge30pIHtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZVNlbmRFdmVudCcsIGV2ZW50LCBoaW50KTtcblxuICAgIGxldCBlbnYgPSBjcmVhdGVFdmVudEVudmVsb3BlKGV2ZW50LCB0aGlzLl9kc24sIHRoaXMuX29wdGlvbnMuX21ldGFkYXRhLCB0aGlzLl9vcHRpb25zLnR1bm5lbCk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgaGludC5hdHRhY2htZW50cyB8fCBbXSkge1xuICAgICAgZW52ID0gYWRkSXRlbVRvRW52ZWxvcGUoZW52LCBjcmVhdGVBdHRhY2htZW50RW52ZWxvcGVJdGVtKGF0dGFjaG1lbnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZW5kRW52ZWxvcGUoZW52KTtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgcHJvbWlzZS50aGVuKHNlbmRSZXNwb25zZSA9PiB0aGlzLmVtaXQoJ2FmdGVyU2VuZEV2ZW50JywgZXZlbnQsIHNlbmRSZXNwb25zZSksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2Vzc2lvbiBvciBzZXNzaW9uIGFnZ3JlZ3JhdGVzIHRvIFNlbnRyeS5cbiAgICovXG4gICBzZW5kU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgLy8gQmFja2ZpbGwgcmVsZWFzZSBhbmQgZW52aXJvbm1lbnQgb24gc2Vzc2lvblxuICAgIGNvbnN0IHsgcmVsZWFzZTogY2xpZW50UmVsZWFzZU9wdGlvbiwgZW52aXJvbm1lbnQ6IGNsaWVudEVudmlyb25tZW50T3B0aW9uID0gREVGQVVMVF9FTlZJUk9OTUVOVCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAoJ2FnZ3JlZ2F0ZXMnIGluIHNlc3Npb24pIHtcbiAgICAgIGNvbnN0IHNlc3Npb25BdHRycyA9IHNlc3Npb24uYXR0cnMgfHwge307XG4gICAgICBpZiAoIXNlc3Npb25BdHRycy5yZWxlYXNlICYmICFjbGllbnRSZWxlYXNlT3B0aW9uKSB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKE1JU1NJTkdfUkVMRUFTRV9GT1JfU0VTU0lPTl9FUlJPUik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlc3Npb25BdHRycy5yZWxlYXNlID0gc2Vzc2lvbkF0dHJzLnJlbGVhc2UgfHwgY2xpZW50UmVsZWFzZU9wdGlvbjtcbiAgICAgIHNlc3Npb25BdHRycy5lbnZpcm9ubWVudCA9IHNlc3Npb25BdHRycy5lbnZpcm9ubWVudCB8fCBjbGllbnRFbnZpcm9ubWVudE9wdGlvbjtcbiAgICAgIHNlc3Npb24uYXR0cnMgPSBzZXNzaW9uQXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc2Vzc2lvbi5yZWxlYXNlICYmICFjbGllbnRSZWxlYXNlT3B0aW9uKSB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKE1JU1NJTkdfUkVMRUFTRV9GT1JfU0VTU0lPTl9FUlJPUik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlc3Npb24ucmVsZWFzZSA9IHNlc3Npb24ucmVsZWFzZSB8fCBjbGllbnRSZWxlYXNlT3B0aW9uO1xuICAgICAgc2Vzc2lvbi5lbnZpcm9ubWVudCA9IHNlc3Npb24uZW52aXJvbm1lbnQgfHwgY2xpZW50RW52aXJvbm1lbnRPcHRpb247XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdiZWZvcmVTZW5kU2Vzc2lvbicsIHNlc3Npb24pO1xuXG4gICAgY29uc3QgZW52ID0gY3JlYXRlU2Vzc2lvbkVudmVsb3BlKHNlc3Npb24sIHRoaXMuX2RzbiwgdGhpcy5fb3B0aW9ucy5fbWV0YWRhdGEsIHRoaXMuX29wdGlvbnMudHVubmVsKTtcblxuICAgIC8vIHNlbmRFbnZlbG9wZSBzaG91bGQgbm90IHRocm93XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIHRoaXMuc2VuZEVudmVsb3BlKGVudik7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIG9uIHRoZSBjbGllbnQgdGhhdCBhbiBldmVudCBnb3QgZHJvcHBlZCAoaWUsIGFuIGV2ZW50IHRoYXQgd2lsbCBub3QgYmUgc2VudCB0byBTZW50cnkpLlxuICAgKi9cbiAgIHJlY29yZERyb3BwZWRFdmVudChyZWFzb24sIGNhdGVnb3J5LCBjb3VudCA9IDEpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZW5kQ2xpZW50UmVwb3J0cykge1xuICAgICAgLy8gV2Ugd2FudCB0byB0cmFjayBlYWNoIGNhdGVnb3J5IChlcnJvciwgdHJhbnNhY3Rpb24sIHNlc3Npb24sIHJlcGxheV9ldmVudCkgc2VwYXJhdGVseVxuICAgICAgLy8gYnV0IHN0aWxsIGtlZXAgdGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gZGlmZmVyZW50IHR5cGUgb2Ygb3V0Y29tZXMuXG4gICAgICAvLyBXZSBjb3VsZCB1c2UgbmVzdGVkIG1hcHMsIGJ1dCBpdCdzIG11Y2ggZWFzaWVyIHRvIHJlYWQgYW5kIHR5cGUgdGhpcyB3YXkuXG4gICAgICAvLyBBIGNvcnJlY3QgdHlwZSBmb3IgbWFwLWJhc2VkIGltcGxlbWVudGF0aW9uIGlmIHdlIHdhbnQgdG8gZ28gdGhhdCByb3V0ZVxuICAgICAgLy8gd291bGQgYmUgYFBhcnRpYWw8UmVjb3JkPFNlbnRyeVJlcXVlc3RUeXBlLCBQYXJ0aWFsPFJlY29yZDxPdXRjb21lLCBudW1iZXI+Pj4+YFxuICAgICAgLy8gV2l0aCB0eXBlc2NyaXB0IDQuMSB3ZSBjb3VsZCBldmVuIHVzZSB0ZW1wbGF0ZSBsaXRlcmFsIHR5cGVzXG4gICAgICBjb25zdCBrZXkgPSBgJHtyZWFzb259OiR7Y2F0ZWdvcnl9YDtcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5sb2coYFJlY29yZGluZyBvdXRjb21lOiBcIiR7a2V5fVwiJHtjb3VudCA+IDEgPyBgICgke2NvdW50fSB0aW1lcylgIDogJyd9YCk7XG4gICAgICB0aGlzLl9vdXRjb21lc1trZXldID0gKHRoaXMuX291dGNvbWVzW2tleV0gfHwgMCkgKyBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzICovXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3aGVuZXZlciBhIHNwYW4gaXMgc3RhcnRlZC5cbiAgICogUmVjZWl2ZXMgdGhlIHNwYW4gYXMgYXJndW1lbnQuXG4gICAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfSBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHJlbW92ZXMgdGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhvb2sgb24gdGhpcyBjbGllbnQuXG4gICAqL1xuICAgb24oaG9vaywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBob29rcyA9ICh0aGlzLl9ob29rc1tob29rXSA9IHRoaXMuX2hvb2tzW2hvb2tdIHx8IFtdKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgYXNzdW1lIHRoZSB0eXBlcyBhcmUgY29ycmVjdFxuICAgIGhvb2tzLnB1c2goY2FsbGJhY2spO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY2FsbGJhY2sgZXhlY3V0aW9uIGhhbmRsZXIgdGhhdCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIGRlcmVnaXN0ZXJzIGEgY2FsbGJhY2suIFRoaXMgaXMgY3J1Y2lhbCBmb3IgbWFuYWdpbmcgaW5zdGFuY2VzIHdoZXJlIGNhbGxiYWNrc1xuICAgIC8vIG5lZWQgdG8gYmUgdW5yZWdpc3RlcmVkIHRvIHByZXZlbnQgc2VsZi1yZWZlcmVuY2luZyBpbiBjYWxsYmFjayBjbG9zdXJlcyxcbiAgICAvLyBlbnN1cmluZyBwcm9wZXIgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGFzc3VtZSB0aGUgdHlwZXMgYXJlIGNvcnJlY3RcbiAgICAgIGNvbnN0IGNiSW5kZXggPSBob29rcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgIGlmIChjYkluZGV4ID4gLTEpIHtcbiAgICAgICAgaG9va3Muc3BsaWNlKGNiSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiogRmlyZSBhIGhvb2sgd2hlbmV2ZXIgYSBzcGFuIHN0YXJ0cy4gKi9cblxuICAvKipcbiAgICogRW1pdCBhIGhvb2sgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHZpYSBgb24oKWAuXG4gICAqL1xuICAgZW1pdChob29rLCAuLi5yZXN0KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5faG9va3NbaG9va107XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4ucmVzdCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGFuIGVudmVsb3BlIHRvIFNlbnRyeS5cbiAgICovXG4gICBzZW5kRW52ZWxvcGUoZW52ZWxvcGUpIHtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZUVudmVsb3BlJywgZW52ZWxvcGUpO1xuXG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCgpICYmIHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVudmVsb3BlKS50aGVuKG51bGwsIHJlYXNvbiA9PiB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgc2VuZGluZyBlbnZlbG9wZTonLCByZWFzb24pO1xuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKCdUcmFuc3BvcnQgZGlzYWJsZWQnKTtcblxuICAgIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKHt9KTtcbiAgfVxuXG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlcyAqL1xuXG4gIC8qKiBTZXR1cCBpbnRlZ3JhdGlvbnMgZm9yIHRoaXMgY2xpZW50LiAqL1xuICAgX3NldHVwSW50ZWdyYXRpb25zKCkge1xuICAgIGNvbnN0IHsgaW50ZWdyYXRpb25zIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHRoaXMuX2ludGVncmF0aW9ucyA9IHNldHVwSW50ZWdyYXRpb25zKHRoaXMsIGludGVncmF0aW9ucyk7XG4gICAgYWZ0ZXJTZXR1cEludGVncmF0aW9ucyh0aGlzLCBpbnRlZ3JhdGlvbnMpO1xuICB9XG5cbiAgLyoqIFVwZGF0ZXMgZXhpc3Rpbmcgc2Vzc2lvbiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZXZlbnQgKi9cbiAgIF91cGRhdGVTZXNzaW9uRnJvbUV2ZW50KHNlc3Npb24sIGV2ZW50KSB7XG4gICAgbGV0IGNyYXNoZWQgPSBldmVudC5sZXZlbCA9PT0gJ2ZhdGFsJztcbiAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSBldmVudC5leGNlcHRpb24/LnZhbHVlcztcblxuICAgIGlmIChleGNlcHRpb25zKSB7XG4gICAgICBlcnJvcmVkID0gdHJ1ZTtcblxuICAgICAgZm9yIChjb25zdCBleCBvZiBleGNlcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1lY2hhbmlzbSA9IGV4Lm1lY2hhbmlzbTtcbiAgICAgICAgaWYgKG1lY2hhbmlzbT8uaGFuZGxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEEgc2Vzc2lvbiBpcyB1cGRhdGVkIGFuZCB0aGF0IHNlc3Npb24gdXBkYXRlIGlzIHNlbnQgaW4gb25seSBvbmUgb2YgdGhlIHR3byBmb2xsb3dpbmcgc2NlbmFyaW9zOlxuICAgIC8vIDEuIFNlc3Npb24gd2l0aCBub24gdGVybWluYWwgc3RhdHVzIGFuZCAwIGVycm9ycyArIGFuIGVycm9yIG9jY3VycmVkIC0+IFdpbGwgc2V0IGVycm9yIGNvdW50IHRvIDEgYW5kIHNlbmQgdXBkYXRlXG4gICAgLy8gMi4gU2Vzc2lvbiB3aXRoIG5vbiB0ZXJtaW5hbCBzdGF0dXMgYW5kIDEgZXJyb3IgKyBhIGNyYXNoIG9jY3VycmVkIC0+IFdpbGwgc2V0IHN0YXR1cyBjcmFzaGVkIGFuZCBzZW5kIHVwZGF0ZVxuICAgIGNvbnN0IHNlc3Npb25Ob25UZXJtaW5hbCA9IHNlc3Npb24uc3RhdHVzID09PSAnb2snO1xuICAgIGNvbnN0IHNob3VsZFVwZGF0ZUFuZFNlbmQgPSAoc2Vzc2lvbk5vblRlcm1pbmFsICYmIHNlc3Npb24uZXJyb3JzID09PSAwKSB8fCAoc2Vzc2lvbk5vblRlcm1pbmFsICYmIGNyYXNoZWQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZUFuZFNlbmQpIHtcbiAgICAgIHVwZGF0ZVNlc3Npb24oc2Vzc2lvbiwge1xuICAgICAgICAuLi4oY3Jhc2hlZCAmJiB7IHN0YXR1czogJ2NyYXNoZWQnIH0pLFxuICAgICAgICBlcnJvcnM6IHNlc3Npb24uZXJyb3JzIHx8IE51bWJlcihlcnJvcmVkIHx8IGNyYXNoZWQpLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNhcHR1cmVTZXNzaW9uKHNlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIGNsaWVudCBpcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBSZXR1cm5zIGEgcHJvbWlzZSBiZWNhdXNlIGl0IHdpbGwgd2FpdCBgdGltZW91dGAgbXMgYmVmb3JlIHNheWluZ1xuICAgKiBcIm5vXCIgKHJlc29sdmluZyB0byBgZmFsc2VgKSBpbiBvcmRlciB0byBnaXZlIHRoZSBjbGllbnQgYSBjaGFuY2UgdG8gcG90ZW50aWFsbHkgZmluaXNoIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dCBUaGUgdGltZSwgaW4gbXMsIGFmdGVyIHdoaWNoIHRvIHJlc29sdmUgdG8gYGZhbHNlYCBpZiB0aGUgY2xpZW50IGlzIHN0aWxsIGJ1c3kuIFBhc3NpbmcgYDBgIChvciBub3RcbiAgICogcGFzc2luZyBhbnl0aGluZykgd2lsbCBtYWtlIHRoZSBwcm9taXNlIHdhaXQgYXMgbG9uZyBhcyBpdCB0YWtlcyBmb3IgcHJvY2Vzc2luZyB0byBmaW5pc2ggYmVmb3JlIHJlc29sdmluZyB0b1xuICAgKiBgdHJ1ZWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgdG8gYHRydWVgIGlmIHByb2Nlc3NpbmcgaXMgYWxyZWFkeSBkb25lIG9yIGZpbmlzaGVzIGJlZm9yZSB0aGUgdGltZW91dCwgYW5kXG4gICAqIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuICAgX2lzQ2xpZW50RG9uZVByb2Nlc3NpbmcodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgU3luY1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgdGlja2VkID0gMDtcbiAgICAgIGNvbnN0IHRpY2sgPSAxO1xuXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX251bVByb2Nlc3NpbmcgPT0gMCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja2VkICs9IHRpY2s7XG4gICAgICAgICAgaWYgKHRpbWVvdXQgJiYgdGlja2VkID49IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBTREsgaXMgZW5hYmxlZCBhbmQgYSB0cmFuc3BvcnQgaXMgcHJlc2VudC4gKi9cbiAgIF9pc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucygpLmVuYWJsZWQgIT09IGZhbHNlICYmIHRoaXMuX3RyYW5zcG9ydCAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY29tbW9uIGluZm9ybWF0aW9uIHRvIGV2ZW50cy5cbiAgICpcbiAgICogVGhlIGluZm9ybWF0aW9uIGluY2x1ZGVzIHJlbGVhc2UgYW5kIGVudmlyb25tZW50IGZyb20gYG9wdGlvbnNgLFxuICAgKiBicmVhZGNydW1icyBhbmQgY29udGV4dCAoZXh0cmEsIHRhZ3MgYW5kIHVzZXIpIGZyb20gdGhlIHNjb3BlLlxuICAgKlxuICAgKiBJbmZvcm1hdGlvbiB0aGF0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZXZlbnQgaXMgbmV2ZXIgb3ZlcndyaXR0ZW4uIEZvclxuICAgKiBuZXN0ZWQgb2JqZWN0cywgc3VjaCBhcyB0aGUgY29udGV4dCwga2V5cyBhcmUgbWVyZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgKiBAcGFyYW0gaGludCBNYXkgY29udGFpbiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBleGNlcHRpb24uXG4gICAqIEBwYXJhbSBjdXJyZW50U2NvcGUgQSBzY29wZSBjb250YWluaW5nIGV2ZW50IG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBBIG5ldyBldmVudCB3aXRoIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqL1xuICAgX3ByZXBhcmVFdmVudChcbiAgICBldmVudCxcbiAgICBoaW50LFxuICAgIGN1cnJlbnRTY29wZSxcbiAgICBpc29sYXRpb25TY29wZSxcbiAgKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IGludGVncmF0aW9ucyA9IE9iamVjdC5rZXlzKHRoaXMuX2ludGVncmF0aW9ucyk7XG4gICAgaWYgKCFoaW50LmludGVncmF0aW9ucyAmJiBpbnRlZ3JhdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgaGludC5pbnRlZ3JhdGlvbnMgPSBpbnRlZ3JhdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdwcmVwcm9jZXNzRXZlbnQnLCBldmVudCwgaGludCk7XG5cbiAgICBpZiAoIWV2ZW50LnR5cGUpIHtcbiAgICAgIGlzb2xhdGlvblNjb3BlLnNldExhc3RFdmVudElkKGV2ZW50LmV2ZW50X2lkIHx8IGhpbnQuZXZlbnRfaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVwYXJlRXZlbnQob3B0aW9ucywgZXZlbnQsIGhpbnQsIGN1cnJlbnRTY29wZSwgdGhpcywgaXNvbGF0aW9uU2NvcGUpLnRoZW4oZXZ0ID0+IHtcbiAgICAgIGlmIChldnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCdwb3N0cHJvY2Vzc0V2ZW50JywgZXZ0LCBoaW50KTtcblxuICAgICAgZXZ0LmNvbnRleHRzID0ge1xuICAgICAgICB0cmFjZTogZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKGN1cnJlbnRTY29wZSksXG4gICAgICAgIC4uLmV2dC5jb250ZXh0cyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlKHRoaXMsIGN1cnJlbnRTY29wZSk7XG5cbiAgICAgIGV2dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICAgIC4uLmV2dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgZXZlbnQgYW5kIGxvZ3MgYW4gZXJyb3IgaW4gY2FzZSBvZiByZWplY3Rpb25cbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSBoaW50XG4gICAqIEBwYXJhbSBzY29wZVxuICAgKi9cbiAgIF9jYXB0dXJlRXZlbnQoXG4gICAgZXZlbnQsXG4gICAgaGludCA9IHt9LFxuICAgIGN1cnJlbnRTY29wZSA9IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIGlzb2xhdGlvblNjb3BlID0gZ2V0SXNvbGF0aW9uU2NvcGUoKSxcbiAgKSB7XG4gICAgaWYgKERFQlVHX0JVSUxEICYmIGlzRXJyb3JFdmVudChldmVudCkpIHtcbiAgICAgIGxvZ2dlci5sb2coYENhcHR1cmVkIGVycm9yIGV2ZW50IFxcYCR7Z2V0UG9zc2libGVFdmVudE1lc3NhZ2VzKGV2ZW50KVswXSB8fCAnPHVua25vd24+J31cXGBgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc0V2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKS50aGVuKFxuICAgICAgZmluYWxFdmVudCA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbEV2ZW50LmV2ZW50X2lkO1xuICAgICAgfSxcbiAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgICAgIGlmIChfaXNEb05vdFNlbmRFdmVudEVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVhc29uLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX2lzSW50ZXJuYWxFcnJvcihyZWFzb24pKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihyZWFzb24ubWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGFuIGV2ZW50IChlaXRoZXIgZXJyb3Igb3IgbWVzc2FnZSkgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAgICpcbiAgICogVGhpcyBhbHNvIGFkZHMgYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQgaW5mb3JtYXRpb24gdG8gdGhlIGV2ZW50LiBIb3dldmVyLFxuICAgKiBwbGF0Zm9ybSBzcGVjaWZpYyBtZXRhIGRhdGEgKHN1Y2ggYXMgdGhlIFVzZXIncyBJUCBhZGRyZXNzKSBtdXN0IGJlIGFkZGVkXG4gICAqIGJ5IHRoZSBTREsgaW1wbGVtZW50b3IuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCB0byBTZW50cnkuXG4gICAqIEBwYXJhbSBoaW50IE1heSBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi5cbiAgICogQHBhcmFtIGN1cnJlbnRTY29wZSBBIHNjb3BlIGNvbnRhaW5pbmcgZXZlbnQgbWV0YWRhdGEuXG4gICAqIEByZXR1cm5zIEEgU3luY1Byb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBldmVudCBvciByZWplY3RzIGluIGNhc2UgZXZlbnQgd2FzL3dpbGwgbm90IGJlIHNlbmQuXG4gICAqL1xuICAgX3Byb2Nlc3NFdmVudChcbiAgICBldmVudCxcbiAgICBoaW50LFxuICAgIGN1cnJlbnRTY29wZSxcbiAgICBpc29sYXRpb25TY29wZSxcbiAgKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IHsgc2FtcGxlUmF0ZSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGlzVHJhbnNhY3Rpb24gPSBpc1RyYW5zYWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGUgfHwgJ2Vycm9yJztcbiAgICBjb25zdCBiZWZvcmVTZW5kTGFiZWwgPSBgYmVmb3JlIHNlbmQgZm9yIHR5cGUgXFxgJHtldmVudFR5cGV9XFxgYDtcblxuICAgIC8vIDEuMCA9PT0gMTAwJSBldmVudHMgYXJlIHNlbnRcbiAgICAvLyAwLjAgPT09IDAlIGV2ZW50cyBhcmUgc2VudFxuICAgIC8vIFNhbXBsaW5nIGZvciB0cmFuc2FjdGlvbiBoYXBwZW5zIHNvbWV3aGVyZSBlbHNlXG4gICAgY29uc3QgcGFyc2VkU2FtcGxlUmF0ZSA9IHR5cGVvZiBzYW1wbGVSYXRlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IHBhcnNlU2FtcGxlUmF0ZShzYW1wbGVSYXRlKTtcbiAgICBpZiAoaXNFcnJvciAmJiB0eXBlb2YgcGFyc2VkU2FtcGxlUmF0ZSA9PT0gJ251bWJlcicgJiYgTWF0aC5yYW5kb20oKSA+IHBhcnNlZFNhbXBsZVJhdGUpIHtcbiAgICAgIHRoaXMucmVjb3JkRHJvcHBlZEV2ZW50KCdzYW1wbGVfcmF0ZScsICdlcnJvcicpO1xuICAgICAgcmV0dXJuIHJlamVjdGVkU3luY1Byb21pc2UoXG4gICAgICAgIF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihcbiAgICAgICAgICBgRGlzY2FyZGluZyBldmVudCBiZWNhdXNlIGl0J3Mgbm90IGluY2x1ZGVkIGluIHRoZSByYW5kb20gc2FtcGxlIChzYW1wbGluZyByYXRlID0gJHtzYW1wbGVSYXRlfSlgLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhQ2F0ZWdvcnkgPSAoZXZlbnRUeXBlID09PSAncmVwbGF5X2V2ZW50JyA/ICdyZXBsYXknIDogZXZlbnRUeXBlKSA7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJlcGFyZUV2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKVxuICAgICAgLnRoZW4ocHJlcGFyZWQgPT4ge1xuICAgICAgICBpZiAocHJlcGFyZWQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnZXZlbnRfcHJvY2Vzc29yJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgICAgICB0aHJvdyBfbWFrZURvTm90U2VuZEV2ZW50RXJyb3IoJ0FuIGV2ZW50IHByb2Nlc3NvciByZXR1cm5lZCBgbnVsbGAsIHdpbGwgbm90IHNlbmQgZXZlbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0ludGVybmFsRXhjZXB0aW9uID0gaGludC5kYXRhICYmIChoaW50LmRhdGEgKS5fX3NlbnRyeV9fID09PSB0cnVlO1xuICAgICAgICBpZiAoaXNJbnRlcm5hbEV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NCZWZvcmVTZW5kKHRoaXMsIG9wdGlvbnMsIHByZXBhcmVkLCBoaW50KTtcbiAgICAgICAgcmV0dXJuIF92YWxpZGF0ZUJlZm9yZVNlbmRSZXN1bHQocmVzdWx0LCBiZWZvcmVTZW5kTGFiZWwpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKHByb2Nlc3NlZEV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmREcm9wcGVkRXZlbnQoJ2JlZm9yZV9zZW5kJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBldmVudC5zcGFucyB8fCBbXTtcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBpdHNlbGYgY291bnRzIGFzIG9uZSBzcGFuLCBwbHVzIGFsbCB0aGUgY2hpbGQgc3BhbnMgdGhhdCBhcmUgYWRkZWRcbiAgICAgICAgICAgIGNvbnN0IHNwYW5Db3VudCA9IDEgKyBzcGFucy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicsIHNwYW5Db3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihgJHtiZWZvcmVTZW5kTGFiZWx9IHJldHVybmVkIFxcYG51bGxcXGAsIHdpbGwgbm90IHNlbmQgZXZlbnQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gICAgICAgIGlmIChpc0Vycm9yICYmIHNlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTZXNzaW9uRnJvbUV2ZW50KHNlc3Npb24sIHByb2Nlc3NlZEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgc3BhbkNvdW50QmVmb3JlID0gcHJvY2Vzc2VkRXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPy5zcGFuQ291bnRCZWZvcmVQcm9jZXNzaW5nIHx8IDA7XG4gICAgICAgICAgY29uc3Qgc3BhbkNvdW50QWZ0ZXIgPSBwcm9jZXNzZWRFdmVudC5zcGFucyA/IHByb2Nlc3NlZEV2ZW50LnNwYW5zLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICBjb25zdCBkcm9wcGVkU3BhbkNvdW50ID0gc3BhbkNvdW50QmVmb3JlIC0gc3BhbkNvdW50QWZ0ZXI7XG4gICAgICAgICAgaWYgKGRyb3BwZWRTcGFuQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicsIGRyb3BwZWRTcGFuQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vbmUgb2YgdGhlIFNlbnRyeSBidWlsdCBldmVudCBwcm9jZXNzb3Igd2lsbCB1cGRhdGUgdHJhbnNhY3Rpb24gbmFtZSxcbiAgICAgICAgLy8gc28gaWYgdGhlIHRyYW5zYWN0aW9uIG5hbWUgaGFzIGJlZW4gY2hhbmdlZCBieSBhbiBldmVudCBwcm9jZXNzb3IsIHdlIGtub3dcbiAgICAgICAgLy8gaXQgaGFzIHRvIGNvbWUgZnJvbSBjdXN0b20gZXZlbnQgcHJvY2Vzc29yIGFkZGVkIGJ5IGEgdXNlclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkluZm8gPSBwcm9jZXNzZWRFdmVudC50cmFuc2FjdGlvbl9pbmZvO1xuICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbkluZm8gJiYgcHJvY2Vzc2VkRXZlbnQudHJhbnNhY3Rpb24gIT09IGV2ZW50LnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gJ2N1c3RvbSc7XG4gICAgICAgICAgcHJvY2Vzc2VkRXZlbnQudHJhbnNhY3Rpb25faW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uSW5mbyxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZW5kRXZlbnQocHJvY2Vzc2VkRXZlbnQsIGhpbnQpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRXZlbnQ7XG4gICAgICB9KVxuICAgICAgLnRoZW4obnVsbCwgcmVhc29uID0+IHtcbiAgICAgICAgaWYgKF9pc0RvTm90U2VuZEV2ZW50RXJyb3IocmVhc29uKSB8fCBfaXNJbnRlcm5hbEVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhcHR1cmVFeGNlcHRpb24ocmVhc29uLCB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgX19zZW50cnlfXzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiByZWFzb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBfbWFrZUludGVybmFsRXJyb3IoXG4gICAgICAgICAgYEV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUgdGhyZXcgYW4gZXJyb3IsIG9yaWdpbmFsIGV2ZW50IHdpbGwgbm90IGJlIHNlbnQuIERldGFpbHMgaGF2ZSBiZWVuIHNlbnQgYXMgYSBuZXcgZXZlbnQuXFxuUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXBpZXMgdGhlIGNsaWVudCB3aXRoIHByb2Nlc3NpbmcgYW5kIGV2ZW50XG4gICAqL1xuICAgX3Byb2Nlc3MocHJvbWlzZSkge1xuICAgIHRoaXMuX251bVByb2Nlc3NpbmcrKztcbiAgICB2b2lkIHByb21pc2UudGhlbihcbiAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5fbnVtUHJvY2Vzc2luZy0tO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fbnVtUHJvY2Vzc2luZy0tO1xuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBvdXRjb21lcyBvbiB0aGlzIGNsaWVudCBhbmQgcmV0dXJucyB0aGVtLlxuICAgKi9cbiAgIF9jbGVhck91dGNvbWVzKCkge1xuICAgIGNvbnN0IG91dGNvbWVzID0gdGhpcy5fb3V0Y29tZXM7XG4gICAgdGhpcy5fb3V0Y29tZXMgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3V0Y29tZXMpLm1hcCgoW2tleSwgcXVhbnRpdHldKSA9PiB7XG4gICAgICBjb25zdCBbcmVhc29uLCBjYXRlZ29yeV0gPSBrZXkuc3BsaXQoJzonKSA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWFzb24sXG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBxdWFudGl0eSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHJlcG9ydHMgYXMgYW4gZW52ZWxvcGUuXG4gICAqL1xuICAgX2ZsdXNoT3V0Y29tZXMoKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZygnRmx1c2hpbmcgb3V0Y29tZXMuLi4nKTtcblxuICAgIGNvbnN0IG91dGNvbWVzID0gdGhpcy5fY2xlYXJPdXRjb21lcygpO1xuXG4gICAgaWYgKG91dGNvbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZygnTm8gb3V0Y29tZXMgdG8gc2VuZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgcmVhbGx5IHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIHdhbnQgdG8gY2hlY2sgZm9yIGEgRFNOIGFuZCBvbmx5IHNlbmQgb3V0Y29tZXMgdGhlblxuICAgIGlmICghdGhpcy5fZHNuKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nKCdObyBkc24gcHJvdmlkZWQsIHdpbGwgbm90IHNlbmQgb3V0Y29tZXMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIubG9nKCdTZW5kaW5nIG91dGNvbWVzOicsIG91dGNvbWVzKTtcblxuICAgIGNvbnN0IGVudmVsb3BlID0gY3JlYXRlQ2xpZW50UmVwb3J0RW52ZWxvcGUob3V0Y29tZXMsIHRoaXMuX29wdGlvbnMudHVubmVsICYmIGRzblRvU3RyaW5nKHRoaXMuX2RzbikpO1xuXG4gICAgLy8gc2VuZEVudmVsb3BlIHNob3VsZCBub3QgdGhyb3dcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy5zZW5kRW52ZWxvcGUoZW52ZWxvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4ge0BsaW5rIEV2ZW50fSBmcm9tIGFsbCBpbnB1dHMgdG8gYGNhcHR1cmVFeGNlcHRpb25gIGFuZCBub24tcHJpbWl0aXZlIGlucHV0cyB0byBgY2FwdHVyZU1lc3NhZ2VgLlxuICAgKi9cblxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQ2xpZW50YCBpbnN0ZWFkLiBUaGlzIGFsaWFzIG1heSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24uXG4gKi9cbi8vIFRPRE8odjEwKTogUmVtb3ZlXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBDbGllbnRgIGluc3RlYWQuIFRoaXMgYWxpYXMgbWF5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi5cbiAqL1xuLy8gVE9ETyh2MTApOiBSZW1vdmVcbmNvbnN0IEJhc2VDbGllbnQgPSBDbGllbnQ7XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCByZXR1cm4gdmFsdWUgb2YgY29uZmlndXJlZCBgYmVmb3JlU2VuZGAgb3IgYGJlZm9yZVNlbmRUcmFuc2FjdGlvbmAgaXMgb2YgZXhwZWN0ZWQgdHlwZSwgYW5kIHJldHVybnMgdGhlIHZhbHVlIGlmIHNvLlxuICovXG5mdW5jdGlvbiBfdmFsaWRhdGVCZWZvcmVTZW5kUmVzdWx0KFxuICBiZWZvcmVTZW5kUmVzdWx0LFxuICBiZWZvcmVTZW5kTGFiZWwsXG4pIHtcbiAgY29uc3QgaW52YWxpZFZhbHVlRXJyb3IgPSBgJHtiZWZvcmVTZW5kTGFiZWx9IG11c3QgcmV0dXJuIFxcYG51bGxcXGAgb3IgYSB2YWxpZCBldmVudC5gO1xuICBpZiAoaXNUaGVuYWJsZShiZWZvcmVTZW5kUmVzdWx0KSkge1xuICAgIHJldHVybiBiZWZvcmVTZW5kUmVzdWx0LnRoZW4oXG4gICAgICBldmVudCA9PiB7XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdChldmVudCkgJiYgZXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBfbWFrZUludGVybmFsRXJyb3IoaW52YWxpZFZhbHVlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0sXG4gICAgICBlID0+IHtcbiAgICAgICAgdGhyb3cgX21ha2VJbnRlcm5hbEVycm9yKGAke2JlZm9yZVNlbmRMYWJlbH0gcmVqZWN0ZWQgd2l0aCAke2V9YCk7XG4gICAgICB9LFxuICAgICk7XG4gIH0gZWxzZSBpZiAoIWlzUGxhaW5PYmplY3QoYmVmb3JlU2VuZFJlc3VsdCkgJiYgYmVmb3JlU2VuZFJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHRocm93IF9tYWtlSW50ZXJuYWxFcnJvcihpbnZhbGlkVmFsdWVFcnJvcik7XG4gIH1cbiAgcmV0dXJuIGJlZm9yZVNlbmRSZXN1bHQ7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgbWF0Y2hpbmcgYGJlZm9yZVNlbmRYWFhgIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzQmVmb3JlU2VuZChcbiAgY2xpZW50LFxuICBvcHRpb25zLFxuICBldmVudCxcbiAgaGludCxcbikge1xuICBjb25zdCB7IGJlZm9yZVNlbmQsIGJlZm9yZVNlbmRUcmFuc2FjdGlvbiwgYmVmb3JlU2VuZFNwYW4gfSA9IG9wdGlvbnM7XG4gIGxldCBwcm9jZXNzZWRFdmVudCA9IGV2ZW50O1xuXG4gIGlmIChpc0Vycm9yRXZlbnQocHJvY2Vzc2VkRXZlbnQpICYmIGJlZm9yZVNlbmQpIHtcbiAgICByZXR1cm4gYmVmb3JlU2VuZChwcm9jZXNzZWRFdmVudCwgaGludCk7XG4gIH1cblxuICBpZiAoaXNUcmFuc2FjdGlvbkV2ZW50KHByb2Nlc3NlZEV2ZW50KSkge1xuICAgIGlmIChiZWZvcmVTZW5kU3Bhbikge1xuICAgICAgLy8gcHJvY2VzcyByb290IHNwYW5cbiAgICAgIGNvbnN0IHByb2Nlc3NlZFJvb3RTcGFuSnNvbiA9IGJlZm9yZVNlbmRTcGFuKGNvbnZlcnRUcmFuc2FjdGlvbkV2ZW50VG9TcGFuSnNvbihwcm9jZXNzZWRFdmVudCkpO1xuICAgICAgaWYgKCFwcm9jZXNzZWRSb290U3Bhbkpzb24pIHtcbiAgICAgICAgc2hvd1NwYW5Ecm9wV2FybmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIGV2ZW50IHdpdGggcHJvY2Vzc2VkIHJvb3Qgc3BhbiB2YWx1ZXNcbiAgICAgICAgcHJvY2Vzc2VkRXZlbnQgPSBtZXJnZShldmVudCwgY29udmVydFNwYW5Kc29uVG9UcmFuc2FjdGlvbkV2ZW50KHByb2Nlc3NlZFJvb3RTcGFuSnNvbikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIGNoaWxkIHNwYW5zXG4gICAgICBpZiAocHJvY2Vzc2VkRXZlbnQuc3BhbnMpIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkU3BhbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzcGFuIG9mIHByb2Nlc3NlZEV2ZW50LnNwYW5zKSB7XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkU3BhbiA9IGJlZm9yZVNlbmRTcGFuKHNwYW4pO1xuICAgICAgICAgIGlmICghcHJvY2Vzc2VkU3Bhbikge1xuICAgICAgICAgICAgc2hvd1NwYW5Ecm9wV2FybmluZygpO1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3BhbnMucHVzaChzcGFuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3BhbnMucHVzaChwcm9jZXNzZWRTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc2VkRXZlbnQuc3BhbnMgPSBwcm9jZXNzZWRTcGFucztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlU2VuZFRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAocHJvY2Vzc2VkRXZlbnQuc3BhbnMpIHtcbiAgICAgICAgLy8gV2Ugc3RvcmUgdGhlICMgb2Ygc3BhbnMgYmVmb3JlIHByb2Nlc3NpbmcgaW4gU0RLIG1ldGFkYXRhLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gY29tcGFyZSBpdCBhZnRlcndhcmRzIHRvIGRldGVybWluZSBob3cgbWFueSBzcGFucyB3ZXJlIGRyb3BwZWRcbiAgICAgICAgY29uc3Qgc3BhbkNvdW50QmVmb3JlID0gcHJvY2Vzc2VkRXZlbnQuc3BhbnMubGVuZ3RoO1xuICAgICAgICBwcm9jZXNzZWRFdmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgICAgICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgICAgICAgIHNwYW5Db3VudEJlZm9yZVByb2Nlc3Npbmc6IHNwYW5Db3VudEJlZm9yZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZWZvcmVTZW5kVHJhbnNhY3Rpb24ocHJvY2Vzc2VkRXZlbnQgLCBoaW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvY2Vzc2VkRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc1RyYW5zYWN0aW9uRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbic7XG59XG5cbi8qKiBFeHRyYWN0IHRyYWNlIGluZm9ybWF0aW9uIGZyb20gc2NvcGUgKi9cbmZ1bmN0aW9uIF9nZXRUcmFjZUluZm9Gcm9tU2NvcGUoXG4gIGNsaWVudCxcbiAgc2NvcGUsXG4pIHtcbiAgaWYgKCFzY29wZSkge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgY29uc3Qgc3BhbiA9IF9nZXRTcGFuRm9yU2NvcGUoc2NvcGUpO1xuICBjb25zdCB0cmFjZUNvbnRleHQgPSBzcGFuID8gc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pIDogZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IHNwYW5cbiAgICA/IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKVxuICAgIDogZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKTtcbiAgcmV0dXJuIFtkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUNvbnRleHRdO1xufVxuXG5leHBvcnQgeyBCYXNlQ2xpZW50LCBDbGllbnQsIF9nZXRUcmFjZUluZm9Gcm9tU2NvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXBcbiIsImltcG9ydCB7IGRzblRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvZHNuLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVudmVsb3BlIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgT1RFTCBsb2cgZW52ZWxvcGUgaXRlbSBmb3IgYSBzZXJpYWxpemVkIE9URUwgbG9nLlxuICpcbiAqIEBwYXJhbSBsb2cgLSBUaGUgc2VyaWFsaXplZCBPVEVMIGxvZyB0byBpbmNsdWRlIGluIHRoZSBlbnZlbG9wZS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIE9URUwgbG9nIGVudmVsb3BlIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU90ZWxMb2dFbnZlbG9wZUl0ZW0obG9nKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdHlwZTogJ290ZWxfbG9nJyxcbiAgICB9LFxuICAgIGxvZyxcbiAgXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVudmVsb3BlIGZvciBhIGxpc3Qgb2YgbG9ncy5cbiAqXG4gKiBAcGFyYW0gbG9ncyAtIFRoZSBsb2dzIHRvIGluY2x1ZGUgaW4gdGhlIGVudmVsb3BlLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIG1ldGFkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIGVudmVsb3BlLlxuICogQHBhcmFtIHR1bm5lbCAtIFRoZSB0dW5uZWwgdG8gaW5jbHVkZSBpbiB0aGUgZW52ZWxvcGUuXG4gKiBAcGFyYW0gZHNuIC0gVGhlIERTTiB0byBpbmNsdWRlIGluIHRoZSBlbnZlbG9wZS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGVudmVsb3BlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPdGVsTG9nRW52ZWxvcGUoXG4gIGxvZ3MsXG4gIG1ldGFkYXRhLFxuICB0dW5uZWwsXG4gIGRzbixcbikge1xuICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgaWYgKG1ldGFkYXRhPy5zZGspIHtcbiAgICBoZWFkZXJzLnNkayA9IHtcbiAgICAgIG5hbWU6IG1ldGFkYXRhLnNkay5uYW1lLFxuICAgICAgdmVyc2lvbjogbWV0YWRhdGEuc2RrLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIGlmICghIXR1bm5lbCAmJiAhIWRzbikge1xuICAgIGhlYWRlcnMuZHNuID0gZHNuVG9TdHJpbmcoZHNuKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbnZlbG9wZShoZWFkZXJzLCBsb2dzLm1hcChjcmVhdGVPdGVsTG9nRW52ZWxvcGVJdGVtKSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU90ZWxMb2dFbnZlbG9wZSwgY3JlYXRlT3RlbExvZ0VudmVsb3BlSXRlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52ZWxvcGUuanMubWFwXG4iLCJpbXBvcnQgeyBfZ2V0VHJhY2VJbmZvRnJvbVNjb3BlIH0gZnJvbSAnLi4vY2xpZW50LmpzJztcbmltcG9ydCB7IGdldENsaWVudCwgZ2V0Q3VycmVudFNjb3BlIH0gZnJvbSAnLi4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4uL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IFNFVkVSSVRZX1RFWFRfVE9fU0VWRVJJVFlfTlVNQkVSIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgX2dldFNwYW5Gb3JTY29wZSB9IGZyb20gJy4uL3V0aWxzL3NwYW5PblNjb3BlLmpzJztcbmltcG9ydCB7IGNyZWF0ZU90ZWxMb2dFbnZlbG9wZSB9IGZyb20gJy4vZW52ZWxvcGUuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGlzUGFyYW1ldGVyaXplZFN0cmluZyB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L2lzLmpzJztcblxuY29uc3QgTUFYX0xPR19CVUZGRVJfU0laRSA9IDEwMDtcblxuY29uc3QgQ0xJRU5UX1RPX0xPR19CVUZGRVJfTUFQID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGxvZyBhdHRyaWJ1dGUgdG8gYSBzZXJpYWxpemVkIGxvZyBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGxvZyBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGxvZyBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBsb2cgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBsb2dBdHRyaWJ1dGVUb1NlcmlhbGl6ZWRMb2dBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlOiB7IGRvdWJsZVZhbHVlOiB2YWx1ZSB9LFxuICAgICAgfTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWU6IHsgYm9vbFZhbHVlOiB2YWx1ZSB9LFxuICAgICAgfTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZTogeyBzdHJpbmdWYWx1ZTogdmFsdWUgfSxcbiAgICAgIH07XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBzdHJpbmdWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA/PyAnJztcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlOiB7IHN0cmluZ1ZhbHVlIH0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhcHR1cmVzIGEgbG9nIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2cgZXZlbnQgdG8gY2FwdHVyZS5cbiAqIEBwYXJhbSBzY29wZSAtIEEgc2NvcGUuIFVzZXMgdGhlIGN1cnJlbnQgc2NvcGUgaWYgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIGNsaWVudCAtIEEgY2xpZW50LiBVc2VzIHRoZSBjdXJyZW50IGNsaWVudCBpZiBub3QgcHJvdmlkZWQuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCB3aWxsIGV4cGVyaWVuY2UgYnJlYWtpbmcgY2hhbmdlcy4gVGhpcyBpcyBub3QgeWV0IHBhcnQgb2ZcbiAqIHRoZSBzdGFibGUgU2VudHJ5IFNESyBBUEkgYW5kIGNhbiBiZSBjaGFuZ2VkIG9yIHJlbW92ZWQgd2l0aG91dCB3YXJuaW5nLlxuICovXG5mdW5jdGlvbiBfSU5URVJOQUxfY2FwdHVyZUxvZyhcbiAgYmVmb3JlTG9nLFxuICBjbGllbnQgPSBnZXRDbGllbnQoKSxcbiAgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKSxcbikge1xuICBpZiAoIWNsaWVudCkge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKCdObyBjbGllbnQgYXZhaWxhYmxlIHRvIGNhcHR1cmUgbG9nLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHsgX2V4cGVyaW1lbnRzLCByZWxlYXNlLCBlbnZpcm9ubWVudCB9ID0gY2xpZW50LmdldE9wdGlvbnMoKTtcbiAgY29uc3QgeyBlbmFibGVMb2dzID0gZmFsc2UsIGJlZm9yZVNlbmRMb2cgfSA9IF9leHBlcmltZW50cyA/PyB7fTtcbiAgaWYgKCFlbmFibGVMb2dzKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ2xvZ2dpbmcgb3B0aW9uIG5vdCBlbmFibGVkLCBsb2cgd2lsbCBub3QgYmUgY2FwdHVyZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgWywgdHJhY2VDb250ZXh0XSA9IF9nZXRUcmFjZUluZm9Gcm9tU2NvcGUoY2xpZW50LCBzY29wZSk7XG5cbiAgY29uc3QgcHJvY2Vzc2VkTG9nQXR0cmlidXRlcyA9IHtcbiAgICAuLi5iZWZvcmVMb2cuYXR0cmlidXRlcyxcbiAgfTtcblxuICBpZiAocmVsZWFzZSkge1xuICAgIHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXNbJ3NlbnRyeS5yZWxlYXNlJ10gPSByZWxlYXNlO1xuICB9XG5cbiAgaWYgKGVudmlyb25tZW50KSB7XG4gICAgcHJvY2Vzc2VkTG9nQXR0cmlidXRlc1snc2VudHJ5LmVudmlyb25tZW50J10gPSBlbnZpcm9ubWVudDtcbiAgfVxuXG4gIGNvbnN0IHsgc2RrIH0gPSBjbGllbnQuZ2V0U2RrTWV0YWRhdGEoKSA/PyB7fTtcbiAgaWYgKHNkaykge1xuICAgIHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXNbJ3NlbnRyeS5zZGsubmFtZSddID0gc2RrLm5hbWU7XG4gICAgcHJvY2Vzc2VkTG9nQXR0cmlidXRlc1snc2VudHJ5LnNkay52ZXJzaW9uJ10gPSBzZGsudmVyc2lvbjtcbiAgfVxuXG4gIGNvbnN0IGJlZm9yZUxvZ01lc3NhZ2UgPSBiZWZvcmVMb2cubWVzc2FnZTtcbiAgaWYgKGlzUGFyYW1ldGVyaXplZFN0cmluZyhiZWZvcmVMb2dNZXNzYWdlKSkge1xuICAgIGNvbnN0IHsgX19zZW50cnlfdGVtcGxhdGVfc3RyaW5nX18sIF9fc2VudHJ5X3RlbXBsYXRlX3ZhbHVlc19fID0gW10gfSA9IGJlZm9yZUxvZ01lc3NhZ2U7XG4gICAgcHJvY2Vzc2VkTG9nQXR0cmlidXRlc1snc2VudHJ5Lm1lc3NhZ2UudGVtcGxhdGUnXSA9IF9fc2VudHJ5X3RlbXBsYXRlX3N0cmluZ19fO1xuICAgIF9fc2VudHJ5X3RlbXBsYXRlX3ZhbHVlc19fLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgcHJvY2Vzc2VkTG9nQXR0cmlidXRlc1tgc2VudHJ5Lm1lc3NhZ2UucGFyYW1ldGVyLiR7aW5kZXh9YF0gPSBwYXJhbTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBfZ2V0U3BhbkZvclNjb3BlKHNjb3BlKTtcbiAgaWYgKHNwYW4pIHtcbiAgICAvLyBBZGQgdGhlIHBhcmVudCBzcGFuIElEIHRvIHRoZSBsb2cgYXR0cmlidXRlcyBmb3IgdHJhY2UgY29udGV4dFxuICAgIHByb2Nlc3NlZExvZ0F0dHJpYnV0ZXNbJ3NlbnRyeS50cmFjZS5wYXJlbnRfc3Bhbl9pZCddID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgfVxuXG4gIGNvbnN0IHByb2Nlc3NlZExvZyA9IHsgLi4uYmVmb3JlTG9nLCBhdHRyaWJ1dGVzOiBwcm9jZXNzZWRMb2dBdHRyaWJ1dGVzIH07XG5cbiAgY2xpZW50LmVtaXQoJ2JlZm9yZUNhcHR1cmVMb2cnLCBwcm9jZXNzZWRMb2cpO1xuXG4gIGNvbnN0IGxvZyA9IGJlZm9yZVNlbmRMb2cgPyBiZWZvcmVTZW5kTG9nKHByb2Nlc3NlZExvZykgOiBwcm9jZXNzZWRMb2c7XG4gIGlmICghbG9nKSB7XG4gICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnbG9nX2l0ZW0nLCAxKTtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignYmVmb3JlU2VuZExvZyByZXR1cm5lZCBudWxsLCBsb2cgd2lsbCBub3QgYmUgY2FwdHVyZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeyBsZXZlbCwgbWVzc2FnZSwgYXR0cmlidXRlcyA9IHt9LCBzZXZlcml0eU51bWJlciB9ID0gbG9nO1xuXG4gIGNvbnN0IHNlcmlhbGl6ZWRMb2cgPSB7XG4gICAgc2V2ZXJpdHlUZXh0OiBsZXZlbCxcbiAgICBib2R5OiB7XG4gICAgICBzdHJpbmdWYWx1ZTogbWVzc2FnZSxcbiAgICB9LFxuICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBsb2dBdHRyaWJ1dGVUb1NlcmlhbGl6ZWRMb2dBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpLFxuICAgIHRpbWVVbml4TmFubzogYCR7bmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKX0wMDAwMDBgLFxuICAgIHRyYWNlSWQ6IHRyYWNlQ29udGV4dD8udHJhY2VfaWQsXG4gICAgc2V2ZXJpdHlOdW1iZXI6IHNldmVyaXR5TnVtYmVyID8/IFNFVkVSSVRZX1RFWFRfVE9fU0VWRVJJVFlfTlVNQkVSW2xldmVsXSxcbiAgfTtcblxuICBjb25zdCBsb2dCdWZmZXIgPSBDTElFTlRfVE9fTE9HX0JVRkZFUl9NQVAuZ2V0KGNsaWVudCk7XG4gIGlmIChsb2dCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIENMSUVOVF9UT19MT0dfQlVGRkVSX01BUC5zZXQoY2xpZW50LCBbc2VyaWFsaXplZExvZ10pO1xuICB9IGVsc2Uge1xuICAgIGxvZ0J1ZmZlci5wdXNoKHNlcmlhbGl6ZWRMb2cpO1xuICAgIGlmIChsb2dCdWZmZXIubGVuZ3RoID4gTUFYX0xPR19CVUZGRVJfU0laRSkge1xuICAgICAgX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcihjbGllbnQsIGxvZ0J1ZmZlcik7XG4gICAgfVxuICB9XG5cbiAgY2xpZW50LmVtaXQoJ2FmdGVyQ2FwdHVyZUxvZycsIGxvZyk7XG59XG5cbi8qKlxuICogRmx1c2hlcyB0aGUgbG9ncyBidWZmZXIgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBjbGllbnQgLSBBIGNsaWVudC5cbiAqIEBwYXJhbSBtYXliZUxvZ0J1ZmZlciAtIEEgbG9nIGJ1ZmZlci4gVXNlcyB0aGUgbG9nIGJ1ZmZlciBmb3IgdGhlIGdpdmVuIGNsaWVudCBpZiBub3QgcHJvdmlkZWQuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCB3aWxsIGV4cGVyaWVuY2UgYnJlYWtpbmcgY2hhbmdlcy4gVGhpcyBpcyBub3QgeWV0IHBhcnQgb2ZcbiAqIHRoZSBzdGFibGUgU2VudHJ5IFNESyBBUEkgYW5kIGNhbiBiZSBjaGFuZ2VkIG9yIHJlbW92ZWQgd2l0aG91dCB3YXJuaW5nLlxuICovXG5mdW5jdGlvbiBfSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyKGNsaWVudCwgbWF5YmVMb2dCdWZmZXIpIHtcbiAgY29uc3QgbG9nQnVmZmVyID0gbWF5YmVMb2dCdWZmZXIgPz8gQ0xJRU5UX1RPX0xPR19CVUZGRVJfTUFQLmdldChjbGllbnQpID8/IFtdO1xuICBpZiAobG9nQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuICBjb25zdCBlbnZlbG9wZSA9IGNyZWF0ZU90ZWxMb2dFbnZlbG9wZShsb2dCdWZmZXIsIGNsaWVudE9wdGlvbnMuX21ldGFkYXRhLCBjbGllbnRPcHRpb25zLnR1bm5lbCwgY2xpZW50LmdldERzbigpKTtcblxuICAvLyBDbGVhciB0aGUgbG9nIGJ1ZmZlciBhZnRlciBlbnZlbG9wZXMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkLlxuICBsb2dCdWZmZXIubGVuZ3RoID0gMDtcblxuICBjbGllbnQuZW1pdCgnZmx1c2hMb2dzJyk7XG5cbiAgLy8gc2VuZEVudmVsb3BlIHNob3VsZCBub3QgdGhyb3dcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICBjbGllbnQuc2VuZEVudmVsb3BlKGVudmVsb3BlKTtcbn1cblxuZXhwb3J0IHsgX0lOVEVSTkFMX2NhcHR1cmVMb2csIF9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIsIGxvZ0F0dHJpYnV0ZVRvU2VyaWFsaXplZExvZ0F0dHJpYnV0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwb3J0cy5qcy5tYXBcbiIsImltcG9ydCB7IFN5bmNQcm9taXNlLCByZXNvbHZlZFN5bmNQcm9taXNlLCByZWplY3RlZFN5bmNQcm9taXNlIH0gZnJvbSAnLi9zeW5jcHJvbWlzZS5qcyc7XG5cbmNvbnN0IFNFTlRSWV9CVUZGRVJfRlVMTF9FUlJPUiA9IFN5bWJvbC5mb3IoJ1NlbnRyeUJ1ZmZlckZ1bGxFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbmV3IFByb21pc2VCdWZmZXIgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBsaW1pdFxuICogQHBhcmFtIGxpbWl0IG1heCBudW1iZXIgb2YgcHJvbWlzZXMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHRoZSBidWZmZXJcbiAqL1xuZnVuY3Rpb24gbWFrZVByb21pc2VCdWZmZXIobGltaXQpIHtcbiAgY29uc3QgYnVmZmVyID0gW107XG5cbiAgZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gbGltaXQgPT09IHVuZGVmaW5lZCB8fCBidWZmZXIubGVuZ3RoIDwgbGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcHJvbWlzZSBmcm9tIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHRhc2sgQ2FuIGJlIGFueSBQcm9taXNlTGlrZTxUPlxuICAgKiBAcmV0dXJucyBSZW1vdmVkIHByb21pc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUodGFzaykge1xuICAgIHJldHVybiBidWZmZXIuc3BsaWNlKGJ1ZmZlci5pbmRleE9mKHRhc2spLCAxKVswXSB8fCBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwcm9taXNlIChyZXByZXNlbnRpbmcgYW4gaW4tZmxpZ2h0IGFjdGlvbikgdG8gdGhlIHF1ZXVlLCBhbmQgc2V0IGl0IHRvIHJlbW92ZSBpdHNlbGYgb24gZnVsZmlsbG1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB0YXNrUHJvZHVjZXIgQSBmdW5jdGlvbiBwcm9kdWNpbmcgYW55IFByb21pc2VMaWtlPFQ+OyBJbiBwcmV2aW91cyB2ZXJzaW9ucyB0aGlzIHVzZWQgdG8gYmUgYHRhc2s6XG4gICAqICAgICAgICBQcm9taXNlTGlrZTxUPmAsIGJ1dCB1bmRlciB0aGF0IG1vZGVsLCBQcm9taXNlcyB3ZXJlIGluc3RhbnRseSBjcmVhdGVkIG9uIHRoZSBjYWxsLXNpdGUgYW5kIHRoZWlyIGV4ZWN1dG9yXG4gICAqICAgICAgICBmdW5jdGlvbnMgdGhlcmVmb3JlIHJhbiBpbW1lZGlhdGVseS4gVGh1cywgZXZlbiBpZiB0aGUgYnVmZmVyIHdhcyBmdWxsLCB0aGUgYWN0aW9uIHN0aWxsIGhhcHBlbmVkLiBCeVxuICAgKiAgICAgICAgcmVxdWlyaW5nIHRoZSBwcm9taXNlIHRvIGJlIHdyYXBwZWQgaW4gYSBmdW5jdGlvbiwgd2UgY2FuIGRlZmVyIHByb21pc2UgY3JlYXRpb24gdW50aWwgYWZ0ZXIgdGhlIGJ1ZmZlclxuICAgKiAgICAgICAgbGltaXQgY2hlY2suXG4gICAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBwcm9taXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkKHRhc2tQcm9kdWNlcikge1xuICAgIGlmICghaXNSZWFkeSgpKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRTeW5jUHJvbWlzZShTRU5UUllfQlVGRkVSX0ZVTExfRVJST1IpO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IHRoZSB0YXNrIGFuZCBhZGQgaXRzIHByb21pc2UgdG8gdGhlIHF1ZXVlXG4gICAgY29uc3QgdGFzayA9IHRhc2tQcm9kdWNlcigpO1xuICAgIGlmIChidWZmZXIuaW5kZXhPZih0YXNrKSA9PT0gLTEpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKHRhc2spO1xuICAgIH1cbiAgICB2b2lkIHRhc2tcbiAgICAgIC50aGVuKCgpID0+IHJlbW92ZSh0YXNrKSlcbiAgICAgIC8vIFVzZSBgdGhlbihudWxsLCByZWplY3Rpb25IYW5kbGVyKWAgcmF0aGVyIHRoYW4gYGNhdGNoKHJlamVjdGlvbkhhbmRsZXIpYCBzbyB0aGF0IHdlIGNhbiB1c2UgYFByb21pc2VMaWtlYFxuICAgICAgLy8gcmF0aGVyIHRoYW4gYFByb21pc2VgLiBgUHJvbWlzZUxpa2VgIGRvZXNuJ3QgaGF2ZSBhIGAuY2F0Y2hgIG1ldGhvZCwgbWFraW5nIGl0cyBwb2x5ZmlsbCBzbWFsbGVyLiAoRVM1IGRpZG4ndFxuICAgICAgLy8gaGF2ZSBwcm9taXNlcywgc28gVFMgaGFzIHRvIHBvbHlmaWxsIHdoZW4gZG93bi1jb21waWxpbmcuKVxuICAgICAgLnRoZW4obnVsbCwgKCkgPT5cbiAgICAgICAgcmVtb3ZlKHRhc2spLnRoZW4obnVsbCwgKCkgPT4ge1xuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYWRkIGFub3RoZXIgY2F0Y2ggaGVyZSBiZWNhdXNlIGByZW1vdmUoKWAgc3RhcnRzIGEgbmV3IHByb21pc2UgY2hhaW4uXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICByZXR1cm4gdGFzaztcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlIHRvIHJlc29sdmUgb3IgZm9yIHRpbWVvdXQgdG8gZXhwaXJlLCB3aGljaGV2ZXIgY29tZXMgZmlyc3QuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRoZSB0aW1lLCBpbiBtcywgYWZ0ZXIgd2hpY2ggdG8gcmVzb2x2ZSB0byBgZmFsc2VgIGlmIHRoZSBxdWV1ZSBpcyBzdGlsbCBub24tZW1wdHkuIFBhc3NpbmcgYDBgIChvclxuICAgKiBub3QgcGFzc2luZyBhbnl0aGluZykgd2lsbCBtYWtlIHRoZSBwcm9taXNlIHdhaXQgYXMgbG9uZyBhcyBpdCB0YWtlcyBmb3IgdGhlIHF1ZXVlIHRvIGRyYWluIGJlZm9yZSByZXNvbHZpbmcgdG9cbiAgICogYHRydWVgLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgaXMgYWxyZWFkeSBlbXB0eSBvciBkcmFpbnMgYmVmb3JlIHRoZSB0aW1lb3V0LCBhbmRcbiAgICogYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGZ1bmN0aW9uIGRyYWluKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjb3VudGVyID0gYnVmZmVyLmxlbmd0aDtcblxuICAgICAgaWYgKCFjb3VudGVyKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyB3YWl0IGZvciBgdGltZW91dGAgbXMgYW5kIHRoZW4gcmVzb2x2ZSB0byBgZmFsc2VgIChpZiBub3QgY2FuY2VsbGVkIGZpcnN0KVxuICAgICAgY29uc3QgY2FwdHVyZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAvLyBpZiBhbGwgcHJvbWlzZXMgcmVzb2x2ZSBpbiB0aW1lLCBjYW5jZWwgdGhlIHRpbWVyIGFuZCByZXNvbHZlIHRvIGB0cnVlYFxuICAgICAgYnVmZmVyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIHZvaWQgcmVzb2x2ZWRTeW5jUHJvbWlzZShpdGVtKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAoIS0tY291bnRlcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNhcHR1cmVkU2V0VGltZW91dCk7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkOiBidWZmZXIsXG4gICAgYWRkLFxuICAgIGRyYWluLFxuICB9O1xufVxuXG5leHBvcnQgeyBTRU5UUllfQlVGRkVSX0ZVTExfRVJST1IsIG1ha2VQcm9taXNlQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlYnVmZmVyLmpzLm1hcFxuIiwiLy8gSW50ZW50aW9uYWxseSBrZWVwaW5nIHRoZSBrZXkgYnJvYWQsIGFzIHdlIGRvbid0IGtub3cgZm9yIHN1cmUgd2hhdCByYXRlIGxpbWl0IGhlYWRlcnMgZ2V0IHJldHVybmVkIGZyb20gYmFja2VuZFxuXG5jb25zdCBERUZBVUxUX1JFVFJZX0FGVEVSID0gNjAgKiAxMDAwOyAvLyA2MCBzZWNvbmRzXG5cbi8qKlxuICogRXh0cmFjdHMgUmV0cnktQWZ0ZXIgdmFsdWUgZnJvbSB0aGUgcmVxdWVzdCBoZWFkZXIgb3IgcmV0dXJucyBkZWZhdWx0IHZhbHVlXG4gKiBAcGFyYW0gaGVhZGVyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiAnUmV0cnktQWZ0ZXInIGhlYWRlclxuICogQHBhcmFtIG5vdyBjdXJyZW50IHVuaXggdGltZXN0YW1wXG4gKlxuICovXG5mdW5jdGlvbiBwYXJzZVJldHJ5QWZ0ZXJIZWFkZXIoaGVhZGVyLCBub3cgPSBEYXRlLm5vdygpKSB7XG4gIGNvbnN0IGhlYWRlckRlbGF5ID0gcGFyc2VJbnQoYCR7aGVhZGVyfWAsIDEwKTtcbiAgaWYgKCFpc05hTihoZWFkZXJEZWxheSkpIHtcbiAgICByZXR1cm4gaGVhZGVyRGVsYXkgKiAxMDAwO1xuICB9XG5cbiAgY29uc3QgaGVhZGVyRGF0ZSA9IERhdGUucGFyc2UoYCR7aGVhZGVyfWApO1xuICBpZiAoIWlzTmFOKGhlYWRlckRhdGUpKSB7XG4gICAgcmV0dXJuIGhlYWRlckRhdGUgLSBub3c7XG4gIH1cblxuICByZXR1cm4gREVGQVVMVF9SRVRSWV9BRlRFUjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lIHRoYXQgdGhlIGdpdmVuIGNhdGVnb3J5IGlzIGRpc2FibGVkIHVudGlsIGZvciByYXRlIGxpbWl0aW5nLlxuICogSW4gY2FzZSBubyBjYXRlZ29yeS1zcGVjaWZpYyBsaW1pdCBpcyBzZXQgYnV0IGEgZ2VuZXJhbCByYXRlIGxpbWl0IGFjcm9zcyBhbGwgY2F0ZWdvcmllcyBpcyBhY3RpdmUsXG4gKiB0aGF0IHRpbWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHJldHVybiB0aGUgdGltZSBpbiBtcyB0aGF0IHRoZSBjYXRlZ29yeSBpcyBkaXNhYmxlZCB1bnRpbCBvciAwIGlmIHRoZXJlJ3Mgbm8gYWN0aXZlIHJhdGUgbGltaXQuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVkVW50aWwobGltaXRzLCBkYXRhQ2F0ZWdvcnkpIHtcbiAgcmV0dXJuIGxpbWl0c1tkYXRhQ2F0ZWdvcnldIHx8IGxpbWl0cy5hbGwgfHwgMDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjYXRlZ29yeSBpcyByYXRlIGxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gaXNSYXRlTGltaXRlZChsaW1pdHMsIGRhdGFDYXRlZ29yeSwgbm93ID0gRGF0ZS5ub3coKSkge1xuICByZXR1cm4gZGlzYWJsZWRVbnRpbChsaW1pdHMsIGRhdGFDYXRlZ29yeSkgPiBub3c7XG59XG5cbi8qKlxuICogVXBkYXRlIHJhdGVsaW1pdHMgZnJvbSBpbmNvbWluZyBoZWFkZXJzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgUmF0ZUxpbWl0cyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVJhdGVMaW1pdHMoXG4gIGxpbWl0cyxcbiAgeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0sXG4gIG5vdyA9IERhdGUubm93KCksXG4pIHtcbiAgY29uc3QgdXBkYXRlZFJhdGVMaW1pdHMgPSB7XG4gICAgLi4ubGltaXRzLFxuICB9O1xuXG4gIC8vIFwiVGhlIG5hbWUgaXMgY2FzZS1pbnNlbnNpdGl2ZS5cIlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGVhZGVycy9nZXRcbiAgY29uc3QgcmF0ZUxpbWl0SGVhZGVyID0gaGVhZGVycz8uWyd4LXNlbnRyeS1yYXRlLWxpbWl0cyddO1xuICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gaGVhZGVycz8uWydyZXRyeS1hZnRlciddO1xuXG4gIGlmIChyYXRlTGltaXRIZWFkZXIpIHtcbiAgICAvKipcbiAgICAgKiByYXRlIGxpbWl0IGhlYWRlcnMgYXJlIG9mIHRoZSBmb3JtXG4gICAgICogICAgIDxoZWFkZXI+LDxoZWFkZXI+LC4uXG4gICAgICogd2hlcmUgZWFjaCA8aGVhZGVyPiBpcyBvZiB0aGUgZm9ybVxuICAgICAqICAgICA8cmV0cnlfYWZ0ZXI+OiA8Y2F0ZWdvcmllcz46IDxzY29wZT46IDxyZWFzb25fY29kZT46IDxuYW1lc3BhY2VzPlxuICAgICAqIHdoZXJlXG4gICAgICogICAgIDxyZXRyeV9hZnRlcj4gaXMgYSBkZWxheSBpbiBzZWNvbmRzXG4gICAgICogICAgIDxjYXRlZ29yaWVzPiBpcyB0aGUgZXZlbnQgdHlwZShzKSAoZXJyb3IsIHRyYW5zYWN0aW9uLCBldGMpIGJlaW5nIHJhdGUgbGltaXRlZCBhbmQgaXMgb2YgdGhlIGZvcm1cbiAgICAgKiAgICAgICAgIDxjYXRlZ29yeT47PGNhdGVnb3J5PjsuLi5cbiAgICAgKiAgICAgPHNjb3BlPiBpcyB3aGF0J3MgYmVpbmcgbGltaXRlZCAob3JnLCBwcm9qZWN0LCBvciBrZXkpIC0gaWdub3JlZCBieSBTREtcbiAgICAgKiAgICAgPHJlYXNvbl9jb2RlPiBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nIGxpa2UgXCJvcmdfcXVvdGFcIiAtIGlnbm9yZWQgYnkgU0RLXG4gICAgICogICAgIDxuYW1lc3BhY2VzPiBTZW1pY29sb24tc2VwYXJhdGVkIGxpc3Qgb2YgbWV0cmljIG5hbWVzcGFjZSBpZGVudGlmaWVycy4gRGVmaW5lcyB3aGljaCBuYW1lc3BhY2Uocykgd2lsbCBiZSBhZmZlY3RlZC5cbiAgICAgKiAgICAgICAgIE9ubHkgcHJlc2VudCBpZiByYXRlIGxpbWl0IGFwcGxpZXMgdG8gdGhlIG1ldHJpY19idWNrZXQgZGF0YSBjYXRlZ29yeS5cbiAgICAgKi9cbiAgICBmb3IgKGNvbnN0IGxpbWl0IG9mIHJhdGVMaW1pdEhlYWRlci50cmltKCkuc3BsaXQoJywnKSkge1xuICAgICAgY29uc3QgW3JldHJ5QWZ0ZXIsIGNhdGVnb3JpZXMsICwgLCBuYW1lc3BhY2VzXSA9IGxpbWl0LnNwbGl0KCc6JywgNSkgO1xuICAgICAgY29uc3QgaGVhZGVyRGVsYXkgPSBwYXJzZUludChyZXRyeUFmdGVyLCAxMCk7XG4gICAgICBjb25zdCBkZWxheSA9ICghaXNOYU4oaGVhZGVyRGVsYXkpID8gaGVhZGVyRGVsYXkgOiA2MCkgKiAxMDAwOyAvLyA2MHNlYyBkZWZhdWx0XG4gICAgICBpZiAoIWNhdGVnb3JpZXMpIHtcbiAgICAgICAgdXBkYXRlZFJhdGVMaW1pdHMuYWxsID0gbm93ICsgZGVsYXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGVnb3JpZXMuc3BsaXQoJzsnKSkge1xuICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ21ldHJpY19idWNrZXQnKSB7XG4gICAgICAgICAgICAvLyBuYW1lc3BhY2VzIHdpbGwgYmUgcHJlc2VudCB3aGVuIGNhdGVnb3J5ID09PSAnbWV0cmljX2J1Y2tldCdcbiAgICAgICAgICAgIGlmICghbmFtZXNwYWNlcyB8fCBuYW1lc3BhY2VzLnNwbGl0KCc7JykuaW5jbHVkZXMoJ2N1c3RvbScpKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRSYXRlTGltaXRzW2NhdGVnb3J5XSA9IG5vdyArIGRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVkUmF0ZUxpbWl0c1tjYXRlZ29yeV0gPSBub3cgKyBkZWxheTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmV0cnlBZnRlckhlYWRlcikge1xuICAgIHVwZGF0ZWRSYXRlTGltaXRzLmFsbCA9IG5vdyArIHBhcnNlUmV0cnlBZnRlckhlYWRlcihyZXRyeUFmdGVySGVhZGVyLCBub3cpO1xuICB9IGVsc2UgaWYgKHN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgIHVwZGF0ZWRSYXRlTGltaXRzLmFsbCA9IG5vdyArIDYwICogMTAwMDtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkUmF0ZUxpbWl0cztcbn1cblxuZXhwb3J0IHsgREVGQVVMVF9SRVRSWV9BRlRFUiwgZGlzYWJsZWRVbnRpbCwgaXNSYXRlTGltaXRlZCwgcGFyc2VSZXRyeUFmdGVySGVhZGVyLCB1cGRhdGVSYXRlTGltaXRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRlbGltaXQuanMubWFwXG4iLCJpbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4uL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IGZvckVhY2hFbnZlbG9wZUl0ZW0sIGVudmVsb3BlSXRlbVR5cGVUb0RhdGFDYXRlZ29yeSwgY3JlYXRlRW52ZWxvcGUsIHNlcmlhbGl6ZUVudmVsb3BlIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvZW52ZWxvcGUuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IG1ha2VQcm9taXNlQnVmZmVyLCBTRU5UUllfQlVGRkVSX0ZVTExfRVJST1IgfSBmcm9tICcuLi91dGlscy1ob2lzdC9wcm9taXNlYnVmZmVyLmpzJztcbmltcG9ydCB7IGlzUmF0ZUxpbWl0ZWQsIHVwZGF0ZVJhdGVMaW1pdHMgfSBmcm9tICcuLi91dGlscy1ob2lzdC9yYXRlbGltaXQuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZWRTeW5jUHJvbWlzZSB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L3N5bmNwcm9taXNlLmpzJztcblxuY29uc3QgREVGQVVMVF9UUkFOU1BPUlRfQlVGRkVSX1NJWkUgPSA2NDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgU2VudHJ5IGBUcmFuc3BvcnRgXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBtYWtlUmVxdWVzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc3BvcnQoXG4gIG9wdGlvbnMsXG4gIG1ha2VSZXF1ZXN0LFxuICBidWZmZXIgPSBtYWtlUHJvbWlzZUJ1ZmZlcihcbiAgICBvcHRpb25zLmJ1ZmZlclNpemUgfHwgREVGQVVMVF9UUkFOU1BPUlRfQlVGRkVSX1NJWkUsXG4gICksXG4pIHtcbiAgbGV0IHJhdGVMaW1pdHMgPSB7fTtcbiAgY29uc3QgZmx1c2ggPSAodGltZW91dCkgPT4gYnVmZmVyLmRyYWluKHRpbWVvdXQpO1xuXG4gIGZ1bmN0aW9uIHNlbmQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCBmaWx0ZXJlZEVudmVsb3BlSXRlbXMgPSBbXTtcblxuICAgIC8vIERyb3AgcmF0ZSBsaW1pdGVkIGl0ZW1zIGZyb20gZW52ZWxvcGVcbiAgICBmb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlLCAoaXRlbSwgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgZGF0YUNhdGVnb3J5ID0gZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5KHR5cGUpO1xuICAgICAgaWYgKGlzUmF0ZUxpbWl0ZWQocmF0ZUxpbWl0cywgZGF0YUNhdGVnb3J5KSkge1xuICAgICAgICBvcHRpb25zLnJlY29yZERyb3BwZWRFdmVudCgncmF0ZWxpbWl0X2JhY2tvZmYnLCBkYXRhQ2F0ZWdvcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyZWRFbnZlbG9wZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTa2lwIHNlbmRpbmcgaWYgZW52ZWxvcGUgaXMgZW1wdHkgYWZ0ZXIgZmlsdGVyaW5nIG91dCByYXRlIGxpbWl0ZWQgZXZlbnRzXG4gICAgaWYgKGZpbHRlcmVkRW52ZWxvcGVJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKHt9KTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZEVudmVsb3BlID0gY3JlYXRlRW52ZWxvcGUoZW52ZWxvcGVbMF0sIGZpbHRlcmVkRW52ZWxvcGVJdGVtcyApO1xuXG4gICAgLy8gQ3JlYXRlcyBjbGllbnQgcmVwb3J0IGZvciBlYWNoIGl0ZW0gaW4gYW4gZW52ZWxvcGVcbiAgICBjb25zdCByZWNvcmRFbnZlbG9wZUxvc3MgPSAocmVhc29uKSA9PiB7XG4gICAgICBmb3JFYWNoRW52ZWxvcGVJdGVtKGZpbHRlcmVkRW52ZWxvcGUsIChpdGVtLCB0eXBlKSA9PiB7XG4gICAgICAgIG9wdGlvbnMucmVjb3JkRHJvcHBlZEV2ZW50KHJlYXNvbiwgZW52ZWxvcGVJdGVtVHlwZVRvRGF0YUNhdGVnb3J5KHR5cGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0VGFzayA9ICgpID0+XG4gICAgICBtYWtlUmVxdWVzdCh7IGJvZHk6IHNlcmlhbGl6ZUVudmVsb3BlKGZpbHRlcmVkRW52ZWxvcGUpIH0pLnRoZW4oXG4gICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRocm93IG9uIE5PSyByZXNwb25zZXMsIGJ1dCB3ZSB3YW50IHRvIGF0IGxlYXN0IGxvZyB0aGVtXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IHVuZGVmaW5lZCAmJiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkpIHtcbiAgICAgICAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKGBTZW50cnkgcmVzcG9uZGVkIHdpdGggc3RhdHVzIGNvZGUgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSB0byBzZW50IGV2ZW50LmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhdGVMaW1pdHMgPSB1cGRhdGVSYXRlTGltaXRzKHJhdGVMaW1pdHMsIHJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICByZWNvcmRFbnZlbG9wZUxvc3MoJ25ldHdvcmtfZXJyb3InKTtcbiAgICAgICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXJyb3IoJ0VuY291bnRlcmVkIGVycm9yIHJ1bm5pbmcgdHJhbnNwb3J0IHJlcXVlc3Q6JywgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgIHJldHVybiBidWZmZXIuYWRkKHJlcXVlc3RUYXNrKS50aGVuKFxuICAgICAgcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yID09PSBTRU5UUllfQlVGRkVSX0ZVTExfRVJST1IpIHtcbiAgICAgICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXJyb3IoJ1NraXBwZWQgc2VuZGluZyBldmVudCBiZWNhdXNlIGJ1ZmZlciBpcyBmdWxsLicpO1xuICAgICAgICAgIHJlY29yZEVudmVsb3BlTG9zcygncXVldWVfb3ZlcmZsb3cnKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBmbHVzaCxcbiAgfTtcbn1cblxuZXhwb3J0IHsgREVGQVVMVF9UUkFOU1BPUlRfQlVGRkVSX1NJWkUsIGNyZWF0ZVRyYW5zcG9ydCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiIsIi8vIEJ5IGRlZmF1bHQsIHdlIHdhbnQgdG8gaW5mZXIgdGhlIElQIGFkZHJlc3MsIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBudWxsYFxuLy8gV2UgZG8gdGhpcyBhZnRlciBhbGwgb3RoZXIgcHJvY2Vzc2luZyBpcyBkb25lXG4vLyBJZiBgaXBfYWRkcmVzc2AgaXMgZXhwbGljaXRseSBzZXQgdG8gYG51bGxgIG9yIGEgdmFsdWUsIHdlIGxlYXZlIGl0IGFzIGlzXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFkZEF1dG9JcEFkZHJlc3NUb1VzZXIob2JqV2l0aE1heWJlVXNlcikge1xuICBpZiAob2JqV2l0aE1heWJlVXNlci51c2VyPy5pcF9hZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICBvYmpXaXRoTWF5YmVVc2VyLnVzZXIgPSB7XG4gICAgICAuLi5vYmpXaXRoTWF5YmVVc2VyLnVzZXIsXG4gICAgICBpcF9hZGRyZXNzOiAne3thdXRvfX0nLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYWRkQXV0b0lwQWRkcmVzc1RvU2Vzc2lvbihzZXNzaW9uKSB7XG4gIGlmICgnYWdncmVnYXRlcycgaW4gc2Vzc2lvbikge1xuICAgIGlmIChzZXNzaW9uLmF0dHJzPy5bJ2lwX2FkZHJlc3MnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXNzaW9uLmF0dHJzID0ge1xuICAgICAgICAuLi5zZXNzaW9uLmF0dHJzLFxuICAgICAgICBpcF9hZGRyZXNzOiAne3thdXRvfX0nLFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNlc3Npb24uaXBBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlc3Npb24uaXBBZGRyZXNzID0gJ3t7YXV0b319JztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgYWRkQXV0b0lwQWRkcmVzc1RvU2Vzc2lvbiwgYWRkQXV0b0lwQWRkcmVzc1RvVXNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXBBZGRyZXNzLmpzLm1hcFxuIiwiaW1wb3J0IHsgU0RLX1ZFUlNJT04gfSBmcm9tICcuLi91dGlscy1ob2lzdC92ZXJzaW9uLmpzJztcblxuLyoqXG4gKiBBIGJ1aWxkZXIgZm9yIHRoZSBTREsgbWV0YWRhdGEgaW4gdGhlIG9wdGlvbnMgZm9yIHRoZSBTREsgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBpZGVudGljYWwgdG8gYGJ1aWxkTWV0YWRhdGFgIGluIFJlbWl4IGFuZCBOZXh0SlMgYW5kIFN2ZWx0ZUtpdC5cbiAqIFdlIGRvbid0IGV4dHJhY3QgaXQgZm9yIGJ1bmRsZSBzaXplIHJlYXNvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvcHVsbC83NDA0XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvcHVsbC80MTk2XG4gKlxuICogSWYgeW91IG1ha2UgY2hhbmdlcyB0byB0aGlzIGZ1bmN0aW9uIGNvbnNpZGVyIHVwZGF0aW5nIHRoZSBvdGhlcnMgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBTREsgb3B0aW9ucyBvYmplY3QgdGhhdCBnZXRzIG11dGF0ZWRcbiAqIEBwYXJhbSBuYW1lcyBsaXN0IG9mIHBhY2thZ2UgbmFtZXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTZGtNZXRhZGF0YShvcHRpb25zLCBuYW1lLCBuYW1lcyA9IFtuYW1lXSwgc291cmNlID0gJ25wbScpIHtcbiAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLl9tZXRhZGF0YSB8fCB7fTtcblxuICBpZiAoIW1ldGFkYXRhLnNkaykge1xuICAgIG1ldGFkYXRhLnNkayA9IHtcbiAgICAgIG5hbWU6IGBzZW50cnkuamF2YXNjcmlwdC4ke25hbWV9YCxcbiAgICAgIHBhY2thZ2VzOiBuYW1lcy5tYXAobmFtZSA9PiAoe1xuICAgICAgICBuYW1lOiBgJHtzb3VyY2V9OkBzZW50cnkvJHtuYW1lfWAsXG4gICAgICAgIHZlcnNpb246IFNES19WRVJTSU9OLFxuICAgICAgfSkpLFxuICAgICAgdmVyc2lvbjogU0RLX1ZFUlNJT04sXG4gICAgfTtcbiAgfVxuXG4gIG9wdGlvbnMuX21ldGFkYXRhID0gbWV0YWRhdGE7XG59XG5cbmV4cG9ydCB7IGFwcGx5U2RrTWV0YWRhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNka01ldGFkYXRhLmpzLm1hcFxuIiwiaW1wb3J0IHsgZ2V0Q2xpZW50LCBnZXRJc29sYXRpb25TY29wZSB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBjb25zb2xlU2FuZGJveCB9IGZyb20gJy4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGRhdGVUaW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICcuL3V0aWxzLWhvaXN0L3RpbWUuanMnO1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSBudW1iZXIgb2YgYnJlYWRjcnVtYnMgYWRkZWQgdG8gYW4gZXZlbnQuIENhbiBiZSBvdmVyd3JpdHRlblxuICogd2l0aCB7QGxpbmsgT3B0aW9ucy5tYXhCcmVhZGNydW1ic30uXG4gKi9cbmNvbnN0IERFRkFVTFRfQlJFQURDUlVNQlMgPSAxMDA7XG5cbi8qKlxuICogUmVjb3JkcyBhIG5ldyBicmVhZGNydW1iIHdoaWNoIHdpbGwgYmUgYXR0YWNoZWQgdG8gZnV0dXJlIGV2ZW50cy5cbiAqXG4gKiBCcmVhZGNydW1icyB3aWxsIGJlIGFkZGVkIHRvIHN1YnNlcXVlbnQgZXZlbnRzIHRvIHByb3ZpZGUgbW9yZSBjb250ZXh0IG9uXG4gKiB1c2VyJ3MgYWN0aW9ucyBwcmlvciB0byBhbiBlcnJvciBvciBjcmFzaC5cbiAqL1xuZnVuY3Rpb24gYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBjb25zdCBpc29sYXRpb25TY29wZSA9IGdldElzb2xhdGlvblNjb3BlKCk7XG5cbiAgaWYgKCFjbGllbnQpIHJldHVybjtcblxuICBjb25zdCB7IGJlZm9yZUJyZWFkY3J1bWIgPSBudWxsLCBtYXhCcmVhZGNydW1icyA9IERFRkFVTFRfQlJFQURDUlVNQlMgfSA9IGNsaWVudC5nZXRPcHRpb25zKCk7XG5cbiAgaWYgKG1heEJyZWFkY3J1bWJzIDw9IDApIHJldHVybjtcblxuICBjb25zdCB0aW1lc3RhbXAgPSBkYXRlVGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWIgPSB7IHRpbWVzdGFtcCwgLi4uYnJlYWRjcnVtYiB9O1xuICBjb25zdCBmaW5hbEJyZWFkY3J1bWIgPSBiZWZvcmVCcmVhZGNydW1iXG4gICAgPyAoY29uc29sZVNhbmRib3goKCkgPT4gYmVmb3JlQnJlYWRjcnVtYihtZXJnZWRCcmVhZGNydW1iLCBoaW50KSkgKVxuICAgIDogbWVyZ2VkQnJlYWRjcnVtYjtcblxuICBpZiAoZmluYWxCcmVhZGNydW1iID09PSBudWxsKSByZXR1cm47XG5cbiAgaWYgKGNsaWVudC5lbWl0KSB7XG4gICAgY2xpZW50LmVtaXQoJ2JlZm9yZUFkZEJyZWFkY3J1bWInLCBmaW5hbEJyZWFkY3J1bWIsIGhpbnQpO1xuICB9XG5cbiAgaXNvbGF0aW9uU2NvcGUuYWRkQnJlYWRjcnVtYihmaW5hbEJyZWFkY3J1bWIsIG1heEJyZWFkY3J1bWJzKTtcbn1cblxuZXhwb3J0IHsgYWRkQnJlYWRjcnVtYiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJlYWRjcnVtYnMuanMubWFwXG4iLCJpbXBvcnQgeyBnZXRDbGllbnQgfSBmcm9tICcuLi9jdXJyZW50U2NvcGVzLmpzJztcbmltcG9ydCB7IGRlZmluZUludGVncmF0aW9uIH0gZnJvbSAnLi4vaW50ZWdyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0T3JpZ2luYWxGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L29iamVjdC5qcyc7XG5cbmxldCBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmc7XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnRnVuY3Rpb25Ub1N0cmluZyc7XG5cbmNvbnN0IFNFVFVQX0NMSUVOVFMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBfZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uID0gKCgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwT25jZSgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuICAgICAgLy8gaW50cmluc2ljcyAobGlrZSBGdW5jdGlvbi5wcm90b3R5cGUpIG1pZ2h0IGJlIGltbXV0YWJsZSBpbiBzb21lIGVudmlyb25tZW50c1xuICAgICAgLy8gZS5nLiBOb2RlIHdpdGggLS1mcm96ZW4taW50cmluc2ljcywgWFMgKGFuIGVtYmVkZGVkIEphdmFTY3JpcHQgZW5naW5lKSBvciBTRVMgKGEgSmF2YVNjcmlwdCBwcm9wb3NhbClcbiAgICAgIHRyeSB7XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICggLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRnVuY3Rpb24gPSBnZXRPcmlnaW5hbEZ1bmN0aW9uKHRoaXMpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPVxuICAgICAgICAgICAgU0VUVVBfQ0xJRU5UUy5oYXMoZ2V0Q2xpZW50KCkgKSAmJiBvcmlnaW5hbEZ1bmN0aW9uICE9PSB1bmRlZmluZWQgPyBvcmlnaW5hbEZ1bmN0aW9uIDogdGhpcztcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaGVyZSwganVzdCBkb24ndCBwYXRjaCB0aGlzXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXR1cChjbGllbnQpIHtcbiAgICAgIFNFVFVQX0NMSUVOVFMuc2V0KGNsaWVudCwgdHJ1ZSk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuLyoqXG4gKiBQYXRjaCB0b1N0cmluZyBjYWxscyB0byByZXR1cm4gcHJvcGVyIG5hbWUgZm9yIHdyYXBwZWQgZnVuY3Rpb25zLlxuICpcbiAqIGBgYGpzXG4gKiBTZW50cnkuaW5pdCh7XG4gKiAgIGludGVncmF0aW9uczogW1xuICogICAgIGZ1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbigpLFxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuY29uc3QgZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uID0gZGVmaW5lSW50ZWdyYXRpb24oX2Z1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbik7XG5cbmV4cG9ydCB7IGZ1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb250b3N0cmluZy5qcy5tYXBcbiIsImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgZGVmaW5lSW50ZWdyYXRpb24gfSBmcm9tICcuLi9pbnRlZ3JhdGlvbi5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy1ob2lzdC9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RXZlbnREZXNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L21pc2MuanMnO1xuaW1wb3J0IHsgc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3Qvc3RyaW5nLmpzJztcbmltcG9ydCB7IGdldFBvc3NpYmxlRXZlbnRNZXNzYWdlcyB9IGZyb20gJy4uL3V0aWxzL2V2ZW50VXRpbHMuanMnO1xuXG4vLyBcIlNjcmlwdCBlcnJvci5cIiBpcyBoYXJkIGNvZGVkIGludG8gYnJvd3NlcnMgZm9yIGVycm9ycyB0aGF0IGl0IGNhbid0IHJlYWQuXG4vLyB0aGlzIGlzIHRoZSByZXN1bHQgb2YgYSBzY3JpcHQgYmVpbmcgcHVsbGVkIGluIGZyb20gYW4gZXh0ZXJuYWwgZG9tYWluIGFuZCBDT1JTLlxuY29uc3QgREVGQVVMVF9JR05PUkVfRVJST1JTID0gW1xuICAvXlNjcmlwdCBlcnJvclxcLj8kLyxcbiAgL15KYXZhc2NyaXB0IGVycm9yOiBTY3JpcHQgZXJyb3JcXC4/IG9uIGxpbmUgMCQvLFxuICAvXlJlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4kLywgLy8gVGhlIGJyb3dzZXIgbG9ncyB0aGlzIHdoZW4gYSBSZXNpemVPYnNlcnZlciBoYW5kbGVyIHRha2VzIGEgYml0IGxvbmdlci4gVXN1YWxseSB0aGlzIGlzIG5vdCBhbiBhY3R1YWwgaXNzdWUgdGhvdWdoLiBJdCBpbmRpY2F0ZXMgc2xvd25lc3MuXG4gIC9eQ2Fubm90IHJlZGVmaW5lIHByb3BlcnR5OiBnb29nbGV0YWckLywgLy8gVGhpcyBpcyB0aHJvd24gd2hlbiBnb29nbGUgdGFnIG1hbmFnZXIgaXMgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGFuIGFkIGJsb2NrZXJcbiAgL15DYW4ndCBmaW5kIHZhcmlhYmxlOiBnbW8kLywgLy8gRXJyb3IgZnJvbSBHb29nbGUgU2VhcmNoIEFwcCBodHRwczovL2lzc3VldHJhY2tlci5nb29nbGUuY29tL2lzc3Vlcy8zOTYwNDMzMzFcbiAgL151bmRlZmluZWQgaXMgbm90IGFuIG9iamVjdCBcXChldmFsdWF0aW5nICdhXFwuW0EtWl0nXFwpJC8sIC8vIFJhbmRvbSBlcnJvciB0aGF0IGhhcHBlbnMgYnV0IG5vdCBhY3Rpb25hYmxlIG9yIG5vdGljZWFibGUgdG8gZW5kLXVzZXJzLlxuICAnY2FuXFwndCByZWRlZmluZSBub24tY29uZmlndXJhYmxlIHByb3BlcnR5IFwic29sYW5hXCInLCAvLyBQcm9iYWJseSBhIGJyb3dzZXIgZXh0ZW5zaW9uIG9yIGN1c3RvbSBicm93c2VyIChCcmF2ZSkgdGhyb3dpbmcgdGhpcyBlcnJvclxuICBcInZ2KCkuZ2V0UmVzdHJpY3Rpb25zIGlzIG5vdCBhIGZ1bmN0aW9uLiAoSW4gJ3Z2KCkuZ2V0UmVzdHJpY3Rpb25zKDEsYSknLCAndnYoKS5nZXRSZXN0cmljdGlvbnMnIGlzIHVuZGVmaW5lZClcIiwgLy8gRXJyb3IgdGhyb3duIGJ5IEdUTSwgc2VlbWluZ2x5IG5vdCBhZmZlY3RpbmcgZW5kLXVzZXJzXG4gIFwiQ2FuJ3QgZmluZCB2YXJpYWJsZTogX0F1dG9maWxsQ2FsbGJhY2tIYW5kbGVyXCIsIC8vIFVuYWN0aW9uYWJsZSBlcnJvciBpbiBpbnN0YWdyYW0gd2VidmlldyBodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL2NvbW11bml0eS90aHJlYWRzLzMyMDAxMzU0OTc5MTE0MS9cbiAgL15Ob24tRXJyb3IgcHJvbWlzZSByZWplY3Rpb24gY2FwdHVyZWQgd2l0aCB2YWx1ZTogT2JqZWN0IE5vdCBGb3VuZCBNYXRjaGluZyBJZDpcXGQrLCBNZXRob2ROYW1lOnNpbXVsYXRlRXZlbnQsIFBhcmFtQ291bnQ6XFxkKyQvLCAvLyB1bmFjdGlvbmFibGUgZXJyb3IgZnJvbSBDRUZTaGFycCwgYSAuTkVUIGxpYnJhcnkgdGhhdCBlbWJlZHMgY2hyb21pdW0gaW4gLk5FVCBhcHBzXG4gIC9eSmF2YSBleGNlcHRpb24gd2FzIHJhaXNlZCBkdXJpbmcgbWV0aG9kIGludm9jYXRpb24kLywgLy8gZXJyb3IgZnJvbSBGYWNlYm9vayBNb2JpbGUgYnJvd3NlciAoaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMTUwNjUpXG5dO1xuXG4vKiogT3B0aW9ucyBmb3IgdGhlIEV2ZW50RmlsdGVycyBpbnRlZ3JhdGlvbiAqL1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0V2ZW50RmlsdGVycyc7XG5cbi8qKlxuICogQW4gaW50ZWdyYXRpb24gdGhhdCBmaWx0ZXJzIG91dCBldmVudHMgKGVycm9ycyBhbmQgdHJhbnNhY3Rpb25zKSBiYXNlZCBvbjpcbiAqXG4gKiAtIChFcnJvcnMpIEEgY3VyYXRlZCBsaXN0IG9mIGtub3duIGxvdy12YWx1ZSBvciBpcnJlbGV2YW50IGVycm9ycyAoc2VlIHtAbGluayBERUZBVUxUX0lHTk9SRV9FUlJPUlN9KVxuICogLSAoRXJyb3JzKSBBIGxpc3Qgb2YgZXJyb3IgbWVzc2FnZXMgb3IgdXJscy9maWxlbmFtZXMgcGFzc2VkIGluIHZpYVxuICogICAtIFRvcCBsZXZlbCBTZW50cnkuaW5pdCBvcHRpb25zIChgaWdub3JlRXJyb3JzYCwgYGRlbnlVcmxzYCwgYGFsbG93VXJsc2ApXG4gKiAgIC0gVGhlIHNhbWUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGludGVncmF0aW9uIGRpcmVjdGx5IHZpYSBAcGFyYW0gb3B0aW9uc1xuICogLSAoVHJhbnNhY3Rpb25zL1NwYW5zKSBBIGxpc3Qgb2Ygcm9vdCBzcGFuICh0cmFuc2FjdGlvbikgbmFtZXMgcGFzc2VkIGluIHZpYVxuICogICAtIFRvcCBsZXZlbCBTZW50cnkuaW5pdCBvcHRpb24gKGBpZ25vcmVUcmFuc2FjdGlvbnNgKVxuICogICAtIFRoZSBzYW1lIG9wdGlvbiBwYXNzZWQgdG8gdGhlIGludGVncmF0aW9uIGRpcmVjdGx5IHZpYSBAcGFyYW0gb3B0aW9uc1xuICpcbiAqIEV2ZW50cyBmaWx0ZXJlZCBieSB0aGlzIGludGVncmF0aW9uIHdpbGwgbm90IGJlIHNlbnQgdG8gU2VudHJ5LlxuICovXG5jb25zdCBldmVudEZpbHRlcnNJbnRlZ3JhdGlvbiA9IGRlZmluZUludGVncmF0aW9uKChvcHRpb25zID0ge30pID0+IHtcbiAgbGV0IG1lcmdlZE9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgbmFtZTogSU5URUdSQVRJT05fTkFNRSxcbiAgICBzZXR1cChjbGllbnQpIHtcbiAgICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuICAgICAgbWVyZ2VkT3B0aW9ucyA9IF9tZXJnZU9wdGlvbnMob3B0aW9ucywgY2xpZW50T3B0aW9ucyk7XG4gICAgfSxcbiAgICBwcm9jZXNzRXZlbnQoZXZlbnQsIF9oaW50LCBjbGllbnQpIHtcbiAgICAgIGlmICghbWVyZ2VkT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbGllbnRPcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcbiAgICAgICAgbWVyZ2VkT3B0aW9ucyA9IF9tZXJnZU9wdGlvbnMob3B0aW9ucywgY2xpZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Nob3VsZERyb3BFdmVudChldmVudCwgbWVyZ2VkT3B0aW9ucykgPyBudWxsIDogZXZlbnQ7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEFuIGludGVncmF0aW9uIHRoYXQgZmlsdGVycyBvdXQgZXZlbnRzIChlcnJvcnMgYW5kIHRyYW5zYWN0aW9ucykgYmFzZWQgb246XG4gKlxuICogLSAoRXJyb3JzKSBBIGN1cmF0ZWQgbGlzdCBvZiBrbm93biBsb3ctdmFsdWUgb3IgaXJyZWxldmFudCBlcnJvcnMgKHNlZSB7QGxpbmsgREVGQVVMVF9JR05PUkVfRVJST1JTfSlcbiAqIC0gKEVycm9ycykgQSBsaXN0IG9mIGVycm9yIG1lc3NhZ2VzIG9yIHVybHMvZmlsZW5hbWVzIHBhc3NlZCBpbiB2aWFcbiAqICAgLSBUb3AgbGV2ZWwgU2VudHJ5LmluaXQgb3B0aW9ucyAoYGlnbm9yZUVycm9yc2AsIGBkZW55VXJsc2AsIGBhbGxvd1VybHNgKVxuICogICAtIFRoZSBzYW1lIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBpbnRlZ3JhdGlvbiBkaXJlY3RseSB2aWEgQHBhcmFtIG9wdGlvbnNcbiAqIC0gKFRyYW5zYWN0aW9ucy9TcGFucykgQSBsaXN0IG9mIHJvb3Qgc3BhbiAodHJhbnNhY3Rpb24pIG5hbWVzIHBhc3NlZCBpbiB2aWFcbiAqICAgLSBUb3AgbGV2ZWwgU2VudHJ5LmluaXQgb3B0aW9uIChgaWdub3JlVHJhbnNhY3Rpb25zYClcbiAqICAgLSBUaGUgc2FtZSBvcHRpb24gcGFzc2VkIHRvIHRoZSBpbnRlZ3JhdGlvbiBkaXJlY3RseSB2aWEgQHBhcmFtIG9wdGlvbnNcbiAqXG4gKiBFdmVudHMgZmlsdGVyZWQgYnkgdGhpcyBpbnRlZ3JhdGlvbiB3aWxsIG5vdCBiZSBzZW50IHRvIFNlbnRyeS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB0aGlzIGludGVncmF0aW9uIHdhcyByZW5hbWVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi5cbiAqIFVzZSBgZXZlbnRGaWx0ZXJzSW50ZWdyYXRpb25gIGluc3RlYWQuXG4gKi9cbmNvbnN0IGluYm91bmRGaWx0ZXJzSW50ZWdyYXRpb24gPSBkZWZpbmVJbnRlZ3JhdGlvbigoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50RmlsdGVyc0ludGVncmF0aW9uKG9wdGlvbnMpLFxuICAgIG5hbWU6ICdJbmJvdW5kRmlsdGVycycsXG4gIH07XG59KSApO1xuXG5mdW5jdGlvbiBfbWVyZ2VPcHRpb25zKFxuICBpbnRlcm5hbE9wdGlvbnMgPSB7fSxcbiAgY2xpZW50T3B0aW9ucyA9IHt9LFxuKSB7XG4gIHJldHVybiB7XG4gICAgYWxsb3dVcmxzOiBbLi4uKGludGVybmFsT3B0aW9ucy5hbGxvd1VybHMgfHwgW10pLCAuLi4oY2xpZW50T3B0aW9ucy5hbGxvd1VybHMgfHwgW10pXSxcbiAgICBkZW55VXJsczogWy4uLihpbnRlcm5hbE9wdGlvbnMuZGVueVVybHMgfHwgW10pLCAuLi4oY2xpZW50T3B0aW9ucy5kZW55VXJscyB8fCBbXSldLFxuICAgIGlnbm9yZUVycm9yczogW1xuICAgICAgLi4uKGludGVybmFsT3B0aW9ucy5pZ25vcmVFcnJvcnMgfHwgW10pLFxuICAgICAgLi4uKGNsaWVudE9wdGlvbnMuaWdub3JlRXJyb3JzIHx8IFtdKSxcbiAgICAgIC4uLihpbnRlcm5hbE9wdGlvbnMuZGlzYWJsZUVycm9yRGVmYXVsdHMgPyBbXSA6IERFRkFVTFRfSUdOT1JFX0VSUk9SUyksXG4gICAgXSxcbiAgICBpZ25vcmVUcmFuc2FjdGlvbnM6IFsuLi4oaW50ZXJuYWxPcHRpb25zLmlnbm9yZVRyYW5zYWN0aW9ucyB8fCBbXSksIC4uLihjbGllbnRPcHRpb25zLmlnbm9yZVRyYW5zYWN0aW9ucyB8fCBbXSldLFxuICB9O1xufVxuXG5mdW5jdGlvbiBfc2hvdWxkRHJvcEV2ZW50KGV2ZW50LCBvcHRpb25zKSB7XG4gIGlmICghZXZlbnQudHlwZSkge1xuICAgIC8vIEZpbHRlciBlcnJvcnNcbiAgICBpZiAoX2lzSWdub3JlZEVycm9yKGV2ZW50LCBvcHRpb25zLmlnbm9yZUVycm9ycykpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBFdmVudCBkcm9wcGVkIGR1ZSB0byBiZWluZyBtYXRjaGVkIGJ5IFxcYGlnbm9yZUVycm9yc1xcYCBvcHRpb24uXFxuRXZlbnQ6ICR7Z2V0RXZlbnREZXNjcmlwdGlvbihldmVudCl9YCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoX2lzVXNlbGVzc0Vycm9yKGV2ZW50KSkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIG5vdCBoYXZpbmcgYW4gZXJyb3IgbWVzc2FnZSwgZXJyb3IgdHlwZSBvciBzdGFja3RyYWNlLlxcbkV2ZW50OiAke2dldEV2ZW50RGVzY3JpcHRpb24oXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICApfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKF9pc0RlbmllZFVybChldmVudCwgb3B0aW9ucy5kZW55VXJscykpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBFdmVudCBkcm9wcGVkIGR1ZSB0byBiZWluZyBtYXRjaGVkIGJ5IFxcYGRlbnlVcmxzXFxgIG9wdGlvbi5cXG5FdmVudDogJHtnZXRFdmVudERlc2NyaXB0aW9uKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgKX0uXFxuVXJsOiAke19nZXRFdmVudEZpbHRlclVybChldmVudCl9YCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIV9pc0FsbG93ZWRVcmwoZXZlbnQsIG9wdGlvbnMuYWxsb3dVcmxzKSkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIG5vdCBiZWluZyBtYXRjaGVkIGJ5IFxcYGFsbG93VXJsc1xcYCBvcHRpb24uXFxuRXZlbnQ6ICR7Z2V0RXZlbnREZXNjcmlwdGlvbihcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICl9LlxcblVybDogJHtfZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpfWAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJykge1xuICAgIC8vIEZpbHRlciB0cmFuc2FjdGlvbnNcblxuICAgIGlmIChfaXNJZ25vcmVkVHJhbnNhY3Rpb24oZXZlbnQsIG9wdGlvbnMuaWdub3JlVHJhbnNhY3Rpb25zKSkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEV2ZW50IGRyb3BwZWQgZHVlIHRvIGJlaW5nIG1hdGNoZWQgYnkgXFxgaWdub3JlVHJhbnNhY3Rpb25zXFxgIG9wdGlvbi5cXG5FdmVudDogJHtnZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KX1gLFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2lzSWdub3JlZEVycm9yKGV2ZW50LCBpZ25vcmVFcnJvcnMpIHtcbiAgaWYgKCFpZ25vcmVFcnJvcnM/Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXRQb3NzaWJsZUV2ZW50TWVzc2FnZXMoZXZlbnQpLnNvbWUobWVzc2FnZSA9PiBzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4obWVzc2FnZSwgaWdub3JlRXJyb3JzKSk7XG59XG5cbmZ1bmN0aW9uIF9pc0lnbm9yZWRUcmFuc2FjdGlvbihldmVudCwgaWdub3JlVHJhbnNhY3Rpb25zKSB7XG4gIGlmICghaWdub3JlVHJhbnNhY3Rpb25zPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBuYW1lID0gZXZlbnQudHJhbnNhY3Rpb247XG4gIHJldHVybiBuYW1lID8gc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKG5hbWUsIGlnbm9yZVRyYW5zYWN0aW9ucykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2lzRGVuaWVkVXJsKGV2ZW50LCBkZW55VXJscykge1xuICBpZiAoIWRlbnlVcmxzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdXJsID0gX2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KTtcbiAgcmV0dXJuICF1cmwgPyBmYWxzZSA6IHN0cmluZ01hdGNoZXNTb21lUGF0dGVybih1cmwsIGRlbnlVcmxzKTtcbn1cblxuZnVuY3Rpb24gX2lzQWxsb3dlZFVybChldmVudCwgYWxsb3dVcmxzKSB7XG4gIGlmICghYWxsb3dVcmxzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB1cmwgPSBfZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpO1xuICByZXR1cm4gIXVybCA/IHRydWUgOiBzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4odXJsLCBhbGxvd1VybHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0TGFzdFZhbGlkVXJsKGZyYW1lcyA9IFtdKSB7XG4gIGZvciAobGV0IGkgPSBmcmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcblxuICAgIGlmIChmcmFtZSAmJiBmcmFtZS5maWxlbmFtZSAhPT0gJzxhbm9ueW1vdXM+JyAmJiBmcmFtZS5maWxlbmFtZSAhPT0gJ1tuYXRpdmUgY29kZV0nKSB7XG4gICAgICByZXR1cm4gZnJhbWUuZmlsZW5hbWUgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gX2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGxpbmtlZCBleGNlcHRpb25zIG9yIGV4Y2VwdGlvbiBhZ2dyZWdhdGVzIHdlIG9ubHkgd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB0b3AgZnJhbWUgb2YgdGhlIFwicm9vdFwiICh0aGUgbWFpbiBleGNlcHRpb24pXG4gICAgLy8gVGhlIHJvb3QgYWx3YXlzIGNvbWVzIGxhc3QgaW4gbGlua2VkIGV4Y2VwdGlvbnNcbiAgICBjb25zdCByb290RXhjZXB0aW9uID0gWy4uLihldmVudC5leGNlcHRpb24/LnZhbHVlcyA/PyBbXSldXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZCh2YWx1ZSA9PiB2YWx1ZS5tZWNoYW5pc20/LnBhcmVudF9pZCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlLnN0YWNrdHJhY2U/LmZyYW1lcz8ubGVuZ3RoKTtcbiAgICBjb25zdCBmcmFtZXMgPSByb290RXhjZXB0aW9uPy5zdGFja3RyYWNlPy5mcmFtZXM7XG4gICAgcmV0dXJuIGZyYW1lcyA/IF9nZXRMYXN0VmFsaWRVcmwoZnJhbWVzKSA6IG51bGw7XG4gIH0gY2F0Y2ggKG9PKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKGBDYW5ub3QgZXh0cmFjdCB1cmwgZm9yIGV2ZW50ICR7Z2V0RXZlbnREZXNjcmlwdGlvbihldmVudCl9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzVXNlbGVzc0Vycm9yKGV2ZW50KSB7XG4gIC8vIFdlIG9ubHkgd2FudCB0byBjb25zaWRlciBldmVudHMgZm9yIGRyb3BwaW5nIHRoYXQgYWN0dWFsbHkgaGF2ZSByZWNvcmRlZCBleGNlcHRpb24gdmFsdWVzLlxuICBpZiAoIWV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIC8vIE5vIHRvcC1sZXZlbCBtZXNzYWdlXG4gICAgIWV2ZW50Lm1lc3NhZ2UgJiZcbiAgICAvLyBUaGVyZSBhcmUgbm8gZXhjZXB0aW9uIHZhbHVlcyB0aGF0IGhhdmUgYSBzdGFja3RyYWNlLCBhIG5vbi1nZW5lcmljLUVycm9yIHR5cGUgb3IgdmFsdWVcbiAgICAhZXZlbnQuZXhjZXB0aW9uLnZhbHVlcy5zb21lKHZhbHVlID0+IHZhbHVlLnN0YWNrdHJhY2UgfHwgKHZhbHVlLnR5cGUgJiYgdmFsdWUudHlwZSAhPT0gJ0Vycm9yJykgfHwgdmFsdWUudmFsdWUpXG4gICk7XG59XG5cbmV4cG9ydCB7IGV2ZW50RmlsdGVyc0ludGVncmF0aW9uLCBpbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudEZpbHRlcnMuanMubWFwXG4iLCJpbXBvcnQgeyBpc0luc3RhbmNlT2YgfSBmcm9tICcuL2lzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGV4Y2VwdGlvbnMgaW5zaWRlIGBldmVudC5leGNlcHRpb24udmFsdWVzYCBmb3IgZXJyb3JzIHRoYXQgYXJlIG5lc3RlZCBvbiBwcm9wZXJ0aWVzIGJhc2VkIG9uIHRoZSBga2V5YCBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QWdncmVnYXRlRXJyb3JzVG9FdmVudChcbiAgZXhjZXB0aW9uRnJvbUVycm9ySW1wbGVtZW50YXRpb24sXG4gIHBhcnNlcixcbiAga2V5LFxuICBsaW1pdCxcbiAgZXZlbnQsXG4gIGhpbnQsXG4pIHtcbiAgaWYgKCFldmVudC5leGNlcHRpb24/LnZhbHVlcyB8fCAhaGludCB8fCAhaXNJbnN0YW5jZU9mKGhpbnQub3JpZ2luYWxFeGNlcHRpb24sIEVycm9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEdlbmVyYWxseSBzcGVha2luZyB0aGUgbGFzdCBpdGVtIGluIGBldmVudC5leGNlcHRpb24udmFsdWVzYCBpcyB0aGUgZXhjZXB0aW9uIG9yaWdpbmF0aW5nIGZyb20gdGhlIG9yaWdpbmFsIEVycm9yXG4gIGNvbnN0IG9yaWdpbmFsRXhjZXB0aW9uID1cbiAgICBldmVudC5leGNlcHRpb24udmFsdWVzLmxlbmd0aCA+IDAgPyBldmVudC5leGNlcHRpb24udmFsdWVzW2V2ZW50LmV4Y2VwdGlvbi52YWx1ZXMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgLy8gV2Ugb25seSBjcmVhdGUgZXhjZXB0aW9uIGdyb3VwaW5nIGlmIHRoZXJlIGlzIGFuIGV4Y2VwdGlvbiBpbiB0aGUgZXZlbnQuXG4gIGlmIChvcmlnaW5hbEV4Y2VwdGlvbikge1xuICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMgPSBhZ2dyZWdhdGVFeGNlcHRpb25zRnJvbUVycm9yKFxuICAgICAgZXhjZXB0aW9uRnJvbUVycm9ySW1wbGVtZW50YXRpb24sXG4gICAgICBwYXJzZXIsXG4gICAgICBsaW1pdCxcbiAgICAgIGhpbnQub3JpZ2luYWxFeGNlcHRpb24gLFxuICAgICAga2V5LFxuICAgICAgZXZlbnQuZXhjZXB0aW9uLnZhbHVlcyxcbiAgICAgIG9yaWdpbmFsRXhjZXB0aW9uLFxuICAgICAgMCxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZUV4Y2VwdGlvbnNGcm9tRXJyb3IoXG4gIGV4Y2VwdGlvbkZyb21FcnJvckltcGxlbWVudGF0aW9uLFxuICBwYXJzZXIsXG4gIGxpbWl0LFxuICBlcnJvcixcbiAga2V5LFxuICBwcmV2RXhjZXB0aW9ucyxcbiAgZXhjZXB0aW9uLFxuICBleGNlcHRpb25JZCxcbikge1xuICBpZiAocHJldkV4Y2VwdGlvbnMubGVuZ3RoID49IGxpbWl0ICsgMSkge1xuICAgIHJldHVybiBwcmV2RXhjZXB0aW9ucztcbiAgfVxuXG4gIGxldCBuZXdFeGNlcHRpb25zID0gWy4uLnByZXZFeGNlcHRpb25zXTtcblxuICAvLyBSZWN1cnNpdmVseSBjYWxsIHRoaXMgZnVuY3Rpb24gaW4gb3JkZXIgdG8gd2FsayBkb3duIGEgY2hhaW4gb2YgZXJyb3JzXG4gIGlmIChpc0luc3RhbmNlT2YoZXJyb3Jba2V5XSwgRXJyb3IpKSB7XG4gICAgYXBwbHlFeGNlcHRpb25Hcm91cEZpZWxkc0ZvclBhcmVudEV4Y2VwdGlvbihleGNlcHRpb24sIGV4Y2VwdGlvbklkKTtcbiAgICBjb25zdCBuZXdFeGNlcHRpb24gPSBleGNlcHRpb25Gcm9tRXJyb3JJbXBsZW1lbnRhdGlvbihwYXJzZXIsIGVycm9yW2tleV0pO1xuICAgIGNvbnN0IG5ld0V4Y2VwdGlvbklkID0gbmV3RXhjZXB0aW9ucy5sZW5ndGg7XG4gICAgYXBwbHlFeGNlcHRpb25Hcm91cEZpZWxkc0ZvckNoaWxkRXhjZXB0aW9uKG5ld0V4Y2VwdGlvbiwga2V5LCBuZXdFeGNlcHRpb25JZCwgZXhjZXB0aW9uSWQpO1xuICAgIG5ld0V4Y2VwdGlvbnMgPSBhZ2dyZWdhdGVFeGNlcHRpb25zRnJvbUVycm9yKFxuICAgICAgZXhjZXB0aW9uRnJvbUVycm9ySW1wbGVtZW50YXRpb24sXG4gICAgICBwYXJzZXIsXG4gICAgICBsaW1pdCxcbiAgICAgIGVycm9yW2tleV0sXG4gICAgICBrZXksXG4gICAgICBbbmV3RXhjZXB0aW9uLCAuLi5uZXdFeGNlcHRpb25zXSxcbiAgICAgIG5ld0V4Y2VwdGlvbixcbiAgICAgIG5ld0V4Y2VwdGlvbklkLFxuICAgICk7XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgY3JlYXRlIGV4Y2VwdGlvbiBncm91cGluZyBmb3IgQWdncmVnYXRlRXJyb3JzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FnZ3JlZ2F0ZUVycm9yXG4gIGlmIChBcnJheS5pc0FycmF5KGVycm9yLmVycm9ycykpIHtcbiAgICBlcnJvci5lcnJvcnMuZm9yRWFjaCgoY2hpbGRFcnJvciwgaSkgPT4ge1xuICAgICAgaWYgKGlzSW5zdGFuY2VPZihjaGlsZEVycm9yLCBFcnJvcikpIHtcbiAgICAgICAgYXBwbHlFeGNlcHRpb25Hcm91cEZpZWxkc0ZvclBhcmVudEV4Y2VwdGlvbihleGNlcHRpb24sIGV4Y2VwdGlvbklkKTtcbiAgICAgICAgY29uc3QgbmV3RXhjZXB0aW9uID0gZXhjZXB0aW9uRnJvbUVycm9ySW1wbGVtZW50YXRpb24ocGFyc2VyLCBjaGlsZEVycm9yKTtcbiAgICAgICAgY29uc3QgbmV3RXhjZXB0aW9uSWQgPSBuZXdFeGNlcHRpb25zLmxlbmd0aDtcbiAgICAgICAgYXBwbHlFeGNlcHRpb25Hcm91cEZpZWxkc0ZvckNoaWxkRXhjZXB0aW9uKG5ld0V4Y2VwdGlvbiwgYGVycm9yc1ske2l9XWAsIG5ld0V4Y2VwdGlvbklkLCBleGNlcHRpb25JZCk7XG4gICAgICAgIG5ld0V4Y2VwdGlvbnMgPSBhZ2dyZWdhdGVFeGNlcHRpb25zRnJvbUVycm9yKFxuICAgICAgICAgIGV4Y2VwdGlvbkZyb21FcnJvckltcGxlbWVudGF0aW9uLFxuICAgICAgICAgIHBhcnNlcixcbiAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICBjaGlsZEVycm9yLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBbbmV3RXhjZXB0aW9uLCAuLi5uZXdFeGNlcHRpb25zXSxcbiAgICAgICAgICBuZXdFeGNlcHRpb24sXG4gICAgICAgICAgbmV3RXhjZXB0aW9uSWQsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3RXhjZXB0aW9ucztcbn1cblxuZnVuY3Rpb24gYXBwbHlFeGNlcHRpb25Hcm91cEZpZWxkc0ZvclBhcmVudEV4Y2VwdGlvbihleGNlcHRpb24sIGV4Y2VwdGlvbklkKSB7XG4gIC8vIERvbid0IGtub3cgaWYgdGhpcyBkZWZhdWx0IG1ha2VzIHNlbnNlLiBUaGUgcHJvdG9jb2wgcmVxdWlyZXMgdXMgdG8gc2V0IHRoZXNlIHZhbHVlcyBzbyB3ZSBwaWNrICpzb21lKiBkZWZhdWx0LlxuICBleGNlcHRpb24ubWVjaGFuaXNtID0gZXhjZXB0aW9uLm1lY2hhbmlzbSB8fCB7IHR5cGU6ICdnZW5lcmljJywgaGFuZGxlZDogdHJ1ZSB9O1xuXG4gIGV4Y2VwdGlvbi5tZWNoYW5pc20gPSB7XG4gICAgLi4uZXhjZXB0aW9uLm1lY2hhbmlzbSxcbiAgICAuLi4oZXhjZXB0aW9uLnR5cGUgPT09ICdBZ2dyZWdhdGVFcnJvcicgJiYgeyBpc19leGNlcHRpb25fZ3JvdXA6IHRydWUgfSksXG4gICAgZXhjZXB0aW9uX2lkOiBleGNlcHRpb25JZCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlFeGNlcHRpb25Hcm91cEZpZWxkc0ZvckNoaWxkRXhjZXB0aW9uKFxuICBleGNlcHRpb24sXG4gIHNvdXJjZSxcbiAgZXhjZXB0aW9uSWQsXG4gIHBhcmVudElkLFxuKSB7XG4gIC8vIERvbid0IGtub3cgaWYgdGhpcyBkZWZhdWx0IG1ha2VzIHNlbnNlLiBUaGUgcHJvdG9jb2wgcmVxdWlyZXMgdXMgdG8gc2V0IHRoZXNlIHZhbHVlcyBzbyB3ZSBwaWNrICpzb21lKiBkZWZhdWx0LlxuICBleGNlcHRpb24ubWVjaGFuaXNtID0gZXhjZXB0aW9uLm1lY2hhbmlzbSB8fCB7IHR5cGU6ICdnZW5lcmljJywgaGFuZGxlZDogdHJ1ZSB9O1xuXG4gIGV4Y2VwdGlvbi5tZWNoYW5pc20gPSB7XG4gICAgLi4uZXhjZXB0aW9uLm1lY2hhbmlzbSxcbiAgICB0eXBlOiAnY2hhaW5lZCcsXG4gICAgc291cmNlLFxuICAgIGV4Y2VwdGlvbl9pZDogZXhjZXB0aW9uSWQsXG4gICAgcGFyZW50X2lkOiBwYXJlbnRJZCxcbiAgfTtcbn1cblxuZXhwb3J0IHsgYXBwbHlBZ2dyZWdhdGVFcnJvcnNUb0V2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZ2dyZWdhdGUtZXJyb3JzLmpzLm1hcFxuIiwiaW1wb3J0IHsgQ09OU09MRV9MRVZFTFMsIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgfSBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZmlsbCB9IGZyb20gJy4uL29iamVjdC5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi4vd29ybGR3aWRlLmpzJztcbmltcG9ydCB7IGFkZEhhbmRsZXIsIG1heWJlSW5zdHJ1bWVudCwgdHJpZ2dlckhhbmRsZXJzIH0gZnJvbSAnLi9oYW5kbGVycy5qcyc7XG5cbi8qKlxuICogQWRkIGFuIGluc3RydW1lbnRhdGlvbiBoYW5kbGVyIGZvciB3aGVuIGEgY29uc29sZS54eHggbWV0aG9kIGlzIGNhbGxlZC5cbiAqXG4gKiBVc2UgYXQgeW91ciBvd24gcmlzaywgdGhpcyBtaWdodCBicmVhayB3aXRob3V0IGNoYW5nZWxvZyBub3RpY2UsIG9ubHkgdXNlZCBpbnRlcm5hbGx5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gIGNvbnN0IHR5cGUgPSAnY29uc29sZSc7XG4gIGFkZEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gIG1heWJlSW5zdHJ1bWVudCh0eXBlLCBpbnN0cnVtZW50Q29uc29sZSk7XG59XG5cbmZ1bmN0aW9uIGluc3RydW1lbnRDb25zb2xlKCkge1xuICBpZiAoISgnY29uc29sZScgaW4gR0xPQkFMX09CSikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBDT05TT0xFX0xFVkVMUy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgIGlmICghKGxldmVsIGluIEdMT0JBTF9PQkouY29uc29sZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaWxsKEdMT0JBTF9PQkouY29uc29sZSwgbGV2ZWwsIGZ1bmN0aW9uIChvcmlnaW5hbENvbnNvbGVNZXRob2QpIHtcbiAgICAgIG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbGV2ZWxdID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlckRhdGEgPSB7IGFyZ3MsIGxldmVsIH07XG4gICAgICAgIHRyaWdnZXJIYW5kbGVycygnY29uc29sZScsIGhhbmRsZXJEYXRhKTtcblxuICAgICAgICBjb25zdCBsb2cgPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW2xldmVsXTtcbiAgICAgICAgbG9nPy5hcHBseShHTE9CQUxfT0JKLmNvbnNvbGUsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFkZENvbnNvbGVJbnN0cnVtZW50YXRpb25IYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zb2xlLmpzLm1hcFxuIiwiLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZy1iYXNlZCBsZXZlbCBpbnRvIGEgYFNldmVyaXR5TGV2ZWxgLCBub3JtYWxpemluZyBpdCBhbG9uZyB0aGUgd2F5LlxuICpcbiAqIEBwYXJhbSBsZXZlbCBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGVzaXJlZCBgU2V2ZXJpdHlMZXZlbGAuXG4gKiBAcmV0dXJucyBUaGUgYFNldmVyaXR5TGV2ZWxgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHN0cmluZywgb3IgJ2xvZycgaWYgdGhlIHN0cmluZyBpc24ndCBhIHZhbGlkIGxldmVsLlxuICovXG5mdW5jdGlvbiBzZXZlcml0eUxldmVsRnJvbVN0cmluZyhsZXZlbCkge1xuICByZXR1cm4gKFxuICAgIGxldmVsID09PSAnd2FybicgPyAnd2FybmluZycgOiBbJ2ZhdGFsJywgJ2Vycm9yJywgJ3dhcm5pbmcnLCAnbG9nJywgJ2luZm8nLCAnZGVidWcnXS5pbmNsdWRlcyhsZXZlbCkgPyBsZXZlbCA6ICdsb2cnXG4gICkgO1xufVxuXG5leHBvcnQgeyBzZXZlcml0eUxldmVsRnJvbVN0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V2ZXJpdHkuanMubWFwXG4iLCJpbXBvcnQgeyBkZWZpbmVJbnRlZ3JhdGlvbiB9IGZyb20gJy4uL2ludGVncmF0aW9uLmpzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMtaG9pc3QvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyYW1lc0Zyb21FdmVudCB9IGZyb20gJy4uL3V0aWxzLWhvaXN0L3N0YWNrdHJhY2UuanMnO1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0RlZHVwZSc7XG5cbmNvbnN0IF9kZWR1cGVJbnRlZ3JhdGlvbiA9ICgoKSA9PiB7XG4gIGxldCBwcmV2aW91c0V2ZW50O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogSU5URUdSQVRJT05fTkFNRSxcbiAgICBwcm9jZXNzRXZlbnQoY3VycmVudEV2ZW50KSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGlnbm9yZSBhbnkgbm9uLWVycm9yIHR5cGUgZXZlbnRzLCBlLmcuIHRyYW5zYWN0aW9ucyBvciByZXBsYXlzXG4gICAgICAvLyBUaGVzZSBzaG91bGQgbmV2ZXIgYmUgZGVkdXBlZCwgYW5kIGFsc28gbm90IGJlIGNvbXBhcmVkIGFnYWluc3QgYXMgX3ByZXZpb3VzRXZlbnQuXG4gICAgICBpZiAoY3VycmVudEV2ZW50LnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFdmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gSnV1dXN0IGluIGNhc2Ugc29tZXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfc2hvdWxkRHJvcEV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICAgICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignRXZlbnQgZHJvcHBlZCBkdWUgdG8gYmVpbmcgYSBkdXBsaWNhdGUgb2YgcHJldmlvdXNseSBjYXB0dXJlZCBldmVudC4nKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX29PKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbiAgICAgIHJldHVybiAocHJldmlvdXNFdmVudCA9IGN1cnJlbnRFdmVudCk7XG4gICAgfSxcbiAgfTtcbn0pIDtcblxuLyoqXG4gKiBEZWR1cGxpY2F0aW9uIGZpbHRlci5cbiAqL1xuY29uc3QgZGVkdXBlSW50ZWdyYXRpb24gPSBkZWZpbmVJbnRlZ3JhdGlvbihfZGVkdXBlSW50ZWdyYXRpb24pO1xuXG4vKiogb25seSBleHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBfc2hvdWxkRHJvcEV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBpZiAoIXByZXZpb3VzRXZlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX2lzU2FtZU1lc3NhZ2VFdmVudChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoX2lzU2FtZUV4Y2VwdGlvbkV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2lzU2FtZU1lc3NhZ2VFdmVudChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpIHtcbiAgY29uc3QgY3VycmVudE1lc3NhZ2UgPSBjdXJyZW50RXZlbnQubWVzc2FnZTtcbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlID0gcHJldmlvdXNFdmVudC5tZXNzYWdlO1xuXG4gIC8vIElmIG5laXRoZXIgZXZlbnQgaGFzIGEgbWVzc2FnZSBwcm9wZXJ0eSwgdGhleSB3ZXJlIGJvdGggZXhjZXB0aW9ucywgc28gYmFpbCBvdXRcbiAgaWYgKCFjdXJyZW50TWVzc2FnZSAmJiAhcHJldmlvdXNNZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgb25seSBvbmUgZXZlbnQgaGFzIGEgc3RhY2t0cmFjZSwgYnV0IG5vdCB0aGUgb3RoZXIgb25lLCB0aGV5IGFyZSBub3QgdGhlIHNhbWVcbiAgaWYgKChjdXJyZW50TWVzc2FnZSAmJiAhcHJldmlvdXNNZXNzYWdlKSB8fCAoIWN1cnJlbnRNZXNzYWdlICYmIHByZXZpb3VzTWVzc2FnZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY3VycmVudE1lc3NhZ2UgIT09IHByZXZpb3VzTWVzc2FnZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghX2lzU2FtZUZpbmdlcnByaW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIV9pc1NhbWVTdGFja3RyYWNlKGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2lzU2FtZUV4Y2VwdGlvbkV2ZW50KGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBjb25zdCBwcmV2aW91c0V4Y2VwdGlvbiA9IF9nZXRFeGNlcHRpb25Gcm9tRXZlbnQocHJldmlvdXNFdmVudCk7XG4gIGNvbnN0IGN1cnJlbnRFeGNlcHRpb24gPSBfZ2V0RXhjZXB0aW9uRnJvbUV2ZW50KGN1cnJlbnRFdmVudCk7XG5cbiAgaWYgKCFwcmV2aW91c0V4Y2VwdGlvbiB8fCAhY3VycmVudEV4Y2VwdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcmV2aW91c0V4Y2VwdGlvbi50eXBlICE9PSBjdXJyZW50RXhjZXB0aW9uLnR5cGUgfHwgcHJldmlvdXNFeGNlcHRpb24udmFsdWUgIT09IGN1cnJlbnRFeGNlcHRpb24udmFsdWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIV9pc1NhbWVGaW5nZXJwcmludChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFfaXNTYW1lU3RhY2t0cmFjZShjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9pc1NhbWVTdGFja3RyYWNlKGN1cnJlbnRFdmVudCwgcHJldmlvdXNFdmVudCkge1xuICBsZXQgY3VycmVudEZyYW1lcyA9IGdldEZyYW1lc0Zyb21FdmVudChjdXJyZW50RXZlbnQpO1xuICBsZXQgcHJldmlvdXNGcmFtZXMgPSBnZXRGcmFtZXNGcm9tRXZlbnQocHJldmlvdXNFdmVudCk7XG5cbiAgLy8gSWYgbmVpdGhlciBldmVudCBoYXMgYSBzdGFja3RyYWNlLCB0aGV5IGFyZSBhc3N1bWVkIHRvIGJlIHRoZSBzYW1lXG4gIGlmICghY3VycmVudEZyYW1lcyAmJiAhcHJldmlvdXNGcmFtZXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIG9ubHkgb25lIGV2ZW50IGhhcyBhIHN0YWNrdHJhY2UsIGJ1dCBub3QgdGhlIG90aGVyIG9uZSwgdGhleSBhcmUgbm90IHRoZSBzYW1lXG4gIGlmICgoY3VycmVudEZyYW1lcyAmJiAhcHJldmlvdXNGcmFtZXMpIHx8ICghY3VycmVudEZyYW1lcyAmJiBwcmV2aW91c0ZyYW1lcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50RnJhbWVzID0gY3VycmVudEZyYW1lcyA7XG4gIHByZXZpb3VzRnJhbWVzID0gcHJldmlvdXNGcmFtZXMgO1xuXG4gIC8vIElmIG51bWJlciBvZiBmcmFtZXMgZGlmZmVyLCB0aGV5IGFyZSBub3QgdGhlIHNhbWVcbiAgaWYgKHByZXZpb3VzRnJhbWVzLmxlbmd0aCAhPT0gY3VycmVudEZyYW1lcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGNvbXBhcmUgdGhlIHR3b1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzRnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBmcmFtZUEgPSBwcmV2aW91c0ZyYW1lc1tpXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IGZyYW1lQiA9IGN1cnJlbnRGcmFtZXNbaV07XG5cbiAgICBpZiAoXG4gICAgICBmcmFtZUEuZmlsZW5hbWUgIT09IGZyYW1lQi5maWxlbmFtZSB8fFxuICAgICAgZnJhbWVBLmxpbmVubyAhPT0gZnJhbWVCLmxpbmVubyB8fFxuICAgICAgZnJhbWVBLmNvbG5vICE9PSBmcmFtZUIuY29sbm8gfHxcbiAgICAgIGZyYW1lQS5mdW5jdGlvbiAhPT0gZnJhbWVCLmZ1bmN0aW9uXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9pc1NhbWVGaW5nZXJwcmludChjdXJyZW50RXZlbnQsIHByZXZpb3VzRXZlbnQpIHtcbiAgbGV0IGN1cnJlbnRGaW5nZXJwcmludCA9IGN1cnJlbnRFdmVudC5maW5nZXJwcmludDtcbiAgbGV0IHByZXZpb3VzRmluZ2VycHJpbnQgPSBwcmV2aW91c0V2ZW50LmZpbmdlcnByaW50O1xuXG4gIC8vIElmIG5laXRoZXIgZXZlbnQgaGFzIGEgZmluZ2VycHJpbnQsIHRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWVcbiAgaWYgKCFjdXJyZW50RmluZ2VycHJpbnQgJiYgIXByZXZpb3VzRmluZ2VycHJpbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIG9ubHkgb25lIGV2ZW50IGhhcyBhIGZpbmdlcnByaW50LCBidXQgbm90IHRoZSBvdGhlciBvbmUsIHRoZXkgYXJlIG5vdCB0aGUgc2FtZVxuICBpZiAoKGN1cnJlbnRGaW5nZXJwcmludCAmJiAhcHJldmlvdXNGaW5nZXJwcmludCkgfHwgKCFjdXJyZW50RmluZ2VycHJpbnQgJiYgcHJldmlvdXNGaW5nZXJwcmludCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50RmluZ2VycHJpbnQgPSBjdXJyZW50RmluZ2VycHJpbnQgO1xuICBwcmV2aW91c0ZpbmdlcnByaW50ID0gcHJldmlvdXNGaW5nZXJwcmludCA7XG5cbiAgLy8gT3RoZXJ3aXNlLCBjb21wYXJlIHRoZSB0d29cbiAgdHJ5IHtcbiAgICByZXR1cm4gISEoY3VycmVudEZpbmdlcnByaW50LmpvaW4oJycpID09PSBwcmV2aW91c0ZpbmdlcnByaW50LmpvaW4oJycpKTtcbiAgfSBjYXRjaCAoX29PKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRFeGNlcHRpb25Gcm9tRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzICYmIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF07XG59XG5cbmV4cG9ydCB7IF9zaG91bGREcm9wRXZlbnQsIGRlZHVwZUludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWR1cGUuanMubWFwXG4iLCIvLyBDdXJpb3VzIGFib3V0IGB0aGlzbWVzc2FnZTovYD8gU2VlOiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMjU1Ny5odG1sXG4vLyAgPiBXaGVuIHRoZSBtZXRob2RzIGFib3ZlIGRvIG5vdCB5aWVsZCBhbiBhYnNvbHV0ZSBVUkksIGEgYmFzZSBVUkxcbi8vICA+IG9mIFwidGhpc21lc3NhZ2U6L1wiIE1VU1QgYmUgZW1wbG95ZWQuIFRoaXMgYmFzZSBVUkwgaGFzIGJlZW5cbi8vICA+IGRlZmluZWQgZm9yIHRoZSBzb2xlIHB1cnBvc2Ugb2YgcmVzb2x2aW5nIHJlbGF0aXZlIHJlZmVyZW5jZXNcbi8vICA+IHdpdGhpbiBhIG11bHRpcGFydC9yZWxhdGVkIHN0cnVjdHVyZSB3aGVuIG5vIG90aGVyIGJhc2UgVVJJIGlzXG4vLyAgPiBzcGVjaWZpZWQuXG4vL1xuLy8gV2UgbmVlZCB0byBwcm92aWRlIGEgYmFzZSBVUkwgdG8gYHBhcnNlU3RyaW5nVG9VUkxPYmplY3RgIGJlY2F1c2UgdGhlIGZldGNoIEFQSSBnaXZlcyB1cyBhXG4vLyByZWxhdGl2ZSBVUkwgc29tZXRpbWVzLlxuLy9cbi8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIHByb3ZpZGUgYSBiYXNlIFVSTCB0byBgcGFyc2VTdHJpbmdUb1VSTE9iamVjdGBcbi8vIGJlY2F1c2UgdGhlIHJlbGF0aXZlIFVSTCBpcyBub3QgdmFsaWQgb24gaXRzIG93bi5cbmNvbnN0IERFRkFVTFRfQkFTRV9VUkwgPSAndGhpc21lc3NhZ2U6Lyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBVUkwgb2JqZWN0IGlzIHJlbGF0aXZlXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBVUkwgb2JqZWN0IGlzIHJlbGF0aXZlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxPYmplY3RSZWxhdGl2ZSh1cmwpIHtcbiAgcmV0dXJuICdpc1JlbGF0aXZlJyBpbiB1cmw7XG59XG5cbi8qKlxuICogUGFyc2VzIHN0cmluZyB0byBhIFVSTCBvYmplY3RcbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBwYXJzZVxuICogQHJldHVybnMgVGhlIHBhcnNlZCBVUkwgb2JqZWN0IG9yIHVuZGVmaW5lZCBpZiB0aGUgVVJMIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdUb1VSTE9iamVjdCh1cmwsIHVybEJhc2UpIHtcbiAgY29uc3QgaXNSZWxhdGl2ZSA9IHVybC5zdGFydHNXaXRoKCcvJyk7XG4gIGNvbnN0IGJhc2UgPSB1cmxCYXNlID8/IChpc1JlbGF0aXZlID8gREVGQVVMVF9CQVNFX1VSTCA6IHVuZGVmaW5lZCk7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGBjYW5QYXJzZWAgdG8gc2hvcnQtY2lyY3VpdCB0aGUgVVJMIGNvbnN0cnVjdG9yIGlmIGl0J3Mgbm90IGEgdmFsaWQgVVJMXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIgdGhhbiB0cnlpbmcgdG8gY29uc3RydWN0IHRoZSBVUkwgYW5kIGNhdGNoaW5nIHRoZSBlcnJvclxuICAgIC8vIE5vZGUgMjArLCBDaHJvbWUgMTIwKywgRmlyZWZveCAxMTUrLCBTYWZhcmkgMTcrXG4gICAgaWYgKCdjYW5QYXJzZScgaW4gVVJMICYmICEoVVJMICkuY2FuUGFyc2UodXJsLCBiYXNlKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsVXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGJhc2UpO1xuICAgIGlmIChpc1JlbGF0aXZlKSB7XG4gICAgICAvLyBCZWNhdXNlIHdlIHVzZWQgYSBmYWtlIGJhc2UgVVJMLCB3ZSBuZWVkIHRvIHJldHVybiBhIHJlbGF0aXZlIFVSTCBvYmplY3QuXG4gICAgICAvLyBXZSBjYW5ub3QgcmV0dXJuIGFueXRoaW5nIGFib3V0IHRoZSBvcmlnaW4sIGhvc3QsIGV0Yy4gYmVjYXVzZSBpdCB3aWxsIHJlZmVyIHRvIHRoZSBmYWtlIGJhc2UgVVJMLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNSZWxhdGl2ZSxcbiAgICAgICAgcGF0aG5hbWU6IGZ1bGxVcmxPYmplY3QucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogZnVsbFVybE9iamVjdC5zZWFyY2gsXG4gICAgICAgIGhhc2g6IGZ1bGxVcmxPYmplY3QuaGFzaCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdWxsVXJsT2JqZWN0O1xuICB9IGNhdGNoIHtcbiAgICAvLyBlbXB0eSBib2R5XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRha2VzIGEgVVJMIG9iamVjdCBhbmQgcmV0dXJucyBhIHNhbml0aXplZCBzdHJpbmcgd2hpY2ggaXMgc2FmZSB0byB1c2UgYXMgc3BhbiBuYW1lXG4gKiBzZWU6IGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay9kYXRhLWhhbmRsaW5nLyNzdHJ1Y3R1cmluZy1kYXRhXG4gKi9cbmZ1bmN0aW9uIGdldFNhbml0aXplZFVybFN0cmluZ0Zyb21VcmxPYmplY3QodXJsKSB7XG4gIGlmIChpc1VSTE9iamVjdFJlbGF0aXZlKHVybCkpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lO1xuICB9XG5cbiAgY29uc3QgbmV3VXJsID0gbmV3IFVSTCh1cmwpO1xuICBuZXdVcmwuc2VhcmNoID0gJyc7XG4gIG5ld1VybC5oYXNoID0gJyc7XG4gIGlmIChbJzgwJywgJzQ0MyddLmluY2x1ZGVzKG5ld1VybC5wb3J0KSkge1xuICAgIG5ld1VybC5wb3J0ID0gJyc7XG4gIH1cbiAgaWYgKG5ld1VybC5wYXNzd29yZCkge1xuICAgIG5ld1VybC5wYXNzd29yZCA9ICclZmlsdGVyZWQlJztcbiAgfVxuICBpZiAobmV3VXJsLnVzZXJuYW1lKSB7XG4gICAgbmV3VXJsLnVzZXJuYW1lID0gJyVmaWx0ZXJlZCUnO1xuICB9XG5cbiAgcmV0dXJuIG5ld1VybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFBhcnNlcyBzdHJpbmcgZm9ybSBvZiBVUkwgaW50byBhbiBvYmplY3RcbiAqIC8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQlxuICogLy8gaW50ZW50aW9uYWxseSB1c2luZyByZWdleCBhbmQgbm90IDxhLz4gaHJlZiBwYXJzaW5nIHRyaWNrIGJlY2F1c2UgUmVhY3QgTmF0aXZlIGFuZCBvdGhlclxuICogLy8gZW52aXJvbm1lbnRzIHdoZXJlIERPTSBtaWdodCBub3QgYmUgYXZhaWxhYmxlXG4gKiBAcmV0dXJucyBwYXJzZWQgVVJMIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvXigoW146Lz8jXSspOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8kLyk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIGNvZXJjZSB0byB1bmRlZmluZWQgdmFsdWVzIHRvIGVtcHR5IHN0cmluZyBzbyB3ZSBkb24ndCBnZXQgJ3VuZGVmaW5lZCdcbiAgY29uc3QgcXVlcnkgPSBtYXRjaFs2XSB8fCAnJztcbiAgY29uc3QgZnJhZ21lbnQgPSBtYXRjaFs4XSB8fCAnJztcbiAgcmV0dXJuIHtcbiAgICBob3N0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XSxcbiAgICBwcm90b2NvbDogbWF0Y2hbMl0sXG4gICAgc2VhcmNoOiBxdWVyeSxcbiAgICBoYXNoOiBmcmFnbWVudCxcbiAgICByZWxhdGl2ZTogbWF0Y2hbNV0gKyBxdWVyeSArIGZyYWdtZW50LCAvLyBldmVyeXRoaW5nIG1pbnVzIG9yaWdpblxuICB9O1xufVxuXG4vKipcbiAqIFN0cmlwIHRoZSBxdWVyeSBzdHJpbmcgYW5kIGZyYWdtZW50IG9mZiBvZiBhIGdpdmVuIFVSTCBvciBwYXRoIChpZiBwcmVzZW50KVxuICpcbiAqIEBwYXJhbSB1cmxQYXRoIEZ1bGwgVVJMIG9yIHBhdGgsIGluY2x1ZGluZyBwb3NzaWJsZSBxdWVyeSBzdHJpbmcgYW5kL29yIGZyYWdtZW50XG4gKiBAcmV0dXJucyBVUkwgb3IgcGF0aCB3aXRob3V0IHF1ZXJ5IHN0cmluZyBvciBmcmFnbWVudFxuICovXG5mdW5jdGlvbiBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQodXJsUGF0aCkge1xuICByZXR1cm4gKHVybFBhdGguc3BsaXQoL1s/I10vLCAxKSApWzBdO1xufVxuXG4vKipcbiAqIFRha2VzIGEgVVJMIG9iamVjdCBhbmQgcmV0dXJucyBhIHNhbml0aXplZCBzdHJpbmcgd2hpY2ggaXMgc2FmZSB0byB1c2UgYXMgc3BhbiBuYW1lXG4gKiBzZWU6IGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay9kYXRhLWhhbmRsaW5nLyNzdHJ1Y3R1cmluZy1kYXRhXG4gKi9cbmZ1bmN0aW9uIGdldFNhbml0aXplZFVybFN0cmluZyh1cmwpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdCwgcGF0aCB9ID0gdXJsO1xuXG4gIGNvbnN0IGZpbHRlcmVkSG9zdCA9XG4gICAgaG9zdFxuICAgICAgLy8gQWx3YXlzIGZpbHRlciBvdXQgYXV0aG9yaXR5XG4gICAgICA/LnJlcGxhY2UoL14uKkAvLCAnW2ZpbHRlcmVkXTpbZmlsdGVyZWRdQCcpXG4gICAgICAvLyBEb24ndCBzaG93IHN0YW5kYXJkIDo4MCAoaHR0cCkgYW5kIDo0NDMgKGh0dHBzKSBwb3J0cyB0byByZWR1Y2UgdGhlIG5vaXNlXG4gICAgICAvLyBUT0RPOiBVc2UgbmV3IFVSTCBnbG9iYWwgaWYgaXQgZXhpc3RzXG4gICAgICAucmVwbGFjZSgvKDo4MCkkLywgJycpXG4gICAgICAucmVwbGFjZSgvKDo0NDMpJC8sICcnKSB8fCAnJztcblxuICByZXR1cm4gYCR7cHJvdG9jb2wgPyBgJHtwcm90b2NvbH06Ly9gIDogJyd9JHtmaWx0ZXJlZEhvc3R9JHtwYXRofWA7XG59XG5cbmV4cG9ydCB7IGdldFNhbml0aXplZFVybFN0cmluZywgZ2V0U2FuaXRpemVkVXJsU3RyaW5nRnJvbVVybE9iamVjdCwgaXNVUkxPYmplY3RSZWxhdGl2ZSwgcGFyc2VTdHJpbmdUb1VSTE9iamVjdCwgcGFyc2VVcmwsIHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLmpzLm1hcFxuIiwiLyoqXG4gKiBEZXRlcm1pbmUgYSBicmVhZGNydW1iJ3MgbG9nIGxldmVsIChvbmx5IGB3YXJuaW5nYCBvciBgZXJyb3JgKSBiYXNlZCBvbiBhbiBIVFRQIHN0YXR1cyBjb2RlLlxuICovXG5mdW5jdGlvbiBnZXRCcmVhZGNydW1iTG9nTGV2ZWxGcm9tSHR0cFN0YXR1c0NvZGUoc3RhdHVzQ29kZSkge1xuICAvLyBOT1RFOiB1bmRlZmluZWQgZGVmYXVsdHMgdG8gJ2luZm8nIGluIFNlbnRyeVxuICBpZiAoc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChzdGF0dXNDb2RlID49IDQwMCAmJiBzdGF0dXNDb2RlIDwgNTAwKSB7XG4gICAgcmV0dXJuICd3YXJuaW5nJztcbiAgfSBlbHNlIGlmIChzdGF0dXNDb2RlID49IDUwMCkge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0QnJlYWRjcnVtYkxvZ0xldmVsRnJvbUh0dHBTdGF0dXNDb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVhZGNydW1iLWxvZy1sZXZlbC5qcy5tYXBcbiIsImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG5jb25zdCBXSU5ET1cgPSBHTE9CQUxfT0JKIDtcblxuLyoqXG4gKiBUZWxscyB3aGV0aGVyIGN1cnJlbnQgZW52aXJvbm1lbnQgc3VwcG9ydHMgRXJyb3JFdmVudCBvYmplY3RzXG4gKiB7QGxpbmsgc3VwcG9ydHNFcnJvckV2ZW50fS5cbiAqXG4gKiBAcmV0dXJucyBBbnN3ZXIgdG8gdGhlIGdpdmVuIHF1ZXN0aW9uLlxuICovXG5mdW5jdGlvbiBzdXBwb3J0c0Vycm9yRXZlbnQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEVycm9yRXZlbnQoJycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgd2hldGhlciBjdXJyZW50IGVudmlyb25tZW50IHN1cHBvcnRzIERPTUVycm9yIG9iamVjdHNcbiAqIHtAbGluayBzdXBwb3J0c0RPTUVycm9yfS5cbiAqXG4gKiBAcmV0dXJucyBBbnN3ZXIgdG8gdGhlIGdpdmVuIHF1ZXN0aW9uLlxuICovXG5mdW5jdGlvbiBzdXBwb3J0c0RPTUVycm9yKCkge1xuICB0cnkge1xuICAgIC8vIENocm9tZTogVk04OToxIFVuY2F1Z2h0IFR5cGVFcnJvcjogRmFpbGVkIHRvIGNvbnN0cnVjdCAnRE9NRXJyb3InOlxuICAgIC8vIDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEl0IHJlYWxseSBuZWVkcyAxIGFyZ3VtZW50LCBub3QgMC5cbiAgICBuZXcgRE9NRXJyb3IoJycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgd2hldGhlciBjdXJyZW50IGVudmlyb25tZW50IHN1cHBvcnRzIERPTUV4Y2VwdGlvbiBvYmplY3RzXG4gKiB7QGxpbmsgc3VwcG9ydHNET01FeGNlcHRpb259LlxuICpcbiAqIEByZXR1cm5zIEFuc3dlciB0byB0aGUgZ2l2ZW4gcXVlc3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRzRE9NRXhjZXB0aW9uKCkge1xuICB0cnkge1xuICAgIG5ldyBET01FeGNlcHRpb24oJycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgd2hldGhlciBjdXJyZW50IGVudmlyb25tZW50IHN1cHBvcnRzIEhpc3RvcnkgQVBJXG4gKiB7QGxpbmsgc3VwcG9ydHNIaXN0b3J5fS5cbiAqXG4gKiBAcmV0dXJucyBBbnN3ZXIgdG8gdGhlIGdpdmVuIHF1ZXN0aW9uLlxuICovXG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHJldHVybiAnaGlzdG9yeScgaW4gV0lORE9XICYmICEhV0lORE9XLmhpc3Rvcnk7XG59XG5cbi8qKlxuICogVGVsbHMgd2hldGhlciBjdXJyZW50IGVudmlyb25tZW50IHN1cHBvcnRzIEZldGNoIEFQSVxuICoge0BsaW5rIHN1cHBvcnRzRmV0Y2h9LlxuICpcbiAqIEByZXR1cm5zIEFuc3dlciB0byB0aGUgZ2l2ZW4gcXVlc3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRzRmV0Y2goKSB7XG4gIGlmICghKCdmZXRjaCcgaW4gV0lORE9XKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbmV3IEhlYWRlcnMoKTtcbiAgICBuZXcgUmVxdWVzdCgnaHR0cDovL3d3dy5leGFtcGxlLmNvbScpO1xuICAgIG5ldyBSZXNwb25zZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogaXNOYXRpdmUgY2hlY2tzIGlmIHRoZSBnaXZlbiBmdW5jdGlvbiBpcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvblxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gaXNOYXRpdmVGdW5jdGlvbihmdW5jKSB7XG4gIHJldHVybiBmdW5jICYmIC9eZnVuY3Rpb25cXHMrXFx3K1xcKFxcKVxccytcXHtcXHMrXFxbbmF0aXZlIGNvZGVcXF1cXHMrXFx9JC8udGVzdChmdW5jLnRvU3RyaW5nKCkpO1xufVxuXG4vKipcbiAqIFRlbGxzIHdoZXRoZXIgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyBGZXRjaCBBUEkgbmF0aXZlbHlcbiAqIHtAbGluayBzdXBwb3J0c05hdGl2ZUZldGNofS5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIGB3aW5kb3cuZmV0Y2hgIGlzIG5hdGl2ZWx5IGltcGxlbWVudGVkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gc3VwcG9ydHNOYXRpdmVGZXRjaCgpIHtcbiAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc3VwcG9ydHNGZXRjaCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmFzdCBwYXRoIHRvIGF2b2lkIERPTSBJL09cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICBpZiAoaXNOYXRpdmVGdW5jdGlvbihXSU5ET1cuZmV0Y2gpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB3aW5kb3cuZmV0Y2ggaXMgaW1wbGVtZW50ZWQsIGJ1dCBpcyBwb2x5ZmlsbGVkIG9yIGFscmVhZHkgd3JhcHBlZCAoZS5nOiBieSBhIGNocm9tZSBleHRlbnNpb24pXG4gIC8vIHNvIGNyZWF0ZSBhIFwicHVyZVwiIGlmcmFtZSB0byBzZWUgaWYgdGhhdCBoYXMgbmF0aXZlIGZldGNoXG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgY29uc3QgZG9jID0gV0lORE9XLmRvY3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgaWYgKGRvYyAmJiB0eXBlb2YgKGRvYy5jcmVhdGVFbGVtZW50ICkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2FuZGJveCA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIHNhbmRib3guaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNhbmRib3gpO1xuICAgICAgaWYgKHNhbmRib3guY29udGVudFdpbmRvdz8uZmV0Y2gpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZXN1bHQgPSBpc05hdGl2ZUZ1bmN0aW9uKHNhbmRib3guY29udGVudFdpbmRvdy5mZXRjaCk7XG4gICAgICB9XG4gICAgICBkb2MuaGVhZC5yZW1vdmVDaGlsZChzYW5kYm94KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgY3JlYXRlIHNhbmRib3ggaWZyYW1lIGZvciBwdXJlIGZldGNoIGNoZWNrLCBiYWlsaW5nIHRvIHdpbmRvdy5mZXRjaDogJywgZXJyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRlbGxzIHdoZXRoZXIgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyBSZXBvcnRpbmdPYnNlcnZlciBBUElcbiAqIHtAbGluayBzdXBwb3J0c1JlcG9ydGluZ09ic2VydmVyfS5cbiAqXG4gKiBAcmV0dXJucyBBbnN3ZXIgdG8gdGhlIGdpdmVuIHF1ZXN0aW9uLlxuICovXG5mdW5jdGlvbiBzdXBwb3J0c1JlcG9ydGluZ09ic2VydmVyKCkge1xuICByZXR1cm4gJ1JlcG9ydGluZ09ic2VydmVyJyBpbiBXSU5ET1c7XG59XG5cbi8qKlxuICogVGVsbHMgd2hldGhlciBjdXJyZW50IGVudmlyb25tZW50IHN1cHBvcnRzIFJlZmVycmVyIFBvbGljeSBBUElcbiAqIHtAbGluayBzdXBwb3J0c1JlZmVycmVyUG9saWN5fS5cbiAqXG4gKiBAcmV0dXJucyBBbnN3ZXIgdG8gdGhlIGdpdmVuIHF1ZXN0aW9uLlxuICovXG5mdW5jdGlvbiBzdXBwb3J0c1JlZmVycmVyUG9saWN5KCkge1xuICAvLyBEZXNwaXRlIGFsbCBzdGFycyBpbiB0aGUgc2t5IHNheWluZyB0aGF0IEVkZ2Ugc3VwcG9ydHMgb2xkIGRyYWZ0IHN5bnRheCwgYWthICduZXZlcicsICdhbHdheXMnLCAnb3JpZ2luJyBhbmQgJ2RlZmF1bHQnXG4gIC8vIChzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1yZWZlcnJlci1wb2xpY3kpLFxuICAvLyBpdCBkb2Vzbid0LiBBbmQgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbnN0ZWFkIG9mIGlnbm9yaW5nIHRoaXMgcGFyYW1ldGVyLi4uXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9yYXZlbi1qcy9pc3N1ZXMvMTIzM1xuXG4gIGlmICghc3VwcG9ydHNGZXRjaCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBuZXcgUmVxdWVzdCgnXycsIHtcbiAgICAgIHJlZmVycmVyUG9saWN5OiAnb3JpZ2luJyAsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgaXNOYXRpdmVGdW5jdGlvbiwgc3VwcG9ydHNET01FcnJvciwgc3VwcG9ydHNET01FeGNlcHRpb24sIHN1cHBvcnRzRXJyb3JFdmVudCwgc3VwcG9ydHNGZXRjaCwgc3VwcG9ydHNIaXN0b3J5LCBzdXBwb3J0c05hdGl2ZUZldGNoLCBzdXBwb3J0c1JlZmVycmVyUG9saWN5LCBzdXBwb3J0c1JlcG9ydGluZ09ic2VydmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBwb3J0cy5qcy5tYXBcbiIsImltcG9ydCB7IGlzRXJyb3IsIGlzUmVxdWVzdCB9IGZyb20gJy4uL2lzLmpzJztcbmltcG9ydCB7IGZpbGwsIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4uL29iamVjdC5qcyc7XG5pbXBvcnQgeyBzdXBwb3J0c05hdGl2ZUZldGNoIH0gZnJvbSAnLi4vc3VwcG9ydHMuanMnO1xuaW1wb3J0IHsgdGltZXN0YW1wSW5TZWNvbmRzIH0gZnJvbSAnLi4vdGltZS5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi4vd29ybGR3aWRlLmpzJztcbmltcG9ydCB7IGFkZEhhbmRsZXIsIG1heWJlSW5zdHJ1bWVudCwgdHJpZ2dlckhhbmRsZXJzIH0gZnJvbSAnLi9oYW5kbGVycy5qcyc7XG5cbi8qKlxuICogQWRkIGFuIGluc3RydW1lbnRhdGlvbiBoYW5kbGVyIGZvciB3aGVuIGEgZmV0Y2ggcmVxdWVzdCBoYXBwZW5zLlxuICogVGhlIGhhbmRsZXIgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgcmVxdWVzdCBzdGFydHMgYW5kIG9uY2Ugd2hlbiBpdCBlbmRzLFxuICogd2hpY2ggY2FuIGJlIGlkZW50aWZpZWQgYnkgY2hlY2tpbmcgaWYgaXQgaGFzIGFuIGBlbmRUaW1lc3RhbXBgLlxuICpcbiAqIFVzZSBhdCB5b3VyIG93biByaXNrLCB0aGlzIG1pZ2h0IGJyZWFrIHdpdGhvdXQgY2hhbmdlbG9nIG5vdGljZSwgb25seSB1c2VkIGludGVybmFsbHkuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFkZEZldGNoSW5zdHJ1bWVudGF0aW9uSGFuZGxlcihcbiAgaGFuZGxlcixcbiAgc2tpcE5hdGl2ZUZldGNoQ2hlY2ssXG4pIHtcbiAgY29uc3QgdHlwZSA9ICdmZXRjaCc7XG4gIGFkZEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gIG1heWJlSW5zdHJ1bWVudCh0eXBlLCAoKSA9PiBpbnN0cnVtZW50RmV0Y2godW5kZWZpbmVkLCBza2lwTmF0aXZlRmV0Y2hDaGVjaykpO1xufVxuXG4vKipcbiAqIEFkZCBhbiBpbnN0cnVtZW50YXRpb24gaGFuZGxlciBmb3IgbG9uZy1saXZlZCBmZXRjaCByZXF1ZXN0cywgbGlrZSBjb25zdW1pbmcgc2VydmVyLXNlbnQgZXZlbnRzIChTU0UpIHZpYSBmZXRjaC5cbiAqIFRoZSBoYW5kbGVyIHdpbGwgcmVzb2x2ZSB0aGUgcmVxdWVzdCBib2R5IGFuZCBlbWl0IHRoZSBhY3R1YWwgYGVuZFRpbWVzdGFtcGAsIHNvIHRoYXQgdGhlXG4gKiBzcGFuIGNhbiBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICpcbiAqIE9ubHkgdXNlZCBpbnRlcm5hbGx5XG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFkZEZldGNoRW5kSW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gIGNvbnN0IHR5cGUgPSAnZmV0Y2gtYm9keS1yZXNvbHZlZCc7XG4gIGFkZEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gIG1heWJlSW5zdHJ1bWVudCh0eXBlLCAoKSA9PiBpbnN0cnVtZW50RmV0Y2goc3RyZWFtSGFuZGxlcikpO1xufVxuXG5mdW5jdGlvbiBpbnN0cnVtZW50RmV0Y2gob25GZXRjaFJlc29sdmVkLCBza2lwTmF0aXZlRmV0Y2hDaGVjayA9IGZhbHNlKSB7XG4gIGlmIChza2lwTmF0aXZlRmV0Y2hDaGVjayAmJiAhc3VwcG9ydHNOYXRpdmVGZXRjaCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmlsbChHTE9CQUxfT0JKLCAnZmV0Y2gnLCBmdW5jdGlvbiAob3JpZ2luYWxGZXRjaCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgLy8gV2UgY2FwdHVyZSB0aGUgZXJyb3IgcmlnaHQgaGVyZSBhbmQgbm90IGluIHRoZSBQcm9taXNlIGVycm9yIGNhbGxiYWNrIGJlY2F1c2UgU2FmYXJpIChhbmQgcHJvYmFibHkgb3RoZXJcbiAgICAgIC8vIGJyb3dzZXJzIHRvbykgd2lsbCB3aXBlIHRoZSBzdGFjayB0cmFjZSB1cCB0byB0aGlzIHBvaW50LCBvbmx5IGxlYXZpbmcgdXMgd2l0aCB0aGlzIGZpbGUgd2hpY2ggaXMgdXNlbGVzcy5cblxuICAgICAgLy8gTk9URTogSWYgeW91IGFyZSBhIFNlbnRyeSB1c2VyLCBhbmQgeW91IGFyZSBzZWVpbmcgdGhpcyBzdGFjayBmcmFtZSxcbiAgICAgIC8vICAgICAgIGl0IG1lYW5zIHRoZSBlcnJvciwgdGhhdCB3YXMgY2F1c2VkIGJ5IHlvdXIgZmV0Y2ggY2FsbCBkaWQgbm90XG4gICAgICAvLyAgICAgICBoYXZlIGEgc3RhY2sgdHJhY2UsIHNvIHRoZSBTREsgYmFja2ZpbGxlZCB0aGUgc3RhY2sgdHJhY2Ugc29cbiAgICAgIC8vICAgICAgIHlvdSBjYW4gc2VlIHdoaWNoIGZldGNoIGNhbGwgZmFpbGVkLlxuICAgICAgY29uc3QgdmlydHVhbEVycm9yID0gbmV3IEVycm9yKCk7XG5cbiAgICAgIGNvbnN0IHsgbWV0aG9kLCB1cmwgfSA9IHBhcnNlRmV0Y2hBcmdzKGFyZ3MpO1xuICAgICAgY29uc3QgaGFuZGxlckRhdGEgPSB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGZldGNoRGF0YToge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICB1cmwsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wOiB0aW1lc3RhbXBJblNlY29uZHMoKSAqIDEwMDAsXG4gICAgICAgIC8vIC8vIEFkZGluZyB0aGUgZXJyb3IgdG8gYmUgYWJsZSB0byBmaW5nZXJwcmludCB0aGUgZmFpbGVkIGZldGNoIGV2ZW50IGluIEh0dHBDbGllbnQgaW5zdHJ1bWVudGF0aW9uXG4gICAgICAgIHZpcnR1YWxFcnJvcixcbiAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc0Zyb21GZXRjaEFyZ3MoYXJncyksXG4gICAgICB9O1xuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBjYWxsYmFjaywgZmV0Y2ggaXMgaW5zdHJ1bWVudGVkIGRpcmVjdGx5XG4gICAgICBpZiAoIW9uRmV0Y2hSZXNvbHZlZCkge1xuICAgICAgICB0cmlnZ2VySGFuZGxlcnMoJ2ZldGNoJywge1xuICAgICAgICAgIC4uLmhhbmRsZXJEYXRhLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgcmV0dXJuIG9yaWdpbmFsRmV0Y2guYXBwbHkoR0xPQkFMX09CSiwgYXJncykudGhlbihcbiAgICAgICAgYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKG9uRmV0Y2hSZXNvbHZlZCkge1xuICAgICAgICAgICAgb25GZXRjaFJlc29sdmVkKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckhhbmRsZXJzKCdmZXRjaCcsIHtcbiAgICAgICAgICAgICAgLi4uaGFuZGxlckRhdGEsXG4gICAgICAgICAgICAgIGVuZFRpbWVzdGFtcDogdGltZXN0YW1wSW5TZWNvbmRzKCkgKiAxMDAwLFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgdHJpZ2dlckhhbmRsZXJzKCdmZXRjaCcsIHtcbiAgICAgICAgICAgIC4uLmhhbmRsZXJEYXRhLFxuICAgICAgICAgICAgZW5kVGltZXN0YW1wOiB0aW1lc3RhbXBJblNlY29uZHMoKSAqIDEwMDAsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yKSAmJiBlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBJZiB5b3UgYXJlIGEgU2VudHJ5IHVzZXIsIGFuZCB5b3UgYXJlIHNlZWluZyB0aGlzIHN0YWNrIGZyYW1lLFxuICAgICAgICAgICAgLy8gICAgICAgaXQgbWVhbnMgdGhlIGVycm9yLCB0aGF0IHdhcyBjYXVzZWQgYnkgeW91ciBmZXRjaCBjYWxsIGRpZCBub3RcbiAgICAgICAgICAgIC8vICAgICAgIGhhdmUgYSBzdGFjayB0cmFjZSwgc28gdGhlIFNESyBiYWNrZmlsbGVkIHRoZSBzdGFjayB0cmFjZSBzb1xuICAgICAgICAgICAgLy8gICAgICAgeW91IGNhbiBzZWUgd2hpY2ggZmV0Y2ggY2FsbCBmYWlsZWQuXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IHZpcnR1YWxFcnJvci5zdGFjaztcbiAgICAgICAgICAgIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShlcnJvciwgJ2ZyYW1lc1RvUG9wJywgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2UgZW5oYW5jZSB0aGUgbm90LXNvLWhlbHBmdWwgXCJGYWlsZWQgdG8gZmV0Y2hcIiBlcnJvciBtZXNzYWdlcyB3aXRoIHRoZSBob3N0XG4gICAgICAgICAgLy8gUG9zc2libGUgbWVzc2FnZXMgd2UgaGFuZGxlIGhlcmU6XG4gICAgICAgICAgLy8gKiBcIkZhaWxlZCB0byBmZXRjaFwiIChjaHJvbWl1bSlcbiAgICAgICAgICAvLyAqIFwiTG9hZCBmYWlsZWRcIiAod2Via2l0KVxuICAgICAgICAgIC8vICogXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIChmaXJlZm94KVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmXG4gICAgICAgICAgICAoZXJyb3IubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcgfHxcbiAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ0xvYWQgZmFpbGVkJyB8fFxuICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID09PSAnTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChoYW5kbGVyRGF0YS5mZXRjaERhdGEudXJsKTtcbiAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGAke2Vycm9yLm1lc3NhZ2V9ICgke3VybC5ob3N0fSlgO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIC8vIGlnbm9yZSBpdCBpZiBlcnJvcnMgaGFwcGVuIGhlcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBJZiB5b3UgYXJlIGEgU2VudHJ5IHVzZXIsIGFuZCB5b3UgYXJlIHNlZWluZyB0aGlzIHN0YWNrIGZyYW1lLFxuICAgICAgICAgIC8vICAgICAgIGl0IG1lYW5zIHRoZSBzZW50cnkuamF2YXNjcmlwdCBTREsgY2F1Z2h0IGFuIGVycm9yIGludm9raW5nIHlvdXIgYXBwbGljYXRpb24gY29kZS5cbiAgICAgICAgICAvLyAgICAgICBUaGlzIGlzIGV4cGVjdGVkIGJlaGF2aW9yIGFuZCBOT1QgaW5kaWNhdGl2ZSBvZiBhIGJ1ZyB3aXRoIHNlbnRyeS5qYXZhc2NyaXB0LlxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9O1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVJlc3BvbnNlKHJlcywgb25GaW5pc2hlZFJlc29sdmluZykge1xuICBpZiAocmVzPy5ib2R5KSB7XG4gICAgY29uc3QgYm9keSA9IHJlcy5ib2R5O1xuICAgIGNvbnN0IHJlc3BvbnNlUmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcblxuICAgIC8vIERlZmluZSBhIG1heGltdW0gZHVyYXRpb24gYWZ0ZXIgd2hpY2ggd2UganVzdCBjYW5jZWxcbiAgICBjb25zdCBtYXhGZXRjaER1cmF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGJvZHkuY2FuY2VsKCkudGhlbihudWxsLCAoKSA9PiB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICA5MCAqIDEwMDAsIC8vIDkwc1xuICAgICk7XG5cbiAgICBsZXQgcmVhZGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgd2hpbGUgKHJlYWRpbmdBY3RpdmUpIHtcbiAgICAgIGxldCBjaHVua1RpbWVvdXQ7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhYm9ydCByZWFkaW5nIGlmIHJlYWQgb3AgdGFrZXMgbW9yZSB0aGFuIDVzXG4gICAgICAgIGNodW5rVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGJvZHkuY2FuY2VsKCkudGhlbihudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBub29wIG9uIGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDUwMDApO1xuXG4gICAgICAgIC8vIFRoaXMgLnJlYWQoKSBjYWxsIHdpbGwgcmVqZWN0L3Rocm93IHdoZW4gd2UgYWJvcnQgZHVlIHRvIHRpbWVvdXRzIHRocm91Z2ggYGJvZHkuY2FuY2VsKClgXG4gICAgICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVzcG9uc2VSZWFkZXIucmVhZCgpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dChjaHVua1RpbWVvdXQpO1xuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgb25GaW5pc2hlZFJlc29sdmluZygpO1xuICAgICAgICAgIHJlYWRpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVhZGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rVGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KG1heEZldGNoRHVyYXRpb25UaW1lb3V0KTtcblxuICAgIHJlc3BvbnNlUmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgYm9keS5jYW5jZWwoKS50aGVuKG51bGwsICgpID0+IHtcbiAgICAgIC8vIG5vb3Agb24gZXJyb3JcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJlYW1IYW5kbGVyKHJlc3BvbnNlKSB7XG4gIC8vIGNsb25lIHJlc3BvbnNlIGZvciBhd2FpdGluZyBzdHJlYW1cbiAgbGV0IGNsb25lZFJlc3BvbnNlRm9yUmVzb2x2aW5nO1xuICB0cnkge1xuICAgIGNsb25lZFJlc3BvbnNlRm9yUmVzb2x2aW5nID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICByZXNvbHZlUmVzcG9uc2UoY2xvbmVkUmVzcG9uc2VGb3JSZXNvbHZpbmcsICgpID0+IHtcbiAgICB0cmlnZ2VySGFuZGxlcnMoJ2ZldGNoLWJvZHktcmVzb2x2ZWQnLCB7XG4gICAgICBlbmRUaW1lc3RhbXA6IHRpbWVzdGFtcEluU2Vjb25kcygpICogMTAwMCxcbiAgICAgIHJlc3BvbnNlLFxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFzUHJvcChvYmosIHByb3ApIHtcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICEhKG9iaiApW3Byb3BdO1xufVxuXG5mdW5jdGlvbiBnZXRVcmxGcm9tUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzb3VyY2U7XG4gIH1cblxuICBpZiAoIXJlc291cmNlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGhhc1Byb3AocmVzb3VyY2UsICd1cmwnKSkge1xuICAgIHJldHVybiByZXNvdXJjZS51cmw7XG4gIH1cblxuICBpZiAocmVzb3VyY2UudG9TdHJpbmcpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGZldGNoIGFyZ3VtZW50cyB0byBmaW5kIHRoZSB1c2VkIEh0dHAgbWV0aG9kIGFuZCB0aGUgdXJsIG9mIHRoZSByZXF1ZXN0LlxuICogRXhwb3J0ZWQgZm9yIHRlc3RzIG9ubHkuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmV0Y2hBcmdzKGZldGNoQXJncykge1xuICBpZiAoZmV0Y2hBcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IG1ldGhvZDogJ0dFVCcsIHVybDogJycgfTtcbiAgfVxuXG4gIGlmIChmZXRjaEFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgW3VybCwgb3B0aW9uc10gPSBmZXRjaEFyZ3MgO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogZ2V0VXJsRnJvbVJlc291cmNlKHVybCksXG4gICAgICBtZXRob2Q6IGhhc1Byb3Aob3B0aW9ucywgJ21ldGhvZCcpID8gU3RyaW5nKG9wdGlvbnMubWV0aG9kKS50b1VwcGVyQ2FzZSgpIDogJ0dFVCcsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGFyZyA9IGZldGNoQXJnc1swXTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IGdldFVybEZyb21SZXNvdXJjZShhcmcgKSxcbiAgICBtZXRob2Q6IGhhc1Byb3AoYXJnLCAnbWV0aG9kJykgPyBTdHJpbmcoYXJnLm1ldGhvZCkudG9VcHBlckNhc2UoKSA6ICdHRVQnLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkZXJzRnJvbUZldGNoQXJncyhmZXRjaEFyZ3MpIHtcbiAgY29uc3QgW3JlcXVlc3RBcmd1bWVudCwgb3B0aW9uc0FyZ3VtZW50XSA9IGZldGNoQXJncztcblxuICB0cnkge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zQXJndW1lbnQgPT09ICdvYmplY3QnICYmXG4gICAgICBvcHRpb25zQXJndW1lbnQgIT09IG51bGwgJiZcbiAgICAgICdoZWFkZXJzJyBpbiBvcHRpb25zQXJndW1lbnQgJiZcbiAgICAgIG9wdGlvbnNBcmd1bWVudC5oZWFkZXJzXG4gICAgKSB7XG4gICAgICByZXR1cm4gbmV3IEhlYWRlcnMob3B0aW9uc0FyZ3VtZW50LmhlYWRlcnMgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHJlcXVlc3RBcmd1bWVudCkpIHtcbiAgICAgIHJldHVybiBuZXcgSGVhZGVycyhyZXF1ZXN0QXJndW1lbnQuaGVhZGVycyk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBub29wXG4gIH1cblxuICByZXR1cm47XG59XG5cbmV4cG9ydCB7IGFkZEZldGNoRW5kSW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgYWRkRmV0Y2hJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBwYXJzZUZldGNoQXJncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwXG4iLCIvKlxuICogVGhpcyBtb2R1bGUgZXhpc3RzIGZvciBvcHRpbWl6YXRpb25zIGluIHRoZSBidWlsZCBwcm9jZXNzIHRocm91Z2ggcm9sbHVwIGFuZCB0ZXJzZXIuICBXZSBkZWZpbmUgc29tZSBnbG9iYWxcbiAqIGNvbnN0YW50cywgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gZHVyaW5nIGJ1aWxkLiBCeSBndWFyZGluZyBjZXJ0YWluIHBpZWNlcyBvZiBjb2RlIHdpdGggZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRoZXNlXG4gKiBjb25zdGFudHMsIHdlIGNhbiBjb250cm9sIHdoZXRoZXIgb3Igbm90IHRoZXkgYXBwZWFyIGluIHRoZSBmaW5hbCBidW5kbGUuIChBbnkgY29kZSBndWFyZGVkIGJ5IGEgZmFsc2UgY29uZGl0aW9uIHdpbGxcbiAqIG5ldmVyIHJ1biwgYW5kIHdpbGwgaGVuY2UgYmUgZHJvcHBlZCBkdXJpbmcgdHJlZXNoYWtpbmcuKSBUaGUgdHdvIHByaW1hcnkgdXNlcyBmb3IgdGhpcyBhcmUgc3RyaXBwaW5nIG91dCBjYWxscyB0b1xuICogYGxvZ2dlcmAgYW5kIHByZXZlbnRpbmcgbm9kZS1yZWxhdGVkIGNvZGUgZnJvbSBhcHBlYXJpbmcgaW4gYnJvd3NlciBidW5kbGVzLlxuICpcbiAqIEF0dGVudGlvbjpcbiAqIFRoaXMgZmlsZSBzaG91bGQgbm90IGJlIHVzZWQgdG8gZGVmaW5lIGNvbnN0YW50cy9mbGFncyB0aGF0IGFyZSBpbnRlbmRlZCB0byBiZSB1c2VkIGZvciB0cmVlLXNoYWtpbmcgY29uZHVjdGVkIGJ5XG4gKiB1c2Vycy4gVGhlc2UgZmxhZ3Mgc2hvdWxkIGxpdmUgaW4gdGhlaXIgcmVzcGVjdGl2ZSBwYWNrYWdlcywgYXMgd2UgaWRlbnRpZmllZCB1c2VyIHRvb2xpbmcgKHNwZWNpZmljYWxseSB3ZWJwYWNrKVxuICogaGF2aW5nIGlzc3VlcyB0cmVlLXNoYWtpbmcgdGhlc2UgY29uc3RhbnRzIGFjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMuXG4gKiBBbiBleGFtcGxlIGZvciB0aGlzIGlzIHRoZSBfX1NFTlRSWV9ERUJVR19fIGNvbnN0YW50LiBJdCBpcyBkZWNsYXJlZCBpbiBlYWNoIHBhY2thZ2UgaW5kaXZpZHVhbGx5IGJlY2F1c2Ugd2Ugd2FudFxuICogdXNlcnMgdG8gYmUgYWJsZSB0byBzaGFrZSBhd2F5IGV4cHJlc3Npb25zIHRoYXQgaXQgZ3VhcmRzLlxuICovXG5cbi8qKlxuICogRmlndXJlcyBvdXQgaWYgd2UncmUgYnVpbGRpbmcgYSBicm93c2VyIGJ1bmRsZS5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSBicm93c2VyIGJ1bmRsZSBidWlsZC5cbiAqL1xuZnVuY3Rpb24gaXNCcm93c2VyQnVuZGxlKCkge1xuICByZXR1cm4gdHlwZW9mIF9fU0VOVFJZX0JST1dTRVJfQlVORExFX18gIT09ICd1bmRlZmluZWQnICYmICEhX19TRU5UUllfQlJPV1NFUl9CVU5ETEVfXztcbn1cblxuLyoqXG4gKiBHZXQgc291cmNlIG9mIFNESy5cbiAqL1xuZnVuY3Rpb24gZ2V0U0RLU291cmNlKCkge1xuICAvLyBUaGlzIGNvbW1lbnQgaXMgdXNlZCB0byBpZGVudGlmeSB0aGlzIGxpbmUgaW4gdGhlIENETiBidW5kbGUgYnVpbGQgc3RlcCBhbmQgcmVwbGFjZSB0aGlzIHdpdGggXCJyZXR1cm4gJ2Nkbic7XCJcbiAgLyogX19TRU5UUllfU0RLX1NPVVJDRV9fICovIHJldHVybiAnbnBtJztcbn1cblxuZXhwb3J0IHsgZ2V0U0RLU291cmNlLCBpc0Jyb3dzZXJCdW5kbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudi5qcy5tYXBcbiIsImltcG9ydCB7IEdMT0JBTF9PQkosIGdldE9yaWdpbmFsRnVuY3Rpb24sIG1hcmtGdW5jdGlvbldyYXBwZWQsIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSwgd2l0aFNjb3BlLCBhZGRFeGNlcHRpb25UeXBlVmFsdWUsIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbSwgY2FwdHVyZUV4Y2VwdGlvbiB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5cbmNvbnN0IFdJTkRPVyA9IEdMT0JBTF9PQkogO1xuXG5sZXQgaWdub3JlT25FcnJvciA9IDA7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVPbkVycm9yKCkge1xuICByZXR1cm4gaWdub3JlT25FcnJvciA+IDA7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpZ25vcmVOZXh0T25FcnJvcigpIHtcbiAgLy8gb25lcnJvciBzaG91bGQgdHJpZ2dlciBiZWZvcmUgc2V0VGltZW91dFxuICBpZ25vcmVPbkVycm9yKys7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlnbm9yZU9uRXJyb3ItLTtcbiAgfSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5cbi8qKlxuICogSW5zdHJ1bWVudHMgdGhlIGdpdmVuIGZ1bmN0aW9uIGFuZCBzZW5kcyBhbiBldmVudCB0byBTZW50cnkgZXZlcnkgdGltZSB0aGVcbiAqIGZ1bmN0aW9uIHRocm93cyBhbiBleGNlcHRpb24uXG4gKlxuICogQHBhcmFtIGZuIEEgZnVuY3Rpb24gdG8gd3JhcC4gSXQgaXMgZ2VuZXJhbGx5IHNhZmUgdG8gcGFzcyBhbiB1bmJvdW5kIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSByZXR1cm5lZCB3cmFwcGVyIGFsd2F5c1xuICogaGFzIGEgY29ycmVjdCBgdGhpc2AgY29udGV4dC5cbiAqIEByZXR1cm5zIFRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB3cmFwKFxuICBmbixcbiAgb3B0aW9uc1xuXG4gPSB7fSxcbikge1xuICAvLyBmb3IgZnV0dXJlIHJlYWRlcnMgd2hhdCB0aGlzIGRvZXMgaXMgd3JhcCBhIGZ1bmN0aW9uIGFuZCB0aGVuIGNyZWF0ZVxuICAvLyBhIGJpLWRpcmVjdGlvbmFsIHdyYXBwaW5nIGJldHdlZW4gdGhlbS5cbiAgLy9cbiAgLy8gZXhhbXBsZTogd3JhcHBlZCA9IHdyYXAob3JpZ2luYWwpO1xuICAvLyAgb3JpZ2luYWwuX19zZW50cnlfd3JhcHBlZF9fIC0+IHdyYXBwZWRcbiAgLy8gIHdyYXBwZWQuX19zZW50cnlfb3JpZ2luYWxfXyAtPiBvcmlnaW5hbFxuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgZnVuY3Rpb24gdGhhdCB3YXMgcHJldmlvdXNseSB3cmFwcGVkLCByZXR1cm5cbiAgICAvLyB0aGUgb3JpZ2luYWwgd3JhcHBlci5cbiAgICBjb25zdCB3cmFwcGVyID0gKGZuICkuX19zZW50cnlfd3JhcHBlZF9fO1xuICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBmaW5kIHRoYXQgdGhlIGBfX3NlbnRyeV93cmFwcGVkX19gIGZ1bmN0aW9uIGlzIG5vdCBhIGZ1bmN0aW9uIGF0IHRoZSB0aW1lIG9mIGFjY2Vzc2luZyBpdCwgaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCBzb21ldGhpbmcgbWVzc2VkIHdpdGggaXQuIEluIHRoYXQgY2FzZSB3ZSB3YW50IHRvIHJldHVybiB0aGUgb3JpZ2luYWxseSBwYXNzZWQgZnVuY3Rpb24uXG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBkb24ndCB3YW5uYSB3cmFwIGl0IHR3aWNlXG4gICAgaWYgKGdldE9yaWdpbmFsRnVuY3Rpb24oZm4pKSB7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSnVzdCBhY2Nlc3NpbmcgY3VzdG9tIHByb3BzIGluIHNvbWUgU2VsZW5pdW0gZW52aXJvbm1lbnRzXG4gICAgLy8gY2FuIGNhdXNlIGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGV4Y2VwdGlvbiAoc2VlIHJhdmVuLWpzIzQ5NSkuXG4gICAgLy8gQmFpbCBvbiB3cmFwcGluZyBhbmQgcmV0dXJuIHRoZSBmdW5jdGlvbiBhcy1pcyAoZGVmZXJzIHRvIHdpbmRvdy5vbmVycm9yKS5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBXcmFwIHRoZSBmdW5jdGlvbiBpdHNlbGZcbiAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgYHNlbnRyeVdyYXBwZWRgIGlzIG5vdCBhbiBhcnJvdyBmdW5jdGlvbiB0byBwcmVzZXJ2ZSB0aGUgY29udGV4dCBvZiBgdGhpc2BcbiAgY29uc3Qgc2VudHJ5V3JhcHBlZCA9IGZ1bmN0aW9uICggLi4uYXJncykge1xuICAgIHRyeSB7XG4gICAgICAvLyBBbHNvIHdyYXAgYXJndW1lbnRzIHRoYXQgYXJlIHRoZW1zZWx2ZXMgZnVuY3Rpb25zXG4gICAgICBjb25zdCB3cmFwcGVkQXJndW1lbnRzID0gYXJncy5tYXAoYXJnID0+IHdyYXAoYXJnLCBvcHRpb25zKSk7XG5cbiAgICAgIC8vIEF0dGVtcHQgdG8gaW52b2tlIHVzZXItbGFuZCBmdW5jdGlvblxuICAgICAgLy8gTk9URTogSWYgeW91IGFyZSBhIFNlbnRyeSB1c2VyLCBhbmQgeW91IGFyZSBzZWVpbmcgdGhpcyBzdGFjayBmcmFtZSwgaXRcbiAgICAgIC8vICAgICAgIG1lYW5zIHRoZSBzZW50cnkuamF2YXNjcmlwdCBTREsgY2F1Z2h0IGFuIGVycm9yIGludm9raW5nIHlvdXIgYXBwbGljYXRpb24gY29kZS4gVGhpc1xuICAgICAgLy8gICAgICAgaXMgZXhwZWN0ZWQgYmVoYXZpb3IgYW5kIE5PVCBpbmRpY2F0aXZlIG9mIGEgYnVnIHdpdGggc2VudHJ5LmphdmFzY3JpcHQuXG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgd3JhcHBlZEFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlnbm9yZU5leHRPbkVycm9yKCk7XG5cbiAgICAgIHdpdGhTY29wZShzY29wZSA9PiB7XG4gICAgICAgIHNjb3BlLmFkZEV2ZW50UHJvY2Vzc29yKGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5tZWNoYW5pc20pIHtcbiAgICAgICAgICAgIGFkZEV4Y2VwdGlvblR5cGVWYWx1ZShldmVudCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgYWRkRXhjZXB0aW9uTWVjaGFuaXNtKGV2ZW50LCBvcHRpb25zLm1lY2hhbmlzbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnQuZXh0cmEgPSB7XG4gICAgICAgICAgICAuLi5ldmVudC5leHRyYSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogYXJncyxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBjYXB0dXJlRXhjZXB0aW9uKGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH0gO1xuXG4gIC8vIFdyYXAgdGhlIHdyYXBwZWQgZnVuY3Rpb24gaW4gYSBwcm94eSwgdG8gZW5zdXJlIGFueSBvdGhlciBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiByZW1haW4gYXZhaWxhYmxlXG4gIHRyeSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBmbikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmbiwgcHJvcGVydHkpKSB7XG4gICAgICAgIHNlbnRyeVdyYXBwZWRbcHJvcGVydHkgXSA9IGZuW3Byb3BlcnR5IF07XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBBY2Nlc3Npbmcgc29tZSBvYmplY3RzIG1heSB0aHJvd1xuICAgIC8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMTE2OFxuICB9XG5cbiAgLy8gU2lnbmFsIHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiB3cmFwcGVkL2ZpbGxlZCBhbHJlYWR5XG4gIC8vIGZvciBib3RoIGRlYnVnZ2luZyBhbmQgdG8gcHJldmVudCBpdCB0byBiZWluZyB3cmFwcGVkL2ZpbGxlZCB0d2ljZVxuICBtYXJrRnVuY3Rpb25XcmFwcGVkKHNlbnRyeVdyYXBwZWQsIGZuKTtcblxuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoZm4sICdfX3NlbnRyeV93cmFwcGVkX18nLCBzZW50cnlXcmFwcGVkKTtcblxuICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uIG5hbWUgKG5vdCBhbGwgYnJvd3NlcnMgYWxsb3cgdGhhdClcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlbnRyeVdyYXBwZWQsICduYW1lJyk7XG4gICAgaWYgKGRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VudHJ5V3JhcHBlZCwgJ25hbWUnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZm4ubmFtZTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gVGhpcyBtYXkgdGhyb3cgaWYgZS5nLiB0aGUgZGVzY3JpcHRvciBkb2VzIG5vdCBleGlzdCwgb3IgYSBicm93c2VyIGRvZXMgbm90IGFsbG93IHJlZGVmaW5pbmcgYG5hbWVgLlxuICAgIC8vIHRvIHNhdmUgc29tZSBieXRlcyB3ZSBzaW1wbHkgdHJ5LWNhdGNoIHRoaXNcbiAgfVxuXG4gIHJldHVybiBzZW50cnlXcmFwcGVkO1xufVxuXG5leHBvcnQgeyBXSU5ET1csIGlnbm9yZU5leHRPbkVycm9yLCBzaG91bGRJZ25vcmVPbkVycm9yLCB3cmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIiwiaW1wb3J0IHsgaXNFcnJvckV2ZW50LCBpc0RPTUVycm9yLCBpc0RPTUV4Y2VwdGlvbiwgYWRkRXhjZXB0aW9uVHlwZVZhbHVlLCBpc0Vycm9yLCBpc1BsYWluT2JqZWN0LCBpc0V2ZW50LCBhZGRFeGNlcHRpb25NZWNoYW5pc20sIGlzUGFyYW1ldGVyaXplZFN0cmluZywgZ2V0Q2xpZW50LCBub3JtYWxpemVUb1NpemUsIGV4dHJhY3RFeGNlcHRpb25LZXlzRm9yTWVzc2FnZSwgcmVzb2x2ZWRTeW5jUHJvbWlzZSB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBFcnJvclxuICovXG5mdW5jdGlvbiBleGNlcHRpb25Gcm9tRXJyb3Ioc3RhY2tQYXJzZXIsIGV4KSB7XG4gIC8vIEdldCB0aGUgZnJhbWVzIGZpcnN0IHNpbmNlIE9wZXJhIGNhbiBsb3NlIHRoZSBzdGFjayBpZiB3ZSB0b3VjaCBhbnl0aGluZyBlbHNlIGZpcnN0XG4gIGNvbnN0IGZyYW1lcyA9IHBhcnNlU3RhY2tGcmFtZXMoc3RhY2tQYXJzZXIsIGV4KTtcblxuICBjb25zdCBleGNlcHRpb24gPSB7XG4gICAgdHlwZTogZXh0cmFjdFR5cGUoZXgpLFxuICAgIHZhbHVlOiBleHRyYWN0TWVzc2FnZShleCksXG4gIH07XG5cbiAgaWYgKGZyYW1lcy5sZW5ndGgpIHtcbiAgICBleGNlcHRpb24uc3RhY2t0cmFjZSA9IHsgZnJhbWVzIH07XG4gIH1cblxuICBpZiAoZXhjZXB0aW9uLnR5cGUgPT09IHVuZGVmaW5lZCAmJiBleGNlcHRpb24udmFsdWUgPT09ICcnKSB7XG4gICAgZXhjZXB0aW9uLnZhbHVlID0gJ1VucmVjb3ZlcmFibGUgZXJyb3IgY2F1Z2h0JztcbiAgfVxuXG4gIHJldHVybiBleGNlcHRpb247XG59XG5cbmZ1bmN0aW9uIGV2ZW50RnJvbVBsYWluT2JqZWN0KFxuICBzdGFja1BhcnNlcixcbiAgZXhjZXB0aW9uLFxuICBzeW50aGV0aWNFeGNlcHRpb24sXG4gIGlzVW5oYW5kbGVkUmVqZWN0aW9uLFxuKSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBjb25zdCBub3JtYWxpemVEZXB0aCA9IGNsaWVudD8uZ2V0T3B0aW9ucygpLm5vcm1hbGl6ZURlcHRoO1xuXG4gIC8vIElmIHdlIGNhbiwgd2UgZXh0cmFjdCBhbiBleGNlcHRpb24gZnJvbSB0aGUgb2JqZWN0IHByb3BlcnRpZXNcbiAgY29uc3QgZXJyb3JGcm9tUHJvcCA9IGdldEVycm9yUHJvcGVydHlGcm9tT2JqZWN0KGV4Y2VwdGlvbik7XG5cbiAgY29uc3QgZXh0cmEgPSB7XG4gICAgX19zZXJpYWxpemVkX186IG5vcm1hbGl6ZVRvU2l6ZShleGNlcHRpb24sIG5vcm1hbGl6ZURlcHRoKSxcbiAgfTtcblxuICBpZiAoZXJyb3JGcm9tUHJvcCkge1xuICAgIHJldHVybiB7XG4gICAgICBleGNlcHRpb246IHtcbiAgICAgICAgdmFsdWVzOiBbZXhjZXB0aW9uRnJvbUVycm9yKHN0YWNrUGFyc2VyLCBlcnJvckZyb21Qcm9wKV0sXG4gICAgICB9LFxuICAgICAgZXh0cmEsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGV4Y2VwdGlvbjoge1xuICAgICAgdmFsdWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBpc0V2ZW50KGV4Y2VwdGlvbikgPyBleGNlcHRpb24uY29uc3RydWN0b3IubmFtZSA6IGlzVW5oYW5kbGVkUmVqZWN0aW9uID8gJ1VuaGFuZGxlZFJlamVjdGlvbicgOiAnRXJyb3InLFxuICAgICAgICAgIHZhbHVlOiBnZXROb25FcnJvck9iamVjdEV4Y2VwdGlvblZhbHVlKGV4Y2VwdGlvbiwgeyBpc1VuaGFuZGxlZFJlamVjdGlvbiB9KSxcbiAgICAgICAgfSAsXG4gICAgICBdLFxuICAgIH0sXG4gICAgZXh0cmEsXG4gIH0gO1xuXG4gIGlmIChzeW50aGV0aWNFeGNlcHRpb24pIHtcbiAgICBjb25zdCBmcmFtZXMgPSBwYXJzZVN0YWNrRnJhbWVzKHN0YWNrUGFyc2VyLCBzeW50aGV0aWNFeGNlcHRpb24pO1xuICAgIGlmIChmcmFtZXMubGVuZ3RoKSB7XG4gICAgICAvLyBldmVudC5leGNlcHRpb24udmFsdWVzWzBdIGhhcyBiZWVuIHNldCBhYm92ZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF0uc3RhY2t0cmFjZSA9IHsgZnJhbWVzIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBldmVudEZyb21FcnJvcihzdGFja1BhcnNlciwgZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBleGNlcHRpb246IHtcbiAgICAgIHZhbHVlczogW2V4Y2VwdGlvbkZyb21FcnJvcihzdGFja1BhcnNlciwgZXgpXSxcbiAgICB9LFxuICB9O1xufVxuXG4vKiogUGFyc2VzIHN0YWNrIGZyYW1lcyBmcm9tIGFuIGVycm9yICovXG5mdW5jdGlvbiBwYXJzZVN0YWNrRnJhbWVzKFxuICBzdGFja1BhcnNlcixcbiAgZXgsXG4pIHtcbiAgLy8gQWNjZXNzIGFuZCBzdG9yZSB0aGUgc3RhY2t0cmFjZSBwcm9wZXJ0eSBiZWZvcmUgZG9pbmcgQU5ZVEhJTkdcbiAgLy8gZWxzZSB0byBpdCBiZWNhdXNlIE9wZXJhIGlzIG5vdCB2ZXJ5IGdvb2QgYXQgcHJvdmlkaW5nIGl0XG4gIC8vIHJlbGlhYmx5IGluIG90aGVyIGNpcmN1bXN0YW5jZXMuXG4gIGNvbnN0IHN0YWNrdHJhY2UgPSBleC5zdGFja3RyYWNlIHx8IGV4LnN0YWNrIHx8ICcnO1xuXG4gIGNvbnN0IHNraXBMaW5lcyA9IGdldFNraXBGaXJzdFN0YWNrU3RyaW5nTGluZXMoZXgpO1xuICBjb25zdCBmcmFtZXNUb1BvcCA9IGdldFBvcEZpcnN0VG9wRnJhbWVzKGV4KTtcblxuICB0cnkge1xuICAgIHJldHVybiBzdGFja1BhcnNlcihzdGFja3RyYWNlLCBza2lwTGluZXMsIGZyYW1lc1RvUG9wKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIG5vLWVtcHR5XG4gIH1cblxuICByZXR1cm4gW107XG59XG5cbi8vIEJhc2VkIG9uIG91ciBvd24gbWFwcGluZyBwYXR0ZXJuIC0gaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnkvYmxvYi85ZjA4MzA1ZTA5ODY2YzhiZDZkMGMyNGY1YjBhYWJkZDdkZDZjNTljL3NyYy9zZW50cnkvbGFuZy9qYXZhc2NyaXB0L2Vycm9ybWFwcGluZy5weSNMODMtTDEwOFxuY29uc3QgcmVhY3RNaW5pZmllZFJlZ2V4cCA9IC9NaW5pZmllZCBSZWFjdCBlcnJvciAjXFxkKzsvaTtcblxuLyoqXG4gKiBDZXJ0YWluIGtub3duIFJlYWN0IGVycm9ycyBjb250YWluIGxpbmtzIHRoYXQgd291bGQgYmUgZmFsc2VseVxuICogcGFyc2VkIGFzIGZyYW1lcy4gVGhpcyBmdW5jdGlvbiBjaGVjayBmb3IgdGhlc2UgZXJyb3JzIGFuZFxuICogcmV0dXJucyBudW1iZXIgb2YgdGhlIHN0YWNrIHN0cmluZyBsaW5lcyB0byBza2lwLlxuICovXG5mdW5jdGlvbiBnZXRTa2lwRmlyc3RTdGFja1N0cmluZ0xpbmVzKGV4KSB7XG4gIGlmIChleCAmJiByZWFjdE1pbmlmaWVkUmVnZXhwLnRlc3QoZXgubWVzc2FnZSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIElmIGVycm9yIGhhcyBgZnJhbWVzVG9Qb3BgIHByb3BlcnR5LCBpdCBtZWFucyB0aGF0IHRoZVxuICogY3JlYXRvciB0ZWxscyB1cyB0aGUgZmlyc3QgeCBmcmFtZXMgd2lsbCBiZSB1c2VsZXNzXG4gKiBhbmQgc2hvdWxkIGJlIGRpc2NhcmRlZC4gVHlwaWNhbGx5IGVycm9yIGZyb20gd3JhcHBlciBmdW5jdGlvblxuICogd2hpY2ggZG9uJ3QgcG9pbnQgdG8gdGhlIGFjdHVhbCBsb2NhdGlvbiBpbiB0aGUgZGV2ZWxvcGVyJ3MgY29kZS5cbiAqXG4gKiBFeGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9pbnZhcmlhbnQvYmxvYi9tYXN0ZXIvaW52YXJpYW50LmpzI0w0NlxuICovXG5mdW5jdGlvbiBnZXRQb3BGaXJzdFRvcEZyYW1lcyhleCkge1xuICBpZiAodHlwZW9mIGV4LmZyYW1lc1RvUG9wID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBleC5mcmFtZXNUb1BvcDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYkFzc2VtYmx5L0phdmFTY3JpcHRfaW50ZXJmYWNlL0V4Y2VwdGlvblxuLy8gQHRzLWV4cGVjdC1lcnJvciAtIFdlYkFzc2VtYmx5LkV4Y2VwdGlvbiBpcyBhIHZhbGlkIGNsYXNzXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5RXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAvLyBDaGVjayBmb3Igc3VwcG9ydFxuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gV2ViQXNzZW1ibHkuRXhjZXB0aW9uIGlzIGEgdmFsaWQgY2xhc3NcbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdlYkFzc2VtYmx5LkV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gV2ViQXNzZW1ibHkuRXhjZXB0aW9uIGlzIGEgdmFsaWQgY2xhc3NcbiAgICByZXR1cm4gZXhjZXB0aW9uIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuRXhjZXB0aW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGZyb20gZXJyb3JzIHdoYXQgd2UgdXNlIGFzIHRoZSBleGNlcHRpb24gYHR5cGVgIGluIGVycm9yIGV2ZW50cy5cbiAqXG4gKiBVc3VhbGx5LCB0aGlzIGlzIHRoZSBgbmFtZWAgcHJvcGVydHkgb24gRXJyb3Igb2JqZWN0cyBidXQgV0FTTSBlcnJvcnMgbmVlZCB0byBiZSB0cmVhdGVkIGRpZmZlcmVudGx5LlxuICovXG5mdW5jdGlvbiBleHRyYWN0VHlwZShleCkge1xuICBjb25zdCBuYW1lID0gZXg/Lm5hbWU7XG5cbiAgLy8gVGhlIG5hbWUgZm9yIFdlYkFzc2VtYmx5LkV4Y2VwdGlvbiBFcnJvcnMgbmVlZHMgdG8gYmUgZXh0cmFjdGVkIGRpZmZlcmVudGx5LlxuICAvLyBDb250ZXh0OiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8xMzc4N1xuICBpZiAoIW5hbWUgJiYgaXNXZWJBc3NlbWJseUV4Y2VwdGlvbihleCkpIHtcbiAgICAvLyBFbXNjcmlwdGVuIHNldHMgYXJyYXlbdHlwZSwgbWVzc2FnZV0gdG8gdGhlIFwibWVzc2FnZVwiIHByb3BlcnR5IG9uIHRoZSBXZWJBc3NlbWJseS5FeGNlcHRpb24gb2JqZWN0XG4gICAgY29uc3QgaGFzVHlwZUluTWVzc2FnZSA9IGV4Lm1lc3NhZ2UgJiYgQXJyYXkuaXNBcnJheShleC5tZXNzYWdlKSAmJiBleC5tZXNzYWdlLmxlbmd0aCA9PSAyO1xuICAgIHJldHVybiBoYXNUeXBlSW5NZXNzYWdlID8gZXgubWVzc2FnZVswXSA6ICdXZWJBc3NlbWJseS5FeGNlcHRpb24nO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHN0YWNrdHJhY2UubWVzc2FnZSBpcyBhbiBFdmVudCBvYmplY3RcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzE5NDlcbiAqIEluIHRoaXMgc3BlY2lmaWMgY2FzZSB3ZSB0cnkgdG8gZXh0cmFjdCBzdGFja3RyYWNlLm1lc3NhZ2UuZXJyb3IubWVzc2FnZVxuICovXG5mdW5jdGlvbiBleHRyYWN0TWVzc2FnZShleCkge1xuICBjb25zdCBtZXNzYWdlID0gZXg/Lm1lc3NhZ2U7XG5cbiAgaWYgKGlzV2ViQXNzZW1ibHlFeGNlcHRpb24oZXgpKSB7XG4gICAgLy8gRm9yIE5vZGUgMTgsIEVtc2NyaXB0ZW4gc2V0cyBhcnJheVt0eXBlLCBtZXNzYWdlXSB0byB0aGUgXCJtZXNzYWdlXCIgcHJvcGVydHkgb24gdGhlIFdlYkFzc2VtYmx5LkV4Y2VwdGlvbiBvYmplY3RcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleC5tZXNzYWdlKSAmJiBleC5tZXNzYWdlLmxlbmd0aCA9PSAyKSB7XG4gICAgICByZXR1cm4gZXgubWVzc2FnZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuICd3YXNtIGV4Y2VwdGlvbic7XG4gIH1cblxuICBpZiAoIW1lc3NhZ2UpIHtcbiAgICByZXR1cm4gJ05vIGVycm9yIG1lc3NhZ2UnO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgdHlwZW9mIG1lc3NhZ2UuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5lcnJvci5tZXNzYWdlO1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYWxsIGlucHV0cyB0byBgY2FwdHVyZUV4Y2VwdGlvbmAgYW5kIG5vbi1wcmltaXRpdmUgaW5wdXRzIHRvIGBjYXB0dXJlTWVzc2FnZWAuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RnJvbUV4Y2VwdGlvbihcbiAgc3RhY2tQYXJzZXIsXG4gIGV4Y2VwdGlvbixcbiAgaGludCxcbiAgYXR0YWNoU3RhY2t0cmFjZSxcbikge1xuICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBoaW50Py5zeW50aGV0aWNFeGNlcHRpb24gfHwgdW5kZWZpbmVkO1xuICBjb25zdCBldmVudCA9IGV2ZW50RnJvbVVua25vd25JbnB1dChzdGFja1BhcnNlciwgZXhjZXB0aW9uLCBzeW50aGV0aWNFeGNlcHRpb24sIGF0dGFjaFN0YWNrdHJhY2UpO1xuICBhZGRFeGNlcHRpb25NZWNoYW5pc20oZXZlbnQpOyAvLyBkZWZhdWx0cyB0byB7IHR5cGU6ICdnZW5lcmljJywgaGFuZGxlZDogdHJ1ZSB9XG4gIGV2ZW50LmxldmVsID0gJ2Vycm9yJztcbiAgaWYgKGhpbnQ/LmV2ZW50X2lkKSB7XG4gICAgZXZlbnQuZXZlbnRfaWQgPSBoaW50LmV2ZW50X2lkO1xuICB9XG4gIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKGV2ZW50KTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgYW5kIEV2ZW50IGZyb20gYSBNZXNzYWdlXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RnJvbU1lc3NhZ2UoXG4gIHN0YWNrUGFyc2VyLFxuICBtZXNzYWdlLFxuICBsZXZlbCA9ICdpbmZvJyxcbiAgaGludCxcbiAgYXR0YWNoU3RhY2t0cmFjZSxcbikge1xuICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBoaW50Py5zeW50aGV0aWNFeGNlcHRpb24gfHwgdW5kZWZpbmVkO1xuICBjb25zdCBldmVudCA9IGV2ZW50RnJvbVN0cmluZyhzdGFja1BhcnNlciwgbWVzc2FnZSwgc3ludGhldGljRXhjZXB0aW9uLCBhdHRhY2hTdGFja3RyYWNlKTtcbiAgZXZlbnQubGV2ZWwgPSBsZXZlbDtcbiAgaWYgKGhpbnQ/LmV2ZW50X2lkKSB7XG4gICAgZXZlbnQuZXZlbnRfaWQgPSBoaW50LmV2ZW50X2lkO1xuICB9XG4gIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKGV2ZW50KTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RnJvbVVua25vd25JbnB1dChcbiAgc3RhY2tQYXJzZXIsXG4gIGV4Y2VwdGlvbixcbiAgc3ludGhldGljRXhjZXB0aW9uLFxuICBhdHRhY2hTdGFja3RyYWNlLFxuICBpc1VuaGFuZGxlZFJlamVjdGlvbixcbikge1xuICBsZXQgZXZlbnQ7XG5cbiAgaWYgKGlzRXJyb3JFdmVudChleGNlcHRpb24gKSAmJiAoZXhjZXB0aW9uICkuZXJyb3IpIHtcbiAgICAvLyBJZiBpdCBpcyBhbiBFcnJvckV2ZW50IHdpdGggYGVycm9yYCBwcm9wZXJ0eSwgZXh0cmFjdCBpdCB0byBnZXQgYWN0dWFsIEVycm9yXG4gICAgY29uc3QgZXJyb3JFdmVudCA9IGV4Y2VwdGlvbiA7XG4gICAgcmV0dXJuIGV2ZW50RnJvbUVycm9yKHN0YWNrUGFyc2VyLCBlcnJvckV2ZW50LmVycm9yICk7XG4gIH1cblxuICAvLyBJZiBpdCBpcyBhIGBET01FcnJvcmAgKHdoaWNoIGlzIGEgbGVnYWN5IEFQSSwgYnV0IHN0aWxsIHN1cHBvcnRlZCBpbiBzb21lIGJyb3dzZXJzKSB0aGVuIHdlIGp1c3QgZXh0cmFjdCB0aGUgbmFtZVxuICAvLyBhbmQgbWVzc2FnZSwgYXMgaXQgZG9lc24ndCBwcm92aWRlIGFueXRoaW5nIGVsc2UuIEFjY29yZGluZyB0byB0aGUgc3BlYywgYWxsIGBET01FeGNlcHRpb25zYCBzaG91bGQgYWxzbyBiZVxuICAvLyBgRXJyb3JgcywgYnV0IHRoYXQncyBub3QgdGhlIGNhc2UgaW4gSUUxMSwgc28gaW4gdGhhdCBjYXNlIHdlIHRyZWF0IGl0IHRoZSBzYW1lIGFzIHdlIGRvIGEgYERPTUVycm9yYC5cbiAgLy9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUVycm9yXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01FeGNlcHRpb25cbiAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ET01FeGNlcHRpb24tc3BlY2lhbG5lc3NcbiAgaWYgKGlzRE9NRXJyb3IoZXhjZXB0aW9uKSB8fCBpc0RPTUV4Y2VwdGlvbihleGNlcHRpb24gKSkge1xuICAgIGNvbnN0IGRvbUV4Y2VwdGlvbiA9IGV4Y2VwdGlvbiA7XG5cbiAgICBpZiAoJ3N0YWNrJyBpbiAoZXhjZXB0aW9uICkpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnRGcm9tRXJyb3Ioc3RhY2tQYXJzZXIsIGV4Y2VwdGlvbiApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gZG9tRXhjZXB0aW9uLm5hbWUgfHwgKGlzRE9NRXJyb3IoZG9tRXhjZXB0aW9uKSA/ICdET01FcnJvcicgOiAnRE9NRXhjZXB0aW9uJyk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZG9tRXhjZXB0aW9uLm1lc3NhZ2UgPyBgJHtuYW1lfTogJHtkb21FeGNlcHRpb24ubWVzc2FnZX1gIDogbmFtZTtcbiAgICAgIGV2ZW50ID0gZXZlbnRGcm9tU3RyaW5nKHN0YWNrUGFyc2VyLCBtZXNzYWdlLCBzeW50aGV0aWNFeGNlcHRpb24sIGF0dGFjaFN0YWNrdHJhY2UpO1xuICAgICAgYWRkRXhjZXB0aW9uVHlwZVZhbHVlKGV2ZW50LCBtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKCdjb2RlJyBpbiBkb21FeGNlcHRpb24pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgZXZlbnQudGFncyA9IHsgLi4uZXZlbnQudGFncywgJ0RPTUV4Y2VwdGlvbi5jb2RlJzogYCR7ZG9tRXhjZXB0aW9uLmNvZGV9YCB9O1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBpZiAoaXNFcnJvcihleGNlcHRpb24pKSB7XG4gICAgLy8gd2UgaGF2ZSBhIHJlYWwgRXJyb3Igb2JqZWN0LCBkbyBub3RoaW5nXG4gICAgcmV0dXJuIGV2ZW50RnJvbUVycm9yKHN0YWNrUGFyc2VyLCBleGNlcHRpb24pO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KGV4Y2VwdGlvbikgfHwgaXNFdmVudChleGNlcHRpb24pKSB7XG4gICAgLy8gSWYgaXQncyBhIHBsYWluIG9iamVjdCBvciBhbiBpbnN0YW5jZSBvZiBgRXZlbnRgICh0aGUgYnVpbHQtaW4gSlMga2luZCwgbm90IHRoaXMgU0RLJ3MgYEV2ZW50YCB0eXBlKSwgc2VyaWFsaXplXG4gICAgLy8gaXQgbWFudWFsbHkuIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBncm91cCBldmVudHMgYmFzZWQgb24gdG9wLWxldmVsIGtleXMgd2hpY2ggaXMgbXVjaCBiZXR0ZXIgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAgIC8vIGdyb3VwIG9uIGFueSBrZXkvdmFsdWUgY2hhbmdlLlxuICAgIGNvbnN0IG9iamVjdEV4Y2VwdGlvbiA9IGV4Y2VwdGlvbiA7XG4gICAgZXZlbnQgPSBldmVudEZyb21QbGFpbk9iamVjdChzdGFja1BhcnNlciwgb2JqZWN0RXhjZXB0aW9uLCBzeW50aGV0aWNFeGNlcHRpb24sIGlzVW5oYW5kbGVkUmVqZWN0aW9uKTtcbiAgICBhZGRFeGNlcHRpb25NZWNoYW5pc20oZXZlbnQsIHtcbiAgICAgIHN5bnRoZXRpYzogdHJ1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICAvLyBJZiBub25lIG9mIHByZXZpb3VzIGNoZWNrcyB3ZXJlIHZhbGlkLCB0aGVuIGl0IG1lYW5zIHRoYXQgaXQncyBub3Q6XG4gIC8vIC0gYW4gaW5zdGFuY2Ugb2YgRE9NRXJyb3JcbiAgLy8gLSBhbiBpbnN0YW5jZSBvZiBET01FeGNlcHRpb25cbiAgLy8gLSBhbiBpbnN0YW5jZSBvZiBFdmVudFxuICAvLyAtIGFuIGluc3RhbmNlIG9mIEVycm9yXG4gIC8vIC0gYSB2YWxpZCBFcnJvckV2ZW50IChvbmUgd2l0aCBhbiBlcnJvciBwcm9wZXJ0eSlcbiAgLy8gLSBhIHBsYWluIE9iamVjdFxuICAvL1xuICAvLyBTbyBiYWlsIG91dCBhbmQgY2FwdHVyZSBpdCBhcyBhIHNpbXBsZSBtZXNzYWdlOlxuICBldmVudCA9IGV2ZW50RnJvbVN0cmluZyhzdGFja1BhcnNlciwgZXhjZXB0aW9uICwgc3ludGhldGljRXhjZXB0aW9uLCBhdHRhY2hTdGFja3RyYWNlKTtcbiAgYWRkRXhjZXB0aW9uVHlwZVZhbHVlKGV2ZW50LCBgJHtleGNlcHRpb259YCwgdW5kZWZpbmVkKTtcbiAgYWRkRXhjZXB0aW9uTWVjaGFuaXNtKGV2ZW50LCB7XG4gICAgc3ludGhldGljOiB0cnVlLFxuICB9KTtcblxuICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50RnJvbVN0cmluZyhcbiAgc3RhY2tQYXJzZXIsXG4gIG1lc3NhZ2UsXG4gIHN5bnRoZXRpY0V4Y2VwdGlvbixcbiAgYXR0YWNoU3RhY2t0cmFjZSxcbikge1xuICBjb25zdCBldmVudCA9IHt9O1xuXG4gIGlmIChhdHRhY2hTdGFja3RyYWNlICYmIHN5bnRoZXRpY0V4Y2VwdGlvbikge1xuICAgIGNvbnN0IGZyYW1lcyA9IHBhcnNlU3RhY2tGcmFtZXMoc3RhY2tQYXJzZXIsIHN5bnRoZXRpY0V4Y2VwdGlvbik7XG4gICAgaWYgKGZyYW1lcy5sZW5ndGgpIHtcbiAgICAgIGV2ZW50LmV4Y2VwdGlvbiA9IHtcbiAgICAgICAgdmFsdWVzOiBbeyB2YWx1ZTogbWVzc2FnZSwgc3RhY2t0cmFjZTogeyBmcmFtZXMgfSB9XSxcbiAgICAgIH07XG4gICAgfVxuICAgIGFkZEV4Y2VwdGlvbk1lY2hhbmlzbShldmVudCwgeyBzeW50aGV0aWM6IHRydWUgfSk7XG4gIH1cblxuICBpZiAoaXNQYXJhbWV0ZXJpemVkU3RyaW5nKG1lc3NhZ2UpKSB7XG4gICAgY29uc3QgeyBfX3NlbnRyeV90ZW1wbGF0ZV9zdHJpbmdfXywgX19zZW50cnlfdGVtcGxhdGVfdmFsdWVzX18gfSA9IG1lc3NhZ2U7XG5cbiAgICBldmVudC5sb2dlbnRyeSA9IHtcbiAgICAgIG1lc3NhZ2U6IF9fc2VudHJ5X3RlbXBsYXRlX3N0cmluZ19fLFxuICAgICAgcGFyYW1zOiBfX3NlbnRyeV90ZW1wbGF0ZV92YWx1ZXNfXyxcbiAgICB9O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGV2ZW50Lm1lc3NhZ2UgPSBtZXNzYWdlO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGdldE5vbkVycm9yT2JqZWN0RXhjZXB0aW9uVmFsdWUoXG4gIGV4Y2VwdGlvbixcbiAgeyBpc1VuaGFuZGxlZFJlamVjdGlvbiB9LFxuKSB7XG4gIGNvbnN0IGtleXMgPSBleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UoZXhjZXB0aW9uKTtcbiAgY29uc3QgY2FwdHVyZVR5cGUgPSBpc1VuaGFuZGxlZFJlamVjdGlvbiA/ICdwcm9taXNlIHJlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcblxuICAvLyBTb21lIEVycm9yRXZlbnQgaW5zdGFuY2VzIGRvIG5vdCBoYXZlIGFuIGBlcnJvcmAgcHJvcGVydHksIHdoaWNoIGlzIHdoeSB0aGV5IGFyZSBub3QgaGFuZGxlZCBiZWZvcmVcbiAgLy8gV2Ugc3RpbGwgd2FudCB0byB0cnkgdG8gZ2V0IGEgZGVjZW50IG1lc3NhZ2UgZm9yIHRoZXNlIGNhc2VzXG4gIGlmIChpc0Vycm9yRXZlbnQoZXhjZXB0aW9uKSkge1xuICAgIHJldHVybiBgRXZlbnQgXFxgRXJyb3JFdmVudFxcYCBjYXB0dXJlZCBhcyAke2NhcHR1cmVUeXBlfSB3aXRoIG1lc3NhZ2UgXFxgJHtleGNlcHRpb24ubWVzc2FnZX1cXGBgO1xuICB9XG5cbiAgaWYgKGlzRXZlbnQoZXhjZXB0aW9uKSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGdldE9iamVjdENsYXNzTmFtZShleGNlcHRpb24pO1xuICAgIHJldHVybiBgRXZlbnQgXFxgJHtjbGFzc05hbWV9XFxgICh0eXBlPSR7ZXhjZXB0aW9uLnR5cGV9KSBjYXB0dXJlZCBhcyAke2NhcHR1cmVUeXBlfWA7XG4gIH1cblxuICByZXR1cm4gYE9iamVjdCBjYXB0dXJlZCBhcyAke2NhcHR1cmVUeXBlfSB3aXRoIGtleXM6ICR7a2V5c31gO1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RDbGFzc05hbWUob2JqKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgcmV0dXJuIHByb3RvdHlwZSA/IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lIDogdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlIGVycm9ycyBoZXJlXG4gIH1cbn1cblxuLyoqIElmIGEgcGxhaW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoYXQgaXMgYW4gYEVycm9yYCwgcmV0dXJuIHRoaXMgZXJyb3IuICovXG5mdW5jdGlvbiBnZXRFcnJvclByb3BlcnR5RnJvbU9iamVjdChvYmopIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgZXZlbnRGcm9tRXhjZXB0aW9uLCBldmVudEZyb21NZXNzYWdlLCBldmVudEZyb21Vbmtub3duSW5wdXQsIGV4Y2VwdGlvbkZyb21FcnJvciwgZXh0cmFjdE1lc3NhZ2UsIGV4dHJhY3RUeXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudGJ1aWxkZXIuanMubWFwXG4iLCJpbXBvcnQgeyBDbGllbnQsIGdldFNES1NvdXJjZSwgYXBwbHlTZGtNZXRhZGF0YSwgX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlciwgYWRkQXV0b0lwQWRkcmVzc1RvVXNlciwgYWRkQXV0b0lwQWRkcmVzc1RvU2Vzc2lvbiB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgeyBldmVudEZyb21FeGNlcHRpb24sIGV2ZW50RnJvbU1lc3NhZ2UgfSBmcm9tICcuL2V2ZW50YnVpbGRlci5qcyc7XG5pbXBvcnQgeyBXSU5ET1cgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG5jb25zdCBERUZBVUxUX0ZMVVNIX0lOVEVSVkFMID0gNTAwMDtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBTZW50cnkgQnJvd3NlciBTREsuXG4gKiBAc2VlIEBzZW50cnkvY29yZSBPcHRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbi8qKlxuICogVGhlIFNlbnRyeSBCcm93c2VyIFNESyBDbGllbnQuXG4gKlxuICogQHNlZSBCcm93c2VyT3B0aW9ucyBmb3IgZG9jdW1lbnRhdGlvbiBvbiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBAc2VlIFNlbnRyeUNsaWVudCBmb3IgdXNhZ2UgZG9jdW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgQnJvd3NlckNsaWVudCBleHRlbmRzIENsaWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQnJvd3NlciBTREsgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBTREsuXG4gICAqL1xuICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAvLyBXZSBkZWZhdWx0IHRoaXMgdG8gdHJ1ZSwgYXMgaXQgaXMgdGhlIHNhZmVyIHNjZW5hcmlvXG4gICAgICBwYXJlbnRTcGFuSXNBbHdheXNSb290U3BhbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBzZGtTb3VyY2UgPSBXSU5ET1cuU0VOVFJZX1NES19TT1VSQ0UgfHwgZ2V0U0RLU291cmNlKCk7XG4gICAgYXBwbHlTZGtNZXRhZGF0YShvcHRzLCAnYnJvd3NlcicsIFsnYnJvd3NlciddLCBzZGtTb3VyY2UpO1xuXG4gICAgc3VwZXIob3B0cyk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzO1xuICAgIGNvbnN0IHsgc2VuZERlZmF1bHRQaWksIF9leHBlcmltZW50cyB9ID0gY2xpZW50Ll9vcHRpb25zO1xuICAgIGNvbnN0IGVuYWJsZUxvZ3MgPSBfZXhwZXJpbWVudHM/LmVuYWJsZUxvZ3M7XG5cbiAgICBpZiAob3B0cy5zZW5kQ2xpZW50UmVwb3J0cyAmJiBXSU5ET1cuZG9jdW1lbnQpIHtcbiAgICAgIFdJTkRPVy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoV0lORE9XLmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICB0aGlzLl9mbHVzaE91dGNvbWVzKCk7XG4gICAgICAgICAgaWYgKGVuYWJsZUxvZ3MpIHtcbiAgICAgICAgICAgIF9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIoY2xpZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChlbmFibGVMb2dzKSB7XG4gICAgICBjbGllbnQub24oJ2ZsdXNoJywgKCkgPT4ge1xuICAgICAgICBfSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyKGNsaWVudCk7XG4gICAgICB9KTtcblxuICAgICAgY2xpZW50Lm9uKCdhZnRlckNhcHR1cmVMb2cnLCAoKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnQuX2xvZ0ZsdXNoSWRsZVRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoY2xpZW50Ll9sb2dGbHVzaElkbGVUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWVudC5fbG9nRmx1c2hJZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIF9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIoY2xpZW50KTtcbiAgICAgICAgfSwgREVGQVVMVF9GTFVTSF9JTlRFUlZBTCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2VuZERlZmF1bHRQaWkpIHtcbiAgICAgIGNsaWVudC5vbigncG9zdHByb2Nlc3NFdmVudCcsIGFkZEF1dG9JcEFkZHJlc3NUb1VzZXIpO1xuICAgICAgY2xpZW50Lm9uKCdiZWZvcmVTZW5kU2Vzc2lvbicsIGFkZEF1dG9JcEFkZHJlc3NUb1Nlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGV2ZW50RnJvbUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQpIHtcbiAgICByZXR1cm4gZXZlbnRGcm9tRXhjZXB0aW9uKHRoaXMuX29wdGlvbnMuc3RhY2tQYXJzZXIsIGV4Y2VwdGlvbiwgaGludCwgdGhpcy5fb3B0aW9ucy5hdHRhY2hTdGFja3RyYWNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGV2ZW50RnJvbU1lc3NhZ2UoXG4gICAgbWVzc2FnZSxcbiAgICBsZXZlbCA9ICdpbmZvJyxcbiAgICBoaW50LFxuICApIHtcbiAgICByZXR1cm4gZXZlbnRGcm9tTWVzc2FnZSh0aGlzLl9vcHRpb25zLnN0YWNrUGFyc2VyLCBtZXNzYWdlLCBsZXZlbCwgaGludCwgdGhpcy5fb3B0aW9ucy5hdHRhY2hTdGFja3RyYWNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIF9wcmVwYXJlRXZlbnQoXG4gICAgZXZlbnQsXG4gICAgaGludCxcbiAgICBjdXJyZW50U2NvcGUsXG4gICAgaXNvbGF0aW9uU2NvcGUsXG4gICkge1xuICAgIGV2ZW50LnBsYXRmb3JtID0gZXZlbnQucGxhdGZvcm0gfHwgJ2phdmFzY3JpcHQnO1xuXG4gICAgcmV0dXJuIHN1cGVyLl9wcmVwYXJlRXZlbnQoZXZlbnQsIGhpbnQsIGN1cnJlbnRTY29wZSwgaXNvbGF0aW9uU2NvcGUpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJyb3dzZXJDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXBcbiIsIi8qKlxuICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogQVRURU5USU9OOiBUaGlzIGNvbnN0YW50IG11c3QgbmV2ZXIgY3Jvc3MgcGFja2FnZSBib3VuZGFyaWVzIChpLmUuIGJlIGV4cG9ydGVkKSB0byBndWFyYW50ZWUgdGhhdCBpdCBjYW4gYmUgdXNlZCBmb3IgdHJlZSBzaGFraW5nLlxuICovXG5jb25zdCBERUJVR19CVUlMRCA9ICh0eXBlb2YgX19TRU5UUllfREVCVUdfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgX19TRU5UUllfREVCVUdfXyk7XG5cbmV4cG9ydCB7IERFQlVHX0JVSUxEIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Zy1idWlsZC5qcy5tYXBcbiIsImltcG9ydCB7IEdMT0JBTF9PQkogfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuXG5jb25zdCBXSU5ET1cgPSBHTE9CQUxfT0JKXG5cbjtcblxuZXhwb3J0IHsgV0lORE9XIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXBcbiIsImltcG9ydCB7IGFkZEhhbmRsZXIsIG1heWJlSW5zdHJ1bWVudCwgdHJpZ2dlckhhbmRsZXJzLCBmaWxsLCBhZGROb25FbnVtZXJhYmxlUHJvcGVydHksIHV1aWQ0IH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJy4uL3R5cGVzLmpzJztcblxuY29uc3QgREVCT1VOQ0VfRFVSQVRJT04gPSAxMDAwO1xuXG5sZXQgZGVib3VuY2VUaW1lcklEO1xubGV0IGxhc3RDYXB0dXJlZEV2ZW50VHlwZTtcbmxldCBsYXN0Q2FwdHVyZWRFdmVudFRhcmdldElkO1xuXG4vKipcbiAqIEFkZCBhbiBpbnN0cnVtZW50YXRpb24gaGFuZGxlciBmb3Igd2hlbiBhIGNsaWNrIG9yIGEga2V5cHJlc3MgaGFwcGVucy5cbiAqXG4gKiBVc2UgYXQgeW91ciBvd24gcmlzaywgdGhpcyBtaWdodCBicmVhayB3aXRob3V0IGNoYW5nZWxvZyBub3RpY2UsIG9ubHkgdXNlZCBpbnRlcm5hbGx5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRDbGlja0tleXByZXNzSW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gIGNvbnN0IHR5cGUgPSAnZG9tJztcbiAgYWRkSGFuZGxlcih0eXBlLCBoYW5kbGVyKTtcbiAgbWF5YmVJbnN0cnVtZW50KHR5cGUsIGluc3RydW1lbnRET00pO1xufVxuXG4vKiogRXhwb3J0ZWQgZm9yIHRlc3RzIG9ubHkuICovXG5mdW5jdGlvbiBpbnN0cnVtZW50RE9NKCkge1xuICBpZiAoIVdJTkRPVy5kb2N1bWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE1ha2UgaXQgc28gdGhhdCBhbnkgY2xpY2sgb3Iga2V5cHJlc3MgdGhhdCBpcyB1bmhhbmRsZWQgLyBidWJibGVkIHVwIGFsbCB0aGUgd2F5IHRvIHRoZSBkb2N1bWVudCB0cmlnZ2VycyBvdXIgZG9tXG4gIC8vIGhhbmRsZXJzLiAoTm9ybWFsbHkgd2UgaGF2ZSBvbmx5IG9uZSwgd2hpY2ggY2FwdHVyZXMgYSBicmVhZGNydW1iIGZvciBlYWNoIGNsaWNrIG9yIGtleXByZXNzLikgRG8gdGhpcyBiZWZvcmVcbiAgLy8gd2UgaW5zdHJ1bWVudCBgYWRkRXZlbnRMaXN0ZW5lcmAgc28gdGhhdCB3ZSBkb24ndCBlbmQgdXAgYXR0YWNoaW5nIHRoaXMgaGFuZGxlciB0d2ljZS5cbiAgY29uc3QgdHJpZ2dlckRPTUhhbmRsZXIgPSB0cmlnZ2VySGFuZGxlcnMuYmluZChudWxsLCAnZG9tJyk7XG4gIGNvbnN0IGdsb2JhbERPTUV2ZW50SGFuZGxlciA9IG1ha2VET01FdmVudEhhbmRsZXIodHJpZ2dlckRPTUhhbmRsZXIsIHRydWUpO1xuICBXSU5ET1cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnbG9iYWxET01FdmVudEhhbmRsZXIsIGZhbHNlKTtcbiAgV0lORE9XLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZ2xvYmFsRE9NRXZlbnRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgLy8gQWZ0ZXIgaG9va2luZyBpbnRvIGNsaWNrIGFuZCBrZXlwcmVzcyBldmVudHMgYnViYmxlZCB1cCB0byBgZG9jdW1lbnRgLCB3ZSBhbHNvIGhvb2sgaW50byB1c2VyLWhhbmRsZWRcbiAgLy8gY2xpY2tzICYga2V5cHJlc3NlcywgYnkgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyIG9mIG91ciBvd24gdG8gYW55IGVsZW1lbnQgdG8gd2hpY2ggdGhleSBhZGQgYSBsaXN0ZW5lci4gVGhhdFxuICAvLyB3YXksIHdoZW5ldmVyIG9uZSBvZiB0aGVpciBoYW5kbGVycyBpcyB0cmlnZ2VyZWQsIG91cnMgd2lsbCBiZSwgdG9vLiAoVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGVpciBoYW5kbGVyXG4gIC8vIGNvdWxkIHBvdGVudGlhbGx5IHByZXZlbnQgdGhlIGV2ZW50IGZyb20gYnViYmxpbmcgdXAgdG8gb3VyIGdsb2JhbCBsaXN0ZW5lcnMuIFRoaXMgd2F5LCBvdXIgaGFuZGxlciBhcmUgc3RpbGxcbiAgLy8gZ3VhcmFudGVlZCB0byBmaXJlIGF0IGxlYXN0IG9uY2UuKVxuICBbJ0V2ZW50VGFyZ2V0JywgJ05vZGUnXS5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICBjb25zdCBnbG9iYWxPYmplY3QgPSBXSU5ET1cgO1xuICAgIGNvbnN0IHByb3RvID0gZ2xvYmFsT2JqZWN0W3RhcmdldF0/LnByb3RvdHlwZTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICBpZiAoIXByb3RvPy5oYXNPd25Qcm9wZXJ0eT8uKCdhZGRFdmVudExpc3RlbmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaWxsKHByb3RvLCAnYWRkRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnaW5hbEFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT0gJ2tleXByZXNzJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9ICh0aGlzLl9fc2VudHJ5X2luc3RydW1lbnRhdGlvbl9oYW5kbGVyc19fID1cbiAgICAgICAgICAgICAgdGhpcy5fX3NlbnRyeV9pbnN0cnVtZW50YXRpb25faGFuZGxlcnNfXyB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyRm9yVHlwZSA9IChoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IHsgcmVmQ291bnQ6IDAgfSk7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlckZvclR5cGUuaGFuZGxlcikge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gbWFrZURPTUV2ZW50SGFuZGxlcih0cmlnZ2VyRE9NSGFuZGxlcik7XG4gICAgICAgICAgICAgIGhhbmRsZXJGb3JUeXBlLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgICBvcmlnaW5hbEFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlckZvclR5cGUucmVmQ291bnQrKztcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBBY2Nlc3NpbmcgZG9tIHByb3BlcnRpZXMgaXMgYWx3YXlzIGZyYWdpbGUuXG4gICAgICAgICAgICAvLyBBbHNvIGFsbG93cyB1cyB0byBza2lwIGBhZGRFdmVudExpc3RlbmVyc2AgY2FsbHMgd2l0aCBubyBwcm9wZXIgYHRoaXNgIGNvbnRleHQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmaWxsKFxuICAgICAgcHJvdG8sXG4gICAgICAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsXG4gICAgICBmdW5jdGlvbiAob3JpZ2luYWxSZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX19zZW50cnlfaW5zdHJ1bWVudGF0aW9uX2hhbmRsZXJzX18gfHwge307XG4gICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJGb3JUeXBlID0gaGFuZGxlcnNbdHlwZV07XG5cbiAgICAgICAgICAgICAgaWYgKGhhbmRsZXJGb3JUeXBlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckZvclR5cGUucmVmQ291bnQtLTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbG9uZ2VyIGFueSBjdXN0b20gaGFuZGxlcnMgb2YgdGhlIGN1cnJlbnQgdHlwZSBvbiB0aGlzIGVsZW1lbnQsIHdlIGNhbiByZW1vdmUgb3VycywgdG9vLlxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyRm9yVHlwZS5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBoYW5kbGVyRm9yVHlwZS5oYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXJGb3JUeXBlLmhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbdHlwZV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGxvbmdlciBhbnkgY3VzdG9tIGhhbmRsZXJzIG9mIGFueSB0eXBlIG9uIHRoaXMgZWxlbWVudCwgY2xlYW51cCBldmVyeXRoaW5nLlxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhoYW5kbGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fX3NlbnRyeV9pbnN0cnVtZW50YXRpb25faGFuZGxlcnNfXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gQWNjZXNzaW5nIGRvbSBwcm9wZXJ0aWVzIGlzIGFsd2F5cyBmcmFnaWxlLlxuICAgICAgICAgICAgICAvLyBBbHNvIGFsbG93cyB1cyB0byBza2lwIGBhZGRFdmVudExpc3RlbmVyc2AgY2FsbHMgd2l0aCBubyBwcm9wZXIgYHRoaXNgIGNvbnRleHQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZXZlbnQgaXMgc2ltaWxhciB0byB0aGUgbGFzdCBjYXB0dXJlZCBvbmUuIEZvciBleGFtcGxlLCB0d28gY2xpY2sgZXZlbnRzIG9uIHRoZSBzYW1lIGJ1dHRvbi5cbiAqL1xuZnVuY3Rpb24gaXNTaW1pbGFyVG9MYXN0Q2FwdHVyZWRFdmVudChldmVudCkge1xuICAvLyBJZiBib3RoIGV2ZW50cyBoYXZlIGRpZmZlcmVudCB0eXBlLCB0aGVuIHVzZXIgZGVmaW5pdGVseSBwZXJmb3JtZWQgdHdvIHNlcGFyYXRlIGFjdGlvbnMuIGUuZy4gY2xpY2sgKyBrZXlwcmVzcy5cbiAgaWYgKGV2ZW50LnR5cGUgIT09IGxhc3RDYXB0dXJlZEV2ZW50VHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gSWYgYm90aCBldmVudHMgaGF2ZSB0aGUgc2FtZSB0eXBlLCBpdCdzIHN0aWxsIHBvc3NpYmxlIHRoYXQgYWN0aW9ucyB3ZXJlIHBlcmZvcm1lZCBvbiBkaWZmZXJlbnQgdGFyZ2V0cy5cbiAgICAvLyBlLmcuIDIgY2xpY2tzIG9uIGRpZmZlcmVudCBidXR0b25zLlxuICAgIGlmICghZXZlbnQudGFyZ2V0IHx8IChldmVudC50YXJnZXQgKS5fc2VudHJ5SWQgIT09IGxhc3RDYXB0dXJlZEV2ZW50VGFyZ2V0SWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBqdXN0IGFjY2Vzc2luZyBgdGFyZ2V0YCBwcm9wZXJ0eSBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgcmFyZSBjaXJjdW1zdGFuY2VzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy84MzhcbiAgfVxuXG4gIC8vIElmIGJvdGggZXZlbnRzIGhhdmUgdGhlIHNhbWUgdHlwZSBfYW5kXyBzYW1lIGB0YXJnZXRgIChhbiBlbGVtZW50IHdoaWNoIHRyaWdnZXJlZCBhbiBldmVudCwgX25vdCBuZWNlc3NhcmlseV9cbiAgLy8gdG8gd2hpY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2FzIGF0dGFjaGVkKSwgd2UgdHJlYXQgdGhlbSBhcyB0aGUgc2FtZSBhY3Rpb24sIGFzIHdlIHdhbnQgdG8gY2FwdHVyZVxuICAvLyBvbmx5IG9uZSBicmVhZGNydW1iLiBlLmcuIG11bHRpcGxlIGNsaWNrcyBvbiB0aGUgc2FtZSBidXR0b24sIG9yIHR5cGluZyBpbnNpZGUgYSB1c2VyIGlucHV0IGJveC5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYW4gZXZlbnQgc2hvdWxkIGJlIGNhcHR1cmVkLlxuICogQHBhcmFtIGV2ZW50IGV2ZW50IHRvIGJlIGNhcHR1cmVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNraXBET01FdmVudChldmVudFR5cGUsIHRhcmdldCkge1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGZpbHRlcmluZyBga2V5cHJlc3NgIGV2ZW50cyBmb3Igbm93LlxuICBpZiAoZXZlbnRUeXBlICE9PSAna2V5cHJlc3MnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCF0YXJnZXQ/LnRhZ05hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIE9ubHkgY29uc2lkZXIga2V5cHJlc3MgZXZlbnRzIG9uIGFjdHVhbCBpbnB1dCBlbGVtZW50cy4gVGhpcyB3aWxsIGRpc3JlZ2FyZCBrZXlwcmVzc2VzIHRhcmdldGluZyBib2R5XG4gIC8vIGUuZy50YWJiaW5nIHRocm91Z2ggZWxlbWVudHMsIGhvdGtleXMsIGV0Yy5cbiAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnSU5QVVQnIHx8IHRhcmdldC50YWdOYW1lID09PSAnVEVYVEFSRUEnIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFdyYXBzIGFkZEV2ZW50TGlzdGVuZXIgdG8gY2FwdHVyZSBVSSBicmVhZGNydW1ic1xuICovXG5mdW5jdGlvbiBtYWtlRE9NRXZlbnRIYW5kbGVyKFxuICBoYW5kbGVyLFxuICBnbG9iYWxMaXN0ZW5lciA9IGZhbHNlLFxuKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRoaXMgaGFuZGxlciBtaWdodCB0cmlnZ2VyIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICAgIC8vIGV2ZW50IChlLmcuIGV2ZW50IHByb3BhZ2F0aW9uIHRocm91Z2ggbm9kZSBhbmNlc3RvcnMpLlxuICAgIC8vIElnbm9yZSBpZiB3ZSd2ZSBhbHJlYWR5IGNhcHR1cmVkIHRoYXQgZXZlbnQuXG4gICAgaWYgKCFldmVudCB8fCBldmVudFsnX3NlbnRyeUNhcHR1cmVkJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG5cbiAgICAvLyBXZSBhbHdheXMgd2FudCB0byBza2lwIF9zb21lXyBldmVudHMuXG4gICAgaWYgKHNob3VsZFNraXBET01FdmVudChldmVudC50eXBlLCB0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFyayBldmVudCBhcyBcInNlZW5cIlxuICAgIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShldmVudCwgJ19zZW50cnlDYXB0dXJlZCcsIHRydWUpO1xuXG4gICAgaWYgKHRhcmdldCAmJiAhdGFyZ2V0Ll9zZW50cnlJZCkge1xuICAgICAgLy8gQWRkIFVVSUQgdG8gZXZlbnQgdGFyZ2V0IHNvIHdlIGNhbiBpZGVudGlmeSBpZlxuICAgICAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwgJ19zZW50cnlJZCcsIHV1aWQ0KCkpO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBldmVudC50eXBlID09PSAna2V5cHJlc3MnID8gJ2lucHV0JyA6IGV2ZW50LnR5cGU7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBsYXN0IGNhcHR1cmVkIGV2ZW50LCBpdCBtZWFucyB0aGF0IHdlIGNhbiBzYWZlbHkgY2FwdHVyZSB0aGUgbmV3IGV2ZW50IGFuZCBzdG9yZSBpdCBmb3IgZnV0dXJlIGNvbXBhcmlzb25zLlxuICAgIC8vIElmIHRoZXJlIGlzIGEgbGFzdCBjYXB0dXJlZCBldmVudCwgc2VlIGlmIHRoZSBuZXcgZXZlbnQgaXMgZGlmZmVyZW50IGVub3VnaCB0byB0cmVhdCBpdCBhcyBhIHVuaXF1ZSBvbmUuXG4gICAgLy8gSWYgdGhhdCdzIHRoZSBjYXNlLCBlbWl0IHRoZSBwcmV2aW91cyBldmVudCBhbmQgc3RvcmUgbG9jYWxseSB0aGUgbmV3bHktY2FwdHVyZWQgRE9NIGV2ZW50LlxuICAgIGlmICghaXNTaW1pbGFyVG9MYXN0Q2FwdHVyZWRFdmVudChldmVudCkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXJEYXRhID0geyBldmVudCwgbmFtZSwgZ2xvYmFsOiBnbG9iYWxMaXN0ZW5lciB9O1xuICAgICAgaGFuZGxlcihoYW5kbGVyRGF0YSk7XG4gICAgICBsYXN0Q2FwdHVyZWRFdmVudFR5cGUgPSBldmVudC50eXBlO1xuICAgICAgbGFzdENhcHR1cmVkRXZlbnRUYXJnZXRJZCA9IHRhcmdldCA/IHRhcmdldC5fc2VudHJ5SWQgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYSBuZXcgZGVib3VuY2UgdGltZXIgdGhhdCB3aWxsIHByZXZlbnQgdXMgZnJvbSBjYXB0dXJpbmcgbXVsdGlwbGUgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIGdyb3VwZWQgdG9nZXRoZXIuXG4gICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXJJRCk7XG4gICAgZGVib3VuY2VUaW1lcklEID0gV0lORE9XLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGFzdENhcHR1cmVkRXZlbnRUYXJnZXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgIGxhc3RDYXB0dXJlZEV2ZW50VHlwZSA9IHVuZGVmaW5lZDtcbiAgICB9LCBERUJPVU5DRV9EVVJBVElPTik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCA7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBqdXN0IGFjY2Vzc2luZyBgdGFyZ2V0YCBwcm9wZXJ0eSBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgcmFyZSBjaXJjdW1zdGFuY2VzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy84MzhcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBhZGRDbGlja0tleXByZXNzSW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgaW5zdHJ1bWVudERPTSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLmpzLm1hcFxuIiwiaW1wb3J0IHsgYWRkSGFuZGxlciwgbWF5YmVJbnN0cnVtZW50LCB0cmlnZ2VySGFuZGxlcnMsIHN1cHBvcnRzSGlzdG9yeSwgZmlsbCB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgeyBXSU5ET1cgfSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmxldCBsYXN0SHJlZjtcblxuLyoqXG4gKiBBZGQgYW4gaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXIgZm9yIHdoZW4gYSBmZXRjaCByZXF1ZXN0IGhhcHBlbnMuXG4gKiBUaGUgaGFuZGxlciBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSB3aGVuIHRoZSByZXF1ZXN0IHN0YXJ0cyBhbmQgb25jZSB3aGVuIGl0IGVuZHMsXG4gKiB3aGljaCBjYW4gYmUgaWRlbnRpZmllZCBieSBjaGVja2luZyBpZiBpdCBoYXMgYW4gYGVuZFRpbWVzdGFtcGAuXG4gKlxuICogVXNlIGF0IHlvdXIgb3duIHJpc2ssIHRoaXMgbWlnaHQgYnJlYWsgd2l0aG91dCBjaGFuZ2Vsb2cgbm90aWNlLCBvbmx5IHVzZWQgaW50ZXJuYWxseS5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWRkSGlzdG9yeUluc3RydW1lbnRhdGlvbkhhbmRsZXIoaGFuZGxlcikge1xuICBjb25zdCB0eXBlID0gJ2hpc3RvcnknO1xuICBhZGRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICBtYXliZUluc3RydW1lbnQodHlwZSwgaW5zdHJ1bWVudEhpc3RvcnkpO1xufVxuXG4vKipcbiAqIEV4cG9ydGVkIGp1c3QgZm9yIHRlc3RpbmdcbiAqL1xuZnVuY3Rpb24gaW5zdHJ1bWVudEhpc3RvcnkoKSB7XG4gIC8vIFRoZSBgcG9wc3RhdGVgIGV2ZW50IG1heSBhbHNvIGJlIHRyaWdnZXJlZCBvbiBgcHVzaFN0YXRlYCwgYnV0IGl0IG1heSBub3QgYWx3YXlzIHJlbGlhYmx5IGJlIGVtaXR0ZWQgYnkgdGhlIGJyb3dzZXJcbiAgLy8gV2hpY2ggaXMgd2h5IHdlIGFsc28gbW9ua2V5LXBhdGNoIG1ldGhvZHMgYmVsb3csIGluIGFkZGl0aW9uIHRvIHRoaXNcbiAgV0lORE9XLmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgKCkgPT4ge1xuICAgIGNvbnN0IHRvID0gV0lORE9XLmxvY2F0aW9uLmhyZWY7XG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBVUkwgc3RhdGUsIGFzIHdlIGFsd2F5cyByZWNlaXZlIG9ubHkgdGhlIHVwZGF0ZWQgc3RhdGVcbiAgICBjb25zdCBmcm9tID0gbGFzdEhyZWY7XG4gICAgbGFzdEhyZWYgPSB0bztcblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJEYXRhID0geyBmcm9tLCB0byB9IDtcbiAgICB0cmlnZ2VySGFuZGxlcnMoJ2hpc3RvcnknLCBoYW5kbGVyRGF0YSk7XG4gIH0pO1xuXG4gIC8vIEp1c3QgZ3VhcmQgYWdhaW5zdCB0aGlzIG5vdCBiZWluZyBhdmFpbGFibGUsIGluIHdlaXJkIGVudmlyb25tZW50c1xuICBpZiAoIXN1cHBvcnRzSGlzdG9yeSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlzdG9yeVJlcGxhY2VtZW50RnVuY3Rpb24ob3JpZ2luYWxIaXN0b3J5RnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCAuLi5hcmdzKSB7XG4gICAgICBjb25zdCB1cmwgPSBhcmdzLmxlbmd0aCA+IDIgPyBhcmdzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHVybCkge1xuICAgICAgICAvLyBjb2VyY2UgdG8gc3RyaW5nICh0aGlzIGlzIHdoYXQgcHVzaFN0YXRlIGRvZXMpXG4gICAgICAgIGNvbnN0IGZyb20gPSBsYXN0SHJlZjtcbiAgICAgICAgY29uc3QgdG8gPSBTdHJpbmcodXJsKTtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBVUkwgc3RhdGUsIGFzIHdlIGFsd2F5cyByZWNlaXZlIG9ubHkgdGhlIHVwZGF0ZWQgc3RhdGVcbiAgICAgICAgbGFzdEhyZWYgPSB0bztcblxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxIaXN0b3J5RnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYW5kbGVyRGF0YSA9IHsgZnJvbSwgdG8gfSA7XG4gICAgICAgIHRyaWdnZXJIYW5kbGVycygnaGlzdG9yeScsIGhhbmRsZXJEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbEhpc3RvcnlGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgZmlsbChXSU5ET1cuaGlzdG9yeSwgJ3B1c2hTdGF0ZScsIGhpc3RvcnlSZXBsYWNlbWVudEZ1bmN0aW9uKTtcbiAgZmlsbChXSU5ET1cuaGlzdG9yeSwgJ3JlcGxhY2VTdGF0ZScsIGhpc3RvcnlSZXBsYWNlbWVudEZ1bmN0aW9uKTtcbn1cblxuZXhwb3J0IHsgYWRkSGlzdG9yeUluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGluc3RydW1lbnRIaXN0b3J5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaXN0b3J5LmpzLm1hcFxuIiwiaW1wb3J0IHsgaXNOYXRpdmVGdW5jdGlvbiwgbG9nZ2VyIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBXSU5ET1cgfSBmcm9tICcuL3R5cGVzLmpzJztcblxuLyoqXG4gKiBXZSBnZW5lcmFsbHkgd2FudCB0byB1c2Ugd2luZG93LmZldGNoIC8gd2luZG93LnNldFRpbWVvdXQuXG4gKiBIb3dldmVyLCBpbiBzb21lIGNhc2VzIHRoaXMgbWF5IGJlIHdyYXBwZWQgKGUuZy4gYnkgWm9uZS5qcyBmb3IgQW5ndWxhciksXG4gKiBzbyB3ZSB0cnkgdG8gZ2V0IGFuIHVucGF0Y2hlZCB2ZXJzaW9uIG9mIHRoaXMgZnJvbSBhIHNhbmRib3hlZCBpZnJhbWUuXG4gKi9cblxuY29uc3QgY2FjaGVkSW1wbGVtZW50YXRpb25zID0ge307XG5cbi8qKlxuICogR2V0IHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgYSBicm93c2VyIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHdlIGdldCBhbiB1bndyYXBwZWQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uLCBpbiBjYXNlcyB3aGVyZSBhIHdyYXBwZWQgZnVuY3Rpb24gY2FuIGxlYWQgdG8gcHJvYmxlbXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGNhbiBiZSByZXRyaWV2ZWQ6XG4gKiAtIGBzZXRUaW1lb3V0YDogVGhpcyBjYW4gYmUgd3JhcHBlZCBieSBlLmcuIEFuZ3VsYXIsIGNhdXNpbmcgY2hhbmdlIGRldGVjdGlvbiB0byBiZSB0cmlnZ2VyZWQuXG4gKiAtIGBmZXRjaGA6IFRoaXMgY2FuIGJlIHdyYXBwZWQgYnkgZS5nLiBhZC1ibG9ja2VycywgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wIHdoZW4gYSByZXF1ZXN0IGlzIGJsb2NrZWQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUltcGxlbWVudGF0aW9uKFxuICBuYW1lLFxuKSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlZEltcGxlbWVudGF0aW9uc1tuYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cblxuICBsZXQgaW1wbCA9IFdJTkRPV1tuYW1lXSA7XG5cbiAgLy8gRmFzdCBwYXRoIHRvIGF2b2lkIERPTSBJL09cbiAgaWYgKGlzTmF0aXZlRnVuY3Rpb24oaW1wbCkpIHtcbiAgICByZXR1cm4gKGNhY2hlZEltcGxlbWVudGF0aW9uc1tuYW1lXSA9IGltcGwuYmluZChXSU5ET1cpICk7XG4gIH1cblxuICBjb25zdCBkb2N1bWVudCA9IFdJTkRPVy5kb2N1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGlmIChkb2N1bWVudCAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYW5kYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBzYW5kYm94LmhpZGRlbiA9IHRydWU7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNhbmRib3gpO1xuICAgICAgY29uc3QgY29udGVudFdpbmRvdyA9IHNhbmRib3guY29udGVudFdpbmRvdztcbiAgICAgIGlmIChjb250ZW50V2luZG93Py5bbmFtZV0pIHtcbiAgICAgICAgaW1wbCA9IGNvbnRlbnRXaW5kb3dbbmFtZV0gO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzYW5kYm94KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBDb3VsZCBub3QgY3JlYXRlIHNhbmRib3ggaWZyYW1lLCBqdXN0IHVzZSB3aW5kb3cueHh4XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybihgQ291bGQgbm90IGNyZWF0ZSBzYW5kYm94IGlmcmFtZSBmb3IgJHtuYW1lfSBjaGVjaywgYmFpbGluZyB0byB3aW5kb3cuJHtuYW1lfTogYCwgZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXR5IGNoZWNrOiBUaGlzIF9zaG91bGRfIG5vdCBoYXBwZW4sIGJ1dCBpZiBpdCBkb2VzLCB3ZSBqdXN0IHNraXAgY2FjaGluZy4uLlxuICAvLyBUaGlzIGNhbiBoYXBwZW4gZS5nLiBpbiB0ZXN0cyB3aGVyZSBmZXRjaCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgZW52LCBvciBzaW1pbGFyLlxuICBpZiAoIWltcGwpIHtcbiAgICByZXR1cm4gaW1wbDtcbiAgfVxuXG4gIHJldHVybiAoY2FjaGVkSW1wbGVtZW50YXRpb25zW25hbWVdID0gaW1wbC5iaW5kKFdJTkRPVykgKTtcbn1cblxuLyoqIENsZWFyIGEgY2FjaGVkIGltcGxlbWVudGF0aW9uLiAqL1xuZnVuY3Rpb24gY2xlYXJDYWNoZWRJbXBsZW1lbnRhdGlvbihuYW1lKSB7XG4gIGNhY2hlZEltcGxlbWVudGF0aW9uc1tuYW1lXSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWwgdXNlY2FzZSBmb3IgaW5jb3JyZWN0bHkgd3JhcHBlZCBGZXRjaCBBUElzIGluIGNvbmp1bmN0aW9uIHdpdGggYWQtYmxvY2tlcnMuXG4gKiBXaGVuZXZlciBzb21lb25lIHdyYXBzIHRoZSBGZXRjaCBBUEkgYW5kIHJldHVybnMgdGhlIHdyb25nIHByb21pc2UgY2hhaW4sXG4gKiB0aGlzIGNoYWluIGJlY29tZXMgb3JwaGFuZWQgYW5kIHRoZXJlIGlzIG5vIHBvc3NpYmxlIHdheSB0byBjYXB0dXJlIGl0J3MgcmVqZWN0aW9uc1xuICogb3RoZXIgdGhhbiBhbGxvd2luZyBpdCBidWJibGUgdXAgdG8gdGhpcyB2ZXJ5IGhhbmRsZXIuIGVnLlxuICpcbiAqIGNvbnN0IGYgPSB3aW5kb3cuZmV0Y2g7XG4gKiB3aW5kb3cuZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gKiAgIGNvbnN0IHAgPSBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKlxuICogICBwLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2hpLicpO1xuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiBwO1xuICogfVxuICpcbiAqIGBwLnRoZW4oZnVuY3Rpb24gKCkgeyAuLi4gfSlgIGlzIHByb2R1Y2luZyBhIGNvbXBsZXRlbHkgc2VwYXJhdGUgcHJvbWlzZSBjaGFpbixcbiAqIGhvd2V2ZXIsIHdoYXQncyByZXR1cm5lZCBpcyBgcGAgLSB0aGUgcmVzdWx0IG9mIG9yaWdpbmFsIGBmZXRjaGAgY2FsbC5cbiAqXG4gKiBUaGlzIG1lYW4sIHRoYXQgd2hlbmV2ZXIgd2UgdXNlIHRoZSBGZXRjaCBBUEkgdG8gc2VuZCBvdXIgb3duIHJlcXVlc3RzLCBfYW5kX1xuICogc29tZSBhZC1ibG9ja2VyIGJsb2NrcyBpdCwgdGhpcyBvcnBoYW5lZCBjaGFpbiB3aWxsIF9hbHdheXNfIHJlamVjdCxcbiAqIGVmZmVjdGl2ZWx5IGNhdXNpbmcgYW5vdGhlciBldmVudCB0byBiZSBjYXB0dXJlZC5cbiAqIFRoaXMgbWFrZXMgYSB3aG9sZSBwcm9jZXNzIGJlY29tZSBhbiBpbmZpbml0ZSBsb29wLCB3aGljaCB3ZSBuZWVkIHRvIHNvbWVob3dcbiAqIGRlYWwgd2l0aCwgYW5kIGJyZWFrIGl0IGluIG9uZSB3YXkgb3IgYW5vdGhlci5cbiAqXG4gKiBUbyBkZWFsIHdpdGggdGhpcyBpc3N1ZSwgd2UgYXJlIG1ha2luZyBzdXJlIHRoYXQgd2UgX2Fsd2F5c18gdXNlIHRoZSByZWFsXG4gKiBicm93c2VyIEZldGNoIEFQSSwgaW5zdGVhZCBvZiByZWx5aW5nIG9uIHdoYXQgYHdpbmRvdy5mZXRjaGAgZXhwb3Nlcy5cbiAqIFRoZSBvbmx5IGRvd25zaWRlIHRvIHRoaXMgd291bGQgYmUgbWlzc2luZyBvdXIgb3duIHJlcXVlc3RzIGFzIGJyZWFkY3J1bWJzLFxuICogYnV0IGJlY2F1c2Ugd2UgYXJlIGFscmVhZHkgbm90IGRvaW5nIHRoaXMsIGl0IHNob3VsZCBiZSBqdXN0IGZpbmUuXG4gKlxuICogUG9zc2libGUgZmFpbGVkIGZldGNoIGVycm9yIG1lc3NhZ2VzIHBlci1icm93c2VyOlxuICpcbiAqIENocm9tZTogIEZhaWxlZCB0byBmZXRjaFxuICogRWRnZTogICAgRmFpbGVkIHRvIEZldGNoXG4gKiBGaXJlZm94OiBOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlXG4gKiBTYWZhcmk6ICByZXNvdXJjZSBibG9ja2VkIGJ5IGNvbnRlbnQgYmxvY2tlclxuICovXG5mdW5jdGlvbiBmZXRjaCguLi5yZXN0KSB7XG4gIHJldHVybiBnZXROYXRpdmVJbXBsZW1lbnRhdGlvbignZmV0Y2gnKSguLi5yZXN0KTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gdW53cmFwcGVkIGBzZXRUaW1lb3V0YCBtZXRob2QuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCBldmVuIGlmIGUuZy4gQW5ndWxhciB3cmFwcyBgc2V0VGltZW91dGAsIHdlIGdldCB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLFxuICogYXZvaWRpbmcgdHJpZ2dlcmluZyBjaGFuZ2UgZGV0ZWN0aW9uLlxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0KC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldE5hdGl2ZUltcGxlbWVudGF0aW9uKCdzZXRUaW1lb3V0JykoLi4ucmVzdCk7XG59XG5cbmV4cG9ydCB7IGNsZWFyQ2FjaGVkSW1wbGVtZW50YXRpb24sIGZldGNoLCBnZXROYXRpdmVJbXBsZW1lbnRhdGlvbiwgc2V0VGltZW91dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0TmF0aXZlSW1wbGVtZW50YXRpb24uanMubWFwXG4iLCJpbXBvcnQgeyBhZGRIYW5kbGVyLCBtYXliZUluc3RydW1lbnQsIHRpbWVzdGFtcEluU2Vjb25kcywgaXNTdHJpbmcsIHRyaWdnZXJIYW5kbGVycyB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgeyBXSU5ET1cgfSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmNvbnN0IFNFTlRSWV9YSFJfREFUQV9LRVkgPSAnX19zZW50cnlfeGhyX3YzX18nO1xuXG4vKipcbiAqIEFkZCBhbiBpbnN0cnVtZW50YXRpb24gaGFuZGxlciBmb3Igd2hlbiBhbiBYSFIgcmVxdWVzdCBoYXBwZW5zLlxuICogVGhlIGhhbmRsZXIgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgcmVxdWVzdCBzdGFydHMgYW5kIG9uY2Ugd2hlbiBpdCBlbmRzLFxuICogd2hpY2ggY2FuIGJlIGlkZW50aWZpZWQgYnkgY2hlY2tpbmcgaWYgaXQgaGFzIGFuIGBlbmRUaW1lc3RhbXBgLlxuICpcbiAqIFVzZSBhdCB5b3VyIG93biByaXNrLCB0aGlzIG1pZ2h0IGJyZWFrIHdpdGhvdXQgY2hhbmdlbG9nIG5vdGljZSwgb25seSB1c2VkIGludGVybmFsbHkuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFkZFhockluc3RydW1lbnRhdGlvbkhhbmRsZXIoaGFuZGxlcikge1xuICBjb25zdCB0eXBlID0gJ3hocic7XG4gIGFkZEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gIG1heWJlSW5zdHJ1bWVudCh0eXBlLCBpbnN0cnVtZW50WEhSKTtcbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gaW5zdHJ1bWVudFhIUigpIHtcbiAgaWYgKCEoV0lORE9XICkuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB4aHJwcm90byA9IFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gIHhocnByb3RvLm9wZW4gPSBuZXcgUHJveHkoeGhycHJvdG8ub3Blbiwge1xuICAgIGFwcGx5KFxuICAgICAgb3JpZ2luYWxPcGVuLFxuICAgICAgeGhyT3BlblRoaXNBcmcsXG4gICAgICB4aHJPcGVuQXJnQXJyYXlcblxuLFxuICAgICkge1xuICAgICAgLy8gTk9URTogSWYgeW91IGFyZSBhIFNlbnRyeSB1c2VyLCBhbmQgeW91IGFyZSBzZWVpbmcgdGhpcyBzdGFjayBmcmFtZSxcbiAgICAgIC8vICAgICAgIGl0IG1lYW5zIHRoZSBlcnJvciwgdGhhdCB3YXMgY2F1c2VkIGJ5IHlvdXIgWEhSIGNhbGwgZGlkIG5vdFxuICAgICAgLy8gICAgICAgaGF2ZSBhIHN0YWNrIHRyYWNlLiBJZiB5b3UgYXJlIHVzaW5nIEh0dHBDbGllbnQgaW50ZWdyYXRpb24sXG4gICAgICAvLyAgICAgICB0aGlzIGlzIHRoZSBleHBlY3RlZCBiZWhhdmlvciwgYXMgd2UgYXJlIHVzaW5nIHRoaXMgdmlydHVhbCBlcnJvciB0byBjYXB0dXJlXG4gICAgICAvLyAgICAgICB0aGUgbG9jYXRpb24gb2YgeW91ciBYSFIgY2FsbCwgYW5kIGdyb3VwIHlvdXIgSHR0cENsaWVudCBldmVudHMgYWNjb3JkaW5nbHkuXG4gICAgICBjb25zdCB2aXJ0dWFsRXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lc3RhbXAgPSB0aW1lc3RhbXBJblNlY29uZHMoKSAqIDEwMDA7XG5cbiAgICAgIC8vIG9wZW4oKSBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCB3aXRoIHR3byBvciBtb3JlIGFyZ3VtZW50c1xuICAgICAgLy8gQnV0IHRvIGJlIG9uIHRoZSBzYWZlIHNpZGUsIHdlIGFjdHVhbGx5IHZhbGlkYXRlIHRoaXMgYW5kIGJhaWwgb3V0IGlmIHdlIGRvbid0IGhhdmUgYSBtZXRob2QgJiB1cmxcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGlzU3RyaW5nKHhock9wZW5BcmdBcnJheVswXSkgPyB4aHJPcGVuQXJnQXJyYXlbMF0udG9VcHBlckNhc2UoKSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHVybCA9IHBhcnNlWGhyVXJsQXJnKHhock9wZW5BcmdBcnJheVsxXSk7XG5cbiAgICAgIGlmICghbWV0aG9kIHx8ICF1cmwpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT3Blbi5hcHBseSh4aHJPcGVuVGhpc0FyZywgeGhyT3BlbkFyZ0FycmF5KTtcbiAgICAgIH1cblxuICAgICAgeGhyT3BlblRoaXNBcmdbU0VOVFJZX1hIUl9EQVRBX0tFWV0gPSB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0X2hlYWRlcnM6IHt9LFxuICAgICAgfTtcblxuICAgICAgLy8gaWYgU2VudHJ5IGtleSBhcHBlYXJzIGluIFVSTCwgZG9uJ3QgY2FwdHVyZSBpdCBhcyBhIHJlcXVlc3RcbiAgICAgIGlmIChtZXRob2QgPT09ICdQT1NUJyAmJiB1cmwubWF0Y2goL3NlbnRyeV9rZXkvKSkge1xuICAgICAgICB4aHJPcGVuVGhpc0FyZy5fX3NlbnRyeV9vd25fcmVxdWVzdF9fID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgLy8gRm9yIHdoYXRldmVyIHJlYXNvbiwgdGhpcyBpcyBub3QgdGhlIHNhbWUgaW5zdGFuY2UgaGVyZSBhcyBmcm9tIHRoZSBvdXRlciBtZXRob2RcbiAgICAgICAgY29uc3QgeGhySW5mbyA9IHhock9wZW5UaGlzQXJnW1NFTlRSWV9YSFJfREFUQV9LRVldO1xuXG4gICAgICAgIGlmICgheGhySW5mbykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4aHJPcGVuVGhpc0FyZy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRvdWNoaW5nIHN0YXR1c0NvZGUgaW4gc29tZSBwbGF0Zm9ybXMgdGhyb3dzXG4gICAgICAgICAgICAvLyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIHhockluZm8uc3RhdHVzX2NvZGUgPSB4aHJPcGVuVGhpc0FyZy5zdGF0dXM7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhhbmRsZXJEYXRhID0ge1xuICAgICAgICAgICAgZW5kVGltZXN0YW1wOiB0aW1lc3RhbXBJblNlY29uZHMoKSAqIDEwMDAsXG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgICAgICAgIHhocjogeGhyT3BlblRoaXNBcmcsXG4gICAgICAgICAgICB2aXJ0dWFsRXJyb3IsXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmlnZ2VySGFuZGxlcnMoJ3hocicsIGhhbmRsZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKCdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIHhock9wZW5UaGlzQXJnICYmIHR5cGVvZiB4aHJPcGVuVGhpc0FyZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgeGhyT3BlblRoaXNBcmcub25yZWFkeXN0YXRlY2hhbmdlID0gbmV3IFByb3h5KHhock9wZW5UaGlzQXJnLm9ucmVhZHlzdGF0ZWNoYW5nZSwge1xuICAgICAgICAgIGFwcGx5KG9yaWdpbmFsT25yZWFkeXN0YXRlY2hhbmdlLCBvbnJlYWR5c3RhdGVjaGFuZ2VUaGlzQXJnLCBvbnJlYWR5c3RhdGVjaGFuZ2VBcmdBcnJheSkge1xuICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25yZWFkeXN0YXRlY2hhbmdlLmFwcGx5KG9ucmVhZHlzdGF0ZWNoYW5nZVRoaXNBcmcsIG9ucmVhZHlzdGF0ZWNoYW5nZUFyZ0FycmF5KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhock9wZW5UaGlzQXJnLmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBvbnJlYWR5c3RhdGVjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJjZXB0aW5nIGBzZXRSZXF1ZXN0SGVhZGVyYCB0byBhY2Nlc3MgdGhlIHJlcXVlc3QgaGVhZGVycyBvZiBYSFIgaW5zdGFuY2UuXG4gICAgICAvLyBUaGlzIHdpbGwgb25seSB3b3JrIGZvciB1c2VyL2xpYnJhcnkgZGVmaW5lZCBoZWFkZXJzLCBub3QgZm9yIHRoZSBkZWZhdWx0L2Jyb3dzZXItYXNzaWduZWQgaGVhZGVycy5cbiAgICAgIC8vIFJlcXVlc3QgY29va2llcyBhcmUgYWxzbyB1bmF2YWlsYWJsZSBmb3IgWEhSLCBhcyBgQ29va2llYCBoZWFkZXIgY2FuJ3QgYmUgZGVmaW5lZCBieSBgc2V0UmVxdWVzdEhlYWRlcmAuXG4gICAgICB4aHJPcGVuVGhpc0FyZy5zZXRSZXF1ZXN0SGVhZGVyID0gbmV3IFByb3h5KHhock9wZW5UaGlzQXJnLnNldFJlcXVlc3RIZWFkZXIsIHtcbiAgICAgICAgYXBwbHkoXG4gICAgICAgICAgb3JpZ2luYWxTZXRSZXF1ZXN0SGVhZGVyLFxuICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXJUaGlzQXJnLFxuICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXJBcmdBcnJheSxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgW2hlYWRlciwgdmFsdWVdID0gc2V0UmVxdWVzdEhlYWRlckFyZ0FycmF5O1xuXG4gICAgICAgICAgY29uc3QgeGhySW5mbyA9IHNldFJlcXVlc3RIZWFkZXJUaGlzQXJnW1NFTlRSWV9YSFJfREFUQV9LRVldO1xuXG4gICAgICAgICAgaWYgKHhockluZm8gJiYgaXNTdHJpbmcoaGVhZGVyKSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHhockluZm8ucmVxdWVzdF9oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbFNldFJlcXVlc3RIZWFkZXIuYXBwbHkoc2V0UmVxdWVzdEhlYWRlclRoaXNBcmcsIHNldFJlcXVlc3RIZWFkZXJBcmdBcnJheSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9yaWdpbmFsT3Blbi5hcHBseSh4aHJPcGVuVGhpc0FyZywgeGhyT3BlbkFyZ0FycmF5KTtcbiAgICB9LFxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gIHhocnByb3RvLnNlbmQgPSBuZXcgUHJveHkoeGhycHJvdG8uc2VuZCwge1xuICAgIGFwcGx5KG9yaWdpbmFsU2VuZCwgc2VuZFRoaXNBcmcsIHNlbmRBcmdBcnJheSkge1xuICAgICAgY29uc3Qgc2VudHJ5WGhyRGF0YSA9IHNlbmRUaGlzQXJnW1NFTlRSWV9YSFJfREFUQV9LRVldO1xuXG4gICAgICBpZiAoIXNlbnRyeVhockRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsU2VuZC5hcHBseShzZW5kVGhpc0FyZywgc2VuZEFyZ0FycmF5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbmRBcmdBcnJheVswXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbnRyeVhockRhdGEuYm9keSA9IHNlbmRBcmdBcnJheVswXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFuZGxlckRhdGEgPSB7XG4gICAgICAgIHN0YXJ0VGltZXN0YW1wOiB0aW1lc3RhbXBJblNlY29uZHMoKSAqIDEwMDAsXG4gICAgICAgIHhocjogc2VuZFRoaXNBcmcsXG4gICAgICB9O1xuICAgICAgdHJpZ2dlckhhbmRsZXJzKCd4aHInLCBoYW5kbGVyRGF0YSk7XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbFNlbmQuYXBwbHkoc2VuZFRoaXNBcmcsIHNlbmRBcmdBcnJheSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBVUkwgYXJndW1lbnQgb2YgYSBYSFIgbWV0aG9kIHRvIGEgc3RyaW5nLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L29wZW4jdXJsXG4gKiB1cmw6IEEgc3RyaW5nIG9yIGFueSBvdGhlciBvYmplY3Qgd2l0aCBhIHN0cmluZ2lmaWVyIOKAlCBpbmNsdWRpbmcgYSBVUkwgb2JqZWN0IOKAlCB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIHJlc291cmNlIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYXJndW1lbnQgb2YgYW4gWEhSIG1ldGhvZFxuICogQHJldHVybnMgVGhlIHBhcnNlZCBVUkwgc3RyaW5nIG9yIHVuZGVmaW5lZCBpZiB0aGUgVVJMIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VYaHJVcmxBcmcodXJsKSB7XG4gIGlmIChpc1N0cmluZyh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlIHBhc3NlZCBpbiBhcmd1bWVudCBpcyBub3QgYSBzdHJpbmcsIGl0IHNob3VsZCBoYXZlIGEgYHRvU3RyaW5nYCBtZXRob2QgYXMgYSBzdHJpbmdpZmllci5cbiAgICAvLyBJZiB0aGF0IGZhaWxzLCB3ZSBqdXN0IHJldHVybiB1bmRlZmluZWQgKGxpa2UgaW4gSUUxMSB3aGVyZSBVUkwgaXMgbm90IGF2YWlsYWJsZSlcbiAgICByZXR1cm4gKHVybCApLnRvU3RyaW5nKCk7XG4gIH0gY2F0Y2gge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB7IFNFTlRSWV9YSFJfREFUQV9LRVksIGFkZFhockluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGluc3RydW1lbnRYSFIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhoci5qcy5tYXBcbiIsImltcG9ydCB7IGdldE5hdGl2ZUltcGxlbWVudGF0aW9uLCBjbGVhckNhY2hlZEltcGxlbWVudGF0aW9uIH0gZnJvbSAnQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9ydCwgcmVqZWN0ZWRTeW5jUHJvbWlzZSB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRyYW5zcG9ydCB0aGF0IHVzZXMgdGhlIEZldGNoIEFQSSB0byBzZW5kIGV2ZW50cyB0byBTZW50cnkuXG4gKi9cbmZ1bmN0aW9uIG1ha2VGZXRjaFRyYW5zcG9ydChcbiAgb3B0aW9ucyxcbiAgbmF0aXZlRmV0Y2ggPSBnZXROYXRpdmVJbXBsZW1lbnRhdGlvbignZmV0Y2gnKSxcbikge1xuICBsZXQgcGVuZGluZ0JvZHlTaXplID0gMDtcbiAgbGV0IHBlbmRpbmdDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gbWFrZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlcXVlc3RTaXplID0gcmVxdWVzdC5ib2R5Lmxlbmd0aDtcbiAgICBwZW5kaW5nQm9keVNpemUgKz0gcmVxdWVzdFNpemU7XG4gICAgcGVuZGluZ0NvdW50Kys7XG5cbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6ICdzdHJpY3Qtb3JpZ2luJyxcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgIC8vIE91dGdvaW5nIHJlcXVlc3RzIGFyZSB1c3VhbGx5IGNhbmNlbGxlZCB3aGVuIG5hdmlnYXRpbmcgdG8gYSBkaWZmZXJlbnQgcGFnZSwgY2F1c2luZyBhIFwiVHlwZUVycm9yOiBGYWlsZWQgdG9cbiAgICAgIC8vIGZldGNoXCIgZXJyb3IgYW5kIHNlbmRpbmcgYSBcIm5ldHdvcmtfZXJyb3JcIiBjbGllbnQtb3V0Y29tZSAtIGluIENocm9tZSwgdGhlIHJlcXVlc3Qgc3RhdHVzIHNob3dzIFwiKGNhbmNlbGxlZClcIi5cbiAgICAgIC8vIFRoZSBga2VlcGFsaXZlYCBmbGFnIGtlZXBzIG91dGdvaW5nIHJlcXVlc3RzIGFsaXZlLCBldmVuIHdoZW4gc3dpdGNoaW5nIHBhZ2VzLiBXZSB3YW50IHRoaXMgc2luY2Ugd2UncmVcbiAgICAgIC8vIGZyZXF1ZW50bHkgc2VuZGluZyBldmVudHMgcmlnaHQgYmVmb3JlIHRoZSB1c2VyIGlzIHN3aXRjaGluZyBwYWdlcyAoZWcuIHdoZW4gZmluaXNoaW5nIG5hdmlnYXRpb24gdHJhbnNhY3Rpb25zKS5cbiAgICAgIC8vIEdvdGNoYXM6XG4gICAgICAvLyAtIGBrZWVwYWxpdmVgIGlzbid0IHN1cHBvcnRlZCBieSBGaXJlZm94XG4gICAgICAvLyAtIEFzIHBlciBzcGVjIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLW9yLWNhY2hlLWZldGNoKTpcbiAgICAgIC8vICAgSWYgdGhlIHN1bSBvZiBjb250ZW50TGVuZ3RoIGFuZCBpbmZsaWdodEtlZXBhbGl2ZUJ5dGVzIGlzIGdyZWF0ZXIgdGhhbiA2NCBraWJpYnl0ZXMsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIC8vICAgV2Ugd2lsbCB0aGVyZWZvcmUgb25seSBhY3RpdmF0ZSB0aGUgZmxhZyB3aGVuIHdlJ3JlIGJlbG93IHRoYXQgbGltaXQuXG4gICAgICAvLyBUaGVyZSBpcyBhbHNvIGEgbGltaXQgb2YgcmVxdWVzdHMgdGhhdCBjYW4gYmUgb3BlbiBhdCB0aGUgc2FtZSB0aW1lLCBzbyB3ZSBhbHNvIGxpbWl0IHRoaXMgdG8gMTVcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L3B1bGwvNzU1MyBmb3IgZGV0YWlsc1xuICAgICAga2VlcGFsaXZlOiBwZW5kaW5nQm9keVNpemUgPD0gNjAwMDAgJiYgcGVuZGluZ0NvdW50IDwgMTUsXG4gICAgICAuLi5vcHRpb25zLmZldGNoT3B0aW9ucyxcbiAgICB9O1xuXG4gICAgaWYgKCFuYXRpdmVGZXRjaCkge1xuICAgICAgY2xlYXJDYWNoZWRJbXBsZW1lbnRhdGlvbignZmV0Y2gnKTtcbiAgICAgIHJldHVybiByZWplY3RlZFN5bmNQcm9taXNlKCdObyBmZXRjaCBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVE9ETzogVGhpcyBtYXkgbmVlZCBhIGBzdXBwcmVzc1RyYWNpbmdgIGNhbGwgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHN3aXRjaCB0aGUgYnJvd3NlciBTREsgdG8gT1RFTFxuICAgICAgcmV0dXJuIG5hdGl2ZUZldGNoKG9wdGlvbnMudXJsLCByZXF1ZXN0T3B0aW9ucykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHBlbmRpbmdCb2R5U2l6ZSAtPSByZXF1ZXN0U2l6ZTtcbiAgICAgICAgcGVuZGluZ0NvdW50LS07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICd4LXNlbnRyeS1yYXRlLWxpbWl0cyc6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdYLVNlbnRyeS1SYXRlLUxpbWl0cycpLFxuICAgICAgICAgICAgJ3JldHJ5LWFmdGVyJzogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJyksXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNsZWFyQ2FjaGVkSW1wbGVtZW50YXRpb24oJ2ZldGNoJyk7XG4gICAgICBwZW5kaW5nQm9keVNpemUgLT0gcmVxdWVzdFNpemU7XG4gICAgICBwZW5kaW5nQ291bnQtLTtcbiAgICAgIHJldHVybiByZWplY3RlZFN5bmNQcm9taXNlKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVUcmFuc3BvcnQob3B0aW9ucywgbWFrZVJlcXVlc3QpO1xufVxuXG5leHBvcnQgeyBtYWtlRmV0Y2hUcmFuc3BvcnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcFxuIiwiaW1wb3J0IHsgY3JlYXRlU3RhY2tQYXJzZXIsIFVOS05PV05fRlVOQ1RJT04gfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuXG4vLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jc25vdmVyL1RyYWNlS2l0LCBhbmQgd2FzIGxhcmdlbHlcbi8vIHJlIC0gd3JpdHRlbiBhcyBwYXJ0IG9mIHJhdmVuIC0ganMuXG4vL1xuLy8gVGhpcyBjb2RlIHdhcyBsYXRlciBjb3BpZWQgdG8gdGhlIEphdmFTY3JpcHQgbW9ubyAtIHJlcG8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgYW5kXG4vLyByZWZhY3RvcmVkIG92ZXIgdGhlIHllYXJzLlxuXG5cbmNvbnN0IE9QRVJBMTBfUFJJT1JJVFkgPSAxMDtcbmNvbnN0IE9QRVJBMTFfUFJJT1JJVFkgPSAyMDtcbmNvbnN0IENIUk9NRV9QUklPUklUWSA9IDMwO1xuY29uc3QgV0lOSlNfUFJJT1JJVFkgPSA0MDtcbmNvbnN0IEdFQ0tPX1BSSU9SSVRZID0gNTA7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lKGZpbGVuYW1lLCBmdW5jLCBsaW5lbm8sIGNvbG5vKSB7XG4gIGNvbnN0IGZyYW1lID0ge1xuICAgIGZpbGVuYW1lLFxuICAgIGZ1bmN0aW9uOiBmdW5jID09PSAnPGFub255bW91cz4nID8gVU5LTk9XTl9GVU5DVElPTiA6IGZ1bmMsXG4gICAgaW5fYXBwOiB0cnVlLCAvLyBBbGwgYnJvd3NlciBmcmFtZXMgYXJlIGNvbnNpZGVyZWQgaW5fYXBwXG4gIH07XG5cbiAgaWYgKGxpbmVubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZnJhbWUubGluZW5vID0gbGluZW5vO1xuICB9XG5cbiAgaWYgKGNvbG5vICE9PSB1bmRlZmluZWQpIHtcbiAgICBmcmFtZS5jb2xubyA9IGNvbG5vO1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lO1xufVxuXG4vLyBUaGlzIHJlZ2V4IG1hdGNoZXMgZnJhbWVzIHRoYXQgaGF2ZSBubyBmdW5jdGlvbiBuYW1lIChpZS4gYXJlIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGUpLlxuLy8gRm9yIGV4YW1wbGUgXCJhdCBodHRwOi8vbG9jYWxob3N0OjUwMDAvL3NjcmlwdC5qczoxOjEyNlwiXG4vLyBGcmFtZXMgX3dpdGhfIGZ1bmN0aW9uIG5hbWVzIHVzdWFsbHkgbG9vayBhcyBmb2xsb3dzOiBcImF0IGNvbW1pdExheW91dEVmZmVjdHMgKHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qczoyMzQyNjoxKVwiXG5jb25zdCBjaHJvbWVSZWdleE5vRm5OYW1lID0gL15cXHMqYXQgKFxcUys/KSg/OjooXFxkKykpKD86OihcXGQrKSlcXHMqJC9pO1xuXG4vLyBUaGlzIHJlZ2V4IG1hdGNoZXMgYWxsIHRoZSBmcmFtZXMgdGhhdCBoYXZlIGEgZnVuY3Rpb24gbmFtZS5cbmNvbnN0IGNocm9tZVJlZ2V4ID1cbiAgL15cXHMqYXQgKD86KC4rP1xcKSg/OiBcXFsuK1xcXSk/fC4qPykgP1xcKCg/OmFkZHJlc3MgYXQgKT8pPyg/OmFzeW5jICk/KCg/Ojxhbm9ueW1vdXM+fFstYS16XSs6fC4qYnVuZGxlfFxcLyk/Lio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xuXG5jb25zdCBjaHJvbWVFdmFsUmVnZXggPSAvXFwoKFxcUyopKD86OihcXGQrKSkoPzo6KFxcZCspKVxcKS87XG5cbi8vIENocm9taXVtIGJhc2VkIGJyb3dzZXJzOiBDaHJvbWUsIEJyYXZlLCBuZXcgT3BlcmEsIG5ldyBFZGdlXG4vLyBXZSBjYW5ub3QgY2FsbCB0aGlzIHZhcmlhYmxlIGBjaHJvbWVgIGJlY2F1c2UgaXQgY2FuIGNvbmZsaWN0IHdpdGggZ2xvYmFsIGBjaHJvbWVgIHZhcmlhYmxlIGluIGNlcnRhaW4gZW52aXJvbm1lbnRzXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzY4ODBcbmNvbnN0IGNocm9tZVN0YWNrUGFyc2VyRm4gPSBsaW5lID0+IHtcbiAgLy8gSWYgdGhlIHN0YWNrIGxpbmUgaGFzIG5vIGZ1bmN0aW9uIG5hbWUsIHdlIG5lZWQgdG8gcGFyc2UgaXQgZGlmZmVyZW50bHlcbiAgY29uc3Qgbm9GblBhcnRzID0gY2hyb21lUmVnZXhOb0ZuTmFtZS5leGVjKGxpbmUpIDtcblxuICBpZiAobm9GblBhcnRzKSB7XG4gICAgY29uc3QgWywgZmlsZW5hbWUsIGxpbmUsIGNvbF0gPSBub0ZuUGFydHM7XG4gICAgcmV0dXJuIGNyZWF0ZUZyYW1lKGZpbGVuYW1lLCBVTktOT1dOX0ZVTkNUSU9OLCArbGluZSwgK2NvbCk7XG4gIH1cblxuICBjb25zdCBwYXJ0cyA9IGNocm9tZVJlZ2V4LmV4ZWMobGluZSkgO1xuXG4gIGlmIChwYXJ0cykge1xuICAgIGNvbnN0IGlzRXZhbCA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoJ2V2YWwnKSA9PT0gMDsgLy8gc3RhcnQgb2YgbGluZVxuXG4gICAgaWYgKGlzRXZhbCkge1xuICAgICAgY29uc3Qgc3ViTWF0Y2ggPSBjaHJvbWVFdmFsUmVnZXguZXhlYyhwYXJ0c1syXSkgO1xuXG4gICAgICBpZiAoc3ViTWF0Y2gpIHtcbiAgICAgICAgLy8gdGhyb3cgb3V0IGV2YWwgbGluZS9jb2x1bW4gYW5kIHVzZSB0b3AtbW9zdCBsaW5lL2NvbHVtbiBudW1iZXJcbiAgICAgICAgcGFydHNbMl0gPSBzdWJNYXRjaFsxXTsgLy8gdXJsXG4gICAgICAgIHBhcnRzWzNdID0gc3ViTWF0Y2hbMl07IC8vIGxpbmVcbiAgICAgICAgcGFydHNbNF0gPSBzdWJNYXRjaFszXTsgLy8gY29sdW1uXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gS2FtaWw6IE9uZSBtb3JlIGhhY2sgd29uJ3QgaHVydCB1cyByaWdodD8gVW5kZXJzdGFuZGluZyBhbmQgYWRkaW5nIG1vcmUgcnVsZXMgb24gdG9wIG9mIHRoZXNlIHJlZ2V4cHMgcmlnaHQgbm93XG4gICAgLy8gd291bGQgYmUgd2F5IHRvbyB0aW1lIGNvbnN1bWluZy4gKFRPRE86IFJld3JpdGUgd2hvbGUgUmVnRXhwIHRvIGJlIG1vcmUgcmVhZGFibGUpXG4gICAgY29uc3QgW2Z1bmMsIGZpbGVuYW1lXSA9IGV4dHJhY3RTYWZhcmlFeHRlbnNpb25EZXRhaWxzKHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sIHBhcnRzWzJdKTtcblxuICAgIHJldHVybiBjcmVhdGVGcmFtZShmaWxlbmFtZSwgZnVuYywgcGFydHNbM10gPyArcGFydHNbM10gOiB1bmRlZmluZWQsIHBhcnRzWzRdID8gK3BhcnRzWzRdIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybjtcbn07XG5cbmNvbnN0IGNocm9tZVN0YWNrTGluZVBhcnNlciA9IFtDSFJPTUVfUFJJT1JJVFksIGNocm9tZVN0YWNrUGFyc2VyRm5dO1xuXG4vLyBnZWNrbyByZWdleDogYCg/OmJ1bmRsZXxcXGQrXFwuanMpYDogYGJ1bmRsZWAgaXMgZm9yIHJlYWN0IG5hdGl2ZSwgYFxcZCtcXC5qc2AgYWxzbyBidXQgc3BlY2lmaWNhbGx5IGZvciByYW0gYnVuZGxlcyBiZWNhdXNlIGl0XG4vLyBnZW5lcmF0ZXMgZmlsZW5hbWVzIHdpdGhvdXQgYSBwcmVmaXggbGlrZSBgZmlsZTovL2AgdGhlIGZpbGVuYW1lcyBpbiB0aGUgc3RhY2t0cmFjZSBhcmUganVzdCA0Mi5qc1xuLy8gV2UgbmVlZCB0aGlzIHNwZWNpZmljIGNhc2UgZm9yIG5vdyBiZWNhdXNlIHdlIHdhbnQgbm8gb3RoZXIgcmVnZXggdG8gbWF0Y2guXG5jb25zdCBnZWNrb1JFZ2V4ID1cbiAgL15cXHMqKC4qPykoPzpcXCgoLio/KVxcKSk/KD86XnxAKT8oKD86Wy1hLXpdKyk/OlxcLy4qP3xcXFtuYXRpdmUgY29kZVxcXXxbXkBdKig/OmJ1bmRsZXxcXGQrXFwuanMpfFxcL1tcXHdcXC0uIC89XSspKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFxzKiQvaTtcbmNvbnN0IGdlY2tvRXZhbFJlZ2V4ID0gLyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7XG5cbmNvbnN0IGdlY2tvID0gbGluZSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gZ2Vja29SRWdleC5leGVjKGxpbmUpIDtcblxuICBpZiAocGFydHMpIHtcbiAgICBjb25zdCBpc0V2YWwgPSBwYXJ0c1szXSAmJiBwYXJ0c1szXS5pbmRleE9mKCcgPiBldmFsJykgPiAtMTtcbiAgICBpZiAoaXNFdmFsKSB7XG4gICAgICBjb25zdCBzdWJNYXRjaCA9IGdlY2tvRXZhbFJlZ2V4LmV4ZWMocGFydHNbM10pIDtcblxuICAgICAgaWYgKHN1Yk1hdGNoKSB7XG4gICAgICAgIC8vIHRocm93IG91dCBldmFsIGxpbmUvY29sdW1uIGFuZCB1c2UgdG9wLW1vc3QgbGluZSBudW1iZXJcbiAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXSB8fCAnZXZhbCc7XG4gICAgICAgIHBhcnRzWzNdID0gc3ViTWF0Y2hbMV07XG4gICAgICAgIHBhcnRzWzRdID0gc3ViTWF0Y2hbMl07XG4gICAgICAgIHBhcnRzWzVdID0gJyc7IC8vIG5vIGNvbHVtbiB3aGVuIGV2YWxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZmlsZW5hbWUgPSBwYXJ0c1szXTtcbiAgICBsZXQgZnVuYyA9IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT047XG4gICAgW2Z1bmMsIGZpbGVuYW1lXSA9IGV4dHJhY3RTYWZhcmlFeHRlbnNpb25EZXRhaWxzKGZ1bmMsIGZpbGVuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVGcmFtZShmaWxlbmFtZSwgZnVuYywgcGFydHNbNF0gPyArcGFydHNbNF0gOiB1bmRlZmluZWQsIHBhcnRzWzVdID8gK3BhcnRzWzVdIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybjtcbn07XG5cbmNvbnN0IGdlY2tvU3RhY2tMaW5lUGFyc2VyID0gW0dFQ0tPX1BSSU9SSVRZLCBnZWNrb107XG5cbmNvbnN0IHdpbmpzUmVnZXggPSAvXlxccyphdCAoPzooKD86XFxbb2JqZWN0IG9iamVjdFxcXSk/LispICk/XFwoPygoPzpbLWEtel0rKTouKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xuXG5jb25zdCB3aW5qcyA9IGxpbmUgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHdpbmpzUmVnZXguZXhlYyhsaW5lKSA7XG5cbiAgcmV0dXJuIHBhcnRzXG4gICAgPyBjcmVhdGVGcmFtZShwYXJ0c1syXSwgcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTiwgK3BhcnRzWzNdLCBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IHVuZGVmaW5lZClcbiAgICA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IHdpbmpzU3RhY2tMaW5lUGFyc2VyID0gW1dJTkpTX1BSSU9SSVRZLCB3aW5qc107XG5cbmNvbnN0IG9wZXJhMTBSZWdleCA9IC8gbGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogaW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG5cbmNvbnN0IG9wZXJhMTAgPSBsaW5lID0+IHtcbiAgY29uc3QgcGFydHMgPSBvcGVyYTEwUmVnZXguZXhlYyhsaW5lKSA7XG4gIHJldHVybiBwYXJ0cyA/IGNyZWF0ZUZyYW1lKHBhcnRzWzJdLCBwYXJ0c1szXSB8fCBVTktOT1dOX0ZVTkNUSU9OLCArcGFydHNbMV0pIDogdW5kZWZpbmVkO1xufTtcblxuY29uc3Qgb3BlcmExMFN0YWNrTGluZVBhcnNlciA9IFtPUEVSQTEwX1BSSU9SSVRZLCBvcGVyYTEwXTtcblxuY29uc3Qgb3BlcmExMVJlZ2V4ID1cbiAgLyBsaW5lIChcXGQrKSwgY29sdW1uIChcXGQrKVxccyooPzppbiAoPzo8YW5vbnltb3VzIGZ1bmN0aW9uOiAoW14+XSspPnwoW14pXSspKVxcKC4qXFwpKT8gaW4gKC4qKTpcXHMqJC9pO1xuXG5jb25zdCBvcGVyYTExID0gbGluZSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gb3BlcmExMVJlZ2V4LmV4ZWMobGluZSkgO1xuICByZXR1cm4gcGFydHMgPyBjcmVhdGVGcmFtZShwYXJ0c1s1XSwgcGFydHNbM10gfHwgcGFydHNbNF0gfHwgVU5LTk9XTl9GVU5DVElPTiwgK3BhcnRzWzFdLCArcGFydHNbMl0pIDogdW5kZWZpbmVkO1xufTtcblxuY29uc3Qgb3BlcmExMVN0YWNrTGluZVBhcnNlciA9IFtPUEVSQTExX1BSSU9SSVRZLCBvcGVyYTExXTtcblxuY29uc3QgZGVmYXVsdFN0YWNrTGluZVBhcnNlcnMgPSBbY2hyb21lU3RhY2tMaW5lUGFyc2VyLCBnZWNrb1N0YWNrTGluZVBhcnNlcl07XG5cbmNvbnN0IGRlZmF1bHRTdGFja1BhcnNlciA9IGNyZWF0ZVN0YWNrUGFyc2VyKC4uLmRlZmF1bHRTdGFja0xpbmVQYXJzZXJzKTtcblxuLyoqXG4gKiBTYWZhcmkgd2ViIGV4dGVuc2lvbnMsIHN0YXJ0aW5nIHZlcnNpb24gdW5rbm93biwgY2FuIHByb2R1Y2UgXCJmcmFtZXMtb25seVwiIHN0YWNrdHJhY2VzLlxuICogV2hhdCBpdCBtZWFucywgaXMgdGhhdCBpbnN0ZWFkIG9mIGZvcm1hdCBsaWtlOlxuICpcbiAqIEVycm9yOiB3YXRcbiAqICAgYXQgZnVuY3Rpb25AdXJsOnJvdzpjb2xcbiAqICAgYXQgZnVuY3Rpb25AdXJsOnJvdzpjb2xcbiAqICAgYXQgZnVuY3Rpb25AdXJsOnJvdzpjb2xcbiAqXG4gKiBpdCBwcm9kdWNlcyBzb21ldGhpbmcgbGlrZTpcbiAqXG4gKiAgIGZ1bmN0aW9uQHVybDpyb3c6Y29sXG4gKiAgIGZ1bmN0aW9uQHVybDpyb3c6Y29sXG4gKiAgIGZ1bmN0aW9uQHVybDpyb3c6Y29sXG4gKlxuICogQmVjYXVzZSBvZiB0aGF0LCBpdCB3b24ndCBiZSBjYXB0dXJlZCBieSBgY2hyb21lYCBSZWdFeHAgYW5kIHdpbGwgZmFsbCBpbnRvIGBHZWNrb2AgYnJhbmNoLlxuICogVGhpcyBmdW5jdGlvbiBpcyBleHRyYWN0ZWQgc28gdGhhdCB3ZSBjYW4gdXNlIGl0IGluIGJvdGggcGxhY2VzIHdpdGhvdXQgZHVwbGljYXRpbmcgdGhlIGxvZ2ljLlxuICogVW5mb3J0dW5hdGVseSBcImp1c3RcIiBjaGFuZ2luZyBSZWdFeHAgaXMgdG9vIGNvbXBsaWNhdGVkIG5vdyBhbmQgbWFraW5nIGl0IHBhc3MgYWxsIHRlc3RzXG4gKiBhbmQgZml4IHRoaXMgY2FzZSBzZWVtcyBsaWtlIGFuIGltcG9zc2libGUsIG9yIGF0IGxlYXN0IHdheSB0b28gdGltZS1jb25zdW1pbmcgdGFzay5cbiAqL1xuY29uc3QgZXh0cmFjdFNhZmFyaUV4dGVuc2lvbkRldGFpbHMgPSAoZnVuYywgZmlsZW5hbWUpID0+IHtcbiAgY29uc3QgaXNTYWZhcmlFeHRlbnNpb24gPSBmdW5jLmluZGV4T2YoJ3NhZmFyaS1leHRlbnNpb24nKSAhPT0gLTE7XG4gIGNvbnN0IGlzU2FmYXJpV2ViRXh0ZW5zaW9uID0gZnVuYy5pbmRleE9mKCdzYWZhcmktd2ViLWV4dGVuc2lvbicpICE9PSAtMTtcblxuICByZXR1cm4gaXNTYWZhcmlFeHRlbnNpb24gfHwgaXNTYWZhcmlXZWJFeHRlbnNpb25cbiAgICA/IFtcbiAgICAgICAgZnVuYy5pbmRleE9mKCdAJykgIT09IC0xID8gKGZ1bmMuc3BsaXQoJ0AnKVswXSApIDogVU5LTk9XTl9GVU5DVElPTixcbiAgICAgICAgaXNTYWZhcmlFeHRlbnNpb24gPyBgc2FmYXJpLWV4dGVuc2lvbjoke2ZpbGVuYW1lfWAgOiBgc2FmYXJpLXdlYi1leHRlbnNpb246JHtmaWxlbmFtZX1gLFxuICAgICAgXVxuICAgIDogW2Z1bmMsIGZpbGVuYW1lXTtcbn07XG5cbmV4cG9ydCB7IGNocm9tZVN0YWNrTGluZVBhcnNlciwgZGVmYXVsdFN0YWNrTGluZVBhcnNlcnMsIGRlZmF1bHRTdGFja1BhcnNlciwgZ2Vja29TdGFja0xpbmVQYXJzZXIsIG9wZXJhMTBTdGFja0xpbmVQYXJzZXIsIG9wZXJhMTFTdGFja0xpbmVQYXJzZXIsIHdpbmpzU3RhY2tMaW5lUGFyc2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFjay1wYXJzZXJzLmpzLm1hcFxuIiwiLyoqXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGJ1aWxkIHRpbWUgZmxhZyB0aGF0IHdpbGwgYmUgdHJ1ZSBieSBkZWZhdWx0LCBidXQgZmFsc2UgaW4gbm9uLWRlYnVnIGJ1aWxkcyBvciBpZiB1c2VycyByZXBsYWNlIGBfX1NFTlRSWV9ERUJVR19fYCBpbiB0aGVpciBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuXG4gKi9cbmNvbnN0IERFQlVHX0JVSUxEID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTtcblxuZXhwb3J0IHsgREVCVUdfQlVJTEQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLWJ1aWxkLmpzLm1hcFxuIiwiaW1wb3J0IHsgYWRkQ2xpY2tLZXlwcmVzc0luc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZFhockluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZEhpc3RvcnlJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBTRU5UUllfWEhSX0RBVEFfS0VZIH0gZnJvbSAnQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzJztcbmltcG9ydCB7IGRlZmluZUludGVncmF0aW9uLCBhZGRDb25zb2xlSW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgYWRkRmV0Y2hJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBnZXRDbGllbnQsIHNhZmVKb2luLCBzZXZlcml0eUxldmVsRnJvbVN0cmluZywgYWRkQnJlYWRjcnVtYiwgbG9nZ2VyLCBodG1sVHJlZUFzU3RyaW5nLCBnZXRDb21wb25lbnROYW1lLCBnZXRCcmVhZGNydW1iTG9nTGV2ZWxGcm9tSHR0cFN0YXR1c0NvZGUsIHBhcnNlVXJsLCBnZXRFdmVudERlc2NyaXB0aW9uIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcyAqL1xuXG5cbi8qKiBtYXhTdHJpbmdMZW5ndGggZ2V0cyBjYXBwZWQgdG8gcHJldmVudCAxMDAgYnJlYWRjcnVtYnMgZXhjZWVkaW5nIDFNQiBldmVudCBwYXlsb2FkIHNpemUgKi9cbmNvbnN0IE1BWF9BTExPV0VEX1NUUklOR19MRU5HVEggPSAxMDI0O1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ0JyZWFkY3J1bWJzJztcblxuY29uc3QgX2JyZWFkY3J1bWJzSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBfb3B0aW9ucyA9IHtcbiAgICBjb25zb2xlOiB0cnVlLFxuICAgIGRvbTogdHJ1ZSxcbiAgICBmZXRjaDogdHJ1ZSxcbiAgICBoaXN0b3J5OiB0cnVlLFxuICAgIHNlbnRyeTogdHJ1ZSxcbiAgICB4aHI6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgc2V0dXAoY2xpZW50KSB7XG4gICAgICAvLyBUT0RPKHYxMCk6IFJlbW92ZSB0aGlzIGZ1bmN0aW9uYWxpdHkgYW5kIHVzZSBgY29uc29sZUludGVncmF0aW9uYCBmcm9tIEBzZW50cnkvY29yZSBpbnN0ZWFkLlxuICAgICAgaWYgKF9vcHRpb25zLmNvbnNvbGUpIHtcbiAgICAgICAgYWRkQ29uc29sZUluc3RydW1lbnRhdGlvbkhhbmRsZXIoX2dldENvbnNvbGVCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfb3B0aW9ucy5kb20pIHtcbiAgICAgICAgYWRkQ2xpY2tLZXlwcmVzc0luc3RydW1lbnRhdGlvbkhhbmRsZXIoX2dldERvbUJyZWFkY3J1bWJIYW5kbGVyKGNsaWVudCwgX29wdGlvbnMuZG9tKSk7XG4gICAgICB9XG4gICAgICBpZiAoX29wdGlvbnMueGhyKSB7XG4gICAgICAgIGFkZFhockluc3RydW1lbnRhdGlvbkhhbmRsZXIoX2dldFhockJyZWFkY3J1bWJIYW5kbGVyKGNsaWVudCkpO1xuICAgICAgfVxuICAgICAgaWYgKF9vcHRpb25zLmZldGNoKSB7XG4gICAgICAgIGFkZEZldGNoSW5zdHJ1bWVudGF0aW9uSGFuZGxlcihfZ2V0RmV0Y2hCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfb3B0aW9ucy5oaXN0b3J5KSB7XG4gICAgICAgIGFkZEhpc3RvcnlJbnN0cnVtZW50YXRpb25IYW5kbGVyKF9nZXRIaXN0b3J5QnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSk7XG4gICAgICB9XG4gICAgICBpZiAoX29wdGlvbnMuc2VudHJ5KSB7XG4gICAgICAgIGNsaWVudC5vbignYmVmb3JlU2VuZEV2ZW50JywgX2dldFNlbnRyeUJyZWFkY3J1bWJIYW5kbGVyKGNsaWVudCkpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59KSA7XG5cbmNvbnN0IGJyZWFkY3J1bWJzSW50ZWdyYXRpb24gPSBkZWZpbmVJbnRlZ3JhdGlvbihfYnJlYWRjcnVtYnNJbnRlZ3JhdGlvbik7XG5cbi8qKlxuICogQWRkcyBhIGJyZWFkY3J1bWIgZm9yIFNlbnRyeSBldmVudHMgb3IgdHJhbnNhY3Rpb25zIGlmIHRoaXMgb3B0aW9uIGlzIGVuYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIF9nZXRTZW50cnlCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFkZFNlbnRyeUJyZWFkY3J1bWIoZXZlbnQpIHtcbiAgICBpZiAoZ2V0Q2xpZW50KCkgIT09IGNsaWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFkZEJyZWFkY3J1bWIoXG4gICAgICB7XG4gICAgICAgIGNhdGVnb3J5OiBgc2VudHJ5LiR7ZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJyA/ICd0cmFuc2FjdGlvbicgOiAnZXZlbnQnfWAsXG4gICAgICAgIGV2ZW50X2lkOiBldmVudC5ldmVudF9pZCxcbiAgICAgICAgbGV2ZWw6IGV2ZW50LmxldmVsLFxuICAgICAgICBtZXNzYWdlOiBnZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgfSxcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEEgSE9DIHRoYXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBicmVhZGNydW1icyBmcm9tIERPTSBBUEkgY2FsbHMuXG4gKiBUaGlzIGlzIGEgSE9DIHNvIHRoYXQgd2UgZ2V0IGFjY2VzcyB0byBkb20gb3B0aW9ucyBpbiB0aGUgY2xvc3VyZS5cbiAqL1xuZnVuY3Rpb24gX2dldERvbUJyZWFkY3J1bWJIYW5kbGVyKFxuICBjbGllbnQsXG4gIGRvbSxcbikge1xuICByZXR1cm4gZnVuY3Rpb24gX2lubmVyRG9tQnJlYWRjcnVtYihoYW5kbGVyRGF0YSkge1xuICAgIGlmIChnZXRDbGllbnQoKSAhPT0gY2xpZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldDtcbiAgICBsZXQgY29tcG9uZW50TmFtZTtcbiAgICBsZXQga2V5QXR0cnMgPSB0eXBlb2YgZG9tID09PSAnb2JqZWN0JyA/IGRvbS5zZXJpYWxpemVBdHRyaWJ1dGUgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgbWF4U3RyaW5nTGVuZ3RoID1cbiAgICAgIHR5cGVvZiBkb20gPT09ICdvYmplY3QnICYmIHR5cGVvZiBkb20ubWF4U3RyaW5nTGVuZ3RoID09PSAnbnVtYmVyJyA/IGRvbS5tYXhTdHJpbmdMZW5ndGggOiB1bmRlZmluZWQ7XG4gICAgaWYgKG1heFN0cmluZ0xlbmd0aCAmJiBtYXhTdHJpbmdMZW5ndGggPiBNQVhfQUxMT1dFRF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgXFxgZG9tLm1heFN0cmluZ0xlbmd0aFxcYCBjYW5ub3QgZXhjZWVkICR7TUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSH0sIGJ1dCBhIHZhbHVlIG9mICR7bWF4U3RyaW5nTGVuZ3RofSB3YXMgY29uZmlndXJlZC4gU2VudHJ5IHdpbGwgdXNlICR7TUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSH0gaW5zdGVhZC5gLFxuICAgICAgICApO1xuICAgICAgbWF4U3RyaW5nTGVuZ3RoID0gTUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGtleUF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAga2V5QXR0cnMgPSBba2V5QXR0cnNdO1xuICAgIH1cblxuICAgIC8vIEFjY2Vzc2luZyBldmVudC50YXJnZXQgY2FuIHRocm93IChzZWUgZ2V0c2VudHJ5L3JhdmVuLWpzIzgzOCwgIzc2OClcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBoYW5kbGVyRGF0YS5ldmVudCA7XG4gICAgICBjb25zdCBlbGVtZW50ID0gX2lzRXZlbnQoZXZlbnQpID8gZXZlbnQudGFyZ2V0IDogZXZlbnQ7XG5cbiAgICAgIHRhcmdldCA9IGh0bWxUcmVlQXNTdHJpbmcoZWxlbWVudCwgeyBrZXlBdHRycywgbWF4U3RyaW5nTGVuZ3RoIH0pO1xuICAgICAgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGFyZ2V0ID0gJzx1bmtub3duPic7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBicmVhZGNydW1iID0ge1xuICAgICAgY2F0ZWdvcnk6IGB1aS4ke2hhbmRsZXJEYXRhLm5hbWV9YCxcbiAgICAgIG1lc3NhZ2U6IHRhcmdldCxcbiAgICB9O1xuXG4gICAgaWYgKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGJyZWFkY3J1bWIuZGF0YSA9IHsgJ3VpLmNvbXBvbmVudF9uYW1lJzogY29tcG9uZW50TmFtZSB9O1xuICAgIH1cblxuICAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwge1xuICAgICAgZXZlbnQ6IGhhbmRsZXJEYXRhLmV2ZW50LFxuICAgICAgbmFtZTogaGFuZGxlckRhdGEubmFtZSxcbiAgICAgIGdsb2JhbDogaGFuZGxlckRhdGEuZ2xvYmFsLFxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYnJlYWRjcnVtYnMgZnJvbSBjb25zb2xlIEFQSSBjYWxsc1xuICovXG5mdW5jdGlvbiBfZ2V0Q29uc29sZUJyZWFkY3J1bWJIYW5kbGVyKGNsaWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gX2NvbnNvbGVCcmVhZGNydW1iKGhhbmRsZXJEYXRhKSB7XG4gICAgaWYgKGdldENsaWVudCgpICE9PSBjbGllbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBicmVhZGNydW1iID0ge1xuICAgICAgY2F0ZWdvcnk6ICdjb25zb2xlJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYXJndW1lbnRzOiBoYW5kbGVyRGF0YS5hcmdzLFxuICAgICAgICBsb2dnZXI6ICdjb25zb2xlJyxcbiAgICAgIH0sXG4gICAgICBsZXZlbDogc2V2ZXJpdHlMZXZlbEZyb21TdHJpbmcoaGFuZGxlckRhdGEubGV2ZWwpLFxuICAgICAgbWVzc2FnZTogc2FmZUpvaW4oaGFuZGxlckRhdGEuYXJncywgJyAnKSxcbiAgICB9O1xuXG4gICAgaWYgKGhhbmRsZXJEYXRhLmxldmVsID09PSAnYXNzZXJ0Jykge1xuICAgICAgaWYgKGhhbmRsZXJEYXRhLmFyZ3NbMF0gPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFkY3J1bWIubWVzc2FnZSA9IGBBc3NlcnRpb24gZmFpbGVkOiAke3NhZmVKb2luKGhhbmRsZXJEYXRhLmFyZ3Muc2xpY2UoMSksICcgJykgfHwgJ2NvbnNvbGUuYXNzZXJ0J31gO1xuICAgICAgICBicmVhZGNydW1iLmRhdGEuYXJndW1lbnRzID0gaGFuZGxlckRhdGEuYXJncy5zbGljZSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IGNhcHR1cmUgYSBicmVhZGNydW1iIGZvciBwYXNzZWQgYXNzZXJ0aW9uc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCB7XG4gICAgICBpbnB1dDogaGFuZGxlckRhdGEuYXJncyxcbiAgICAgIGxldmVsOiBoYW5kbGVyRGF0YS5sZXZlbCxcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGJyZWFkY3J1bWJzIGZyb20gWEhSIEFQSSBjYWxsc1xuICovXG5mdW5jdGlvbiBfZ2V0WGhyQnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBfeGhyQnJlYWRjcnVtYihoYW5kbGVyRGF0YSkge1xuICAgIGlmIChnZXRDbGllbnQoKSAhPT0gY2xpZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzdGFydFRpbWVzdGFtcCwgZW5kVGltZXN0YW1wIH0gPSBoYW5kbGVyRGF0YTtcblxuICAgIGNvbnN0IHNlbnRyeVhockRhdGEgPSBoYW5kbGVyRGF0YS54aHJbU0VOVFJZX1hIUl9EQVRBX0tFWV07XG5cbiAgICAvLyBXZSBvbmx5IGNhcHR1cmUgY29tcGxldGUsIG5vbi1zZW50cnkgcmVxdWVzdHNcbiAgICBpZiAoIXN0YXJ0VGltZXN0YW1wIHx8ICFlbmRUaW1lc3RhbXAgfHwgIXNlbnRyeVhockRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IG1ldGhvZCwgdXJsLCBzdGF0dXNfY29kZSwgYm9keSB9ID0gc2VudHJ5WGhyRGF0YTtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBzdGF0dXNfY29kZSxcbiAgICB9O1xuXG4gICAgY29uc3QgaGludCA9IHtcbiAgICAgIHhocjogaGFuZGxlckRhdGEueGhyLFxuICAgICAgaW5wdXQ6IGJvZHksXG4gICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgIGVuZFRpbWVzdGFtcCxcbiAgICB9O1xuXG4gICAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICAgIGNhdGVnb3J5OiAneGhyJyxcbiAgICAgIGRhdGEsXG4gICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICBsZXZlbDogZ2V0QnJlYWRjcnVtYkxvZ0xldmVsRnJvbUh0dHBTdGF0dXNDb2RlKHN0YXR1c19jb2RlKSxcbiAgICB9O1xuXG4gICAgY2xpZW50LmVtaXQoJ2JlZm9yZU91dGdvaW5nUmVxdWVzdEJyZWFkY3J1bWInLCBicmVhZGNydW1iLCBoaW50ICk7XG5cbiAgICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIGhpbnQpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYnJlYWRjcnVtYnMgZnJvbSBmZXRjaCBBUEkgY2FsbHNcbiAqL1xuZnVuY3Rpb24gX2dldEZldGNoQnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBfZmV0Y2hCcmVhZGNydW1iKGhhbmRsZXJEYXRhKSB7XG4gICAgaWYgKGdldENsaWVudCgpICE9PSBjbGllbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHN0YXJ0VGltZXN0YW1wLCBlbmRUaW1lc3RhbXAgfSA9IGhhbmRsZXJEYXRhO1xuXG4gICAgLy8gV2Ugb25seSBjYXB0dXJlIGNvbXBsZXRlIGZldGNoIHJlcXVlc3RzXG4gICAgaWYgKCFlbmRUaW1lc3RhbXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlckRhdGEuZmV0Y2hEYXRhLnVybC5tYXRjaCgvc2VudHJ5X2tleS8pICYmIGhhbmRsZXJEYXRhLmZldGNoRGF0YS5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgLy8gV2Ugd2lsbCBub3QgY3JlYXRlIGJyZWFkY3J1bWJzIGZvciBmZXRjaCByZXF1ZXN0cyB0aGF0IGNvbnRhaW4gYHNlbnRyeV9rZXlgIChpbnRlcm5hbCBzZW50cnkgcmVxdWVzdHMpXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgKHtcbiAgICAgIG1ldGhvZDogaGFuZGxlckRhdGEuZmV0Y2hEYXRhLm1ldGhvZCxcbiAgICAgIHVybDogaGFuZGxlckRhdGEuZmV0Y2hEYXRhLnVybCxcbiAgICB9KTtcblxuICAgIGlmIChoYW5kbGVyRGF0YS5lcnJvcikge1xuICAgICAgY29uc3QgZGF0YSA9IGhhbmRsZXJEYXRhLmZldGNoRGF0YTtcbiAgICAgIGNvbnN0IGhpbnQgPSB7XG4gICAgICAgIGRhdGE6IGhhbmRsZXJEYXRhLmVycm9yLFxuICAgICAgICBpbnB1dDogaGFuZGxlckRhdGEuYXJncyxcbiAgICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICAgIGVuZFRpbWVzdGFtcCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGJyZWFkY3J1bWIgPSB7XG4gICAgICAgIGNhdGVnb3J5OiAnZmV0Y2gnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgfSA7XG5cbiAgICAgIGNsaWVudC5lbWl0KCdiZWZvcmVPdXRnb2luZ1JlcXVlc3RCcmVhZGNydW1iJywgYnJlYWRjcnVtYiwgaGludCApO1xuXG4gICAgICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIGhpbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGhhbmRsZXJEYXRhLnJlc3BvbnNlIDtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC4uLmhhbmRsZXJEYXRhLmZldGNoRGF0YSxcbiAgICAgICAgc3RhdHVzX2NvZGU6IHJlc3BvbnNlPy5zdGF0dXMsXG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVyRGF0YS5mZXRjaERhdGEucmVxdWVzdF9ib2R5X3NpemU7XG4gICAgICBoYW5kbGVyRGF0YS5mZXRjaERhdGEucmVzcG9uc2VfYm9keV9zaXplO1xuICAgICAgcmVzcG9uc2U/LnN0YXR1cztcblxuICAgICAgY29uc3QgaGludCA9IHtcbiAgICAgICAgaW5wdXQ6IGhhbmRsZXJEYXRhLmFyZ3MsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgICAgZW5kVGltZXN0YW1wLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICAgICAgY2F0ZWdvcnk6ICdmZXRjaCcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgbGV2ZWw6IGdldEJyZWFkY3J1bWJMb2dMZXZlbEZyb21IdHRwU3RhdHVzQ29kZShkYXRhLnN0YXR1c19jb2RlKSxcbiAgICAgIH07XG5cbiAgICAgIGNsaWVudC5lbWl0KCdiZWZvcmVPdXRnb2luZ1JlcXVlc3RCcmVhZGNydW1iJywgYnJlYWRjcnVtYiwgaGludCApO1xuXG4gICAgICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIGhpbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGJyZWFkY3J1bWJzIGZyb20gaGlzdG9yeSBBUEkgY2FsbHNcbiAqL1xuZnVuY3Rpb24gX2dldEhpc3RvcnlCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9oaXN0b3J5QnJlYWRjcnVtYihoYW5kbGVyRGF0YSkge1xuICAgIGlmIChnZXRDbGllbnQoKSAhPT0gY2xpZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGZyb20gPSBoYW5kbGVyRGF0YS5mcm9tO1xuICAgIGxldCB0byA9IGhhbmRsZXJEYXRhLnRvO1xuICAgIGNvbnN0IHBhcnNlZExvYyA9IHBhcnNlVXJsKFdJTkRPVy5sb2NhdGlvbi5ocmVmKTtcbiAgICBsZXQgcGFyc2VkRnJvbSA9IGZyb20gPyBwYXJzZVVybChmcm9tKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwYXJzZWRUbyA9IHBhcnNlVXJsKHRvKTtcblxuICAgIC8vIEluaXRpYWwgcHVzaFN0YXRlIGRvZXNuJ3QgcHJvdmlkZSBgZnJvbWAgaW5mb3JtYXRpb25cbiAgICBpZiAoIXBhcnNlZEZyb20/LnBhdGgpIHtcbiAgICAgIHBhcnNlZEZyb20gPSBwYXJzZWRMb2M7XG4gICAgfVxuXG4gICAgLy8gVXNlIG9ubHkgdGhlIHBhdGggY29tcG9uZW50IG9mIHRoZSBVUkwgaWYgdGhlIFVSTCBtYXRjaGVzIHRoZSBjdXJyZW50XG4gICAgLy8gZG9jdW1lbnQgKGFsbW9zdCBhbGwgdGhlIHRpbWUgd2hlbiB1c2luZyBwdXNoU3RhdGUpXG4gICAgaWYgKHBhcnNlZExvYy5wcm90b2NvbCA9PT0gcGFyc2VkVG8ucHJvdG9jb2wgJiYgcGFyc2VkTG9jLmhvc3QgPT09IHBhcnNlZFRvLmhvc3QpIHtcbiAgICAgIHRvID0gcGFyc2VkVG8ucmVsYXRpdmU7XG4gICAgfVxuICAgIGlmIChwYXJzZWRMb2MucHJvdG9jb2wgPT09IHBhcnNlZEZyb20ucHJvdG9jb2wgJiYgcGFyc2VkTG9jLmhvc3QgPT09IHBhcnNlZEZyb20uaG9zdCkge1xuICAgICAgZnJvbSA9IHBhcnNlZEZyb20ucmVsYXRpdmU7XG4gICAgfVxuXG4gICAgYWRkQnJlYWRjcnVtYih7XG4gICAgICBjYXRlZ29yeTogJ25hdmlnYXRpb24nLFxuICAgICAgZGF0YToge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9pc0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50ICYmICEhKGV2ZW50ICkudGFyZ2V0O1xufVxuXG5leHBvcnQgeyBicmVhZGNydW1ic0ludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVhZGNydW1icy5qcy5tYXBcbiIsImltcG9ydCB7IGRlZmluZUludGVncmF0aW9uLCBmaWxsLCBnZXRGdW5jdGlvbk5hbWUsIGdldE9yaWdpbmFsRnVuY3Rpb24gfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgV0lORE9XLCB3cmFwIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5cbmNvbnN0IERFRkFVTFRfRVZFTlRfVEFSR0VUID0gW1xuICAnRXZlbnRUYXJnZXQnLFxuICAnV2luZG93JyxcbiAgJ05vZGUnLFxuICAnQXBwbGljYXRpb25DYWNoZScsXG4gICdBdWRpb1RyYWNrTGlzdCcsXG4gICdCcm9hZGNhc3RDaGFubmVsJyxcbiAgJ0NoYW5uZWxNZXJnZXJOb2RlJyxcbiAgJ0NyeXB0b09wZXJhdGlvbicsXG4gICdFdmVudFNvdXJjZScsXG4gICdGaWxlUmVhZGVyJyxcbiAgJ0hUTUxVbmtub3duRWxlbWVudCcsXG4gICdJREJEYXRhYmFzZScsXG4gICdJREJSZXF1ZXN0JyxcbiAgJ0lEQlRyYW5zYWN0aW9uJyxcbiAgJ0tleU9wZXJhdGlvbicsXG4gICdNZWRpYUNvbnRyb2xsZXInLFxuICAnTWVzc2FnZVBvcnQnLFxuICAnTW9kYWxXaW5kb3cnLFxuICAnTm90aWZpY2F0aW9uJyxcbiAgJ1NWR0VsZW1lbnRJbnN0YW5jZScsXG4gICdTY3JlZW4nLFxuICAnU2hhcmVkV29ya2VyJyxcbiAgJ1RleHRUcmFjaycsXG4gICdUZXh0VHJhY2tDdWUnLFxuICAnVGV4dFRyYWNrTGlzdCcsXG4gICdXZWJTb2NrZXQnLFxuICAnV2ViU29ja2V0V29ya2VyJyxcbiAgJ1dvcmtlcicsXG4gICdYTUxIdHRwUmVxdWVzdCcsXG4gICdYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0JyxcbiAgJ1hNTEh0dHBSZXF1ZXN0VXBsb2FkJyxcbl07XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnQnJvd3NlckFwaUVycm9ycyc7XG5cbmNvbnN0IF9icm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBfb3B0aW9ucyA9IHtcbiAgICBYTUxIdHRwUmVxdWVzdDogdHJ1ZSxcbiAgICBldmVudFRhcmdldDogdHJ1ZSxcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHRydWUsXG4gICAgc2V0SW50ZXJ2YWw6IHRydWUsXG4gICAgc2V0VGltZW91dDogdHJ1ZSxcbiAgICAuLi5vcHRpb25zLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogSU5URUdSQVRJT05fTkFNRSxcbiAgICAvLyBUT0RPOiBUaGlzIGN1cnJlbnRseSBvbmx5IHdvcmtzIGZvciB0aGUgZmlyc3QgY2xpZW50IHRoaXMgaXMgc2V0dXBcbiAgICAvLyBXZSBtYXkgd2FudCB0byBhZGp1c3QgdGhpcyB0byBjaGVjayBmb3IgY2xpZW50IGV0Yy5cbiAgICBzZXR1cE9uY2UoKSB7XG4gICAgICBpZiAoX29wdGlvbnMuc2V0VGltZW91dCkge1xuICAgICAgICBmaWxsKFdJTkRPVywgJ3NldFRpbWVvdXQnLCBfd3JhcFRpbWVGdW5jdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfb3B0aW9ucy5zZXRJbnRlcnZhbCkge1xuICAgICAgICBmaWxsKFdJTkRPVywgJ3NldEludGVydmFsJywgX3dyYXBUaW1lRnVuY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX29wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIGZpbGwoV0lORE9XLCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgX3dyYXBSQUYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX29wdGlvbnMuWE1MSHR0cFJlcXVlc3QgJiYgJ1hNTEh0dHBSZXF1ZXN0JyBpbiBXSU5ET1cpIHtcbiAgICAgICAgZmlsbChYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUsICdzZW5kJywgX3dyYXBYSFIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBldmVudFRhcmdldE9wdGlvbiA9IF9vcHRpb25zLmV2ZW50VGFyZ2V0O1xuICAgICAgaWYgKGV2ZW50VGFyZ2V0T3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gQXJyYXkuaXNBcnJheShldmVudFRhcmdldE9wdGlvbikgPyBldmVudFRhcmdldE9wdGlvbiA6IERFRkFVTFRfRVZFTlRfVEFSR0VUO1xuICAgICAgICBldmVudFRhcmdldC5mb3JFYWNoKF93cmFwRXZlbnRUYXJnZXQpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogV3JhcCB0aW1lciBmdW5jdGlvbnMgYW5kIGV2ZW50IHRhcmdldHMgdG8gY2F0Y2ggZXJyb3JzIGFuZCBwcm92aWRlIGJldHRlciBtZXRhIGRhdGEuXG4gKi9cbmNvbnN0IGJyb3dzZXJBcGlFcnJvcnNJbnRlZ3JhdGlvbiA9IGRlZmluZUludGVncmF0aW9uKF9icm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24pO1xuXG5mdW5jdGlvbiBfd3JhcFRpbWVGdW5jdGlvbihvcmlnaW5hbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCAuLi5hcmdzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxDYWxsYmFjayA9IGFyZ3NbMF07XG4gICAgYXJnc1swXSA9IHdyYXAob3JpZ2luYWxDYWxsYmFjaywge1xuICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgIGRhdGE6IHsgZnVuY3Rpb246IGdldEZ1bmN0aW9uTmFtZShvcmlnaW5hbCkgfSxcbiAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgIHR5cGU6ICdpbnN0cnVtZW50JyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfd3JhcFJBRihvcmlnaW5hbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCBjYWxsYmFjaykge1xuICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICB3cmFwKGNhbGxiYWNrLCB7XG4gICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uOiAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyxcbiAgICAgICAgICAgIGhhbmRsZXI6IGdldEZ1bmN0aW9uTmFtZShvcmlnaW5hbCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3dyYXBYSFIob3JpZ2luYWxTZW5kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoIC4uLmFyZ3MpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBjb25zdCB4aHIgPSB0aGlzO1xuICAgIGNvbnN0IHhtbEh0dHBSZXF1ZXN0UHJvcHMgPSBbJ29ubG9hZCcsICdvbmVycm9yJywgJ29ucHJvZ3Jlc3MnLCAnb25yZWFkeXN0YXRlY2hhbmdlJ107XG5cbiAgICB4bWxIdHRwUmVxdWVzdFByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAocHJvcCBpbiB4aHIgJiYgdHlwZW9mIHhocltwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWxsKHhociwgcHJvcCwgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBwcm9wLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGdldEZ1bmN0aW9uTmFtZShvcmlnaW5hbCksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBJZiBJbnN0cnVtZW50IGludGVncmF0aW9uIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgQnJvd3NlckFwaUVycm9ycywgZ2V0IHRoZSBuYW1lIG9mIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxGdW5jdGlvbiA9IGdldE9yaWdpbmFsRnVuY3Rpb24ob3JpZ2luYWwpO1xuICAgICAgICAgIGlmIChvcmlnaW5hbEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICB3cmFwT3B0aW9ucy5tZWNoYW5pc20uZGF0YS5oYW5kbGVyID0gZ2V0RnVuY3Rpb25OYW1lKG9yaWdpbmFsRnVuY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSB3cmFwIGRpcmVjdGx5XG4gICAgICAgICAgcmV0dXJuIHdyYXAob3JpZ2luYWwsIHdyYXBPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3JpZ2luYWxTZW5kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfd3JhcEV2ZW50VGFyZ2V0KHRhcmdldCkge1xuICBjb25zdCBnbG9iYWxPYmplY3QgPSBXSU5ET1cgO1xuICBjb25zdCBwcm90byA9IGdsb2JhbE9iamVjdFt0YXJnZXRdPy5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAoIXByb3RvPy5oYXNPd25Qcm9wZXJ0eT8uKCdhZGRFdmVudExpc3RlbmVyJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmaWxsKHByb3RvLCAnYWRkRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnaW5hbClcblxuIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBldmVudE5hbWUsIGZuLCBvcHRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNFdmVudExpc3RlbmVyT2JqZWN0KGZuKSkge1xuICAgICAgICAgIC8vIEVTbGludCBkaXNhYmxlIGV4cGxhbmF0aW9uOlxuICAgICAgICAgIC8vICBGaXJzdCwgaXQgaXMgZ2VuZXJhbGx5IHNhZmUgdG8gY2FsbCBgd3JhcGAgd2l0aCBhbiB1bmJvdW5kIGZ1bmN0aW9uLiBGdXJ0aGVybW9yZSwgdXNpbmcgYC5iaW5kKClgIHdvdWxkXG4gICAgICAgICAgLy8gIGludHJvZHVjZSBhIGJ1ZyBoZXJlLCBiZWNhdXNlIGJpbmQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IGRvZXNuJ3QgaGF2ZSBvdXJcbiAgICAgICAgICAvLyAgZmxhZ3MobGlrZSBfX3NlbnRyeV9vcmlnaW5hbF9fKSBhdHRhY2hlZC4gYHdyYXBgIGNoZWNrcyBmb3IgdGhvc2UgZmxhZ3MgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcuXG4gICAgICAgICAgLy8gIFdpdGhvdXQgdGhvc2UgZmxhZ3MsIGV2ZXJ5IGNhbGwgdG8gYWRkRXZlbnRMaXN0ZW5lciB3cmFwcyB0aGUgZnVuY3Rpb24gYWdhaW4sIGNhdXNpbmcgYSBtZW1vcnkgbGVhay5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgZm4uaGFuZGxlRXZlbnQgPSB3cmFwKGZuLmhhbmRsZUV2ZW50LCB7XG4gICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiAnaGFuZGxlRXZlbnQnLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGdldEZ1bmN0aW9uTmFtZShmbiksXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2luc3RydW1lbnQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGNhbiBzb21ldGltZXMgZ2V0ICdQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJoYW5kbGUgRXZlbnQnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgd3JhcChmbiwge1xuICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBmdW5jdGlvbjogJ2FkZEV2ZW50TGlzdGVuZXInLFxuICAgICAgICAgICAgICBoYW5kbGVyOiBnZXRGdW5jdGlvbk5hbWUoZm4pLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICBdKTtcbiAgICB9O1xuICB9KTtcblxuICBmaWxsKHByb3RvLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIpXG5cbiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZXZlbnROYW1lLCBmbiwgb3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVyZSBhcmUgMiBwb3NzaWJsZSBzY2VuYXJpb3MgaGVyZTpcbiAgICAgICAqXG4gICAgICAgKiAxLiBTb21lb25lIHBhc3NlcyBhIGNhbGxiYWNrLCB3aGljaCB3YXMgYXR0YWNoZWQgcHJpb3IgdG8gU2VudHJ5IGluaXRpYWxpemF0aW9uLCBvciBieSB1c2luZyB1bm1vZGlmaWVkXG4gICAgICAgKiBtZXRob2QsIGVnLiBgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci5jYWxsKGVsLCBuYW1lLCBoYW5kbGVyKS4gSW4gdGhpcyBjYXNlLCB3ZSB0cmVhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAgKiBhcyBhIHBhc3MtdGhyb3VnaCwgYW5kIGNhbGwgb3JpZ2luYWwgYHJlbW92ZUV2ZW50TGlzdGVuZXJgIHdpdGggaXQuXG4gICAgICAgKlxuICAgICAgICogMi4gU29tZW9uZSBwYXNzZXMgYSBjYWxsYmFjaywgd2hpY2ggd2FzIGF0dGFjaGVkIGFmdGVyIFNlbnRyeSB3YXMgaW5pdGlhbGl6ZWQsIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2FzIHVzaW5nXG4gICAgICAgKiBvdXIgd3JhcHBlZCB2ZXJzaW9uIG9mIGBhZGRFdmVudExpc3RlbmVyYCwgd2hpY2ggaW50ZXJuYWxseSBjYWxscyBgd3JhcGAgaGVscGVyLlxuICAgICAgICogVGhpcyBoZWxwZXIgXCJ3cmFwc1wiIHdob2xlIGNhbGxiYWNrIGluc2lkZSBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQsIGFuZCBhdHRhY2hlZCBhcHByb3ByaWF0ZSBtZXRhZGF0YSB0byBpdCxcbiAgICAgICAqIGluIG9yZGVyIGZvciB1cyB0byBtYWtlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB3cmFwcGVkL25vbi13cmFwcGVkIGZ1bmN0aW9ucyBwb3NzaWJsZS5cbiAgICAgICAqIElmIGEgZnVuY3Rpb24gd2FzIHdyYXBwZWQsIGl0IGhhcyBhZGRpdGlvbmFsIHByb3BlcnR5IG9mIGBfX3NlbnRyeV93cmFwcGVkX19gLCBob2xkaW5nIHRoZSBoYW5kbGVyLlxuICAgICAgICpcbiAgICAgICAqIFdoZW4gc29tZW9uZSBhZGRzIGEgaGFuZGxlciBwcmlvciB0byBpbml0aWFsaXphdGlvbiwgYW5kIHRoZW4gZG8gaXQgYWdhaW4sIGJ1dCBhZnRlcixcbiAgICAgICAqIHRoZW4gd2UgaGF2ZSB0byBkZXRhY2ggYm90aCBvZiB0aGVtLiBPdGhlcndpc2UsIGlmIHdlJ2QgZGV0YWNoIG9ubHkgd3JhcHBlZCBvbmUsIGl0J2QgYmUgaW1wb3NzaWJsZVxuICAgICAgICogdG8gZ2V0IHJpZCBvZiB0aGUgaW5pdGlhbCBoYW5kbGVyIGFuZCBpdCdkIHN0aWNrIHRoZXJlIGZvcmV2ZXIuXG4gICAgICAgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXZlbnRIYW5kbGVyID0gKGZuICkuX19zZW50cnlfd3JhcHBlZF9fO1xuICAgICAgICBpZiAob3JpZ2luYWxFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICBvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIG9yaWdpbmFsRXZlbnRIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmUsIGFjY2Vzc2luZyBfX3NlbnRyeV93cmFwcGVkX18gd2lsbCB0aHJvdyBpbiBzb21lIFNlbGVuaXVtIGVudmlyb25tZW50c1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgZm4sIG9wdGlvbnMpO1xuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0V2ZW50TGlzdGVuZXJPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgKG9iaiApLmhhbmRsZUV2ZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgeyBicm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJhcGllcnJvcnMuanMubWFwXG4iLCJpbXBvcnQgeyBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlciB9IGZyb20gJ0BzZW50cnktaW50ZXJuYWwvYnJvd3Nlci11dGlscyc7XG5pbXBvcnQgeyBkZWZpbmVJbnRlZ3JhdGlvbiwgbG9nZ2VyLCBzdGFydFNlc3Npb24sIGNhcHR1cmVTZXNzaW9uIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5cbi8qKlxuICogV2hlbiBhZGRlZCwgYXV0b21hdGljYWxseSBjcmVhdGVzIHNlc3Npb25zIHdoaWNoIGFsbG93IHlvdSB0byB0cmFjayBhZG9wdGlvbiBhbmQgY3Jhc2hlcyAoY3Jhc2ggZnJlZSByYXRlKSBpbiB5b3VyIFJlbGVhc2VzIGluIFNlbnRyeS5cbiAqIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZG9jcy5zZW50cnkuaW8vcHJvZHVjdC9yZWxlYXNlcy9oZWFsdGgvXG4gKlxuICogTm90ZTogSW4gb3JkZXIgZm9yIHNlc3Npb24gdHJhY2tpbmcgdG8gd29yaywgeW91IG5lZWQgdG8gc2V0IHVwIFJlbGVhc2VzOiBodHRwczovL2RvY3Muc2VudHJ5LmlvL3Byb2R1Y3QvcmVsZWFzZXMvXG4gKi9cbmNvbnN0IGJyb3dzZXJTZXNzaW9uSW50ZWdyYXRpb24gPSBkZWZpbmVJbnRlZ3JhdGlvbigoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0Jyb3dzZXJTZXNzaW9uJyxcbiAgICBzZXR1cE9uY2UoKSB7XG4gICAgICBpZiAodHlwZW9mIFdJTkRPVy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgICBsb2dnZXIud2FybignVXNpbmcgdGhlIGBicm93c2VyU2Vzc2lvbkludGVncmF0aW9uYCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgc2Vzc2lvbiBkdXJhdGlvbiBmb3IgYnJvd3NlciBzZXNzaW9ucyBkb2VzIG5vdCB0cmFjayBhIG1lYW5pbmdmdWxcbiAgICAgIC8vIGNvbmNlcHQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIG1ldHJpYy5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgY2FwdHVyZWQgc2Vzc2lvbnMgYXJlIGFraW4gdG8gcGFnZSB2aWV3cywgYW5kIHRodXMgd2VcbiAgICAgIC8vIGRpc2NhcmQgdGhlaXIgZHVyYXRpb24uXG4gICAgICBzdGFydFNlc3Npb24oeyBpZ25vcmVEdXJhdGlvbjogdHJ1ZSB9KTtcbiAgICAgIGNhcHR1cmVTZXNzaW9uKCk7XG5cbiAgICAgIC8vIFdlIHdhbnQgdG8gY3JlYXRlIGEgc2Vzc2lvbiBmb3IgZXZlcnkgbmF2aWdhdGlvbiBhcyB3ZWxsXG4gICAgICBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlcigoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBhbiBhZGRpdGlvbmFsIHNlc3Npb24gZm9yIHRoZSBpbml0aWFsIHJvdXRlIG9yIGlmIHRoZSBsb2NhdGlvbiBkaWQgbm90IGNoYW5nZVxuICAgICAgICBpZiAoZnJvbSAhPT0gdW5kZWZpbmVkICYmIGZyb20gIT09IHRvKSB7XG4gICAgICAgICAgc3RhcnRTZXNzaW9uKHsgaWdub3JlRHVyYXRpb246IHRydWUgfSk7XG4gICAgICAgICAgY2FwdHVyZVNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG5leHBvcnQgeyBicm93c2VyU2Vzc2lvbkludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2Vyc2Vzc2lvbi5qcy5tYXBcbiIsImltcG9ydCB7IGRlZmluZUludGVncmF0aW9uLCBhZGRHbG9iYWxFcnJvckluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGdldENsaWVudCwgY2FwdHVyZUV2ZW50LCBsb2dnZXIsIGFkZEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGlzUHJpbWl0aXZlLCBpc1N0cmluZywgZ2V0TG9jYXRpb25IcmVmLCBVTktOT1dOX0ZVTkNUSU9OIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgZXZlbnRGcm9tVW5rbm93bklucHV0IH0gZnJvbSAnLi4vZXZlbnRidWlsZGVyLmpzJztcbmltcG9ydCB7IHNob3VsZElnbm9yZU9uRXJyb3IgfSBmcm9tICcuLi9oZWxwZXJzLmpzJztcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdHbG9iYWxIYW5kbGVycyc7XG5cbmNvbnN0IF9nbG9iYWxIYW5kbGVyc0ludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgX29wdGlvbnMgPSB7XG4gICAgb25lcnJvcjogdHJ1ZSxcbiAgICBvbnVuaGFuZGxlZHJlamVjdGlvbjogdHJ1ZSxcbiAgICAuLi5vcHRpb25zLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogSU5URUdSQVRJT05fTkFNRSxcbiAgICBzZXR1cE9uY2UoKSB7XG4gICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSA1MDtcbiAgICB9LFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgaWYgKF9vcHRpb25zLm9uZXJyb3IpIHtcbiAgICAgICAgX2luc3RhbGxHbG9iYWxPbkVycm9ySGFuZGxlcihjbGllbnQpO1xuICAgICAgICBnbG9iYWxIYW5kbGVyTG9nKCdvbmVycm9yJyk7XG4gICAgICB9XG4gICAgICBpZiAoX29wdGlvbnMub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgX2luc3RhbGxHbG9iYWxPblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXIoY2xpZW50KTtcbiAgICAgICAgZ2xvYmFsSGFuZGxlckxvZygnb251bmhhbmRsZWRyZWplY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xufSkgO1xuXG5jb25zdCBnbG9iYWxIYW5kbGVyc0ludGVncmF0aW9uID0gZGVmaW5lSW50ZWdyYXRpb24oX2dsb2JhbEhhbmRsZXJzSW50ZWdyYXRpb24pO1xuXG5mdW5jdGlvbiBfaW5zdGFsbEdsb2JhbE9uRXJyb3JIYW5kbGVyKGNsaWVudCkge1xuICBhZGRHbG9iYWxFcnJvckluc3RydW1lbnRhdGlvbkhhbmRsZXIoZGF0YSA9PiB7XG4gICAgY29uc3QgeyBzdGFja1BhcnNlciwgYXR0YWNoU3RhY2t0cmFjZSB9ID0gZ2V0T3B0aW9ucygpO1xuXG4gICAgaWYgKGdldENsaWVudCgpICE9PSBjbGllbnQgfHwgc2hvdWxkSWdub3JlT25FcnJvcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBtc2csIHVybCwgbGluZSwgY29sdW1uLCBlcnJvciB9ID0gZGF0YTtcblxuICAgIGNvbnN0IGV2ZW50ID0gX2VuaGFuY2VFdmVudFdpdGhJbml0aWFsRnJhbWUoXG4gICAgICBldmVudEZyb21Vbmtub3duSW5wdXQoc3RhY2tQYXJzZXIsIGVycm9yIHx8IG1zZywgdW5kZWZpbmVkLCBhdHRhY2hTdGFja3RyYWNlLCBmYWxzZSksXG4gICAgICB1cmwsXG4gICAgICBsaW5lLFxuICAgICAgY29sdW1uLFxuICAgICk7XG5cbiAgICBldmVudC5sZXZlbCA9ICdlcnJvcic7XG5cbiAgICBjYXB0dXJlRXZlbnQoZXZlbnQsIHtcbiAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBlcnJvcixcbiAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgICAgdHlwZTogJ29uZXJyb3InLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9pbnN0YWxsR2xvYmFsT25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyKGNsaWVudCkge1xuICBhZGRHbG9iYWxVbmhhbmRsZWRSZWplY3Rpb25JbnN0cnVtZW50YXRpb25IYW5kbGVyKGUgPT4ge1xuICAgIGNvbnN0IHsgc3RhY2tQYXJzZXIsIGF0dGFjaFN0YWNrdHJhY2UgfSA9IGdldE9wdGlvbnMoKTtcblxuICAgIGlmIChnZXRDbGllbnQoKSAhPT0gY2xpZW50IHx8IHNob3VsZElnbm9yZU9uRXJyb3IoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gX2dldFVuaGFuZGxlZFJlamVjdGlvbkVycm9yKGUgKTtcblxuICAgIGNvbnN0IGV2ZW50ID0gaXNQcmltaXRpdmUoZXJyb3IpXG4gICAgICA/IF9ldmVudEZyb21SZWplY3Rpb25XaXRoUHJpbWl0aXZlKGVycm9yKVxuICAgICAgOiBldmVudEZyb21Vbmtub3duSW5wdXQoc3RhY2tQYXJzZXIsIGVycm9yLCB1bmRlZmluZWQsIGF0dGFjaFN0YWNrdHJhY2UsIHRydWUpO1xuXG4gICAgZXZlbnQubGV2ZWwgPSAnZXJyb3InO1xuXG4gICAgY2FwdHVyZUV2ZW50KGV2ZW50LCB7XG4gICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXJyb3IsXG4gICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgIHR5cGU6ICdvbnVuaGFuZGxlZHJlamVjdGlvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldFVuaGFuZGxlZFJlamVjdGlvbkVycm9yKGVycm9yKSB7XG4gIGlmIChpc1ByaW1pdGl2ZShlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBkaWcgdGhlIG9iamVjdCBvZiB0aGUgcmVqZWN0aW9uIG91dCBvZiBrbm93biBldmVudCB0eXBlc1xuICB0cnkge1xuXG4gICAgLy8gUHJvbWlzZVJlamVjdGlvbkV2ZW50cyBzdG9yZSB0aGUgb2JqZWN0IG9mIHRoZSByZWplY3Rpb24gdW5kZXIgJ3JlYXNvbidcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Byb21pc2VSZWplY3Rpb25FdmVudFxuICAgIGlmICgncmVhc29uJyBpbiAoZXJyb3IgKSkge1xuICAgICAgcmV0dXJuIChlcnJvciApLnJlYXNvbjtcbiAgICB9XG5cbiAgICAvLyBzb21ldGhpbmcsIHNvbWV3aGVyZSwgKGxpa2VseSBhIGJyb3dzZXIgZXh0ZW5zaW9uKSBlZmZlY3RpdmVseSBjYXN0cyBQcm9taXNlUmVqZWN0aW9uRXZlbnRzXG4gICAgLy8gdG8gQ3VzdG9tRXZlbnRzLCBtb3ZpbmcgdGhlIGBwcm9taXNlYCBhbmQgYHJlYXNvbmAgYXR0cmlidXRlcyBvZiB0aGUgUFJFIGludG9cbiAgICAvLyB0aGUgQ3VzdG9tRXZlbnQncyBgZGV0YWlsYCBhdHRyaWJ1dGUsIHNpbmNlIHRoZXkncmUgbm90IHBhcnQgb2YgQ3VzdG9tRXZlbnQncyBzcGVjXG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCBhbmRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yMzgwXG4gICAgaWYgKCdkZXRhaWwnIGluIChlcnJvciApICYmICdyZWFzb24nIGluIChlcnJvciApLmRldGFpbCkge1xuICAgICAgcmV0dXJuIChlcnJvciApLmRldGFpbC5yZWFzb247XG4gICAgfVxuICB9IGNhdGNoIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGZyb20gYSBwcm9taXNlIHJlamVjdGlvbiB3aGVyZSB0aGUgYHJlYXNvbmAgaXMgYSBwcmltaXRpdmUuXG4gKlxuICogQHBhcmFtIHJlYXNvbjogVGhlIGByZWFzb25gIHByb3BlcnR5IG9mIHRoZSBwcm9taXNlIHJlamVjdGlvblxuICogQHJldHVybnMgQW4gRXZlbnQgb2JqZWN0IHdpdGggYW4gYXBwcm9wcmlhdGUgYGV4Y2VwdGlvbmAgdmFsdWVcbiAqL1xuZnVuY3Rpb24gX2V2ZW50RnJvbVJlamVjdGlvbldpdGhQcmltaXRpdmUocmVhc29uKSB7XG4gIHJldHVybiB7XG4gICAgZXhjZXB0aW9uOiB7XG4gICAgICB2YWx1ZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdVbmhhbmRsZWRSZWplY3Rpb24nLFxuICAgICAgICAgIC8vIFN0cmluZygpIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBQcmltaXRpdmUgdHlwZSBpbmNsdWRlcyBzeW1ib2xzICh3aGljaCBjYW4ndCBiZSBhdXRvbWF0aWNhbGx5IHN0cmluZ2lmaWVkKVxuICAgICAgICAgIHZhbHVlOiBgTm9uLUVycm9yIHByb21pc2UgcmVqZWN0aW9uIGNhcHR1cmVkIHdpdGggdmFsdWU6ICR7U3RyaW5nKHJlYXNvbil9YCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2VuaGFuY2VFdmVudFdpdGhJbml0aWFsRnJhbWUoXG4gIGV2ZW50LFxuICB1cmwsXG4gIGxpbmUsXG4gIGNvbHVtbixcbikge1xuICAvLyBldmVudC5leGNlcHRpb25cbiAgY29uc3QgZSA9IChldmVudC5leGNlcHRpb24gPSBldmVudC5leGNlcHRpb24gfHwge30pO1xuICAvLyBldmVudC5leGNlcHRpb24udmFsdWVzXG4gIGNvbnN0IGV2ID0gKGUudmFsdWVzID0gZS52YWx1ZXMgfHwgW10pO1xuICAvLyBldmVudC5leGNlcHRpb24udmFsdWVzWzBdXG4gIGNvbnN0IGV2MCA9IChldlswXSA9IGV2WzBdIHx8IHt9KTtcbiAgLy8gZXZlbnQuZXhjZXB0aW9uLnZhbHVlc1swXS5zdGFja3RyYWNlXG4gIGNvbnN0IGV2MHMgPSAoZXYwLnN0YWNrdHJhY2UgPSBldjAuc3RhY2t0cmFjZSB8fCB7fSk7XG4gIC8vIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF0uc3RhY2t0cmFjZS5mcmFtZXNcbiAgY29uc3QgZXYwc2YgPSAoZXYwcy5mcmFtZXMgPSBldjBzLmZyYW1lcyB8fCBbXSk7XG5cbiAgY29uc3QgY29sbm8gPSBjb2x1bW47XG4gIGNvbnN0IGxpbmVubyA9IGxpbmU7XG4gIGNvbnN0IGZpbGVuYW1lID0gaXNTdHJpbmcodXJsKSAmJiB1cmwubGVuZ3RoID4gMCA/IHVybCA6IGdldExvY2F0aW9uSHJlZigpO1xuXG4gIC8vIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF0uc3RhY2t0cmFjZS5mcmFtZXNcbiAgaWYgKGV2MHNmLmxlbmd0aCA9PT0gMCkge1xuICAgIGV2MHNmLnB1c2goe1xuICAgICAgY29sbm8sXG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGZ1bmN0aW9uOiBVTktOT1dOX0ZVTkNUSU9OLFxuICAgICAgaW5fYXBwOiB0cnVlLFxuICAgICAgbGluZW5vLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVyTG9nKHR5cGUpIHtcbiAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZyhgR2xvYmFsIEhhbmRsZXIgYXR0YWNoZWQ6ICR7dHlwZX1gKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQ/LmdldE9wdGlvbnMoKSB8fCB7XG4gICAgc3RhY2tQYXJzZXI6ICgpID0+IFtdLFxuICAgIGF0dGFjaFN0YWNrdHJhY2U6IGZhbHNlLFxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZXhwb3J0IHsgZ2xvYmFsSGFuZGxlcnNJbnRlZ3JhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFsaGFuZGxlcnMuanMubWFwXG4iLCJpbXBvcnQgeyBkZWZpbmVJbnRlZ3JhdGlvbiwgZ2V0TG9jYXRpb25IcmVmIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xuXG4vKipcbiAqIENvbGxlY3RzIGluZm9ybWF0aW9uIGFib3V0IEhUVFAgcmVxdWVzdCBoZWFkZXJzIGFuZFxuICogYXR0YWNoZXMgdGhlbSB0byB0aGUgZXZlbnQuXG4gKi9cbmNvbnN0IGh0dHBDb250ZXh0SW50ZWdyYXRpb24gPSBkZWZpbmVJbnRlZ3JhdGlvbigoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0h0dHBDb250ZXh0JyxcbiAgICBwcmVwcm9jZXNzRXZlbnQoZXZlbnQpIHtcbiAgICAgIC8vIGlmIG5vbmUgb2YgdGhlIGluZm9ybWF0aW9uIHdlIHdhbnQgZXhpc3RzLCBkb24ndCBib3RoZXJcbiAgICAgIGlmICghV0lORE9XLm5hdmlnYXRvciAmJiAhV0lORE9XLmxvY2F0aW9uICYmICFXSU5ET1cuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBncmFiIGFzIG11Y2ggaW5mbyBhcyBleGlzdHMgYW5kIGFkZCBpdCB0byB0aGUgZXZlbnRcbiAgICAgIGNvbnN0IHVybCA9IGV2ZW50LnJlcXVlc3Q/LnVybCB8fCBnZXRMb2NhdGlvbkhyZWYoKTtcbiAgICAgIGNvbnN0IHsgcmVmZXJyZXIgfSA9IFdJTkRPVy5kb2N1bWVudCB8fCB7fTtcbiAgICAgIGNvbnN0IHsgdXNlckFnZW50IH0gPSBXSU5ET1cubmF2aWdhdG9yIHx8IHt9O1xuXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAuLi5ldmVudC5yZXF1ZXN0Py5oZWFkZXJzLFxuICAgICAgICAuLi4ocmVmZXJyZXIgJiYgeyBSZWZlcmVyOiByZWZlcnJlciB9KSxcbiAgICAgICAgLi4uKHVzZXJBZ2VudCAmJiB7ICdVc2VyLUFnZW50JzogdXNlckFnZW50IH0pLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIC4uLmV2ZW50LnJlcXVlc3QsXG4gICAgICAgIC4uLih1cmwgJiYgeyB1cmwgfSksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9O1xuXG4gICAgICBldmVudC5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9LFxuICB9O1xufSk7XG5cbmV4cG9ydCB7IGh0dHBDb250ZXh0SW50ZWdyYXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBjb250ZXh0LmpzLm1hcFxuIiwiaW1wb3J0IHsgZGVmaW5lSW50ZWdyYXRpb24sIGFwcGx5QWdncmVnYXRlRXJyb3JzVG9FdmVudCB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgeyBleGNlcHRpb25Gcm9tRXJyb3IgfSBmcm9tICcuLi9ldmVudGJ1aWxkZXIuanMnO1xuXG5jb25zdCBERUZBVUxUX0tFWSA9ICdjYXVzZSc7XG5jb25zdCBERUZBVUxUX0xJTUlUID0gNTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdMaW5rZWRFcnJvcnMnO1xuXG5jb25zdCBfbGlua2VkRXJyb3JzSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgfHwgREVGQVVMVF9MSU1JVDtcbiAgY29uc3Qga2V5ID0gb3B0aW9ucy5rZXkgfHwgREVGQVVMVF9LRVk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByZXByb2Nlc3NFdmVudChldmVudCwgaGludCwgY2xpZW50KSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gY2xpZW50LmdldE9wdGlvbnMoKTtcblxuICAgICAgYXBwbHlBZ2dyZWdhdGVFcnJvcnNUb0V2ZW50KFxuICAgICAgICAvLyBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgTGlua2VkRXJyb3JzIGludGVncmF0aW9uIGluIGNvcmUgYnkgdXNpbmcgYSBkaWZmZXJlbnQgZXhjZXB0aW9uRnJvbUVycm9yIGZ1bmN0aW9uXG4gICAgICAgIGV4Y2VwdGlvbkZyb21FcnJvcixcbiAgICAgICAgb3B0aW9ucy5zdGFja1BhcnNlcixcbiAgICAgICAga2V5LFxuICAgICAgICBsaW1pdCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGhpbnQsXG4gICAgICApO1xuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogQWdncmVncmF0ZSBsaW5rZWQgZXJyb3JzIGluIGFuIGV2ZW50LlxuICovXG5jb25zdCBsaW5rZWRFcnJvcnNJbnRlZ3JhdGlvbiA9IGRlZmluZUludGVncmF0aW9uKF9saW5rZWRFcnJvcnNJbnRlZ3JhdGlvbik7XG5cbmV4cG9ydCB7IGxpbmtlZEVycm9yc0ludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rZWRlcnJvcnMuanMubWFwXG4iLCJpbXBvcnQgeyBpbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uLCBmdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb24sIGRlZHVwZUludGVncmF0aW9uLCBjb25zb2xlU2FuZGJveCwgc3VwcG9ydHNGZXRjaCwgbG9nZ2VyLCBnZXRJbnRlZ3JhdGlvbnNUb1NldHVwLCBzdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnMsIGluaXRBbmRCaW5kLCBnZXRDdXJyZW50U2NvcGUsIGxhc3RFdmVudElkLCBnZXRSZXBvcnREaWFsb2dFbmRwb2ludCwgZ2V0TG9jYXRpb25IcmVmIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IEJyb3dzZXJDbGllbnQgfSBmcm9tICcuL2NsaWVudC5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGJyZWFkY3J1bWJzSW50ZWdyYXRpb24gfSBmcm9tICcuL2ludGVncmF0aW9ucy9icmVhZGNydW1icy5qcyc7XG5pbXBvcnQgeyBicm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24gfSBmcm9tICcuL2ludGVncmF0aW9ucy9icm93c2VyYXBpZXJyb3JzLmpzJztcbmltcG9ydCB7IGJyb3dzZXJTZXNzaW9uSW50ZWdyYXRpb24gfSBmcm9tICcuL2ludGVncmF0aW9ucy9icm93c2Vyc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBnbG9iYWxIYW5kbGVyc0ludGVncmF0aW9uIH0gZnJvbSAnLi9pbnRlZ3JhdGlvbnMvZ2xvYmFsaGFuZGxlcnMuanMnO1xuaW1wb3J0IHsgaHR0cENvbnRleHRJbnRlZ3JhdGlvbiB9IGZyb20gJy4vaW50ZWdyYXRpb25zL2h0dHBjb250ZXh0LmpzJztcbmltcG9ydCB7IGxpbmtlZEVycm9yc0ludGVncmF0aW9uIH0gZnJvbSAnLi9pbnRlZ3JhdGlvbnMvbGlua2VkZXJyb3JzLmpzJztcbmltcG9ydCB7IGRlZmF1bHRTdGFja1BhcnNlciB9IGZyb20gJy4vc3RhY2stcGFyc2Vycy5qcyc7XG5pbXBvcnQgeyBtYWtlRmV0Y2hUcmFuc3BvcnQgfSBmcm9tICcuL3RyYW5zcG9ydHMvZmV0Y2guanMnO1xuXG4vKiogR2V0IHRoZSBkZWZhdWx0IGludGVncmF0aW9ucyBmb3IgdGhlIGJyb3dzZXIgU0RLLiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEludGVncmF0aW9ucyhfb3B0aW9ucykge1xuICAvKipcbiAgICogTm90ZTogUGxlYXNlIG1ha2Ugc3VyZSB0aGlzIHN0YXlzIGluIHN5bmMgd2l0aCBBbmd1bGFyIFNESywgd2hpY2ggcmUtZXhwb3J0c1xuICAgKiBgZ2V0RGVmYXVsdEludGVncmF0aW9uc2AgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0IG9mIGludGVncmF0aW9ucy5cbiAgICovXG4gIHJldHVybiBbXG4gICAgLy8gVE9ETyh2MTApOiBSZXBsYWNlIHdpdGggYGV2ZW50RmlsdGVyc0ludGVncmF0aW9uYCBvbmNlIHdlIHJlbW92ZSB0aGUgZGVwcmVjYXRlZCBgaW5ib3VuZEZpbHRlcnNJbnRlZ3JhdGlvbmBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBpbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uKCksXG4gICAgZnVuY3Rpb25Ub1N0cmluZ0ludGVncmF0aW9uKCksXG4gICAgYnJvd3NlckFwaUVycm9yc0ludGVncmF0aW9uKCksXG4gICAgYnJlYWRjcnVtYnNJbnRlZ3JhdGlvbigpLFxuICAgIGdsb2JhbEhhbmRsZXJzSW50ZWdyYXRpb24oKSxcbiAgICBsaW5rZWRFcnJvcnNJbnRlZ3JhdGlvbigpLFxuICAgIGRlZHVwZUludGVncmF0aW9uKCksXG4gICAgaHR0cENvbnRleHRJbnRlZ3JhdGlvbigpLFxuICAgIGJyb3dzZXJTZXNzaW9uSW50ZWdyYXRpb24oKSxcbiAgXTtcbn1cblxuLyoqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0T3B0aW9ucyhvcHRpb25zQXJnID0ge30pIHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZGVmYXVsdEludGVncmF0aW9uczogZ2V0RGVmYXVsdEludGVncmF0aW9ucygpLFxuICAgIHJlbGVhc2U6XG4gICAgICB0eXBlb2YgX19TRU5UUllfUkVMRUFTRV9fID09PSAnc3RyaW5nJyAvLyBUaGlzIGFsbG93cyBidWlsZCB0b29saW5nIHRvIGZpbmQtYW5kLXJlcGxhY2UgX19TRU5UUllfUkVMRUFTRV9fIHRvIGluamVjdCBhIHJlbGVhc2UgdmFsdWVcbiAgICAgICAgPyBfX1NFTlRSWV9SRUxFQVNFX19cbiAgICAgICAgOiBXSU5ET1cuU0VOVFJZX1JFTEVBU0U/LmlkLCAvLyBUaGlzIHN1cHBvcnRzIHRoZSB2YXJpYWJsZSB0aGF0IHNlbnRyeS13ZWJwYWNrLXBsdWdpbiBpbmplY3RzXG4gICAgc2VuZENsaWVudFJlcG9ydHM6IHRydWUsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5kcm9wVG9wTGV2ZWxVbmRlZmluZWRLZXlzKG9wdGlvbnNBcmcpLFxuICB9O1xufVxuXG4vKipcbiAqIEluIGNvbnRyYXN0IHRvIHRoZSByZWd1bGFyIGBkcm9wVW5kZWZpbmVkS2V5c2AgbWV0aG9kLFxuICogdGhpcyBvbmUgZG9lcyBub3QgZGVlcC1kcm9wIGtleXMsIGJ1dCBvbmx5IG9uIHRoZSB0b3AgbGV2ZWwuXG4gKi9cbmZ1bmN0aW9uIGRyb3BUb3BMZXZlbFVuZGVmaW5lZEtleXMob2JqKSB7XG4gIGNvbnN0IG11dGF0ZXRlZE9iaiA9IHt9O1xuXG4gIGZvciAoY29uc3QgayBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopKSB7XG4gICAgY29uc3Qga2V5ID0gayA7XG4gICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG11dGF0ZXRlZE9ialtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG11dGF0ZXRlZE9iajtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2hvd0Jyb3dzZXJFeHRlbnNpb25FcnJvcigpIHtcbiAgY29uc3Qgd2luZG93V2l0aE1heWJlRXh0ZW5zaW9uID1cbiAgICB0eXBlb2YgV0lORE9XLndpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKFdJTkRPVyApO1xuICBpZiAoIXdpbmRvd1dpdGhNYXliZUV4dGVuc2lvbikge1xuICAgIC8vIE5vIG5lZWQgdG8gc2hvdyB0aGUgZXJyb3IgaWYgd2UncmUgbm90IGluIGEgYnJvd3NlciB3aW5kb3cgZW52aXJvbm1lbnQgKGUuZy4gc2VydmljZSB3b3JrZXJzKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbktleSA9IHdpbmRvd1dpdGhNYXliZUV4dGVuc2lvbi5jaHJvbWUgPyAnY2hyb21lJyA6ICdicm93c2VyJztcbiAgY29uc3QgZXh0ZW5zaW9uT2JqZWN0ID0gd2luZG93V2l0aE1heWJlRXh0ZW5zaW9uW2V4dGVuc2lvbktleV07XG5cbiAgY29uc3QgcnVudGltZUlkID0gZXh0ZW5zaW9uT2JqZWN0Py5ydW50aW1lPy5pZDtcbiAgY29uc3QgaHJlZiA9IGdldExvY2F0aW9uSHJlZigpIHx8ICcnO1xuXG4gIGNvbnN0IGV4dGVuc2lvblByb3RvY29scyA9IFsnY2hyb21lLWV4dGVuc2lvbjonLCAnbW96LWV4dGVuc2lvbjonLCAnbXMtYnJvd3Nlci1leHRlbnNpb246JywgJ3NhZmFyaS13ZWItZXh0ZW5zaW9uOiddO1xuXG4gIC8vIFJ1bm5pbmcgdGhlIFNESyBpbiBhIGRlZGljYXRlZCBleHRlbnNpb24gcGFnZSBhbmQgY2FsbGluZyBTZW50cnkuaW5pdCBpcyBmaW5lOyBubyByaXNrIG9mIGRhdGEgbGVha2FnZVxuICBjb25zdCBpc0RlZGljYXRlZEV4dGVuc2lvblBhZ2UgPVxuICAgICEhcnVudGltZUlkICYmIFdJTkRPVyA9PT0gV0lORE9XLnRvcCAmJiBleHRlbnNpb25Qcm90b2NvbHMuc29tZShwcm90b2NvbCA9PiBocmVmLnN0YXJ0c1dpdGgoYCR7cHJvdG9jb2x9Ly9gKSk7XG5cbiAgLy8gUnVubmluZyB0aGUgU0RLIGluIE5XLmpzLCB3aGljaCBhcHBlYXJzIGxpa2UgYSBicm93c2VyIGV4dGVuc2lvbiBidXQgaXNuJ3QsIGlzIGFsc28gZmluZVxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzEyNjY4XG4gIGNvbnN0IGlzTldqcyA9IHR5cGVvZiB3aW5kb3dXaXRoTWF5YmVFeHRlbnNpb24ubncgIT09ICd1bmRlZmluZWQnO1xuXG4gIHJldHVybiAhIXJ1bnRpbWVJZCAmJiAhaXNEZWRpY2F0ZWRFeHRlbnNpb25QYWdlICYmICFpc05XanM7XG59XG5cbi8qKlxuICogQSBtYWdpYyBzdHJpbmcgdGhhdCBidWlsZCB0b29saW5nIGNhbiBsZXZlcmFnZSBpbiBvcmRlciB0byBpbmplY3QgYSByZWxlYXNlIHZhbHVlIGludG8gdGhlIFNESy5cbiAqL1xuXG4vKipcbiAqIFRoZSBTZW50cnkgQnJvd3NlciBTREsgQ2xpZW50LlxuICpcbiAqIFRvIHVzZSB0aGlzIFNESywgY2FsbCB0aGUge0BsaW5rIGluaXR9IGZ1bmN0aW9uIGFzIGVhcmx5IGFzIHBvc3NpYmxlIHdoZW5cbiAqIGxvYWRpbmcgdGhlIHdlYiBwYWdlLiBUbyBzZXQgY29udGV4dCBpbmZvcm1hdGlvbiBvciBzZW5kIG1hbnVhbCBldmVudHMsIHVzZVxuICogdGhlIHByb3ZpZGVkIG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqXG4gKiBpbXBvcnQgeyBpbml0IH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbiAqXG4gKiBpbml0KHtcbiAqICAgZHNuOiAnX19EU05fXycsXG4gKiAgIC8vIC4uLlxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogaW1wb3J0IHsgYWRkQnJlYWRjcnVtYiB9IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG4gKiBhZGRCcmVhZGNydW1iKHtcbiAqICAgbWVzc2FnZTogJ015IEJyZWFkY3J1bWInLFxuICogICAvLyAuLi5cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqXG4gKiBpbXBvcnQgKiBhcyBTZW50cnkgZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbiAqIFNlbnRyeS5jYXB0dXJlTWVzc2FnZSgnSGVsbG8sIHdvcmxkIScpO1xuICogU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24obmV3IEVycm9yKCdHb29kIGJ5ZScpKTtcbiAqIFNlbnRyeS5jYXB0dXJlRXZlbnQoe1xuICogICBtZXNzYWdlOiAnTWFudWFsJyxcbiAqICAgc3RhY2t0cmFjZTogW1xuICogICAgIC8vIC4uLlxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBCcm93c2VyT3B0aW9uc30gZm9yIGRvY3VtZW50YXRpb24gb24gY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBpbml0KGJyb3dzZXJPcHRpb25zID0ge30pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdE9wdGlvbnMoYnJvd3Nlck9wdGlvbnMpO1xuXG4gIGlmICghb3B0aW9ucy5za2lwQnJvd3NlckV4dGVuc2lvbkNoZWNrICYmIHNob3VsZFNob3dCcm93c2VyRXh0ZW5zaW9uRXJyb3IoKSkge1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgY29uc29sZVNhbmRib3goKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdbU2VudHJ5XSBZb3UgY2Fubm90IHJ1biBTZW50cnkgdGhpcyB3YXkgaW4gYSBicm93c2VyIGV4dGVuc2lvbiwgY2hlY2s6IGh0dHBzOi8vZG9jcy5zZW50cnkuaW8vcGxhdGZvcm1zL2phdmFzY3JpcHQvYmVzdC1wcmFjdGljZXMvYnJvd3Nlci1leHRlbnNpb25zLycsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKERFQlVHX0JVSUxEICYmICFzdXBwb3J0c0ZldGNoKCkpIHtcbiAgICBsb2dnZXIud2FybihcbiAgICAgICdObyBGZXRjaCBBUEkgZGV0ZWN0ZWQuIFRoZSBTZW50cnkgU0RLIHJlcXVpcmVzIGEgRmV0Y2ggQVBJIGNvbXBhdGlibGUgZW52aXJvbm1lbnQgdG8gc2VuZCBldmVudHMuIFBsZWFzZSBhZGQgYSBGZXRjaCBBUEkgcG9seWZpbGwuJyxcbiAgICApO1xuICB9XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGFja1BhcnNlcjogc3RhY2tQYXJzZXJGcm9tU3RhY2tQYXJzZXJPcHRpb25zKG9wdGlvbnMuc3RhY2tQYXJzZXIgfHwgZGVmYXVsdFN0YWNrUGFyc2VyKSxcbiAgICBpbnRlZ3JhdGlvbnM6IGdldEludGVncmF0aW9uc1RvU2V0dXAob3B0aW9ucyksXG4gICAgdHJhbnNwb3J0OiBvcHRpb25zLnRyYW5zcG9ydCB8fCBtYWtlRmV0Y2hUcmFuc3BvcnQsXG4gIH07XG5cbiAgcmV0dXJuIGluaXRBbmRCaW5kKEJyb3dzZXJDbGllbnQsIGNsaWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFByZXNlbnQgdGhlIHVzZXIgd2l0aCBhIHJlcG9ydCBkaWFsb2cuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgRXZlcnl0aGluZyBpcyBvcHRpb25hbCwgd2UgdHJ5IHRvIGZldGNoIGFsbCBpbmZvIG5lZWQgZnJvbSB0aGUgZ2xvYmFsIHNjb3BlLlxuICovXG5mdW5jdGlvbiBzaG93UmVwb3J0RGlhbG9nKG9wdGlvbnMgPSB7fSkge1xuICAvLyBkb2Vzbid0IHdvcmsgd2l0aG91dCBhIGRvY3VtZW50IChSZWFjdCBOYXRpdmUpXG4gIGlmICghV0lORE9XLmRvY3VtZW50KSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKCdHbG9iYWwgZG9jdW1lbnQgbm90IGRlZmluZWQgaW4gc2hvd1JlcG9ydERpYWxvZyBjYWxsJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3QgY2xpZW50ID0gc2NvcGUuZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IGRzbiA9IGNsaWVudD8uZ2V0RHNuKCk7XG5cbiAgaWYgKCFkc24pIHtcbiAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIuZXJyb3IoJ0RTTiBub3QgY29uZmlndXJlZCBmb3Igc2hvd1JlcG9ydERpYWxvZyBjYWxsJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNjb3BlKSB7XG4gICAgb3B0aW9ucy51c2VyID0ge1xuICAgICAgLi4uc2NvcGUuZ2V0VXNlcigpLFxuICAgICAgLi4ub3B0aW9ucy51c2VyLFxuICAgIH07XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZXZlbnRJZCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBsYXN0RXZlbnRJZCgpO1xuICAgIGlmIChldmVudElkKSB7XG4gICAgICBvcHRpb25zLmV2ZW50SWQgPSBldmVudElkO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNjcmlwdCA9IFdJTkRPVy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gIHNjcmlwdC5zcmMgPSBnZXRSZXBvcnREaWFsb2dFbmRwb2ludChkc24sIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLm9uTG9hZCkge1xuICAgIHNjcmlwdC5vbmxvYWQgPSBvcHRpb25zLm9uTG9hZDtcbiAgfVxuXG4gIGNvbnN0IHsgb25DbG9zZSB9ID0gb3B0aW9ucztcbiAgaWYgKG9uQ2xvc2UpIHtcbiAgICBjb25zdCByZXBvcnREaWFsb2dDbG9zZWRNZXNzYWdlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRhdGEgPT09ICdfX3NlbnRyeV9yZXBvcnRkaWFsb2dfY2xvc2VkX18nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFdJTkRPVy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcmVwb3J0RGlhbG9nQ2xvc2VkTWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBXSU5ET1cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlcG9ydERpYWxvZ0Nsb3NlZE1lc3NhZ2VIYW5kbGVyKTtcbiAgfVxuXG4gIGNvbnN0IGluamVjdGlvblBvaW50ID0gV0lORE9XLmRvY3VtZW50LmhlYWQgfHwgV0lORE9XLmRvY3VtZW50LmJvZHk7XG4gIGlmIChpbmplY3Rpb25Qb2ludCkge1xuICAgIGluamVjdGlvblBvaW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH0gZWxzZSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmVycm9yKCdOb3QgaW5qZWN0aW5nIHJlcG9ydCBkaWFsb2cuIE5vIGluamVjdGlvbiBwb2ludCBmb3VuZCBpbiBIVE1MJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgdG8gYmUgQVBJIGNvbXBhdGlibGUgd2l0aCB0aGUgbG9hZGVyLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBmb3JjZUxvYWQoKSB7XG4gIC8vIE5vb3Bcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgdG8gYmUgQVBJIGNvbXBhdGlibGUgd2l0aCB0aGUgbG9hZGVyLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBvbkxvYWQoY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuZXhwb3J0IHsgYXBwbHlEZWZhdWx0T3B0aW9ucywgZm9yY2VMb2FkLCBnZXREZWZhdWx0SW50ZWdyYXRpb25zLCBpbml0LCBvbkxvYWQsIHNob3dSZXBvcnREaWFsb2cgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay5qcy5tYXBcbiIsImNvbnN0IGNvbmZpZyA9IHtcbiAgY29kZWxlc3M6IHByb2Nlc3MuZW52LkNPREVMRVNTX1NES19BUFBfVVJMIHx8ICdodHRwczovL2FsbG95c2RrLmFsbG95LmNvLycsXG4gIGFwaTogcHJvY2Vzcy5lbnYuQVBJX1VSTCB8fCAnaHR0cHM6Ly9kb2N2LXByb2QtYXBpLmFsbG95LmNvLydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZztcbiIsImRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgSUdMT086IGFueTtcbiAgfVxufVxuXG5jb25zdCBJT1ZBVElPTl9ET01BSU5fS0VZID0gJ2lvdmF0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKCkgPT4ge1xuICB3aW5kb3cuSUdMT08gPSB3aW5kb3cuSUdMT08gfHwge1xuICAgIGxvYWRlcjoge1xuICAgICAgdXJpX2hvb2s6ICcvaW9qcy8nLCAvLyByb3V0ZSB0aGF0IGNvbnRhaW5zIHRoZSBwcm94eSB0byBJb3ZhdGlvbiBvbiB0aGUgc2VydmVyIHNpZGVcbiAgICAgIHZlcnNpb246ICdnZW5lcmFsNScsIC8vIHZlcnNpb24gb2YgdGhlIGphdmFzY3JpcHQgdG8gdXNlXG4gICAgICBzdWJrZXk6ICc1RkV4c2Urb0ExMTM0Qmhpd0NGMkVlUTFUZmlzUEpHaGE0Q3BWRzJuZDdFPScsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBkZWxheSA9IChtaWxsaXNlY29uZHM6IG51bWJlcikgPT5cbiAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbWlsbGlzZWNvbmRzKSk7XG5cbiAgY29uc3QgdGhpcmRQYXJ0eVNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB0aGlyZFBhcnR5U2NyaXB0LnNyYyA9ICdodHRwczovL2NpLW1wc25hcmUuaW92YXRpb24uY29tL3NuYXJlLmpzJztcbiAgdGhpcmRQYXJ0eVNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHRoaXJkUGFydHlTY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXJkUGFydHlTY3JpcHQpO1xuXG4gIGNvbnN0IHRoaXJkUGFydHlJZCA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZz4ocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgZ2V0VGhpcmRQYXJ0eUlkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcmRQYXJ0eVNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgZ2V0VGhpcmRQYXJ0eUlkKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgaWQgPSB0eXBlb2YgaW9HZXRCbGFja2JveCA9PT0gJ2Z1bmN0aW9uJyA/IGlvR2V0QmxhY2tib3goKT8uYmxhY2tib3ggOiBudWxsO1xuICAgICAgICByZXNvbHZlKGlkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXNvbHZlKCcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcmRQYXJ0eVNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZ2V0VGhpcmRQYXJ0eUlkKTtcbiAgfSk7XG5cbiAgaWYgKCF0aGlyZFBhcnR5SWQpIHtcbiAgICAvLyBBcHBlbmRpbmcgdGhpcyBzY3JpcHQgdGhyb3dzIGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdoaWNoIGNsaWVudHMgZG8gbm90IGxpa2VcbiAgICAvLyBzbyBkb24ndCBleGVjdXRlIHRoaXMgYmxvY2sgb2YgY29kZSB1bmxlc3MgbmVjZXNzYXJ5XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNyYyA9ICdodHRwczovL3NjcmlwdHMuYWxsb3kuY29tL2lvdmF0aW9uLmpzJztcbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0dXMnLCAnbG9hZGluZycpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgIGNvbnN0IGZpcnN0UGFydHlJZCA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZz4ocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBnZXRGaXJzdFBhcnR5SWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgZ2V0Rmlyc3RQYXJ0eUlkKTtcbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdG8gcmVtb3ZlIGRlbGF5XG4gICAgICAgIGF3YWl0IGRlbGF5KDUwMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaWQgPSB3aW5kb3cuSUdMT08uZ2V0QmxhY2tib3goKT8uYmxhY2tib3g7XG4gICAgICAgICAgcmVzb2x2ZShpZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc29sdmUoJycpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBnZXRGaXJzdFBhcnR5SWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBmaXJzdFBhcnR5SWQ7XG4gIH1cblxuICByZXR1cm4gdGhpcmRQYXJ0eUlkO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZUlvdmF0aW9uID0gKCkgPT4ge1xuICBjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0Jyk7XG4gIHNjcmlwdHMuZm9yRWFjaChzY3JpcHQgPT4ge1xuICAgIGlmIChzY3JpcHQuc3JjLmluY2x1ZGVzKElPVkFUSU9OX0RPTUFJTl9LRVkpKSB7XG4gICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgfVxuICB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2V4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWdleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBfcmVnZXguZGVmYXVsdC50ZXN0KHV1aWQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy51bnNhZmVTdHJpbmdpZnkgPSB1bnNhZmVTdHJpbmdpZnk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuXG5mdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IHN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkudW5zYWZlU3RyaW5naWZ5KShiKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBfZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gdm9pZCAwO1xuZXhwb3J0cy5kZWZhdWx0ID0gdjM1O1xuXG52YXIgX3N0cmluZ2lmeSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcblxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5jb25zdCBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydHMuRE5TID0gRE5TO1xuY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLlVSTCA9IFVSTDtcblxuZnVuY3Rpb24gdjM1KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBfbmFtZXNwYWNlO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSAoMCwgX3BhcnNlLmRlZmF1bHQpKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKCgoX25hbWVzcGFjZSA9IG5hbWVzcGFjZSkgPT09IG51bGwgfHwgX25hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hbWVzcGFjZS5sZW5ndGgpICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkudW5zYWZlU3RyaW5naWZ5KShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8qXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcbiAqXG4gKiBNb2RpZmljYXRpb24gb2YgSmF2YVNjcmlwdCBNRDVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZDVUb0hleEVuY29kZWRBcnJheSh3b3Jkc1RvTWQ1KGJ5dGVzVG9Xb3JkcyhieXRlcyksIGJ5dGVzLmxlbmd0aCAqIDgpKTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNVRvSGV4RW5jb2RlZEFycmF5KGlucHV0KSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICBjb25zdCBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgY29uc3QgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgY29uc3QgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgcmV0dXJuIChpbnB1dExlbmd0aDggKyA2NCA+Pj4gOSA8PCA0KSArIDE0ICsgMTtcbn1cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5cblxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMjtcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xuICBsZXQgYSA9IDE3MzI1ODQxOTM7XG4gIGxldCBiID0gLTI3MTczMzg3OTtcbiAgbGV0IGMgPSAtMTczMjU4NDE5NDtcbiAgbGV0IGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIGNvbnN0IG9sZGEgPSBhO1xuICAgIGNvbnN0IG9sZGIgPSBiO1xuICAgIGNvbnN0IG9sZGMgPSBjO1xuICAgIGNvbnN0IG9sZGQgPSBkO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgfVxuXG4gIHJldHVybiBbYSwgYiwgYywgZF07XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBieXRlcyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuZ3RoOCkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICBjb25zdCBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIGNvbnN0IG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBtZDU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX21kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZDUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2MyA9ICgwLCBfdi5kZWZhdWx0KSgndjMnLCAweDMwLCBfbWQuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2MztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbnZhciBfZGVmYXVsdCA9IHtcbiAgcmFuZG9tVVVJRFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX25hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbmF0aXZlLmpzXCIpKTtcblxudmFyIF9ybmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JuZy5qc1wiKSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAoX25hdGl2ZS5kZWZhdWx0LnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBfbmF0aXZlLmRlZmF1bHQucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkocm5kcyk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHY0O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgY29uc3QgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgY29uc3QgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIGNvbnN0IE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgY29uc3QgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tpICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1baV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW2ldW3RdO1xuICAgIH1cblxuICAgIGZvciAobGV0IHQgPSAxNjsgdCA8IDgwOyArK3QpIHtcbiAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIGxldCBhID0gSFswXTtcbiAgICBsZXQgYiA9IEhbMV07XG4gICAgbGV0IGMgPSBIWzJdO1xuICAgIGxldCBkID0gSFszXTtcbiAgICBsZXQgZSA9IEhbNF07XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDgwOyArK3QpIHtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICBjb25zdCBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbdF0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxudmFyIF9kZWZhdWx0ID0gc2hhMTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YzNS5qc1wiKSk7XG5cbnZhciBfc2hhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zaGExLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjUgPSAoMCwgX3YuZGVmYXVsdCkoJ3Y1JywgMHg1MCwgX3NoYS5kZWZhdWx0KTtcbnZhciBfZGVmYXVsdCA9IHY1O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE1KSwgMTYpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2ZXJzaW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOSUxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX25pbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wYXJzZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2M1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsaWRhdGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92ZXJzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25pbC5qc1wiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnRcbmV4cG9ydCBjb25zdCBzZXRTZXNzaW9uSWQgPSAoc3RvcmFnZUxhYmVsOiBzdHJpbmcsIG5ldXJvVXNlcklkPzogc3RyaW5nKSA9PiB7XG4gIGxldCBzZXNzaW9uSWQ7XG4gIGlmICghc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlTGFiZWwpKSB7XG4gICAgc2Vzc2lvbklkID0gbmV1cm9Vc2VySWQgfHwgdXVpZHY0KCk7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlTGFiZWwsIHNlc3Npb25JZCk7XG4gIH0gZWxzZSB7XG4gICAgc2Vzc2lvbklkID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlTGFiZWwpO1xuICB9XG4gIHJldHVybiBzZXNzaW9uSWQ7XG59O1xuIiwiaW1wb3J0IHsgc2V0U2Vzc2lvbklkIH0gZnJvbSAnLi9oZWxwZXJzJztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBuaWQ6IGFueTtcbiAgICBuaWRMb2FkZWQ6IGJvb2xlYW47XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE5FVVJPSURfRE9NQUlOX0tFWSA9ICduZXVyby1pZC5jb20nO1xuXG5jb25zdCBlbWJlZE5ldXJvSWQgPSAobmV1cm9Vc2VySWQsIHNpdGVJZCwgcHJvZHVjdGlvbiwgbmV1cm9JZEZ1bm5lbCkgPT4ge1xuICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCduZXVyb0lkT3BlbicsICd0cnVlJyk7XG5cbiAgY29uc3QgaWRlbnRpdHlJZCA9IHNldFNlc3Npb25JZCgnaWRlbnRpdHlJZCcsIG5ldXJvVXNlcklkKTtcbiAgLy8gc2xpY2UgJ2Zvcm1fJyBvZmYgdGhlIHNpdGVJZFxuICBjb25zdCBzaXRlSWRTdHJpbmcgPSB3aW5kb3cuZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgIHByb2R1Y3Rpb25cbiAgICAgID8gc2l0ZUlkLnNsaWNlKDUpXG4gICAgICA6IGAke3NpdGVJZH0tdGVzdGAuc2xpY2UoNSlcbiAgKTtcblxuICAvLyBDcmVhdGUgc2NyaXB0XG4gIGNvbnN0IHNjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LnNyYyA9IGAvL3NjcmlwdHMuJHtORVVST0lEX0RPTUFJTl9LRVl9L2MvbmlkLSR7c2l0ZUlkU3RyaW5nfS5qc2A7XG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG5cbiAgaWYgKCF3aW5kb3cubmlkKSB7XG4gICAgd2luZG93Lm5pZCA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICh3aW5kb3cubmlkLnEgPSB3aW5kb3cubmlkLnEgfHwgW10pLnB1c2goYXJncyk7XG4gICAgfTtcbiAgfVxuICAvLyBBZGQgc2NyaXB0IHRvIGRvY3VtZW50IGlmIHRoZXJlIGlzIG5vIHJlcGVhdFxuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgd2luZG93Lm5pZCgnaWRlbnRpZnknLCBpZGVudGl0eUlkKTtcbiAgaWYgKG5ldXJvSWRGdW5uZWwpIHtcbiAgICB3aW5kb3cubmlkKCdzZXRWYXJpYWJsZScsICdmdW5uZWwnLCBuZXVyb0lkRnVubmVsKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGl0eUlkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZW1iZWROZXVyb0lkO1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlTmV1cm9JZCA9IChyZW1vdmVTY3JpcHQgPSBmYWxzZSkgPT4ge1xuICAvLyBjcmVhdGVzIGEgY2hlY2sgdG8gYXZvaWQgY2FsbGluZyBjbG9zZVNlc3Npb24gbW9yZSB0aGFuIG9uY2VcbiAgaWYgKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ25ldXJvSWRPcGVuJykgPT09ICd0cnVlJyAmJiB3aW5kb3cubmlkKSB7XG4gICAgd2luZG93Lm5pZCgnY2xvc2VTZXNzaW9uJyk7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnbmV1cm9JZE9wZW4nLCAnZmFsc2UnKTtcbiAgfVxuXG4gIGlmIChyZW1vdmVTY3JpcHQpIHtcbiAgICBpZiAod2luZG93Lm5pZExvYWRlZCkge1xuICAgICAgLy8gVGhlIGFib3ZlIG5ldXJvSUQgZW1iZWRkZWQgc2NyaXB0IGxvYWRzIGEgc2Vjb25kYXJ5IHNjcmlwdCBhbmQgdXNlcyB0aGlzIGdsb2JhbCB3aW5kb3dcbiAgICAgIC8vIHZhcmlhYmxlIHRvIGNoZWNrIGlmIGl0J3MgbG9hZGVkLiBJZiB0cnVlLCBzZWNvbmRhcnkgc2NyaXB0IHdpbGwgbm90IGJlIGxvYWRlZCB3aGVuIGluaXQvb3BlblxuICAgICAgLy8gcnVucyBhZ2FpbiBpbiB0aGUgc2FtZSBzZXNzaW9uLlxuICAgICAgd2luZG93Lm5pZExvYWRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcbiAgICBzY3JpcHRzLmZvckVhY2goc2NyaXB0ID0+IHtcbiAgICAgIGlmIChzY3JpcHQuc3JjLmluY2x1ZGVzKE5FVVJPSURfRE9NQUlOX0tFWSkpIHtcbiAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuIiwiZGVjbGFyZSBjb25zdCBkZXZpY2VyOiBhbnk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIChzb2N1cmVQdWJsaWNUb2tlbjogc3RyaW5nKSA9PiB7XG4gIC8vIENyZWF0ZSBzY3JpcHRcbiAgY29uc3Qgc2NyaXB0OiBIVE1MU2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vc2NyaXB0cy5hbGxveS5jb20vZGV2aWNlci5taW4uanMnO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXR1cycsICdsb2FkaW5nJyk7XG4gIC8vIEFkZCBzY3JpcHQgdG8gZG9jdW1lbnQgYm9keVxuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgLy8gY3JlYXRlIHByb21pc2UgdG8gYXdhaXQgZ2V0IGRldmljZSBJRFxuICBjb25zdCBzb2N1cmVEZXZpY2VJZCA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZz4ocmVzb2x2ZSA9PiB7XG4gICAgLy8gZ2V0IGRldmljZSBJZCBmcm9tIGRldmljZXIgbGlicmFyeVxuICAgIGNvbnN0IGdldERldmljZUlkID0gKCkgPT4ge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIGFmdGVyIGVudGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGdldERldmljZUlkKTtcbiAgICAgIGNvbnN0IGRldmljZUZQT3B0aW9ucyA9IHtcbiAgICAgICAgcHVibGljS2V5OiBzb2N1cmVQdWJsaWNUb2tlbixcbiAgICAgICAgdXNlckNvbnNlbnQ6IHRydWUsXG4gICAgICAgIGVuZHBvaW50OiAnZGV2aWNlLmFsbG95LmNvbScsXG4gICAgICAgIGNvbnRleHQ6ICdob21lcGFnZScsXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZ2V0IGRldmljZSBJRFxuICAgICAgICBkZXZpY2VyLnJ1bihkZXZpY2VGUE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnNlc3Npb25JZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmUoJycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB3YWl0IHRvIHNjcmlwdCB0byBiZSBmdWxseSBsb2FkZWRcbiAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGdldERldmljZUlkKTtcbiAgfSk7XG4gIHJldHVybiBzb2N1cmVEZXZpY2VJZDtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVTb2N1cmUgPSAoKSA9PiB7XG4gIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcbiAgc2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG4gICAgaWYgKHNjcmlwdC5zcmMuaW5jbHVkZXMoJ3NjcmlwdHMuYWxsb3kuY29tL2RldmljZXInKSkge1xuICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiZXhwb3J0IHR5cGUgU2lnbWFEZXZpY2VPcHRpb25zID0ge1xuICBzZGtLZXk6IHN0cmluZztcbiAgY29uZmlnQmFzZVVybD86IHN0cmluZztcbiAgdXNlU29jdXJlR292PzogYm9vbGVhbjtcbiAgY3VzdG9tZXJTZXNzaW9uSWQ/OiBzdHJpbmc7XG4gIGRpc2FibGVEZXZpY2VDb29raWU/OiBib29sZWFuO1xuICBkZXZpY2VDb29raWVOYW1lPzogc3RyaW5nO1xufVxuXG5kZWNsYXJlIGNvbnN0IFNpZ21hRGV2aWNlTWFuYWdlcjoge1xuICBpbml0aWFsaXplOiAoIG9wdGlvbnM6IFNpZ21hRGV2aWNlT3B0aW9ucyApID0+IHZvaWRcbiAgZ2V0U2Vzc2lvblRva2VuOiAoKSA9PiBQcm9taXNlPHN0cmluZz47XG59O1xuXG5leHBvcnQgY29uc3QgU09DVVJFX0RJX0RPTUFJTl9LRVkgPSAnc2RrLmR2LnNvY3VyZS5pbyc7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIChzaWdtYURldmljZU9wdGlvbnM6IFNpZ21hRGV2aWNlT3B0aW9ucykgPT4ge1xuICAvLyBDcmVhdGUgc2NyaXB0XG4gIGNvbnN0IHNjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LnNyYyA9IGBodHRwczovLyR7U09DVVJFX0RJX0RPTUFJTl9LRVl9L2xhdGVzdC9kZXZpY2Utcmlzay1zZGsuanNgO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xuICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXR1cycsICdsb2FkaW5nJyk7XG5cbiAgLy8gQWRkIHNjcmlwdCB0byBkb2N1bWVudCBib2R5XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAvLyBjcmVhdGUgcHJvbWlzZSB0byBhd2FpdCBnZXQgc2Vzc2lvbiB0b2tlblxuICBjb25zdCBzb2N1cmVTZXNzaW9uVG9rZW4gPSBhd2FpdCBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlKSA9PiB7ICAgXG4gICAgY29uc3QgZ2V0U2Vzc2lvblRva2VuID0gKCkgPT4ge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIGFmdGVyIGVudGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGdldFNlc3Npb25Ub2tlbik7XG4gICAgICB0cnkge1xuICAgICAgICBTaWdtYURldmljZU1hbmFnZXIuaW5pdGlhbGl6ZShzaWdtYURldmljZU9wdGlvbnMpO1xuICAgICAgICBTaWdtYURldmljZU1hbmFnZXIuZ2V0U2Vzc2lvblRva2VuKCkudGhlbigoc2Vzc2lvblRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHNlc3Npb25Ub2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmUoJycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB3YWl0IGZvciBzY3JpcHQgdG8gYmUgZnVsbHkgbG9hZGVkXG4gICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBnZXRTZXNzaW9uVG9rZW4pO1xuICB9KTtcbiAgcmV0dXJuIHNvY3VyZVNlc3Npb25Ub2tlbjtcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZVNvY3VyZURpZ2l0YWxJbnRlbGxpZ2VuY2UgPSAoKSA9PiB7XG4gIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcbiAgc2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG4gICAgaWYgKHNjcmlwdC5zcmMuaW5jbHVkZXMoU09DVVJFX0RJX0RPTUFJTl9LRVkpKSB7XG4gICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgfVxuICB9KTtcbn0iLCJpbXBvcnQgeyBzZXRTZXNzaW9uSWQgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5cbmNvbnN0IFRIUkVBVE1FVFJJWF9ET01BSU5fS0VZID0gJ2gub25saW5lLW1ldHJpeC5uZXQnO1xuXG5leHBvcnQgZGVmYXVsdCAob3JnSWQ6IHN0cmluZykgPT4ge1xuXG4gIGNvbnN0IHNlc3Npb25JZCA9IHNldFNlc3Npb25JZCgndG1TZXNzaW9uSWQnKTtcblxuICAvLyBTYW5pdGl6ZSBvcmdJZCBhbmQgc2Vzc2lvbklkIGJ5IGVuc3VyaW5nIHRoZXkgYXJlIHNhZmUgdG8gdXNlXG4gIGNvbnN0IHNhZmVPcmdJZCA9IGVuY29kZVVSSUNvbXBvbmVudChvcmdJZCk7ICAgLy8gRW5jb2RpbmcgdGhlIHZhbHVlc1xuICBjb25zdCBzYWZlU2Vzc2lvbklkID0gZW5jb2RlVVJJQ29tcG9uZW50KHNlc3Npb25JZCk7XG5cbiAgLy8gQ3JlYXRlIHNjcmlwdFxuICBjb25zdCBzY3JpcHQ6IEhUTUxTY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5zcmMgPSBgaHR0cHM6Ly8ke1RIUkVBVE1FVFJJWF9ET01BSU5fS0VZfS9mcC90YWdzP29yZ19pZD0ke3NhZmVPcmdJZH0mc2Vzc2lvbl9pZD0ke3NhZmVTZXNzaW9uSWR9YDtcbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblxuICAvLyBBZGQgc2NyaXB0IHRvIGRvY3VtZW50IFxuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cbiAgcmV0dXJuIHNlc3Npb25JZDtcbn0gXG5cbmV4cG9ydCBjb25zdCByZW1vdmVUaHJlYXRtZXRyaXggPSAoKSA9PiB7XG4gIGNvbnN0IHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcbiAgc2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG4gICAgaWYgKHNjcmlwdC5zcmMuaW5jbHVkZXMoVEhSRUFUTUVUUklYX0RPTUFJTl9LRVkpKSB7XG4gICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgfVxuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gJ0ZldGNoRXJyb3InO1xuXG4gIGluZm8/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICBzdGF0dXM/OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSBkYXRhLic7XG4gIH1cbn0iLCJpbXBvcnQgRmV0Y2hFcnJvciBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IENPTU1PTl9IRUFERVJTID0ge1xuICAnWC1BbGxveS1TZGstUGxhdGZvcm0nOiAnV2ViJyxcbiAgJ1gtQWxsb3ktU2RrLVZlcnNpb24nOiAnMScsXG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG59O1xuXG5mdW5jdGlvbiBpc1dlYigpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNvbW1vbkZldGNoPFQ+KHtcbiAgdXJsLFxuICBtZXRob2QsXG4gIGhlYWRlcnMsXG4gIGZldGNoT3B0aW9ucyxcbiAgZGF0YSxcbn06IHtcbiAgdXJsOiBzdHJpbmc7XG4gIG1ldGhvZDogUmVxdWVzdEluaXRbJ21ldGhvZCddO1xuICBoZWFkZXJzPzogUmVxdWVzdEluaXRbJ2hlYWRlcnMnXTtcbiAgZmV0Y2hPcHRpb25zPzogT21pdDxSZXF1ZXN0SW5pdCwgJ21ldGhvZCcgfCAnaGVhZGVycyc+O1xuICBkYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59KTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge1xuICAgIG1ldGhvZCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5DT01NT05fSEVBREVSUyxcbiAgICAgICdYLVBhcmVudC1Eb21haW4nOiAoaXNXZWIoKSk/IGRvY3VtZW50LnJlZmVycmVyOiAnJyxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfSxcbiAgICAuLi5mZXRjaE9wdGlvbnMsXG4gIH07XG4gIGlmIChtZXRob2QgJiYgZGF0YSAmJiBbJ1BPU1QnLCAnUFVUJ10uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtjb25maWcuYXBpfSR7dXJsfWAsIG9wdGlvbnMpO1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRmV0Y2hFcnJvcigpO1xuICAgIGVycm9yLmluZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgZXJyb3Iuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG4iLCJpbXBvcnQgY29tbW9uRmV0Y2ggZnJvbSBcIi4vZmV0Y2hcIjtcblxudHlwZSBBdXRoSW5pdFJlc3BvbnNlID0ge1xuICBhY2Nlc3NfdG9rZW46IHN0cmluZztcbn07XG5cbmNvbnN0IGZldGNoQXV0aEluaXQgPSAoaWQgOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhJbml0UmVzcG9uc2U+ID0+IHtcbiAgcmV0dXJuIGNvbW1vbkZldGNoKHtcbiAgICB1cmw6ICdhdXRoL2luaXQnLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGZldGNoT3B0aW9uczoge1xuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBpZCxcbiAgICAgIH0pLFxuICAgIH0sXG4gIH0pO1xufVxuXG5jb25zdCBmZXRjaFB1YmxpY0luZm8gPSAoXG4gIGtleTogc3RyaW5nLFxuICBhY2Nlc3NUb2tlbjogc3RyaW5nLCBcbiAgKTogUHJvbWlzZTx7IHNlcnZpY2VzOiBhbnkgfT4gPT4ge1xuICByZXR1cm4gY29tbW9uRmV0Y2goe1xuICAgIHVybDogYGNsaWVudC9wdWJsaWMvJHtrZXl9YCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgJ2FsbG95LWpvdXJuZXktYXBwbGljYXRpb24tc3luYyc6ICd0cnVlJ1xuICAgIH0sXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgfSk7XG59XG5cbnR5cGUgSm91cm5leUFwcGxpY2F0aW9uUmVzcG9uc2UgPSB7XG4gIGpvdXJuZXlfYXBwbGljYXRpb25fdG9rZW46IHN0cmluZztcbn07XG5cbmNvbnN0IGdlbmVyYXRlSm91cm5leUFwcGxpY2F0aW9uID0gKFxuICBqb3VybmV5VG9rZW46IHN0cmluZywgXG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmcsIFxuICBqb3VybmV5RGF0YTogYW55LFxuICBwcm9kdWN0aW9uOiBib29sZWFuID0gZmFsc2UsXG4gICk6IFByb21pc2U8Sm91cm5leUFwcGxpY2F0aW9uUmVzcG9uc2U+ID0+IHtcbiAgcmV0dXJuIGNvbW1vbkZldGNoKHtcbiAgICB1cmw6IGB2MS9qb3VybmV5cy8ke2pvdXJuZXlUb2tlbn0vYXBwbGljYXRpb25zYCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgJ2FsbG95LWpvdXJuZXktYXBwbGljYXRpb24tc3luYyc6ICd0cnVlJyxcbiAgICAgICdhbGxveS1zYW5kYm94JzogcHJvZHVjdGlvbiA/ICdmYWxzZScgOiAndHJ1ZScsXG4gICAgfSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBmZXRjaE9wdGlvbnM6IHtcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsuLi5qb3VybmV5RGF0YX0pXG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgZ2VuZXJhdGVFdmFsdWF0aW9uID0gKFxuICBhY2Nlc3NUb2tlbjogc3RyaW5nLCBcbiAgZXZhbHVhdGlvbkRhdGE6IGFueSxcbiAgZW50aXR5VG9rZW4/OiBzdHJpbmcsIFxuICBleHRlcm5hbEVudGl0eUlkPzogc3RyaW5nLFxuICBwcm9kdWN0aW9uOiBib29sZWFuID0gZmFsc2UsXG4pID0+IHtcbiAgcmV0dXJuIGNvbW1vbkZldGNoKHtcbiAgICB1cmw6ICdldmFsdWF0aW9ucycsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAuLi4oZW50aXR5VG9rZW4gJiYgeyAnQWxsb3ktRW50aXR5LVRva2VuJzogZW50aXR5VG9rZW4gfSksXG4gICAgICAuLi4oZXh0ZXJuYWxFbnRpdHlJZCAmJiB7XG4gICAgICAgICdBbGxveS1FeHRlcm5hbC1FbnRpdHktSUQnOiBleHRlcm5hbEVudGl0eUlkLFxuICAgICAgfSksXG4gICAgICAnYWxsb3ktc2FuZGJveCc6IHByb2R1Y3Rpb24gPyAnZmFsc2UnIDogJ3RydWUnLFxuICAgIH0sXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZmV0Y2hPcHRpb25zOiB7XG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7Li4uZXZhbHVhdGlvbkRhdGF9KVxuICAgIH1cbiAgfSk7XG59XG5cbnR5cGUgRW50aXR5UmVzcG9uc2UgPSB7XG4gIGVudGl0eV90b2tlbjogc3RyaW5nO1xufTtcblxuZXhwb3J0ICB7XG4gIGZldGNoQXV0aEluaXQsXG4gIGZldGNoUHVibGljSW5mbyxcbiAgZ2VuZXJhdGVKb3VybmV5QXBwbGljYXRpb24sXG4gIGdlbmVyYXRlRXZhbHVhdGlvbixcbn1cblxuIiwiY29uc3QgZ2V0RW1iZWRkZWREYXRhU291cmNlcyA9ICh7XG4gIHNvY3VyZURldmljZUlkLCBzb2N1cmVTZXNzaW9uVG9rZW4sIGlzTmV1cm9JZEVuYWJsZWQsIG5ldXJvSWRTaXRlSWQsIGlvdmF0aW9uQmxhY2tib3hJZCwgdGhyZWF0bWV0cml4U2Vzc2lvbklkLCB0aHJlYXRtZXRyaXhPcmdJZCxcbn0pID0+IHtcbiAgY29uc3Qgc291cmNlczogYW55ID0ge307XG4gIGlmIChzb2N1cmVEZXZpY2VJZCkgc291cmNlcy5zb2N1cmVfc2Vzc2lvbl9pZCA9IHNvY3VyZURldmljZUlkO1xuICBpZiAoc29jdXJlU2Vzc2lvblRva2VuKSBzb3VyY2VzLnNvY3VyZV9zZXNzaW9uX2lkID0gc29jdXJlU2Vzc2lvblRva2VuO1xuICBpZiAoaXNOZXVyb0lkRW5hYmxlZCAmJiBuZXVyb0lkU2l0ZUlkKSB7XG4gICAgY29uc3QgaWRlbnRpdHlJZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2lkZW50aXR5SWQnKTtcbiAgICBzb3VyY2VzLm5ldXJvX3VzZXJfaWQgPSBpZGVudGl0eUlkO1xuICAgIHNvdXJjZXMuc2l0ZV9pZCA9IG5ldXJvSWRTaXRlSWQ7XG4gIH0gXG4gIGlmICh0aHJlYXRtZXRyaXhTZXNzaW9uSWQpIHtcbiAgICBzb3VyY2VzLnRocmVhdG1ldHJpeF9zZXNzaW9uX2lkID0gdGhyZWF0bWV0cml4U2Vzc2lvbklkO1xuICAgIHNvdXJjZXMub3JnX2lkID0gdGhyZWF0bWV0cml4T3JnSWQ7XG4gIH1cbiAgaWYgKGlvdmF0aW9uQmxhY2tib3hJZCkge1xuICAgIHNvdXJjZXMuaW92YXRpb25fYmxhY2tib3ggPSBpb3ZhdGlvbkJsYWNrYm94SWQ7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEVtYmVkZGVkRGF0YVNvdXJjZXM7IiwiZXhwb3J0IGRlZmF1bHQgJzIuMy4wJzsiLCJpbXBvcnQgcXVlcnlTdHJpbmcgZnJvbSAncXVlcnktc3RyaW5nJztcbmltcG9ydCB7XG4gIEJyb3dzZXJDbGllbnQsXG4gIGRlZmF1bHRTdGFja1BhcnNlcixcbiAgZ2V0RGVmYXVsdEludGVncmF0aW9ucyxcbiAgbWFrZUZldGNoVHJhbnNwb3J0LFxuICBTY29wZSxcbn0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQge1xuICBlbWJlZFNvY3VyZSxcbiAgZW1iZWROZXVyb0lkLFxuICBlbWJlZElvdmF0aW9uLFxuICBlbWJlZFRocmVhdG1ldHJpeCxcbiAgZW1iZWRTb2N1cmVEaWdpdGFsSW50ZWxsaWdlbmNlLFxuICByZW1vdmVJb3ZhdGlvbixcbiAgcmVtb3ZlTmV1cm9JZCxcbiAgcmVtb3ZlU29jdXJlLFxuICByZW1vdmVTb2N1cmVEaWdpdGFsSW50ZWxsaWdlbmNlLFxuICByZW1vdmVUaHJlYXRtZXRyaXgsXG59IGZyb20gJy4vc2VydmljZXMnO1xuaW1wb3J0IHsgQWxsb3ksIEluaXQsIEpvdXJuZXlEYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBmZXRjaEF1dGhJbml0LFxuICBnZW5lcmF0ZUpvdXJuZXlBcHBsaWNhdGlvbixcbiAgZ2VuZXJhdGVFdmFsdWF0aW9uLFxuICBmZXRjaFB1YmxpY0luZm8sXG59IGZyb20gJy4vdXRpbHMvYXBpJztcbmltcG9ydCBnZXRFbWJlZGRlZERhdGFTb3VyY2VzIGZyb20gJy4vdXRpbHMvZGF0YVNvdXJjZXMnO1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi92ZXJzaW9uJztcblxuY29uc3QgYWxsb3lJZCA9ICdhbGxveSc7XG5jb25zdCBhbGxveUluaXRQYXJhbXM6IEluaXQgPSB7IGtleTogJycsIG5wbVBhY2thZ2VWZXJzaW9uOiB2ZXJzaW9uIH07XG5sZXQgYWxsb3lDYWxsYmFjazogKGFyZzA6IGFueSkgPT4gdm9pZDtcbmxldCBpZnJhbWVTcmM6IHN0cmluZztcbmxldCBzZW50cnlUZWxlbWV0cnk6IGJvb2xlYW4gPSB0cnVlO1xuXG4vLyBmaWx0ZXIgU2VudHJ5IGludGVncmF0aW9ucyB0aGF0IHVzZSB0aGUgZ2xvYmFsIHZhcmlhYmxlXG5jb25zdCBpbnRlZ3JhdGlvbnMgPSBnZXREZWZhdWx0SW50ZWdyYXRpb25zKHt9KS5maWx0ZXIoXG4gIChkZWZhdWx0SW50ZWdyYXRpb24pID0+IHtcbiAgICByZXR1cm4gIVtcIkJyb3dzZXJBcGlFcnJvcnNcIiwgXCJCcmVhZGNydW1ic1wiLCBcIkdsb2JhbEhhbmRsZXJzXCJdLmluY2x1ZGVzKFxuICAgICAgZGVmYXVsdEludGVncmF0aW9uLm5hbWUsXG4gICAgKTtcbiAgfSxcbik7XG5jb25zdCBjbGllbnQgPSBuZXcgQnJvd3NlckNsaWVudCh7XG4gIGRzbjogXCJodHRwczovL2RhZjBhZDQ3NGYyYTJhMGZiMzQyOTc1NGE0NGNhYTQ3QG80Nzg4ODQuaW5nZXN0LnVzLnNlbnRyeS5pby80NTA5MjA0MjkyODk0NzIxXCIsXG4gIHJlbGVhc2U6IGBhbGxveS13ZWItc2RrQCR7dmVyc2lvbn1gLFxuICBzdGFja1BhcnNlcjogZGVmYXVsdFN0YWNrUGFyc2VyLFxuICBpbnRlZ3JhdGlvbnMsXG4gIHRyYW5zcG9ydDogbWFrZUZldGNoVHJhbnNwb3J0LFxufSk7XG5jb25zdCBzZW50cnlTY29wZSA9IG5ldyBTY29wZSgpO1xuc2VudHJ5U2NvcGUuc2V0Q2xpZW50KGNsaWVudCk7XG5jbGllbnQuaW5pdCgpOyAvLyBpbml0aWFsaXppbmcgaGFzIHRvIGJlIGRvbmUgYWZ0ZXIgc2V0dGluZyB0aGUgY2xpZW50IG9uIHRoZSBzY29wZVxuXG5jb25zdCBjcmVhdGVFdmFsdWF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICByZW1vdmVOZXVyb0lkKCk7XG4gIGNvbnN0IHtcbiAgICBrZXksXG4gICAgZW50aXR5VG9rZW4sXG4gICAgZXZhbHVhdGlvbkRhdGEsXG4gICAgcHJvZHVjdGlvbixcbiAgICBleHRlcm5hbEVudGl0eUlkLFxuICAgIHNvY3VyZURldmljZUlkLFxuICAgIHNvY3VyZVNlc3Npb25Ub2tlbixcbiAgICBpb3ZhdGlvbkJsYWNrYm94SWQsXG4gICAgbmV1cm9JZFNpdGVJZCxcbiAgICB0aHJlYXRtZXRyaXhTZXNzaW9uSWQsXG4gICAgdGhyZWF0bWV0cml4T3JnSWQsXG4gIH0gPSBhbGxveUluaXRQYXJhbXM7XG4gIGNvbnN0IHsgYWNjZXNzX3Rva2VuOiB0b2tlbiB9ID0gYXdhaXQgZmV0Y2hBdXRoSW5pdChrZXkpO1xuICBjb25zdCBpc05ldXJvSWRFbmFibGVkID0gISFuZXVyb0lkU2l0ZUlkO1xuICBjb25zdCBjdXJyRW50aXR5VG9rZW4gPSBlbnRpdHlUb2tlbjtcblxuICBjb25zdCBlbWJlZGRlZERhdGFTb3VyY2VzID0gZ2V0RW1iZWRkZWREYXRhU291cmNlcyh7XG4gICAgc29jdXJlRGV2aWNlSWQsXG4gICAgc29jdXJlU2Vzc2lvblRva2VuLFxuICAgIGlzTmV1cm9JZEVuYWJsZWQsXG4gICAgbmV1cm9JZFNpdGVJZCxcbiAgICBpb3ZhdGlvbkJsYWNrYm94SWQsXG4gICAgdGhyZWF0bWV0cml4U2Vzc2lvbklkLFxuICAgIHRocmVhdG1ldHJpeE9yZ0lkLFxuICB9KTtcblxuICBjb25zdCBkYXRhID0ge1xuICAgIC4uLmV2YWx1YXRpb25EYXRhLFxuICAgIC4uLmVtYmVkZGVkRGF0YVNvdXJjZXMsXG4gIH07XG5cbiAgY29uc3QgZXZhbHVhdGlvbiA9IGF3YWl0IGdlbmVyYXRlRXZhbHVhdGlvbihcbiAgICB0b2tlbixcbiAgICBkYXRhLFxuICAgIGN1cnJFbnRpdHlUb2tlbixcbiAgICBleHRlcm5hbEVudGl0eUlkLFxuICAgIHByb2R1Y3Rpb24sXG4gICk7XG4gIHJldHVybiBldmFsdWF0aW9uO1xufTtcblxuY29uc3QgY3JlYXRlSm91cm5leUFwcGxpY2F0aW9uID0gYXN5bmMgKGRhdGE6IEpvdXJuZXlEYXRhKSA9PiB7XG4gIHJlbW92ZU5ldXJvSWQoKTtcbiAgY29uc3Qge1xuICAgIGtleSxcbiAgICBqb3VybmV5VG9rZW4sXG4gICAgcHJvZHVjdGlvbixcbiAgICBzb2N1cmVEZXZpY2VJZCxcbiAgICBzb2N1cmVTZXNzaW9uVG9rZW4sXG4gICAgaW92YXRpb25CbGFja2JveElkLFxuICAgIG5ldXJvSWRTaXRlSWQsXG4gICAgdGhyZWF0bWV0cml4U2Vzc2lvbklkLFxuICAgIHRocmVhdG1ldHJpeE9yZ0lkLFxuICB9ID0gYWxsb3lJbml0UGFyYW1zO1xuXG4gIGlmIChqb3VybmV5VG9rZW4pIHtcbiAgICBjb25zdCBqb3VybmV5RGF0YSA9IGRhdGE7XG5cbiAgICBjb25zdCB7IGFjY2Vzc190b2tlbjogdG9rZW4gfSA9IGF3YWl0IGZldGNoQXV0aEluaXQoa2V5KTtcbiAgICBjb25zdCBpc05ldXJvSWRFbmFibGVkID0gISFuZXVyb0lkU2l0ZUlkO1xuXG4gICAgY29uc3QgZW1iZWRkZWREYXRhU291cmNlcyA9IGdldEVtYmVkZGVkRGF0YVNvdXJjZXMoe1xuICAgICAgc29jdXJlRGV2aWNlSWQsXG4gICAgICBzb2N1cmVTZXNzaW9uVG9rZW4sXG4gICAgICBpc05ldXJvSWRFbmFibGVkLFxuICAgICAgbmV1cm9JZFNpdGVJZCxcbiAgICAgIGlvdmF0aW9uQmxhY2tib3hJZCxcbiAgICAgIHRocmVhdG1ldHJpeFNlc3Npb25JZCxcbiAgICAgIHRocmVhdG1ldHJpeE9yZ0lkLFxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGVtYmVkZGVkRGF0YVNvdXJjZXMpLmxlbmd0aCA+PSAxKSB7XG4gICAgICBqb3VybmV5RGF0YS5lbnRpdGllcyA9IGRhdGEuZW50aXRpZXM/Lm1hcChlbnRpdHkgPT4ge1xuICAgICAgICBjb25zdCBlbnRpdHlXaXRoRGV2aWNlSWQgPSBlbnRpdHk7XG4gICAgICAgIGVudGl0eVdpdGhEZXZpY2VJZC5kYXRhID0ge1xuICAgICAgICAgIC4uLmVudGl0eVdpdGhEZXZpY2VJZC5kYXRhLFxuICAgICAgICAgIC4uLmVtYmVkZGVkRGF0YVNvdXJjZXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnRpdHlXaXRoRGV2aWNlSWQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBqb3VybmV5QXBwbGljYXRpb25SZXNwb25zZSA9IGF3YWl0IGdlbmVyYXRlSm91cm5leUFwcGxpY2F0aW9uKFxuICAgICAgam91cm5leVRva2VuLFxuICAgICAgdG9rZW4sXG4gICAgICBqb3VybmV5RGF0YSxcbiAgICAgIHByb2R1Y3Rpb24sXG4gICAgKTtcbiAgICBhbGxveUluaXRQYXJhbXMuam91cm5leUFwcGxpY2F0aW9uVG9rZW4gPVxuICAgICAgam91cm5leUFwcGxpY2F0aW9uUmVzcG9uc2Uuam91cm5leV9hcHBsaWNhdGlvbl90b2tlbjtcbiAgICByZXR1cm4gam91cm5leUFwcGxpY2F0aW9uUmVzcG9uc2U7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZW1vdmVOZXVyb0lkKHRydWUpO1xuICAgIHJlbW92ZUlvdmF0aW9uKCk7XG4gICAgcmVtb3ZlU29jdXJlKCk7XG4gICAgcmVtb3ZlU29jdXJlRGlnaXRhbEludGVsbGlnZW5jZSgpO1xuICAgIHJlbW92ZVRocmVhdG1ldHJpeCgpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhbGxveUlkKTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzZW50cnlUZWxlbWV0cnkpIHtcbiAgICAgIHNlbnRyeVNjb3BlLmNhcHR1cmVFeGNlcHRpb24oZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGZldGNoQ2xpZW50U2VydmljZXMgPSBhc3luYyBrZXkgPT4ge1xuICBjb25zdCB7IGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfSA9IGF3YWl0IGZldGNoQXV0aEluaXQoa2V5KTtcbiAgY29uc3QgcHVibGljSW5mbyA9IGF3YWl0IGZldGNoUHVibGljSW5mbyhrZXksIGFjY2Vzc1Rva2VuKTtcbiAgY29uc3QgaXNOZXVyb0lkRW5hYmxlZCA9IHB1YmxpY0luZm8/LnNlcnZpY2VzPy5uZXVyb19pZCB8fCBmYWxzZTtcbiAgY29uc3QgbmV1cm9JZFNpdGVJZCA9IHB1YmxpY0luZm8/LnNlcnZpY2VzPy5uZXVyb19pZD8uc2l0ZUlkIHx8ICcnO1xuICBjb25zdCBpc1RocmVhdG1ldHJpeEVuYWJsZWQgPSBwdWJsaWNJbmZvPy5zZXJ2aWNlcz8udGhyZWF0bWV0cml4IHx8IGZhbHNlO1xuICBjb25zdCB0aHJlYXRtZXRyaXhPcmdJZCA9IHB1YmxpY0luZm8/LnNlcnZpY2VzPy50aHJlYXRtZXRyaXg/Lm9yZ0lkIHx8ICcnO1xuICBjb25zdCBpc0lvdmF0aW9uRW5hYmxlZCA9IHB1YmxpY0luZm8/LnNlcnZpY2VzPy5pb3ZhdGlvbiB8fCBmYWxzZTtcbiAgY29uc3QgaXNTb2N1cmVFbmFibGVkID0gcHVibGljSW5mbz8uc2VydmljZXM/LnNvY3VyZV9kdiB8fCBmYWxzZTtcbiAgY29uc3Qgc29jdXJlUHVibGljVG9rZW4gPVxuICAgIHB1YmxpY0luZm8/LnNlcnZpY2VzPy5zb2N1cmVfZHY/LnB1YmxpY1Rva2VuIHx8IGZhbHNlO1xuICBjb25zdCBpc1NvY3VyZURpZ2l0YWxJbnRlbEVuYWJsZWQgPVxuICAgIHB1YmxpY0luZm8/LnNlcnZpY2VzPy5zb2N1cmVfZGlnaXRhbF9pbnRlbCB8fCBmYWxzZTtcbiAgY29uc3Qgc29jdXJlRGlnaXRhbEludGVsUHVibGljVG9rZW4gPVxuICAgIHB1YmxpY0luZm8/LnNlcnZpY2VzPy5zb2N1cmVfZGlnaXRhbF9pbnRlbD8ucHVibGljVG9rZW4gfHwgJyc7XG4gIHJldHVybiB7XG4gICAgaXNOZXVyb0lkRW5hYmxlZCxcbiAgICBuZXVyb0lkU2l0ZUlkLFxuICAgIGlzSW92YXRpb25FbmFibGVkLFxuICAgIGlzU29jdXJlRW5hYmxlZCxcbiAgICBzb2N1cmVQdWJsaWNUb2tlbixcbiAgICBpc1RocmVhdG1ldHJpeEVuYWJsZWQsXG4gICAgdGhyZWF0bWV0cml4T3JnSWQsXG4gICAgaXNTb2N1cmVEaWdpdGFsSW50ZWxFbmFibGVkLFxuICAgIHNvY3VyZURpZ2l0YWxJbnRlbFB1YmxpY1Rva2VuLFxuICB9O1xufTtcblxuY29uc3QgaW5pdCA9IGFzeW5jICh7XG4gIGtleSxcbiAgYXBpVXJsLFxuICBhcHBVcmwsXG4gIGVudGl0eVRva2VuLFxuICBleHRlcm5hbEVudGl0eUlkLFxuICBldmFsdWF0aW9uRGF0YSxcbiAgcHJvZHVjdGlvbixcbiAgbWF4RXZhbHVhdGlvbkF0dGVtcHRzLFxuICBkb2N1bWVudHMsXG4gIHNlbGZpZSxcbiAgY29sb3IsXG4gIGN1c3RvbVN0eWxlLFxuICBjdXN0b21lclNsdWcsXG4gIGZvcmNlTW9iaWxlLFxuICB2YWxpZGF0aW9uUHJlQ2hlY2tzLFxuICBzaG93SGVhZGVyLFxuICBqb3VybmV5QXBwbGljYXRpb25Ub2tlbixcbiAgam91cm5leVRva2VuLFxuICBpc1NpbmdsZUVudGl0eSxcbiAgaXNSZWFjdE5hdGl2ZSxcbiAgaXNBbmRyb2lkRGV2aWNlLFxuICBuZXVyb1VzZXJJZCxcbiAgbmV1cm9JZEZ1bm5lbCxcbiAgc29jdXJlQ3VzdG9tZXJTZXNzaW9uSWQsXG4gIHRlbGVtZXRyeSA9IHRydWUsXG59OiBJbml0KSA9PiB7XG4gIHNlbnRyeVRlbGVtZXRyeSA9IHRlbGVtZXRyeTtcblxuICB0cnkge1xuICAgIC8vIHJlc2V0IGFueSByZXNpZHVhbCBpbml0IHBhcmFtcyB3aGVuIGZpcnN0IGluaXRpYWxpemluZ1xuICAgIE9iamVjdC5rZXlzKGFsbG95SW5pdFBhcmFtcykuZm9yRWFjaChhbGxveUtleSA9PiB7XG4gICAgICBkZWxldGUgYWxsb3lJbml0UGFyYW1zW2FsbG95S2V5XTtcbiAgICB9KTtcblxuICAgIGFsbG95SW5pdFBhcmFtcy5rZXkgPSBrZXk7XG4gICAgYWxsb3lJbml0UGFyYW1zLm5wbVBhY2thZ2VWZXJzaW9uID0gdmVyc2lvbjtcbiAgICBpZiAoY3VzdG9tZXJTbHVnKSB7XG4gICAgICBjb25zdCBzZGtBcGlVcmwgPSBgaHR0cHM6Ly8ke2N1c3RvbWVyU2x1Z30tYWxsb3lzZGsuYXBpLmFsbG95LmNvbS9gO1xuICAgICAgY29uc3QgY29kZWxlc3NVcmwgPSBgaHR0cHM6Ly8ke2N1c3RvbWVyU2x1Z30tYWxsb3lzZGsuYXBwLmFsbG95LmNvbS9gO1xuICAgICAgY29uZmlnLmNvZGVsZXNzID0gY29kZWxlc3NVcmw7XG4gICAgICBjb25maWcuYXBpID0gc2RrQXBpVXJsO1xuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgb25jZSBwcm92aXNpb25pbmcgd29ya3Mgb24gY3VzdG9tZXJTbHVnIGJhc2lzXG4gICAgaWYgKGFwaVVybCAmJiBhcHBVcmwpIHtcbiAgICAgIGNvbmZpZy5jb2RlbGVzcyA9IGFwcFVybDtcbiAgICAgIGNvbmZpZy5hcGkgPSBhcGlVcmw7XG4gICAgfVxuICAgIGlmIChlbnRpdHlUb2tlbikge1xuICAgICAgYWxsb3lJbml0UGFyYW1zLmVudGl0eVRva2VuID0gZW50aXR5VG9rZW47XG4gICAgfVxuICAgIGlmIChleHRlcm5hbEVudGl0eUlkKSB7XG4gICAgICBhbGxveUluaXRQYXJhbXMuZXh0ZXJuYWxFbnRpdHlJZCA9IGV4dGVybmFsRW50aXR5SWQ7XG4gICAgfVxuICAgIGlmIChwcm9kdWN0aW9uKSB7XG4gICAgICBhbGxveUluaXRQYXJhbXMucHJvZHVjdGlvbiA9IHByb2R1Y3Rpb247XG4gICAgfVxuICAgIGlmIChtYXhFdmFsdWF0aW9uQXR0ZW1wdHMpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5tYXhFdmFsdWF0aW9uQXR0ZW1wdHMgPSBtYXhFdmFsdWF0aW9uQXR0ZW1wdHM7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudHMpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5kb2N1bWVudHMgPSBkb2N1bWVudHM7XG4gICAgfVxuICAgIGlmIChzZWxmaWUpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5zZWxmaWUgPSBzZWxmaWU7XG4gICAgfVxuICAgIGlmIChmb3JjZU1vYmlsZSkge1xuICAgICAgYWxsb3lJbml0UGFyYW1zLmZvcmNlTW9iaWxlID0gZm9yY2VNb2JpbGU7XG4gICAgfVxuICAgIGlmIChzaG93SGVhZGVyID09PSBmYWxzZSkge1xuICAgICAgYWxsb3lJbml0UGFyYW1zLnNob3dIZWFkZXIgPSBzaG93SGVhZGVyO1xuICAgIH1cbiAgICBpZiAodmFsaWRhdGlvblByZUNoZWNrcykge1xuICAgICAgYWxsb3lJbml0UGFyYW1zLnZhbGlkYXRpb25QcmVDaGVja3MgPSB2YWxpZGF0aW9uUHJlQ2hlY2tzO1xuICAgIH1cbiAgICBpZiAoam91cm5leUFwcGxpY2F0aW9uVG9rZW4pIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5qb3VybmV5QXBwbGljYXRpb25Ub2tlbiA9IGpvdXJuZXlBcHBsaWNhdGlvblRva2VuO1xuICAgIH1cbiAgICBpZiAoam91cm5leVRva2VuKSB7XG4gICAgICBhbGxveUluaXRQYXJhbXMuam91cm5leVRva2VuID0gam91cm5leVRva2VuO1xuICAgIH1cbiAgICBpZiAoaXNTaW5nbGVFbnRpdHkpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5pc1NpbmdsZUVudGl0eSA9IGlzU2luZ2xlRW50aXR5O1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGlzTmV1cm9JZEVuYWJsZWQsXG4gICAgICBuZXVyb0lkU2l0ZUlkLFxuICAgICAgaXNUaHJlYXRtZXRyaXhFbmFibGVkLFxuICAgICAgdGhyZWF0bWV0cml4T3JnSWQsXG4gICAgICBpc0lvdmF0aW9uRW5hYmxlZCxcbiAgICAgIGlzU29jdXJlRW5hYmxlZCxcbiAgICAgIHNvY3VyZVB1YmxpY1Rva2VuLFxuICAgICAgaXNTb2N1cmVEaWdpdGFsSW50ZWxFbmFibGVkLFxuICAgICAgc29jdXJlRGlnaXRhbEludGVsUHVibGljVG9rZW4sXG4gICAgfSA9IGF3YWl0IGZldGNoQ2xpZW50U2VydmljZXMoa2V5KTtcblxuICAgIGlmIChzb2N1cmVQdWJsaWNUb2tlbiAmJiBpc1NvY3VyZUVuYWJsZWQpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5zb2N1cmVQdWJsaWNUb2tlbiA9IHNvY3VyZVB1YmxpY1Rva2VuO1xuICAgICAgY29uc3Qgc29jdXJlRGV2aWNlSWQgPSBhd2FpdCBlbWJlZFNvY3VyZShzb2N1cmVQdWJsaWNUb2tlbik7XG4gICAgICBhbGxveUluaXRQYXJhbXMuc29jdXJlRGV2aWNlSWQgPSBzb2N1cmVEZXZpY2VJZDtcbiAgICB9XG5cbiAgICBpZiAoc29jdXJlRGlnaXRhbEludGVsUHVibGljVG9rZW4gJiYgaXNTb2N1cmVEaWdpdGFsSW50ZWxFbmFibGVkKSB7XG4gICAgICBhbGxveUluaXRQYXJhbXMuc29jdXJlRGlnaXRhbEludGVsUHVibGljVG9rZW4gPSBzb2N1cmVEaWdpdGFsSW50ZWxQdWJsaWNUb2tlbjtcbiAgICAgIGNvbnN0IHNvY3VyZVNlc3Npb25Ub2tlbiA9IGF3YWl0IGVtYmVkU29jdXJlRGlnaXRhbEludGVsbGlnZW5jZSh7XG4gICAgICAgIHNka0tleTogc29jdXJlRGlnaXRhbEludGVsUHVibGljVG9rZW4sXG4gICAgICAgIGN1c3RvbWVyU2Vzc2lvbklkOiBzb2N1cmVDdXN0b21lclNlc3Npb25JZCxcbiAgICAgIH0pO1xuICAgICAgYWxsb3lJbml0UGFyYW1zLnNvY3VyZVNlc3Npb25Ub2tlbiA9IHNvY3VyZVNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXVyb0lkRW5hYmxlZCAmJiBuZXVyb0lkU2l0ZUlkKSB7XG4gICAgICBhbGxveUluaXRQYXJhbXMubmV1cm9JZFNpdGVJZCA9IG5ldXJvSWRTaXRlSWQ7XG4gICAgICBjb25zdCBpZGVudGl0eUlkID0gZW1iZWROZXVyb0lkKFxuICAgICAgICBuZXVyb1VzZXJJZCxcbiAgICAgICAgbmV1cm9JZFNpdGVJZCxcbiAgICAgICAgcHJvZHVjdGlvbiB8fCBmYWxzZSxcbiAgICAgICAgbmV1cm9JZEZ1bm5lbCxcbiAgICAgICk7XG4gICAgICAvLyBuZXVyb1VzZXJJZCBpcyBhbGxveSdzIGludGVybmFsIG1hcHBpbmcgZm9yIGlkZW50aXR5SWRcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5uZXVyb1VzZXJJZCA9IGlkZW50aXR5SWQ7XG4gICAgICBpZiAobmV1cm9JZEZ1bm5lbCkge1xuICAgICAgICBhbGxveUluaXRQYXJhbXMubmV1cm9JZEZ1bm5lbCA9IG5ldXJvSWRGdW5uZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVGhyZWF0bWV0cml4RW5hYmxlZCAmJiB0aHJlYXRtZXRyaXhPcmdJZCkge1xuICAgICAgYWxsb3lJbml0UGFyYW1zLnRocmVhdG1ldHJpeE9yZ0lkID0gdGhyZWF0bWV0cml4T3JnSWQ7XG4gICAgICBjb25zdCBzZXNzaW9uSWQgPSBlbWJlZFRocmVhdG1ldHJpeCh0aHJlYXRtZXRyaXhPcmdJZCk7XG4gICAgICBhbGxveUluaXRQYXJhbXMudGhyZWF0bWV0cml4U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgIH1cblxuICAgIGlmIChpc0lvdmF0aW9uRW5hYmxlZCkge1xuICAgICAgY29uc3QgYmxhY2tib3hJZCA9IGF3YWl0IGVtYmVkSW92YXRpb24oKTtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5pb3ZhdGlvbkJsYWNrYm94SWQgPSBibGFja2JveElkO1xuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSkge1xuICAgICAgYWxsb3lJbml0UGFyYW1zLmlzUmVhY3ROYXRpdmUgPSBpc1JlYWN0TmF0aXZlO1xuICAgIH1cblxuICAgIGlmIChpc0FuZHJvaWREZXZpY2UpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5pc0FuZHJvaWREZXZpY2UgPSBpc0FuZHJvaWREZXZpY2U7XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgdGhlIHRoZW1lIGFuZCBjb21wb25lbnQgY3VzdG9taXphdGlvbiBvYmplY3QgaW50byBhIHN0cmluZyBhbmQgcGFzcyBpdCBhbG9uZyB0byBTREsgVUkuXG4gICAgY29uc3QgdGhlbWVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjdXN0b21TdHlsZT8udGhlbWUpO1xuICAgIGNvbnN0IGNvbXBvbmVudE92ZXJyaWRlU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICBjdXN0b21TdHlsZT8uY29tcG9uZW50T3ZlcnJpZGUsXG4gICAgKTtcbiAgICBjb25zdCB0aGVtZU9iamVjdCA9IHtcbiAgICAgIHRoZW1lOiB0aGVtZVN0cmluZyxcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBvbmVudE92ZXJyaWRlT2JqZWN0ID0ge1xuICAgICAgY29tcG9uZW50T3ZlcnJpZGU6IGNvbXBvbmVudE92ZXJyaWRlU3RyaW5nLFxuICAgIH07XG5cbiAgICBpZnJhbWVTcmMgPSBgJHtxdWVyeVN0cmluZy5zdHJpbmdpZnkoYWxsb3lJbml0UGFyYW1zKX0ke1xuICAgICAgZXZhbHVhdGlvbkRhdGEgPyBgJiR7cXVlcnlTdHJpbmcuc3RyaW5naWZ5KGV2YWx1YXRpb25EYXRhKX1gIDogJydcbiAgICB9JHtjb2xvciA/IGAmJHtxdWVyeVN0cmluZy5zdHJpbmdpZnkoY29sb3IpfWAgOiAnJ30ke1xuICAgICAgdGhlbWVPYmplY3QudGhlbWUgPyBgJiR7cXVlcnlTdHJpbmcuc3RyaW5naWZ5KHRoZW1lT2JqZWN0KX1gIDogJydcbiAgICB9JHtcbiAgICAgIGNvbXBvbmVudE92ZXJyaWRlT2JqZWN0LmNvbXBvbmVudE92ZXJyaWRlXG4gICAgICAgID8gYCYke3F1ZXJ5U3RyaW5nLnN0cmluZ2lmeShjb21wb25lbnRPdmVycmlkZU9iamVjdCl9YFxuICAgICAgICA6ICcnXG4gICAgfWA7XG5cbiAgICBpZiAoZXZhbHVhdGlvbkRhdGEpIHtcbiAgICAgIGFsbG95SW5pdFBhcmFtcy5ldmFsdWF0aW9uRGF0YSA9IGV2YWx1YXRpb25EYXRhO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNlbnRyeVRlbGVtZXRyeSkge1xuICAgICAgc2VudHJ5U2NvcGUuY2FwdHVyZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbGxveUluaXRQYXJhbXM7XG59O1xuXG5jb25zdCBnZXRQdWJsaWNVcmwgPSAoKSA9PiB7XG4gIGxldCBwdWJsaWNVcmwgPSBgJHtjb25maWcuY29kZWxlc3N9PyR7aWZyYW1lU3JjfWA7XG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgYWxsb3lJbml0UGFyYW1zLmpvdXJuZXlBcHBsaWNhdGlvblRva2VuICYmXG4gICAgICAhcHVibGljVXJsLmluY2x1ZGVzKCdqb3VybmV5QXBwbGljYXRpb25Ub2tlbicpXG4gICAgKSB7XG4gICAgICBwdWJsaWNVcmwgPSBgJHtjb25maWcuY29kZWxlc3N9PyR7aWZyYW1lU3JjfSZqb3VybmV5QXBwbGljYXRpb25Ub2tlbj0ke2FsbG95SW5pdFBhcmFtcy5qb3VybmV5QXBwbGljYXRpb25Ub2tlbn1gO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNlbnRyeVRlbGVtZXRyeSkge1xuICAgICAgc2VudHJ5U2NvcGUuY2FwdHVyZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHVibGljVXJsO1xufTtcblxuY29uc3Qgb3BlbiA9IChjYjogKGRhdGE6IGFueSkgPT4gdm9pZCwgYW5jaG9yRWxlbWVudD86IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIHJlbW92ZU5ldXJvSWQoKTtcbiAgICBjb25zdCBldmVudExpc3RlbmVyID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGlzQWxsb3lVcmwgPVxuICAgICAgICBldmVudC5vcmlnaW4gPT09ICdodHRwczovL2RvY3YtaWZyYW1lLmFsbG95LmNvJyB8fFxuICAgICAgICBldmVudC5vcmlnaW4gPT09ICdodHRwczovL2FsbG95c2RrLmFsbG95LmNvJyB8fFxuICAgICAgICBldmVudC5vcmlnaW4uaW5jbHVkZXMoJy5hcHAuYWxsb3kuY29tJylcblxuICAgICAgaWYgKCFpc0FsbG95VXJsIHx8ICFhbGxveUNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRMaXN0ZW5lcik7XG4gICAgICBhbGxveUNhbGxiYWNrKGV2ZW50LmRhdGEpO1xuICAgICAgY2xvc2UoKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRMaXN0ZW5lcik7XG4gICAgYWxsb3lDYWxsYmFjayA9IGNiO1xuICAgIGlmICghYWxsb3lJbml0UGFyYW1zLmtleSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdUaGUgQWxsb3kgZnJhbWV3b3JrIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gWW91IGFyZSBtaXNzaW5nIHRoZSBzZGsga2V5IGluIHlvdXIgaW5pdGlhbGl6ZSBwYXJhbWV0ZXJzLicsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbGxveUhlYWRTdHlsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWxsb3ktaWZyYW1lLXN0eWxlJyk7XG4gICAgICBpZiAoIWFsbG95SGVhZFN0eWxlcykge1xuICAgICAgICBkb2N1bWVudC5oZWFkLmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgICAnYmVmb3JlZW5kJyxcbiAgICAgICAgICBgPHN0eWxlIGlkPVwiYWxsb3ktaWZyYW1lLXN0eWxlXCI+XG4gICAgICAgICAgQGtleWZyYW1lcyBmYWRlIHtcbiAgICAgICAgICAgIDAlLCA0MCUgeyBvcGFjaXR5OiAwIH1cbiAgICAgICAgICAgIDgwJSB7IG9wYWNpdHk6IDEgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBAa2V5ZnJhbWVzIHNsaWRlb3BlbiB7XG4gICAgICAgICAgICBmcm9tIHtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogMTAwJTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG8ge1xuICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAwJTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLmFsbG95LWNvbnRhaW5lciB7XG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICB6LWluZGV4OiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICAgICAgICAgIC5hbGxveS1jb250YWluZXIge1xuICAgICAgICAgICAgICBhbmltYXRpb246IHNsaWRlb3BlbiAxcyBsaW5lYXI7XG4gICAgICAgICAgICAgIGhlaWdodDogNzIwcHg7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgICAgICAgIHdpZHRoOiA1MHJlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLmFsbG95LWlmcmFtZSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbjogZmFkZSAxLjVzIGxpbmVhcjtcbiAgICAgICAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICAgIG1heC1oZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICAgICAgICAgICAgLmFsbG95LWlmcmFtZSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMXJlbTtcbiAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDEwcHggMjBweCAwIHJnYmEoNjMsODMsOTIsMC4zKTtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9PC9zdHlsZT5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYWxsb3lJZCk7XG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdhbGxveS1jb250YWluZXInO1xuICAgICAgICBjb25zdCBhbGxveUlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBhbGxveUlmcmFtZS5pZCA9ICdhbGxveUlmcmFtZSc7XG4gICAgICAgIGFsbG95SWZyYW1lLnNyYyA9IGdldFB1YmxpY1VybCgpO1xuICAgICAgICBhbGxveUlmcmFtZS5hbGxvdyA9ICdhdXRvcGxheTsgY2FtZXJhOyBtaWNyb3Bob25lOyBmdWxsc2NyZWVuOyBhY2NlbGVyb21ldGVyOyBtYWduZXRvbWV0ZXI7IGd5cm9zY29wZTsgcGljdHVyZS1pbi1waWN0dXJlJztcbiAgICAgICAgYWxsb3lJZnJhbWUuY2xhc3NOYW1lID0gJ2FsbG95LWlmcmFtZSc7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IGFsbG95SWQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGFsbG95SWZyYW1lKTtcblxuICAgICAgICBpZiAoYW5jaG9yRWxlbWVudCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWxsb3knKSkge1xuICAgICAgICAgIGNvbnN0IGlkQW5jaG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgY29uc3QgY2xhc3NBbmNob3IgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgIGlmIChpZEFuY2hvcikge1xuICAgICAgICAgICAgaWRBbmNob3IuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFxuICAgICAgICAgICAgICAnYWZ0ZXJiZWdpbicsXG4gICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGxveScpISxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc0FuY2hvclswXSkge1xuICAgICAgICAgICAgY2xhc3NBbmNob3JbMF0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFxuICAgICAgICAgICAgICAnYWZ0ZXJiZWdpbicsXG4gICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGxveScpISxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoc2VudHJ5VGVsZW1ldHJ5KSB7XG4gICAgICBzZW50cnlTY29wZS5jYXB0dXJlRXhjZXB0aW9uKGVycik7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBhbGxveTogQWxsb3kgPSB7XG4gIGluaXQsXG4gIG9wZW4sXG4gIGNsb3NlLFxuICBjcmVhdGVKb3VybmV5QXBwbGljYXRpb24sXG4gIGNyZWF0ZUV2YWx1YXRpb24sXG4gIGdldFB1YmxpY1VybCxcbn07XG5leHBvcnQgeyBJbml0IH07XG5cbmV4cG9ydCBkZWZhdWx0IGFsbG95O1xuIl0sIm5hbWVzIjpbInN0cmljdFVyaUVuY29kZSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQxIiwic3BsaXRPbkZpcnN0IiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJERUJVR19CVUlMRCIsImlzRXJyb3JFdmVudCIsIldJTkRPVyIsIndpdGhTY29wZSIsIklOVEVHUkFUSU9OX05BTUUiLCJfc2hvdWxkRHJvcEV2ZW50IiwiX2RlZmF1bHQiLCJ2YWxpZGF0ZV8xIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInN0cmluZ2lmeV8xIiwiX3ZhbGlkYXRlIiwidjFfMSIsIl9ybmciLCJfc3RyaW5naWZ5IiwicGFyc2VfMSIsInYzNV8xIiwiVVJMIiwidjNfMSIsIl92IiwidjRfMSIsInY1XzEiLCJ2ZXJzaW9uXzEiLCJ2ZXJzaW9uIiwicmVxdWlyZSQkNCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsInJlcXVpcmUkJDgiLCJ1dWlkdjQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQ0EsSUFBQSxlQUFjLEdBQUcsR0FBRyxJQUFJLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQzs7SUNBMUgsSUFBSSxLQUFLLEdBQUcsY0FBYyxDQUFDO0lBQzNCLElBQUksYUFBYSxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pFLElBQUksWUFBWSxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hEO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFO0lBQzdDLENBQUMsSUFBSTtJQUNMO0lBQ0EsRUFBRSxPQUFPLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkQsRUFBRSxDQUFDLE9BQU8sR0FBRyxFQUFFO0lBQ2Y7SUFDQSxFQUFFO0FBQ0Y7SUFDQSxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDOUIsRUFBRSxPQUFPLFVBQVUsQ0FBQztJQUNwQixFQUFFO0FBQ0Y7SUFDQSxDQUFDLEtBQUssR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQ3BCO0lBQ0E7SUFDQSxDQUFDLElBQUksSUFBSSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3ZDLENBQUMsSUFBSSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQztJQUNBLENBQUMsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDekYsQ0FBQztBQUNEO0lBQ0EsU0FBUyxNQUFNLENBQUMsS0FBSyxFQUFFO0lBQ3ZCLENBQUMsSUFBSTtJQUNMLEVBQUUsT0FBTyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQyxFQUFFLENBQUMsT0FBTyxHQUFHLEVBQUU7SUFDZixFQUFFLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2hEO0lBQ0EsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUMxQyxHQUFHLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hEO0lBQ0EsR0FBRyxNQUFNLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDN0MsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLEVBQUU7SUFDRixDQUFDO0FBQ0Q7SUFDQSxTQUFTLHdCQUF3QixDQUFDLEtBQUssRUFBRTtJQUN6QztJQUNBLENBQUMsSUFBSSxVQUFVLEdBQUc7SUFDbEIsRUFBRSxRQUFRLEVBQUUsY0FBYztJQUMxQixFQUFFLFFBQVEsRUFBRSxjQUFjO0lBQzFCLEVBQUUsQ0FBQztBQUNIO0lBQ0EsQ0FBQyxJQUFJLEtBQUssR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3RDLENBQUMsT0FBTyxLQUFLLEVBQUU7SUFDZixFQUFFLElBQUk7SUFDTjtJQUNBLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELEdBQUcsQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNoQixHQUFHLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqQztJQUNBLEdBQUcsSUFBSSxNQUFNLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQzVCLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUNsQyxJQUFJO0lBQ0osR0FBRztBQUNIO0lBQ0EsRUFBRSxLQUFLLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQyxFQUFFO0FBQ0Y7SUFDQTtJQUNBLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQztBQUM5QjtJQUNBLENBQUMsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUN2QztJQUNBLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDMUM7SUFDQSxFQUFFLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QixFQUFFLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvRCxFQUFFO0FBQ0Y7SUFDQSxDQUFDLE9BQU8sS0FBSyxDQUFDO0lBQ2QsQ0FBQztBQUNEO1FBQ0Esa0JBQWMsR0FBRyxVQUFVLFVBQVUsRUFBRTtJQUN2QyxDQUFDLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxFQUFFO0lBQ3JDLEVBQUUsTUFBTSxJQUFJLFNBQVMsQ0FBQyxxREFBcUQsR0FBRyxPQUFPLFVBQVUsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUN2RyxFQUFFO0FBQ0Y7SUFDQSxDQUFDLElBQUk7SUFDTCxFQUFFLFVBQVUsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztBQUM5QztJQUNBO0lBQ0EsRUFBRSxPQUFPLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3hDLEVBQUUsQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNmO0lBQ0EsRUFBRSxPQUFPLHdCQUF3QixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzlDLEVBQUU7SUFDRixDQUFDOztJQzNGRCxJQUFBLFlBQWMsR0FBRyxDQUFDLE1BQU0sRUFBRSxTQUFTLEtBQUs7SUFDeEMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsQ0FBQyxFQUFFO0lBQ3JFLEVBQUUsTUFBTSxJQUFJLFNBQVMsQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO0lBQ3ZFLEVBQUU7QUFDRjtJQUNBLENBQUMsSUFBSSxTQUFTLEtBQUssRUFBRSxFQUFFO0lBQ3ZCLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xCLEVBQUU7QUFDRjtJQUNBLENBQUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNsRDtJQUNBLENBQUMsSUFBSSxjQUFjLEtBQUssQ0FBQyxDQUFDLEVBQUU7SUFDNUIsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEIsRUFBRTtBQUNGO0lBQ0EsQ0FBQyxPQUFPO0lBQ1IsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUM7SUFDakMsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO0lBQ2pELEVBQUUsQ0FBQztJQUNILENBQUM7O0lDcEJELElBQUEsU0FBYyxHQUFHLFVBQVUsR0FBRyxFQUFFLFNBQVMsRUFBRTtJQUMzQyxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztJQUNkLENBQUMsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QixDQUFDLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDdEM7SUFDQSxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0lBQ3ZDLEVBQUUsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLEVBQUUsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCO0lBQ0EsRUFBRSxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFO0lBQ3hFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNsQixHQUFHO0lBQ0gsRUFBRTtBQUNGO0lBQ0EsQ0FBQyxPQUFPLEdBQUcsQ0FBQztJQUNaLENBQUM7OztLQ2ZELE1BQU1BLGlCQUFlLEdBQUdDLGVBQTRCLENBQUM7S0FDckQsTUFBTSxlQUFlLEdBQUdDLGtCQUErQixDQUFDO0tBQ3hELE1BQU1DLGNBQVksR0FBR0MsWUFBeUIsQ0FBQztLQUMvQyxNQUFNLFlBQVksR0FBR0MsU0FBcUIsQ0FBQztBQUMzQztLQUNBLE1BQU0saUJBQWlCLEdBQUcsS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUN6RTtLQUNBLFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFO01BQ3ZDLFFBQVEsT0FBTyxDQUFDLFdBQVc7SUFDNUIsR0FBRSxLQUFLLE9BQU87SUFDZCxJQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssS0FBSztJQUNwQyxLQUFJLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEM7U0FDSTtVQUNDLEtBQUssS0FBSyxTQUFTO0lBQ3hCLE9BQU0sT0FBTyxDQUFDLFFBQVEsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDO0lBQ3pDLE9BQU0sT0FBTyxDQUFDLGVBQWUsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDO1dBQ3hDO1VBQ0QsT0FBTyxNQUFNLENBQUM7VUFDZDtBQUNMO0lBQ0EsS0FBSSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7VUFDbkIsT0FBTyxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1VBQ3JFO0FBQ0w7SUFDQSxLQUFJLE9BQU87SUFDWCxNQUFLLEdBQUcsTUFBTTtJQUNkLE1BQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUMvRixNQUFLLENBQUM7SUFDTixLQUFJLENBQUM7QUFDTDtJQUNBLEdBQUUsS0FBSyxTQUFTO0lBQ2hCLElBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxLQUFLO1NBQ2hDO1VBQ0MsS0FBSyxLQUFLLFNBQVM7SUFDeEIsT0FBTSxPQUFPLENBQUMsUUFBUSxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUM7SUFDekMsT0FBTSxPQUFPLENBQUMsZUFBZSxJQUFJLEtBQUssS0FBSyxFQUFFLENBQUM7V0FDeEM7VUFDRCxPQUFPLE1BQU0sQ0FBQztVQUNkO0FBQ0w7SUFDQSxLQUFJLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTtVQUNuQixPQUFPLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1VBQzFEO0FBQ0w7SUFDQSxLQUFJLE9BQU8sQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2RixLQUFJLENBQUM7QUFDTDtPQUNFLEtBQUssT0FBTyxDQUFDO0lBQ2YsR0FBRSxLQUFLLFdBQVc7SUFDbEIsSUFBRyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEtBQUs7SUFDcEMsS0FBSSxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtVQUNoRSxPQUFPLE1BQU0sQ0FBQztVQUNkO0FBQ0w7SUFDQSxLQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7VUFDeEIsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1VBQ3RFO0FBQ0w7U0FDSSxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO0lBQ2pGLEtBQUksQ0FBQztBQUNMO09BQ0U7SUFDRixJQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssS0FBSztTQUNoQztVQUNDLEtBQUssS0FBSyxTQUFTO0lBQ3hCLE9BQU0sT0FBTyxDQUFDLFFBQVEsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDO0lBQ3pDLE9BQU0sT0FBTyxDQUFDLGVBQWUsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDO1dBQ3hDO1VBQ0QsT0FBTyxNQUFNLENBQUM7VUFDZDtBQUNMO0lBQ0EsS0FBSSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7SUFDeEIsTUFBSyxPQUFPLENBQUMsR0FBRyxNQUFNLEVBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1VBQ3pDO0FBQ0w7SUFDQSxLQUFJLE9BQU8sQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNyRixLQUFJLENBQUM7T0FDSDtNQUNEO0FBQ0Q7S0FDQSxTQUFTLG9CQUFvQixDQUFDLE9BQU8sRUFBRTtNQUN0QyxJQUFJLE1BQU0sQ0FBQztBQUNaO01BQ0MsUUFBUSxPQUFPLENBQUMsV0FBVztJQUM1QixHQUFFLEtBQUssT0FBTztJQUNkLElBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxLQUFLO1NBQ25DLE1BQU0sR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BDO1NBQ0ksR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDO1NBQ0ksSUFBSSxDQUFDLE1BQU0sRUFBRTtJQUNqQixNQUFLLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDOUIsTUFBSyxPQUFPO1VBQ1A7QUFDTDtJQUNBLEtBQUksSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUFFO0lBQ3hDLE1BQUssV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztVQUN0QjtBQUNMO0lBQ0EsS0FBSSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3hDLEtBQUksQ0FBQztBQUNMO0lBQ0EsR0FBRSxLQUFLLFNBQVM7SUFDaEIsSUFBRyxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEtBQUs7U0FDbkMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDN0IsR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ25DO1NBQ0ksSUFBSSxDQUFDLE1BQU0sRUFBRTtJQUNqQixNQUFLLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDOUIsTUFBSyxPQUFPO1VBQ1A7QUFDTDtJQUNBLEtBQUksSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUFFO1VBQ25DLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hDLE1BQUssT0FBTztVQUNQO0FBQ0w7SUFDQSxLQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxRCxLQUFJLENBQUM7QUFDTDtPQUNFLEtBQUssT0FBTyxDQUFDO0lBQ2YsR0FBRSxLQUFLLFdBQVc7SUFDbEIsSUFBRyxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEtBQUs7SUFDdkMsS0FBSSxNQUFNLE9BQU8sR0FBRyxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUMxRixNQUFNLGNBQWMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztJQUNwSSxLQUFJLEtBQUssR0FBRyxjQUFjLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDNUQsS0FBSSxNQUFNLFFBQVEsR0FBRyxPQUFPLElBQUksY0FBYyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksR0FBRyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNoTCxLQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUM7SUFDaEMsS0FBSSxDQUFDO0FBQ0w7T0FDRTtJQUNGLElBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxLQUFLO0lBQ3ZDLEtBQUksSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUFFO0lBQ3hDLE1BQUssV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUM5QixNQUFLLE9BQU87VUFDUDtBQUNMO0lBQ0EsS0FBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDMUQsS0FBSSxDQUFDO09BQ0g7TUFDRDtBQUNEO0tBQ0EsU0FBUyw0QkFBNEIsQ0FBQyxLQUFLLEVBQUU7TUFDNUMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDdEQsR0FBRSxNQUFNLElBQUksU0FBUyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7T0FDNUU7TUFDRDtBQUNEO0lBQ0EsQ0FBQSxTQUFTLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0lBQ2hDLEVBQUMsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0lBQ3JCLEdBQUUsT0FBTyxPQUFPLENBQUMsTUFBTSxHQUFHTCxpQkFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO09BQzNFO0FBQ0Y7TUFDQyxPQUFPLEtBQUssQ0FBQztNQUNiO0FBQ0Q7SUFDQSxDQUFBLFNBQVMsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUU7SUFDaEMsRUFBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7SUFDckIsR0FBRSxPQUFPLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztPQUM5QjtBQUNGO01BQ0MsT0FBTyxLQUFLLENBQUM7TUFDYjtBQUNEO0tBQ0EsU0FBUyxVQUFVLENBQUMsS0FBSyxFQUFFO0lBQzNCLEVBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzNCLEdBQUUsT0FBTyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7T0FDcEI7QUFDRjtJQUNBLEVBQUMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7T0FDOUIsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxLQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQyxHQUFHLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO09BQ3pCO0FBQ0Y7TUFDQyxPQUFPLEtBQUssQ0FBQztNQUNiO0FBQ0Q7S0FDQSxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUU7TUFDMUIsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxFQUFDLElBQUksU0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFFO09BQ3JCLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztPQUNsQztBQUNGO01BQ0MsT0FBTyxLQUFLLENBQUM7TUFDYjtBQUNEO0tBQ0EsU0FBUyxPQUFPLENBQUMsR0FBRyxFQUFFO0lBQ3RCLEVBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO01BQ2QsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNwQyxFQUFDLElBQUksU0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFFO09BQ3JCLElBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO09BQzVCO0FBQ0Y7TUFDQyxPQUFPLElBQUksQ0FBQztNQUNaO0FBQ0Q7S0FDQSxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUU7SUFDeEIsRUFBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQzFCLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkMsRUFBQyxJQUFJLFVBQVUsS0FBSyxDQUFDLENBQUMsRUFBRTtPQUN0QixPQUFPLEVBQUUsQ0FBQztPQUNWO0FBQ0Y7TUFDQyxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO01BQ25DO0FBQ0Q7SUFDQSxDQUFBLFNBQVMsVUFBVSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUU7SUFDcEMsRUFBQyxJQUFJLE9BQU8sQ0FBQyxZQUFZLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUU7SUFDakgsR0FBRSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO09BQ3RCLE1BQU0sSUFBSSxPQUFPLENBQUMsYUFBYSxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU0sSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFLEtBQUssT0FBTyxDQUFDLEVBQUU7T0FDMUgsS0FBSyxHQUFHLEtBQUssQ0FBQyxXQUFXLEVBQUUsS0FBSyxNQUFNLENBQUM7T0FDdkM7QUFDRjtNQUNDLE9BQU8sS0FBSyxDQUFDO01BQ2I7QUFDRDtJQUNBLENBQUEsU0FBUyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRTtJQUMvQixFQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO09BQ3ZCLE1BQU0sRUFBRSxJQUFJO09BQ1osSUFBSSxFQUFFLElBQUk7T0FDVixXQUFXLEVBQUUsTUFBTTtPQUNuQixvQkFBb0IsRUFBRSxHQUFHO09BQ3pCLFlBQVksRUFBRSxLQUFLO09BQ25CLGFBQWEsRUFBRSxLQUFLO09BQ3BCLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDYjtJQUNBLEVBQUMsNEJBQTRCLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDNUQ7SUFDQSxFQUFDLE1BQU0sU0FBUyxHQUFHLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ2pEO0lBQ0E7TUFDQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDO0lBQ0EsRUFBQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtPQUM5QixPQUFPLEdBQUcsQ0FBQztPQUNYO0FBQ0Y7SUFDQSxFQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM1QztNQUNDLElBQUksQ0FBQyxLQUFLLEVBQUU7T0FDWCxPQUFPLEdBQUcsQ0FBQztPQUNYO0FBQ0Y7TUFDQyxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDdkMsR0FBRSxJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7SUFDcEIsSUFBRyxTQUFTO1FBQ1Q7QUFDSDtPQUNFLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUdHLGNBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMzRjtJQUNBO0lBQ0E7SUFDQSxHQUFFLEtBQUssR0FBRyxLQUFLLEtBQUssU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzdILEdBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO09BQzVDO0FBQ0Y7TUFDQyxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDckMsR0FBRSxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDdkIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTtRQUNoRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDdkMsS0FBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUN6QztJQUNKLElBQUcsTUFBTTtRQUNOLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDO09BQ0Q7QUFDRjtJQUNBLEVBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLEtBQUssRUFBRTtPQUMzQixPQUFPLEdBQUcsQ0FBQztPQUNYO0FBQ0Y7SUFDQSxFQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxLQUFLO0lBQ3hILEdBQUUsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLEdBQUUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUM1RTtRQUNHLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsSUFBRyxNQUFNO0lBQ1QsSUFBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ3BCO0FBQ0g7T0FDRSxPQUFPLE1BQU0sQ0FBQztPQUNkLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO01BQ3hCO0FBQ0Q7SUFDQSxDQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQWtCLE9BQU8sQ0FBQztJQUMxQixDQUFBLE9BQUEsQ0FBQSxLQUFBLEdBQWdCLEtBQUssQ0FBQztBQUN0QjtJQUNBLENBQUEsT0FBQSxDQUFBLFNBQUEsR0FBb0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxLQUFLO01BQ3hDLElBQUksQ0FBQyxNQUFNLEVBQUU7T0FDWixPQUFPLEVBQUUsQ0FBQztPQUNWO0FBQ0Y7SUFDQSxFQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO09BQ3ZCLE1BQU0sRUFBRSxJQUFJO09BQ1osTUFBTSxFQUFFLElBQUk7T0FDWixXQUFXLEVBQUUsTUFBTTtPQUNuQixvQkFBb0IsRUFBRSxHQUFHO09BQ3pCLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDYjtJQUNBLEVBQUMsNEJBQTRCLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDNUQ7TUFDQyxNQUFNLFlBQVksR0FBRyxHQUFHO09BQ3ZCLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEQsT0FBTyxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2pELEdBQUUsQ0FBQztBQUNIO0lBQ0EsRUFBQyxNQUFNLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNsRDtJQUNBLEVBQUMsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCO01BQ0MsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQ3hDLEdBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN2QixVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlCO09BQ0Q7QUFDRjtNQUNDLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDdEM7SUFDQSxFQUFDLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxLQUFLLEVBQUU7T0FDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDeEI7QUFDRjtJQUNBLEVBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSTtJQUN4QixHQUFFLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1QjtJQUNBLEdBQUUsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ3hCLE9BQU8sRUFBRSxDQUFDO1FBQ1Y7QUFDSDtJQUNBLEdBQUUsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO0lBQ3RCLElBQUcsT0FBTyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQzVCO0FBQ0g7SUFDQSxHQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUM1QixJQUFHLE9BQU8sS0FBSztVQUNWLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQy9CLE1BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1o7QUFDSDtJQUNBLEdBQUUsT0FBTyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzdELEdBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEMsRUFBQyxDQUFDO0FBQ0Y7SUFDQSxDQUFBLE9BQUEsQ0FBQSxRQUFBLEdBQW1CLENBQUMsR0FBRyxFQUFFLE9BQU8sS0FBSztJQUNyQyxFQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO09BQ3ZCLE1BQU0sRUFBRSxJQUFJO09BQ1osRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNiO0lBQ0EsRUFBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHQSxjQUFZLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzdDO01BQ0MsT0FBTyxNQUFNLENBQUMsTUFBTTtPQUNuQjtJQUNGLElBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTtRQUM3QixLQUFLLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUM7UUFDbkM7SUFDSCxHQUFFLE9BQU8sSUFBSSxPQUFPLENBQUMsdUJBQXVCLElBQUksSUFBSSxHQUFHLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUU7SUFDdkcsR0FBRSxDQUFDO0lBQ0gsRUFBQyxDQUFDO0FBQ0Y7SUFDQSxDQUFBLE9BQUEsQ0FBQSxZQUFBLEdBQXVCLENBQUMsTUFBTSxFQUFFLE9BQU8sS0FBSztJQUM1QyxFQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO09BQ3ZCLE1BQU0sRUFBRSxJQUFJO09BQ1osTUFBTSxFQUFFLElBQUk7T0FDWixFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2I7SUFDQSxFQUFDLE1BQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztNQUN2RCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsRCxFQUFDLE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUN2RTtJQUNBLEVBQUMsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDOUQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7TUFDcEQsSUFBSSxXQUFXLEVBQUU7T0FDaEIsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7T0FDaEM7QUFDRjtNQUNDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEMsRUFBQyxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRTtJQUNoQyxHQUFFLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUN4RDtBQUNGO0lBQ0EsRUFBQyxPQUFPLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLEVBQUMsQ0FBQztBQUNGO0lBQ0EsQ0FBQSxPQUFBLENBQUEsSUFBQSxHQUFlLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEtBQUs7SUFDM0MsRUFBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztPQUN2Qix1QkFBdUIsRUFBRSxJQUFJO09BQzdCLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDYjtJQUNBLEVBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsa0JBQWtCLENBQUMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRSxFQUFDLE9BQU8sT0FBTyxDQUFDLFlBQVksQ0FBQztJQUM3QixHQUFFLEdBQUc7SUFDTCxHQUFFLEtBQUssRUFBRSxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQztJQUNwQyxHQUFFLGtCQUFrQjtPQUNsQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2IsRUFBQyxDQUFDO0FBQ0Y7SUFDQSxDQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQWtCLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEtBQUs7SUFDOUMsRUFBQyxNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNwSDtNQUNDLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDO01BQ3JELENBQUE7Ozs7O0lDblpEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNRyxhQUFXLElBQUksT0FBTyxnQkFBZ0IsS0FBSyxXQUFXLElBQUksZ0JBQWdCLENBQUM7O0lDTGpGO0FBQ0E7SUFDQTtJQUNBLE1BQU0sVUFBVSxHQUFHLFVBQVU7O0lDSDdCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNQSxhQUFXLElBQUksT0FBTyxnQkFBZ0IsS0FBSyxXQUFXLElBQUksZ0JBQWdCLENBQUM7O0lDTGpGO0FBQ0E7SUFDQSxNQUFNLFdBQVcsR0FBRyxRQUFROztJQ0M1QjtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsR0FBRztJQUMxQjtJQUNBLEVBQUUsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0IsRUFBRSxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0FBQ0Q7SUFDQTtJQUNBLFNBQVMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFO0lBQ25DLEVBQUUsTUFBTSxVQUFVLElBQUksT0FBTyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ3JFO0lBQ0E7SUFDQSxFQUFFLFVBQVUsQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sSUFBSSxXQUFXLENBQUM7QUFDekQ7SUFDQTtJQUNBO0lBQ0EsRUFBRSxRQUFRLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxFQUFFO0lBQ25FLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQjtJQUMzQixFQUFFLElBQUk7SUFDTixFQUFFLE9BQU87SUFDVCxFQUFFLEdBQUcsR0FBRyxVQUFVO0lBQ2xCLEVBQUU7SUFDRixFQUFFLE1BQU0sVUFBVSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM3RCxFQUFFLE1BQU0sT0FBTyxJQUFJLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDNUU7SUFDQSxFQUFFLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3REOztJQ2pEQTtJQUNBLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDO0FBQ2hDO0lBQ0EsTUFBTSxjQUFjLEdBQUc7SUFDdkIsRUFBRSxPQUFPO0lBQ1QsRUFBRSxNQUFNO0lBQ1IsRUFBRSxNQUFNO0lBQ1IsRUFBRSxPQUFPO0lBQ1QsRUFBRSxLQUFLO0lBQ1AsRUFBRSxRQUFRO0lBQ1YsRUFBRSxPQUFPO0lBQ1QsQ0FBQyxFQUFFO0FBQ0g7SUFDQTtJQUNBLE1BQU0sc0JBQXNCO0FBQzVCO0lBQ0EsR0FBRyxFQUFFLENBQUM7QUFDTjtJQUNBO0FBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxRQUFRLEVBQUU7SUFDbEMsRUFBRSxJQUFJLEVBQUUsU0FBUyxJQUFJLFVBQVUsQ0FBQyxFQUFFO0lBQ2xDLElBQUksT0FBTyxRQUFRLEVBQUUsQ0FBQztJQUN0QixHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLEVBQUU7SUFDdEMsRUFBRSxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDMUI7SUFDQSxFQUFFLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsRUFBRTtBQUM3RDtJQUNBO0lBQ0EsRUFBRSxhQUFhLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSTtJQUNqQyxJQUFJLE1BQU0scUJBQXFCLEdBQUcsc0JBQXNCLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDakUsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzFDLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLHFCQUFxQixDQUFDO0lBQzNDLEdBQUcsQ0FBQyxDQUFDO0FBQ0w7SUFDQSxFQUFFLElBQUk7SUFDTixJQUFJLE9BQU8sUUFBUSxFQUFFLENBQUM7SUFDdEIsR0FBRyxTQUFTO0lBQ1o7SUFDQSxJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJO0lBQ25DLE1BQU0sT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUM1QyxLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLFVBQVUsR0FBRztJQUN0QixFQUFFLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN0QixFQUFFLE1BQU0sTUFBTSxHQUFHO0lBQ2pCLElBQUksTUFBTSxFQUFFLE1BQU07SUFDbEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ3JCLEtBQUs7SUFDTCxJQUFJLE9BQU8sRUFBRSxNQUFNO0lBQ25CLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN0QixLQUFLO0lBQ0wsSUFBSSxTQUFTLEVBQUUsTUFBTSxPQUFPO0lBQzVCLEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxJQUFJQSxhQUFXLEVBQUU7SUFDbkIsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSTtJQUNuQyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxLQUFLO0lBQ2xDLFFBQVEsSUFBSSxPQUFPLEVBQUU7SUFDckIsVUFBVSxjQUFjLENBQUMsTUFBTTtJQUMvQixZQUFZLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDckUsV0FBVyxDQUFDLENBQUM7SUFDYixTQUFTO0lBQ1QsT0FBTyxDQUFDO0lBQ1IsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHLE1BQU07SUFDVCxJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJO0lBQ25DLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sU0FBUyxDQUFDO0lBQ3JDLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLE1BQU0sRUFBRTtJQUNqQixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sTUFBTSxHQUFHLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUM7O0lDNUZ2RCxNQUFNLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztJQUM3QjtJQUNBLE1BQU0sb0JBQW9CLEdBQUcsaUJBQWlCLENBQUM7SUFDL0MsTUFBTSxrQkFBa0IsR0FBRyxpQ0FBaUMsQ0FBQztBQUM3RDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxHQUFHLE9BQU8sRUFBRTtJQUN2QyxFQUFFLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNFO0lBQ0EsRUFBRSxPQUFPLENBQUMsS0FBSyxFQUFFLGNBQWMsR0FBRyxDQUFDLEVBQUUsV0FBVyxHQUFHLENBQUMsS0FBSztJQUN6RCxJQUFJLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUN0QixJQUFJLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEM7SUFDQSxJQUFJLEtBQUssSUFBSSxDQUFDLEdBQUcsY0FBYyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0lBQ3hELE1BQU0sTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQzdCO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxFQUFFO0lBQzlCLFFBQVEsU0FBUztJQUNqQixPQUFPO0FBQ1A7SUFDQTtJQUNBO0lBQ0EsTUFBTSxNQUFNLFdBQVcsR0FBRyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDNUc7SUFDQTtJQUNBO0lBQ0EsTUFBTSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUU7SUFDM0MsUUFBUSxTQUFTO0lBQ2pCLE9BQU87QUFDUDtJQUNBLE1BQU0sS0FBSyxNQUFNLE1BQU0sSUFBSSxhQUFhLEVBQUU7SUFDMUMsUUFBUSxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDMUM7SUFDQSxRQUFRLElBQUksS0FBSyxFQUFFO0lBQ25CLFVBQVUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixVQUFVLE1BQU07SUFDaEIsU0FBUztJQUNULE9BQU87QUFDUDtJQUNBLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLHNCQUFzQixHQUFHLFdBQVcsRUFBRTtJQUNqRSxRQUFRLE1BQU07SUFDZCxPQUFPO0lBQ1AsS0FBSztBQUNMO0lBQ0EsSUFBSSxPQUFPLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUNsRSxHQUFHLENBQUM7SUFDSixDQUFDO0FBY0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLDJCQUEyQixDQUFDLEtBQUssRUFBRTtJQUM1QyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO0lBQ3JCLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkM7SUFDQTtJQUNBLEVBQUUsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRTtJQUMxRSxJQUFJLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNyQixHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3ZCO0lBQ0E7SUFDQSxFQUFFLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRTtJQUM3RSxJQUFJLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxJQUFJLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRTtJQUMvRSxNQUFNLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUN2QixLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssS0FBSztJQUNuRSxJQUFJLEdBQUcsS0FBSztJQUNaLElBQUksUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRLElBQUksaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsUUFBUTtJQUN0RSxJQUFJLFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUSxJQUFJLGdCQUFnQjtJQUNoRCxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ04sQ0FBQztBQUNEO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7SUFDaEMsRUFBRSxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0FBQ0Q7SUFDQSxNQUFNLG1CQUFtQixHQUFHLGFBQWEsQ0FBQztBQUMxQztJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZUFBZSxDQUFDLEVBQUUsRUFBRTtJQUM3QixFQUFFLElBQUk7SUFDTixJQUFJLElBQUksQ0FBQyxFQUFFLElBQUksT0FBTyxFQUFFLEtBQUssVUFBVSxFQUFFO0lBQ3pDLE1BQU0sT0FBTyxtQkFBbUIsQ0FBQztJQUNqQyxLQUFLO0lBQ0wsSUFBSSxPQUFPLEVBQUUsQ0FBQyxJQUFJLElBQUksbUJBQW1CLENBQUM7SUFDMUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2Q7SUFDQTtJQUNBLElBQUksT0FBTyxtQkFBbUIsQ0FBQztJQUMvQixHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUU7SUFDbkMsRUFBRSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO0FBQ3BDO0lBQ0EsRUFBRSxJQUFJLFNBQVMsRUFBRTtJQUNqQixJQUFJLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUN0QixJQUFJLElBQUk7SUFDUjtJQUNBLE1BQU0sU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJO0lBQ3hDO0lBQ0EsUUFBUSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO0lBQ3JDO0lBQ0EsVUFBVSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsRCxTQUFTO0lBQ1QsT0FBTyxDQUFDLENBQUM7SUFDVCxNQUFNLE9BQU8sTUFBTSxDQUFDO0lBQ3BCLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNsQixNQUFNLE9BQU8sU0FBUyxDQUFDO0lBQ3ZCLEtBQUs7SUFDTCxHQUFHO0lBQ0gsRUFBRSxPQUFPLFNBQVMsQ0FBQztJQUNuQjs7SUM3SkE7SUFDQSxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDcEIsTUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQ3hCO0lBQ0E7SUFDQSxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFO0lBQ25DLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDeEMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEMsQ0FBQztBQVdEO0lBQ0E7SUFDQSxTQUFTLGVBQWUsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFO0lBQzdDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUMzQixJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDOUIsSUFBSSxJQUFJO0lBQ1IsTUFBTSxZQUFZLEVBQUUsQ0FBQztJQUNyQixLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDaEIsTUFBTUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQywwQkFBMEIsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFFLEtBQUs7SUFDTCxHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFO0lBQ3JDLEVBQUUsTUFBTSxZQUFZLEdBQUcsSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDckIsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0EsRUFBRSxLQUFLLE1BQU0sT0FBTyxJQUFJLFlBQVksRUFBRTtJQUN0QyxJQUFJLElBQUk7SUFDUixNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDaEIsTUFBTUEsYUFBVztJQUNqQixRQUFRLE1BQU0sQ0FBQyxLQUFLO0lBQ3BCLFVBQVUsQ0FBQyx1REFBdUQsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUM7SUFDckgsVUFBVSxDQUFDO0lBQ1gsU0FBUyxDQUFDO0lBQ1YsS0FBSztJQUNMLEdBQUc7SUFDSDs7SUNuREEsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLENBQUM7QUFDOUI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG9DQUFvQyxDQUFDLE9BQU8sRUFBRTtJQUN2RCxFQUFFLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQztJQUN2QixFQUFFLFVBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUIsRUFBRSxlQUFlLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7QUFDRDtJQUNBLFNBQVMsZUFBZSxHQUFHO0lBQzNCLEVBQUUsa0JBQWtCLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztBQUMxQztJQUNBO0lBQ0E7SUFDQSxFQUFFLFVBQVUsQ0FBQyxPQUFPLEdBQUc7SUFDdkIsSUFBSSxHQUFHO0lBQ1AsSUFBSSxHQUFHO0lBQ1AsSUFBSSxJQUFJO0lBQ1IsSUFBSSxNQUFNO0lBQ1YsSUFBSSxLQUFLO0lBQ1QsSUFBSTtJQUNKLElBQUksTUFBTSxXQUFXLEdBQUc7SUFDeEIsTUFBTSxNQUFNO0lBQ1osTUFBTSxLQUFLO0lBQ1gsTUFBTSxJQUFJO0lBQ1YsTUFBTSxHQUFHO0lBQ1QsTUFBTSxHQUFHO0lBQ1QsS0FBSyxDQUFDO0lBQ04sSUFBSSxlQUFlLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQzFDO0lBQ0EsSUFBSSxJQUFJLGtCQUFrQixFQUFFO0lBQzVCO0lBQ0EsTUFBTSxPQUFPLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdkQsS0FBSztBQUNMO0lBQ0EsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHLENBQUM7QUFDSjtJQUNBLEVBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUM7SUFDcEQ7O0lDNUNBLElBQUksK0JBQStCLEdBQUcsSUFBSSxDQUFDO0FBQzNDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpREFBaUQ7SUFDMUQsRUFBRSxPQUFPO0lBQ1QsRUFBRTtJQUNGLEVBQUUsTUFBTSxJQUFJLEdBQUcsb0JBQW9CLENBQUM7SUFDcEMsRUFBRSxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVCLEVBQUUsZUFBZSxDQUFDLElBQUksRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO0lBQ3RELENBQUM7QUFDRDtJQUNBLFNBQVMsNEJBQTRCLEdBQUc7SUFDeEMsRUFBRSwrQkFBK0IsR0FBRyxVQUFVLENBQUMsb0JBQW9CLENBQUM7QUFDcEU7SUFDQTtJQUNBO0lBQ0EsRUFBRSxVQUFVLENBQUMsb0JBQW9CLEdBQUcsVUFBVSxDQUFDLEVBQUU7SUFDakQsSUFBSSxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUM7SUFDMUIsSUFBSSxlQUFlLENBQUMsb0JBQW9CLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDdkQ7SUFDQSxJQUFJLElBQUksK0JBQStCLEVBQUU7SUFDekM7SUFDQSxNQUFNLE9BQU8sK0JBQStCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNwRSxLQUFLO0FBQ0w7SUFDQSxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxVQUFVLENBQUMsb0JBQW9CLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDO0lBQ2pFOztJQ3JDQTtJQUNBLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBQ2pEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE9BQU8sQ0FBQyxHQUFHLEVBQUU7SUFDdEIsRUFBRSxRQUFRLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ2xDLElBQUksS0FBSyxnQkFBZ0IsQ0FBQztJQUMxQixJQUFJLEtBQUssb0JBQW9CLENBQUM7SUFDOUIsSUFBSSxLQUFLLHVCQUF1QixDQUFDO0lBQ2pDLElBQUksS0FBSyxnQ0FBZ0M7SUFDekMsTUFBTSxPQUFPLElBQUksQ0FBQztJQUNsQixJQUFJO0lBQ0osTUFBTSxPQUFPLFlBQVksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEMsR0FBRztJQUNILENBQUM7SUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsU0FBUyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUU7SUFDbkMsRUFBRSxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBU0MsY0FBWSxDQUFDLEdBQUcsRUFBRTtJQUMzQixFQUFFLE9BQU8sU0FBUyxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0QyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtJQUN6QixFQUFFLE9BQU8sU0FBUyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNwQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLEdBQUcsRUFBRTtJQUM3QixFQUFFLE9BQU8sU0FBUyxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN4QyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsUUFBUSxDQUFDLEdBQUcsRUFBRTtJQUN2QixFQUFFLE9BQU8sU0FBUyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNsQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMscUJBQXFCLENBQUMsR0FBRyxFQUFFO0lBQ3BDLEVBQUU7SUFDRixJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVE7SUFDM0IsSUFBSSxHQUFHLEtBQUssSUFBSTtJQUNoQixJQUFJLDRCQUE0QixJQUFJLEdBQUc7SUFDdkMsSUFBSSw0QkFBNEIsSUFBSSxHQUFHO0lBQ3ZDLElBQUk7SUFDSixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLEdBQUcsRUFBRTtJQUMxQixFQUFFLE9BQU8sR0FBRyxLQUFLLElBQUksSUFBSSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsS0FBSyxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksT0FBTyxHQUFHLEtBQUssVUFBVSxDQUFDLENBQUM7SUFDOUcsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGFBQWEsQ0FBQyxHQUFHLEVBQUU7SUFDNUIsRUFBRSxPQUFPLFNBQVMsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDbEMsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE9BQU8sQ0FBQyxHQUFHLEVBQUU7SUFDdEIsRUFBRSxPQUFPLE9BQU8sS0FBSyxLQUFLLFdBQVcsSUFBSSxZQUFZLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2xFLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxTQUFTLENBQUMsR0FBRyxFQUFFO0lBQ3hCLEVBQUUsT0FBTyxPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksWUFBWSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RSxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsUUFBUSxDQUFDLEdBQUcsRUFBRTtJQUN2QixFQUFFLE9BQU8sU0FBUyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNsQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtJQUN6QjtJQUNBLEVBQUUsT0FBTyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksSUFBSSxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLENBQUM7SUFDOUQsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQixDQUFDLEdBQUcsRUFBRTtJQUMvQixFQUFFLE9BQU8sYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGFBQWEsSUFBSSxHQUFHLElBQUksZ0JBQWdCLElBQUksR0FBRyxJQUFJLGlCQUFpQixJQUFJLEdBQUcsQ0FBQztJQUMzRyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRTtJQUNqQyxFQUFFLElBQUk7SUFDTixJQUFJLE9BQU8sR0FBRyxZQUFZLElBQUksQ0FBQztJQUMvQixHQUFHLENBQUMsT0FBTyxFQUFFLEVBQUU7SUFDZixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxHQUFHLEVBQUU7SUFDN0I7SUFDQSxFQUFFLE9BQU8sQ0FBQyxFQUFFLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxHQUFHLEtBQUssSUFBSSxLQUFLLENBQUMsR0FBRyxHQUFHLE9BQU8sSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzFGLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUU7SUFDNUIsRUFBRSxPQUFPLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxZQUFZLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzFFOztJQ3RNQSxNQUFNQyxRQUFNLEdBQUcsVUFBVSxFQUFFO0FBQzNCO0lBQ0EsTUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUM7QUFDckM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQjtJQUN6QixFQUFFLElBQUk7SUFDTixFQUFFLE9BQU8sR0FBRyxFQUFFO0lBQ2QsRUFBRTtJQUNGLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRTtJQUNiLElBQUksT0FBTyxXQUFXLENBQUM7SUFDdkIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUk7SUFDTixJQUFJLElBQUksV0FBVyxHQUFHLElBQUksRUFBRTtJQUM1QixJQUFJLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLElBQUksTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ25CLElBQUksSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLElBQUksTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQzVCLElBQUksTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztJQUN2QyxJQUFJLElBQUksT0FBTyxDQUFDO0lBQ2hCLElBQUksTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUN6RSxJQUFJLE1BQU0sZUFBZSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxlQUFlLEtBQUsseUJBQXlCLENBQUM7QUFDOUc7SUFDQSxJQUFJLE9BQU8sV0FBVyxJQUFJLE1BQU0sRUFBRSxHQUFHLG1CQUFtQixFQUFFO0lBQzFELE1BQU0sT0FBTyxHQUFHLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM1RDtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxLQUFLLE1BQU0sR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsU0FBUyxHQUFHLE9BQU8sQ0FBQyxNQUFNLElBQUksZUFBZSxDQUFDLEVBQUU7SUFDbEgsUUFBUSxNQUFNO0lBQ2QsT0FBTztBQUNQO0lBQ0EsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCO0lBQ0EsTUFBTSxHQUFHLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUM1QixNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDO0lBQzNDLEtBQUs7QUFDTDtJQUNBLElBQUksT0FBTyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3pDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNoQixJQUFJLE9BQU8sV0FBVyxDQUFDO0lBQ3ZCLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFO0lBQzVDLEVBQUUsTUFBTSxJQUFJLEdBQUcsRUFBRTtBQUNqQjtJQUNBLENBQUM7QUFDRDtJQUNBLEVBQUUsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pCO0lBQ0EsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRTtJQUN0QixJQUFJLE9BQU8sRUFBRSxDQUFDO0lBQ2QsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLElBQUlBLFFBQU0sQ0FBQyxXQUFXLEVBQUU7SUFDMUI7SUFDQSxJQUFJLElBQUksSUFBSSxZQUFZLFdBQVcsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0lBQ3JELE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLEVBQUU7SUFDM0MsUUFBUSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUMvQyxPQUFPO0lBQ1AsTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEVBQUU7SUFDekMsUUFBUSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDN0MsT0FBTztJQUNQLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZDO0lBQ0E7SUFDQSxFQUFFLE1BQU0sWUFBWSxHQUFHLFFBQVEsRUFBRSxNQUFNO0lBQ3ZDLE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ2xILE1BQU0sSUFBSSxDQUFDO0FBQ1g7SUFDQSxFQUFFLElBQUksWUFBWSxFQUFFLE1BQU0sRUFBRTtJQUM1QixJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsV0FBVyxJQUFJO0lBQ3hDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFELEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRyxNQUFNO0lBQ1QsSUFBSSxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDakIsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsS0FBSztBQUNMO0lBQ0EsSUFBSSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3JDLElBQUksSUFBSSxTQUFTLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0lBQzFDLE1BQU0sTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QyxNQUFNLEtBQUssTUFBTSxDQUFDLElBQUksT0FBTyxFQUFFO0lBQy9CLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsT0FBTztJQUNQLEtBQUs7SUFDTCxHQUFHO0lBQ0gsRUFBRSxNQUFNLFlBQVksR0FBRyxDQUFDLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0RSxFQUFFLEtBQUssTUFBTSxDQUFDLElBQUksWUFBWSxFQUFFO0lBQ2hDLElBQUksTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QyxJQUFJLElBQUksSUFBSSxFQUFFO0lBQ2QsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkMsS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3RCLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZUFBZSxHQUFHO0lBQzNCLEVBQUUsSUFBSTtJQUNOLElBQUksT0FBT0EsUUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0lBQ3pDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsRUFBRTtJQUNmLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQixDQUFDLElBQUksRUFBRTtJQUNoQztJQUNBLEVBQUUsSUFBSSxDQUFDQSxRQUFNLENBQUMsV0FBVyxFQUFFO0lBQzNCLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFdBQVcsR0FBRyxJQUFJLEVBQUU7SUFDMUIsRUFBRSxNQUFNLG1CQUFtQixHQUFHLENBQUMsQ0FBQztJQUNoQyxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUNoRCxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7SUFDdEIsTUFBTSxPQUFPLElBQUksQ0FBQztJQUNsQixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksV0FBVyxZQUFZLFdBQVcsRUFBRTtJQUM1QyxNQUFNLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0lBQ2xELFFBQVEsT0FBTyxXQUFXLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDdEQsT0FBTztJQUNQLE1BQU0sSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxFQUFFO0lBQ2hELFFBQVEsT0FBTyxXQUFXLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3BELE9BQU87SUFDUCxLQUFLO0FBQ0w7SUFDQSxJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDO0lBQ3pDLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxJQUFJLENBQUM7SUFDZDs7SUNyS0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRTtJQUNoQyxFQUFFLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7SUFDNUMsSUFBSSxPQUFPLEdBQUcsQ0FBQztJQUNmLEdBQUc7SUFDSCxFQUFFLE9BQU8sR0FBRyxDQUFDLE1BQU0sSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3RCxDQUFDO0FBNENEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRTtJQUNwQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzdCLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNwQjtJQUNBLEVBQUUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDekMsSUFBSSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0IsSUFBSSxJQUFJO0lBQ1I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDakMsUUFBUSxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDdEMsT0FBTyxNQUFNO0lBQ2IsUUFBUSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ25DLE9BQU87SUFDUCxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDaEIsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLDhCQUE4QixDQUFDLENBQUM7SUFDbEQsS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGlCQUFpQjtJQUMxQixFQUFFLEtBQUs7SUFDUCxFQUFFLE9BQU87SUFDVCxFQUFFLHVCQUF1QixHQUFHLEtBQUs7SUFDakMsRUFBRTtJQUNGLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUN4QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDekIsSUFBSSxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsR0FBRztJQUNILEVBQUUsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDekIsSUFBSSxPQUFPLHVCQUF1QixHQUFHLEtBQUssS0FBSyxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqRixHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHdCQUF3QjtJQUNqQyxFQUFFLFVBQVU7SUFDWixFQUFFLFFBQVEsR0FBRyxFQUFFO0lBQ2YsRUFBRSx1QkFBdUIsR0FBRyxLQUFLO0lBQ2pDLEVBQUU7SUFDRixFQUFFLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksaUJBQWlCLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSx1QkFBdUIsQ0FBQyxDQUFDLENBQUM7SUFDbkc7O0lDbElBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRTtJQUNoRCxFQUFFLElBQUksRUFBRSxJQUFJLElBQUksTUFBTSxDQUFDLEVBQUU7SUFDekIsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNqQztJQUNBLEVBQUUsSUFBSSxPQUFPLFFBQVEsS0FBSyxVQUFVLEVBQUU7SUFDdEMsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsRUFBRTtBQUNoRDtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO0lBQ3JDLElBQUksbUJBQW1CLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzNDLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSTtJQUNOLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQztJQUMzQixHQUFHLENBQUMsTUFBTTtJQUNWLElBQUlGLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsMEJBQTBCLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3RGLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsd0JBQXdCLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7SUFDcEQsRUFBRSxJQUFJO0lBQ04sSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUU7SUFDckM7SUFDQSxNQUFNLEtBQUssRUFBRSxLQUFLO0lBQ2xCLE1BQU0sUUFBUSxFQUFFLElBQUk7SUFDcEIsTUFBTSxZQUFZLEVBQUUsSUFBSTtJQUN4QixLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUcsQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNoQixJQUFJQSxhQUFXLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLHVDQUF1QyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNoRyxHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUU7SUFDaEQsRUFBRSxJQUFJO0lBQ04sSUFBSSxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQztJQUMzQyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDbkQsSUFBSSx3QkFBd0IsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkUsR0FBRyxDQUFDLE9BQU8sR0FBRyxFQUFFLEVBQUU7SUFDbEIsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsbUJBQW1CLENBQUMsSUFBSSxFQUFFO0lBQ25DLEVBQUUsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUM7SUFDbEMsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsb0JBQW9CLENBQUMsS0FBSztBQUNuQztJQUNBLENBQUM7SUFDRCxFQUFFLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLElBQUksT0FBTztJQUNYLE1BQU0sT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO0lBQzVCLE1BQU0sSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO0lBQ3RCLE1BQU0sS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO0lBQ3hCLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7SUFDaEMsS0FBSyxDQUFDO0lBQ04sR0FBRyxNQUFNLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzdCLElBQUksTUFBTSxNQUFNO0FBQ2hCO0lBQ0EsR0FBRztJQUNILE1BQU0sSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO0lBQ3RCLE1BQU0sTUFBTSxFQUFFLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDaEQsTUFBTSxhQUFhLEVBQUUsb0JBQW9CLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQztJQUM5RCxNQUFNLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUFDO0lBQ2hDLEtBQUssQ0FBQztBQUNOO0lBQ0EsSUFBSSxJQUFJLE9BQU8sV0FBVyxLQUFLLFdBQVcsSUFBSSxZQUFZLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxFQUFFO0lBQ2hGLE1BQU0sTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ25DLEtBQUs7QUFDTDtJQUNBLElBQUksT0FBTyxNQUFNLENBQUM7SUFDbEIsR0FBRyxNQUFNO0lBQ1QsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLG9CQUFvQixDQUFDLE1BQU0sRUFBRTtJQUN0QyxFQUFFLElBQUk7SUFDTixJQUFJLE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqRyxHQUFHLENBQUMsT0FBTyxHQUFHLEVBQUU7SUFDaEIsSUFBSSxPQUFPLFdBQVcsQ0FBQztJQUN2QixHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQixDQUFDLEdBQUcsRUFBRTtJQUMvQixFQUFFLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUU7SUFDL0MsSUFBSSxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7SUFDOUIsSUFBSSxLQUFLLE1BQU0sUUFBUSxJQUFJLEdBQUcsRUFBRTtJQUNoQyxNQUFNLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsRUFBRTtJQUMvRCxRQUFRLGNBQWMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsQ0FBQztJQUNwRCxPQUFPO0lBQ1AsS0FBSztJQUNMLElBQUksT0FBTyxjQUFjLENBQUM7SUFDMUIsR0FBRyxNQUFNO0lBQ1QsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUNkLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyw4QkFBOEIsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLEVBQUUsRUFBRTtJQUNuRSxFQUFFLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUM1RCxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNkO0lBQ0EsRUFBRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0I7SUFDQSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7SUFDakIsSUFBSSxPQUFPLHNCQUFzQixDQUFDO0lBQ2xDLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLFNBQVMsRUFBRTtJQUNwQyxJQUFJLE9BQU8sUUFBUSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN6QyxHQUFHO0FBQ0g7SUFDQSxFQUFFLEtBQUssSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxZQUFZLEdBQUcsQ0FBQyxFQUFFLFlBQVksRUFBRSxFQUFFO0lBQ3pFLElBQUksTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlELElBQUksSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBRTtJQUN2QyxNQUFNLFNBQVM7SUFDZixLQUFLO0lBQ0wsSUFBSSxJQUFJLFlBQVksS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO0lBQ3RDLE1BQU0sT0FBTyxVQUFVLENBQUM7SUFDeEIsS0FBSztJQUNMLElBQUksT0FBTyxRQUFRLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzNDLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDWjs7SUN0TEEsU0FBUyxTQUFTLEdBQUc7SUFDckIsRUFBRSxNQUFNLEdBQUcsR0FBRyxVQUFVLEVBQUU7SUFDMUIsRUFBRSxPQUFPLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxLQUFLLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBRSxFQUFFO0lBQ3JDLEVBQUUsSUFBSSxhQUFhLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQy9DLEVBQUUsSUFBSTtJQUNOLElBQUksSUFBSSxNQUFNLEVBQUUsVUFBVSxFQUFFO0lBQzVCLE1BQU0sT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNuRCxLQUFLO0lBQ0wsSUFBSSxJQUFJLE1BQU0sRUFBRSxlQUFlLEVBQUU7SUFDakMsTUFBTSxhQUFhLEdBQUcsTUFBTTtJQUM1QjtJQUNBO0lBQ0E7SUFDQTtJQUNBLFFBQVEsTUFBTSxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0MsUUFBUSxNQUFNLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzNDO0lBQ0EsUUFBUSxPQUFPLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixPQUFPLENBQUM7SUFDUixLQUFLO0lBQ0wsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2Q7SUFDQTtJQUNBLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNoRTtJQUNBLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUM7SUFDaEUsR0FBRyxDQUFDO0lBQ0osQ0FBQztBQUNEO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUU7SUFDbEMsRUFBRSxPQUFPLEtBQUssQ0FBQyxTQUFTLEVBQUUsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUU7SUFDcEMsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsR0FBRyxLQUFLLENBQUM7SUFDL0MsRUFBRSxJQUFJLE9BQU8sRUFBRTtJQUNmLElBQUksT0FBTyxPQUFPLENBQUM7SUFDbkIsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRCxFQUFFLElBQUksY0FBYyxFQUFFO0lBQ3RCLElBQUksSUFBSSxjQUFjLENBQUMsSUFBSSxJQUFJLGNBQWMsQ0FBQyxLQUFLLEVBQUU7SUFDckQsTUFBTSxPQUFPLENBQUMsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMvRCxLQUFLO0lBQ0wsSUFBSSxPQUFPLGNBQWMsQ0FBQyxJQUFJLElBQUksY0FBYyxDQUFDLEtBQUssSUFBSSxPQUFPLElBQUksV0FBVyxDQUFDO0lBQ2pGLEdBQUc7SUFDSCxFQUFFLE9BQU8sT0FBTyxJQUFJLFdBQVcsQ0FBQztJQUNoQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMscUJBQXFCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7SUFDbkQsRUFBRSxNQUFNLFNBQVMsSUFBSSxLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDLENBQUM7SUFDOUQsRUFBRSxNQUFNLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0QsRUFBRSxNQUFNLGNBQWMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUU7SUFDN0IsSUFBSSxjQUFjLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUM7SUFDdkMsR0FBRztJQUNILEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUU7SUFDNUIsSUFBSSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksSUFBSSxPQUFPLENBQUM7SUFDMUMsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFO0lBQ3BELEVBQUUsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEQsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFO0lBQ3ZCLElBQUksT0FBTztJQUNYLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQzlELEVBQUUsTUFBTSxnQkFBZ0IsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBQ3BELEVBQUUsY0FBYyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUcsZ0JBQWdCLEVBQUUsR0FBRyxnQkFBZ0IsRUFBRSxHQUFHLFlBQVksRUFBRSxDQUFDO0FBQzNGO0lBQ0EsRUFBRSxJQUFJLFlBQVksSUFBSSxNQUFNLElBQUksWUFBWSxFQUFFO0lBQzlDLElBQUksTUFBTSxVQUFVLEdBQUcsRUFBRSxHQUFHLGdCQUFnQixFQUFFLElBQUksRUFBRSxHQUFHLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzRSxJQUFJLGNBQWMsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQztJQUMvQyxHQUFHO0lBQ0gsQ0FBQztBQThERDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsdUJBQXVCLENBQUMsU0FBUyxFQUFFO0lBQzVDLEVBQUUsSUFBSSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUNwQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSTtJQUNOO0lBQ0E7SUFDQSxJQUFJLHdCQUF3QixDQUFDLFNBQVMsR0FBRyxxQkFBcUIsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0RSxHQUFHLENBQUMsT0FBTyxHQUFHLEVBQUU7SUFDaEI7SUFDQSxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUU7SUFDdEMsRUFBRSxJQUFJO0lBQ04sSUFBSSxPQUFPLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDO0lBQzVDLEdBQUcsQ0FBQyxNQUFNLEVBQUU7SUFDWjs7SUNuTkEsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFDOUI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxzQkFBc0IsR0FBRztJQUNsQyxFQUFFLE9BQU8sSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLGdCQUFnQixDQUFDO0lBQ3ZDLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZ0NBQWdDLEdBQUc7SUFDNUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsVUFBVSxFQUFFO0lBQ3RDLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUU7SUFDekIsSUFBSSxPQUFPLHNCQUFzQixDQUFDO0lBQ2xDLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQSxFQUFFLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNsRSxFQUFFLE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxVQUFVLElBQUksU0FBUyxHQUFHLHdCQUF3QixHQUFHLFdBQVcsQ0FBQyxVQUFVLENBQUM7QUFDN0c7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLE9BQU8sTUFBTTtJQUNmLElBQUksT0FBTyxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLElBQUksZ0JBQWdCLENBQUM7SUFDL0QsR0FBRyxDQUFDO0lBQ0osQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxrQkFBa0IsR0FBRyxnQ0FBZ0MsRUFBRTs7SUNyRDdEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUU7SUFDOUI7SUFDQSxFQUFFLE1BQU0sWUFBWSxHQUFHLGtCQUFrQixFQUFFLENBQUM7QUFDNUM7SUFDQSxFQUFFLE1BQU0sT0FBTyxHQUFHO0lBQ2xCLElBQUksR0FBRyxFQUFFLEtBQUssRUFBRTtJQUNoQixJQUFJLElBQUksRUFBRSxJQUFJO0lBQ2QsSUFBSSxTQUFTLEVBQUUsWUFBWTtJQUMzQixJQUFJLE9BQU8sRUFBRSxZQUFZO0lBQ3pCLElBQUksUUFBUSxFQUFFLENBQUM7SUFDZixJQUFJLE1BQU0sRUFBRSxJQUFJO0lBQ2hCLElBQUksTUFBTSxFQUFFLENBQUM7SUFDYixJQUFJLGNBQWMsRUFBRSxLQUFLO0lBQ3pCLElBQUksTUFBTSxFQUFFLE1BQU0sYUFBYSxDQUFDLE9BQU8sQ0FBQztJQUN4QyxHQUFHLENBQUM7QUFDSjtJQUNBLEVBQUUsSUFBSSxPQUFPLEVBQUU7SUFDZixJQUFJLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDcEMsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRTtJQUM5QyxFQUFFLElBQUksT0FBTyxDQUFDLElBQUksRUFBRTtJQUNwQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO0lBQ3ZELE1BQU0sT0FBTyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUNsRCxLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtJQUN0QyxNQUFNLE9BQU8sQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDbkYsS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxJQUFJLGtCQUFrQixFQUFFLENBQUM7QUFDaEU7SUFDQSxFQUFFLElBQUksT0FBTyxDQUFDLGtCQUFrQixFQUFFO0lBQ2xDLElBQUksT0FBTyxDQUFDLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztJQUM1RCxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksT0FBTyxDQUFDLGNBQWMsRUFBRTtJQUM5QixJQUFJLE9BQU8sQ0FBQyxjQUFjLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQztJQUNwRCxHQUFHO0lBQ0gsRUFBRSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7SUFDbkI7SUFDQSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEtBQUssRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUFHLEdBQUcsS0FBSyxFQUFFLENBQUM7SUFDcEUsR0FBRztJQUNILEVBQUUsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtJQUNsQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNoQyxHQUFHO0lBQ0gsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0lBQ25DLElBQUksT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbkMsR0FBRztJQUNILEVBQUUsSUFBSSxPQUFPLE9BQU8sQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO0lBQzNDLElBQUksT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ3RDLEdBQUc7SUFDSCxFQUFFLElBQUksT0FBTyxDQUFDLGNBQWMsRUFBRTtJQUM5QixJQUFJLE9BQU8sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO0lBQ2pDLEdBQUcsTUFBTSxJQUFJLE9BQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7SUFDbkQsSUFBSSxPQUFPLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDeEMsR0FBRyxNQUFNO0lBQ1QsSUFBSSxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDekQsSUFBSSxPQUFPLENBQUMsUUFBUSxHQUFHLFFBQVEsSUFBSSxDQUFDLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNwRCxHQUFHO0lBQ0gsRUFBRSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFDdkIsSUFBSSxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDdEMsR0FBRztJQUNILEVBQUUsSUFBSSxPQUFPLENBQUMsV0FBVyxFQUFFO0lBQzNCLElBQUksT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDO0lBQzlDLEdBQUc7SUFDSCxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7SUFDL0MsSUFBSSxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7SUFDMUMsR0FBRztJQUNILEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtJQUMvQyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztJQUMxQyxHQUFHO0lBQ0gsRUFBRSxJQUFJLE9BQU8sT0FBTyxDQUFDLE1BQU0sS0FBSyxRQUFRLEVBQUU7SUFDMUMsSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFDcEMsR0FBRztJQUNILEVBQUUsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0lBQ3RCLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQ3BDLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxZQUFZLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRTtJQUN2QyxFQUFFLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUNuQixFQUFFLElBQUksTUFBTSxFQUFFO0lBQ2QsSUFBSSxPQUFPLEdBQUcsRUFBRSxNQUFNLEVBQUUsQ0FBQztJQUN6QixHQUFHLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLElBQUksRUFBRTtJQUN0QyxJQUFJLE9BQU8sR0FBRyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUNuQyxHQUFHO0FBQ0g7SUFDQSxFQUFFLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDbEMsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxhQUFhLENBQUMsT0FBTyxFQUFFO0lBQ2hDLEVBQUUsT0FBTztJQUNULElBQUksR0FBRyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekIsSUFBSSxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7SUFDdEI7SUFDQSxJQUFJLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRTtJQUMzRCxJQUFJLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRTtJQUMvRCxJQUFJLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtJQUMxQixJQUFJLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtJQUMxQixJQUFJLEdBQUcsRUFBRSxPQUFPLE9BQU8sQ0FBQyxHQUFHLEtBQUssUUFBUSxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsS0FBSyxRQUFRLEdBQUcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVM7SUFDMUcsSUFBSSxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVE7SUFDOUIsSUFBSSxrQkFBa0IsRUFBRSxPQUFPLENBQUMsa0JBQWtCO0lBQ2xELElBQUksS0FBSyxFQUFFO0lBQ1gsTUFBTSxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87SUFDOUIsTUFBTSxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVc7SUFDdEMsTUFBTSxVQUFVLEVBQUUsT0FBTyxDQUFDLFNBQVM7SUFDbkMsTUFBTSxVQUFVLEVBQUUsT0FBTyxDQUFDLFNBQVM7SUFDbkMsS0FBSztJQUNMLEdBQUcsQ0FBQztJQUNKOztJQzNKQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGVBQWUsR0FBRztJQUMzQixFQUFFLE9BQU8sS0FBSyxFQUFFLENBQUM7SUFDakIsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxjQUFjLEdBQUc7SUFDMUIsRUFBRSxPQUFPLEtBQUssRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMvQjs7SUNkQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsS0FBSyxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUNqRDtJQUNBO0lBQ0EsRUFBRSxJQUFJLENBQUMsUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ2hFLElBQUksT0FBTyxRQUFRLENBQUM7SUFDcEIsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLElBQUksVUFBVSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtJQUN4RCxJQUFJLE9BQU8sVUFBVSxDQUFDO0lBQ3RCLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxNQUFNLE1BQU0sR0FBRyxFQUFFLEdBQUcsVUFBVSxFQUFFLENBQUM7QUFDbkM7SUFDQTtJQUNBLEVBQUUsS0FBSyxNQUFNLEdBQUcsSUFBSSxRQUFRLEVBQUU7SUFDOUIsSUFBSSxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLEVBQUU7SUFDN0QsTUFBTSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCOztJQzVCQSxNQUFNLGdCQUFnQixHQUFHLGFBQWEsQ0FBQztBQUN2QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFO0lBQ3ZDLEVBQUUsSUFBSSxJQUFJLEVBQUU7SUFDWixJQUFJLHdCQUF3QixDQUFDLEtBQUssR0FBRyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3RCxHQUFHLE1BQU07SUFDVDtJQUNBLElBQUksT0FBTyxDQUFDLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3RDLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFO0lBQ2pDLEVBQUUsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNqQzs7SUNiQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLHVCQUF1QixHQUFHLEdBQUcsQ0FBQztBQUNwQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sS0FBSyxDQUFDO0lBQ1o7QUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBLEdBQUcsV0FBVyxHQUFHO0lBQ2pCLElBQUksSUFBSSxDQUFDLG1CQUFtQixHQUFHLEtBQUssQ0FBQztJQUNyQyxJQUFJLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO0lBQzlCLElBQUksSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztJQUMvQixJQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0lBQzNCLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7SUFDM0IsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztJQUNwQixJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ3BCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDckIsSUFBSSxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN4QixJQUFJLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLENBQUM7SUFDckMsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEdBQUc7SUFDL0IsTUFBTSxPQUFPLEVBQUUsZUFBZSxFQUFFO0lBQ2hDLE1BQU0sVUFBVSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUU7SUFDL0IsS0FBSyxDQUFDO0lBQ04sR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxLQUFLLEdBQUc7SUFDWCxJQUFJLE1BQU0sUUFBUSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7SUFDakMsSUFBSSxRQUFRLENBQUMsWUFBWSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkQsSUFBSSxRQUFRLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDdkMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDekMsSUFBSSxRQUFRLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDL0MsSUFBSSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFO0lBQzlCO0lBQ0E7SUFDQSxNQUFNLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHO0lBQ2pDLFFBQVEsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDaEQsT0FBTyxDQUFDO0lBQ1IsS0FBSztBQUNMO0lBQ0EsSUFBSSxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDaEMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDbEMsSUFBSSxRQUFRLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEMsSUFBSSxRQUFRLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO0lBQ3RELElBQUksUUFBUSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzlDLElBQUksUUFBUSxDQUFDLGdCQUFnQixHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUMzRCxJQUFJLFFBQVEsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNuRCxJQUFJLFFBQVEsQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7SUFDekUsSUFBSSxRQUFRLENBQUMsbUJBQW1CLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQ25FLElBQUksUUFBUSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3BDLElBQUksUUFBUSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0FBQzlDO0lBQ0EsSUFBSSxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN2RDtJQUNBLElBQUksT0FBTyxRQUFRLENBQUM7SUFDcEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRTtJQUNyQixJQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0lBQzFCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxjQUFjLENBQUMsV0FBVyxFQUFFO0lBQy9CLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDcEMsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxTQUFTLEdBQUc7SUFDZixJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRTtJQUN6QixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsV0FBVyxHQUFHO0lBQ2pCLElBQUksT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzdCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsZ0JBQWdCLENBQUMsUUFBUSxFQUFFO0lBQzlCLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDeEMsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUU7SUFDL0IsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLE9BQU8sQ0FBQyxJQUFJLEVBQUU7SUFDakI7SUFDQTtJQUNBLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLElBQUk7SUFDekIsTUFBTSxLQUFLLEVBQUUsU0FBUztJQUN0QixNQUFNLEVBQUUsRUFBRSxTQUFTO0lBQ25CLE1BQU0sVUFBVSxFQUFFLFNBQVM7SUFDM0IsTUFBTSxRQUFRLEVBQUUsU0FBUztJQUN6QixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0lBQ3ZCLE1BQU0sYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDakMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLE9BQU8sR0FBRztJQUNiLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxPQUFPLENBQUMsSUFBSSxFQUFFO0lBQ2pCLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRztJQUNqQixNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUs7SUFDbkIsTUFBTSxHQUFHLElBQUk7SUFDYixLQUFLLENBQUM7SUFDTixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ2pDLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRTtJQUN0QixJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUcsS0FBSyxFQUFFLENBQUM7SUFDakQsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNqQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFO0lBQ3JCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRztJQUNsQixNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU07SUFDcEIsTUFBTSxHQUFHLE1BQU07SUFDZixLQUFLLENBQUM7SUFDTixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ2pDLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRTtJQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsS0FBSyxFQUFFLENBQUM7SUFDbkQsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNqQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxjQUFjLENBQUMsV0FBVyxFQUFFO0lBQy9CLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDcEMsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNqQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRTtJQUNuQixJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDakMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUU7SUFDNUIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0lBQ2pDLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDakMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxVQUFVLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRTtJQUM1QixJQUFJLElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtJQUMxQjtJQUNBLE1BQU0sT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLEtBQUssTUFBTTtJQUNYLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7SUFDcEMsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNqQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsVUFBVSxDQUFDLE9BQU8sRUFBRTtJQUN2QixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7SUFDbEIsTUFBTSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDM0IsS0FBSyxNQUFNO0lBQ1gsTUFBTSxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUM5QixLQUFLO0lBQ0wsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNqQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsVUFBVSxHQUFHO0lBQ2hCLElBQUksT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRTtJQUMxQixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7SUFDekIsTUFBTSxPQUFPLElBQUksQ0FBQztJQUNsQixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sWUFBWSxHQUFHLE9BQU8sY0FBYyxLQUFLLFVBQVUsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDO0FBQ3RHO0lBQ0EsSUFBSSxNQUFNLGFBQWE7SUFDdkIsTUFBTSxZQUFZLFlBQVksS0FBSztJQUNuQyxVQUFVLFlBQVksQ0FBQyxZQUFZLEVBQUU7SUFDckMsVUFBVSxhQUFhLENBQUMsWUFBWSxDQUFDO0lBQ3JDLGFBQWEsY0FBYztJQUMzQixZQUFZLFNBQVMsQ0FBQztBQUN0QjtJQUNBLElBQUksTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsV0FBVyxHQUFHLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxHQUFHLGFBQWEsSUFBSSxFQUFFLENBQUM7QUFDN0c7SUFDQSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQztJQUM1QyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxLQUFLLEVBQUUsQ0FBQztJQUMvQyxJQUFJLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxRQUFRLEVBQUUsQ0FBQztBQUN4RDtJQUNBLElBQUksSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDMUMsTUFBTSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUN4QixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksS0FBSyxFQUFFO0lBQ2YsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUMxQixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRTtJQUM1QixNQUFNLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ3RDLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxrQkFBa0IsRUFBRTtJQUM1QixNQUFNLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxrQkFBa0IsQ0FBQztJQUNwRCxLQUFLO0FBQ0w7SUFDQSxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxLQUFLLEdBQUc7SUFDWDtJQUNBLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7SUFDM0IsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztJQUNwQixJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7SUFDcEIsSUFBSSxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO0lBQzVCLElBQUksSUFBSSxDQUFDLGdCQUFnQixHQUFHLFNBQVMsQ0FBQztJQUN0QyxJQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO0lBQ2xDLElBQUksSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7SUFDOUIsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdEMsSUFBSSxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztJQUMzQixJQUFJLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMxRjtJQUNBLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDakMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsYUFBYSxDQUFDLFVBQVUsRUFBRSxjQUFjLEVBQUU7SUFDN0MsSUFBSSxNQUFNLFNBQVMsR0FBRyxPQUFPLGNBQWMsS0FBSyxRQUFRLEdBQUcsY0FBYyxHQUFHLHVCQUF1QixDQUFDO0FBQ3BHO0lBQ0E7SUFDQSxJQUFJLElBQUksU0FBUyxJQUFJLENBQUMsRUFBRTtJQUN4QixNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxnQkFBZ0IsR0FBRztJQUM3QixNQUFNLFNBQVMsRUFBRSxzQkFBc0IsRUFBRTtJQUN6QyxNQUFNLEdBQUcsVUFBVTtJQUNuQjtJQUNBLE1BQU0sT0FBTyxFQUFFLFVBQVUsQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLE9BQU87SUFDM0YsS0FBSyxDQUFDO0FBQ047SUFDQSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDN0MsSUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBRTtJQUM5QyxNQUFNLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5RCxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDdEUsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztBQUNqQztJQUNBLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxpQkFBaUIsR0FBRztJQUN2QixJQUFJLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzRCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGdCQUFnQixHQUFHO0lBQ3RCLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7SUFDM0IsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUNqQyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsYUFBYSxDQUFDLFVBQVUsRUFBRTtJQUM3QixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3ZDLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxnQkFBZ0IsR0FBRztJQUN0QixJQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0lBQzNCLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxZQUFZLEdBQUc7SUFDbEIsSUFBSSxPQUFPO0lBQ1gsTUFBTSxXQUFXLEVBQUUsSUFBSSxDQUFDLFlBQVk7SUFDcEMsTUFBTSxXQUFXLEVBQUUsSUFBSSxDQUFDLFlBQVk7SUFDcEMsTUFBTSxRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVM7SUFDOUIsTUFBTSxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7SUFDdEIsTUFBTSxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU07SUFDeEIsTUFBTSxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUs7SUFDdEIsTUFBTSxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU07SUFDeEIsTUFBTSxXQUFXLEVBQUUsSUFBSSxDQUFDLFlBQVksSUFBSSxFQUFFO0lBQzFDLE1BQU0sZUFBZSxFQUFFLElBQUksQ0FBQyxnQkFBZ0I7SUFDNUMsTUFBTSxrQkFBa0IsRUFBRSxJQUFJLENBQUMsbUJBQW1CO0lBQ2xELE1BQU0scUJBQXFCLEVBQUUsSUFBSSxDQUFDLHNCQUFzQjtJQUN4RCxNQUFNLGVBQWUsRUFBRSxJQUFJLENBQUMsZ0JBQWdCO0lBQzVDLE1BQU0sSUFBSSxFQUFFLGdCQUFnQixDQUFDLElBQUksQ0FBQztJQUNsQyxLQUFLLENBQUM7SUFDTixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLHdCQUF3QixDQUFDLE9BQU8sRUFBRTtJQUNyQyxJQUFJLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLHNCQUFzQixFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRixJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcscUJBQXFCLENBQUMsT0FBTyxFQUFFO0lBQ2xDLElBQUksSUFBSSxDQUFDLG1CQUFtQixHQUFHLE9BQU8sQ0FBQztJQUN2QyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcscUJBQXFCLEdBQUc7SUFDM0IsSUFBSSxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztJQUNwQyxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFO0lBQ3JDLElBQUksTUFBTSxPQUFPLEdBQUcsSUFBSSxFQUFFLFFBQVEsSUFBSSxLQUFLLEVBQUUsQ0FBQztBQUM5QztJQUNBLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7SUFDdkIsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLDZEQUE2RCxDQUFDLENBQUM7SUFDakYsTUFBTSxPQUFPLE9BQU8sQ0FBQztJQUNyQixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUN0RTtJQUNBLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0I7SUFDakMsTUFBTSxTQUFTO0lBQ2YsTUFBTTtJQUNOLFFBQVEsaUJBQWlCLEVBQUUsU0FBUztJQUNwQyxRQUFRLGtCQUFrQjtJQUMxQixRQUFRLEdBQUcsSUFBSTtJQUNmLFFBQVEsUUFBUSxFQUFFLE9BQU87SUFDekIsT0FBTztJQUNQLE1BQU0sSUFBSTtJQUNWLEtBQUssQ0FBQztBQUNOO0lBQ0EsSUFBSSxPQUFPLE9BQU8sQ0FBQztJQUNuQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxjQUFjLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7SUFDeEMsSUFBSSxNQUFNLE9BQU8sR0FBRyxJQUFJLEVBQUUsUUFBUSxJQUFJLEtBQUssRUFBRSxDQUFDO0FBQzlDO0lBQ0EsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtJQUN2QixNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsMkRBQTJELENBQUMsQ0FBQztJQUMvRSxNQUFNLE9BQU8sT0FBTyxDQUFDO0lBQ3JCLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxrQkFBa0IsR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNsRDtJQUNBLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjO0lBQy9CLE1BQU0sT0FBTztJQUNiLE1BQU0sS0FBSztJQUNYLE1BQU07SUFDTixRQUFRLGlCQUFpQixFQUFFLE9BQU87SUFDbEMsUUFBUSxrQkFBa0I7SUFDMUIsUUFBUSxHQUFHLElBQUk7SUFDZixRQUFRLFFBQVEsRUFBRSxPQUFPO0lBQ3pCLE9BQU87SUFDUCxNQUFNLElBQUk7SUFDVixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksT0FBTyxPQUFPLENBQUM7SUFDbkIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUU7SUFDN0IsSUFBSSxNQUFNLE9BQU8sR0FBRyxJQUFJLEVBQUUsUUFBUSxJQUFJLEtBQUssRUFBRSxDQUFDO0FBQzlDO0lBQ0EsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtJQUN2QixNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMseURBQXlELENBQUMsQ0FBQztJQUM3RSxNQUFNLE9BQU8sT0FBTyxDQUFDO0lBQ3JCLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEVBQUUsR0FBRyxJQUFJLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzNFO0lBQ0EsSUFBSSxPQUFPLE9BQU8sQ0FBQztJQUNuQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLHFCQUFxQixHQUFHO0lBQzNCO0lBQ0E7SUFDQTtJQUNBLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtJQUNuQyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUM7SUFDdEMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUk7SUFDL0MsUUFBUSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkIsT0FBTyxDQUFDLENBQUM7SUFDVCxNQUFNLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLENBQUM7SUFDdkMsS0FBSztJQUNMLEdBQUc7SUFDSDs7SUNoa0JBO0lBQ0EsU0FBUyxzQkFBc0IsR0FBRztJQUNsQyxFQUFFLE9BQU8sa0JBQWtCLENBQUMscUJBQXFCLEVBQUUsTUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDdEUsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLHdCQUF3QixHQUFHO0lBQ3BDLEVBQUUsT0FBTyxrQkFBa0IsQ0FBQyx1QkFBdUIsRUFBRSxNQUFNLElBQUksS0FBSyxFQUFFLENBQUMsQ0FBQztJQUN4RTs7SUNOQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hCO0lBQ0EsR0FBRyxXQUFXLENBQUMsS0FBSyxFQUFFLGNBQWMsRUFBRTtJQUN0QyxJQUFJLElBQUksYUFBYSxDQUFDO0lBQ3RCLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNoQixNQUFNLGFBQWEsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQ2xDLEtBQUssTUFBTTtJQUNYLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQztJQUM1QixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksc0JBQXNCLENBQUM7SUFDL0IsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO0lBQ3pCLE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQUMzQyxLQUFLLE1BQU07SUFDWCxNQUFNLHNCQUFzQixHQUFHLGNBQWMsQ0FBQztJQUM5QyxLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7SUFDN0MsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLHNCQUFzQixDQUFDO0lBQ2xELEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsU0FBUyxDQUFDLFFBQVEsRUFBRTtJQUN2QixJQUFJLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUNwQztJQUNBLElBQUksSUFBSSxrQkFBa0IsQ0FBQztJQUMzQixJQUFJLElBQUk7SUFDUixNQUFNLGtCQUFrQixHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDaEIsTUFBTSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDdkIsTUFBTSxNQUFNLENBQUMsQ0FBQztJQUNkLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxVQUFVLENBQUMsa0JBQWtCLENBQUMsRUFBRTtJQUN4QztJQUNBLE1BQU0sT0FBTyxrQkFBa0IsQ0FBQyxJQUFJO0lBQ3BDLFFBQVEsR0FBRyxJQUFJO0lBQ2YsVUFBVSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDM0IsVUFBVSxPQUFPLEdBQUcsQ0FBQztJQUNyQixTQUFTO0lBQ1QsUUFBUSxDQUFDLElBQUk7SUFDYixVQUFVLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUMzQixVQUFVLE1BQU0sQ0FBQyxDQUFDO0lBQ2xCLFNBQVM7SUFDVCxPQUFPLENBQUM7SUFDUixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNyQixJQUFJLE9BQU8sa0JBQWtCLENBQUM7SUFDOUIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxTQUFTLEdBQUc7SUFDZixJQUFJLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE1BQU0sRUFBRTtJQUN0QyxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLFFBQVEsR0FBRztJQUNkLElBQUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDO0lBQ3BDLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsaUJBQWlCLEdBQUc7SUFDdkIsSUFBSSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDaEMsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxXQUFXLEdBQUc7SUFDakIsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDaEQsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxVQUFVLEdBQUc7SUFDaEI7SUFDQSxJQUFJLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUMxQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO0lBQ3JCLE1BQU0sTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUU7SUFDOUIsTUFBTSxLQUFLO0lBQ1gsS0FBSyxDQUFDLENBQUM7SUFDUCxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsU0FBUyxHQUFHO0lBQ2YsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUM5QyxJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDL0IsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxvQkFBb0IsR0FBRztJQUNoQyxFQUFFLE1BQU0sUUFBUSxHQUFHLGNBQWMsRUFBRSxDQUFDO0lBQ3BDLEVBQUUsTUFBTSxNQUFNLEdBQUcsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDNUM7SUFDQSxFQUFFLFFBQVEsTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJLElBQUksaUJBQWlCLENBQUMsc0JBQXNCLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxDQUFDLEVBQUU7SUFDdEgsQ0FBQztBQUNEO0lBQ0EsU0FBU0csV0FBUyxDQUFDLFFBQVEsRUFBRTtJQUM3QixFQUFFLE9BQU8sb0JBQW9CLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEQsQ0FBQztBQUNEO0lBQ0EsU0FBUyxZQUFZLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRTtJQUN2QyxFQUFFLE1BQU0sS0FBSyxHQUFHLG9CQUFvQixFQUFFLEVBQUU7SUFDeEMsRUFBRSxPQUFPLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTTtJQUMvQixJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3RDLElBQUksT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGtCQUFrQixDQUFDLFFBQVEsRUFBRTtJQUN0QyxFQUFFLE9BQU8sb0JBQW9CLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTTtJQUNoRCxJQUFJLE9BQU8sUUFBUSxDQUFDLG9CQUFvQixFQUFFLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO0lBQ2hFLEdBQUcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyw0QkFBNEIsR0FBRztJQUN4QyxFQUFFLE9BQU87SUFDVCxJQUFJLGtCQUFrQjtJQUN0QixlQUFJQSxXQUFTO0lBQ2IsSUFBSSxZQUFZO0lBQ2hCLElBQUkscUJBQXFCLEVBQUUsQ0FBQyxlQUFlLEVBQUUsUUFBUSxLQUFLO0lBQzFELE1BQU0sT0FBTyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxQyxLQUFLO0lBQ0wsSUFBSSxlQUFlLEVBQUUsTUFBTSxvQkFBb0IsRUFBRSxDQUFDLFFBQVEsRUFBRTtJQUM1RCxJQUFJLGlCQUFpQixFQUFFLE1BQU0sb0JBQW9CLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRTtJQUN2RSxHQUFHLENBQUM7SUFDSjs7SUM1SUE7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHVCQUF1QixDQUFDLE9BQU8sRUFBRTtJQUMxQyxFQUFFLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzNDO0lBQ0EsRUFBRSxJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUU7SUFDbEIsSUFBSSxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUM7SUFDdEIsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLE9BQU8sNEJBQTRCLEVBQUUsQ0FBQztJQUN4Qzs7SUN2QkE7SUFDQTtJQUNBO0lBQ0EsU0FBUyxlQUFlLEdBQUc7SUFDM0IsRUFBRSxNQUFNLE9BQU8sR0FBRyxjQUFjLEVBQUUsQ0FBQztJQUNuQyxFQUFFLE1BQU0sR0FBRyxHQUFHLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQy9DLEVBQUUsT0FBTyxHQUFHLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDL0IsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGlCQUFpQixHQUFHO0lBQzdCLEVBQUUsTUFBTSxPQUFPLEdBQUcsY0FBYyxFQUFFLENBQUM7SUFDbkMsRUFBRSxNQUFNLEdBQUcsR0FBRyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMvQyxFQUFFLE9BQU8sR0FBRyxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDakMsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsR0FBRztJQUMxQixFQUFFLE9BQU8sa0JBQWtCLENBQUMsYUFBYSxFQUFFLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQzlELENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsU0FBUztJQUNsQixFQUFFLEdBQUcsSUFBSTtJQUNULEVBQUU7SUFDRixFQUFFLE1BQU0sT0FBTyxHQUFHLGNBQWMsRUFBRSxDQUFDO0lBQ25DLEVBQUUsTUFBTSxHQUFHLEdBQUcsdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDL0M7SUFDQTtJQUNBLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtJQUN6QixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ25DO0lBQ0EsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0lBQ2hCLE1BQU0sT0FBTyxHQUFHLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLEtBQUs7QUFDTDtJQUNBLElBQUksT0FBTyxHQUFHLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM3QyxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoQyxDQUFDO0FBb0NEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxTQUFTLEdBQUc7SUFDckIsRUFBRSxPQUFPLGVBQWUsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3ZDLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsd0JBQXdCLENBQUMsS0FBSyxFQUFFO0lBQ3pDLEVBQUUsTUFBTSxrQkFBa0IsR0FBRyxLQUFLLENBQUMscUJBQXFCLEVBQUUsQ0FBQztBQUMzRDtJQUNBLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQztBQUMxRTtJQUNBLEVBQUUsTUFBTSxZQUFZLEdBQUc7SUFDdkIsSUFBSSxRQUFRLEVBQUUsT0FBTztJQUNyQixJQUFJLE9BQU8sRUFBRSxpQkFBaUIsSUFBSSxjQUFjLEVBQUU7SUFDbEQsR0FBRyxDQUFDO0FBQ0o7SUFDQSxFQUFFLElBQUksWUFBWSxFQUFFO0lBQ3BCLElBQUksWUFBWSxDQUFDLGNBQWMsR0FBRyxZQUFZLENBQUM7SUFDL0MsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLFlBQVksQ0FBQztJQUN0Qjs7SUN6SEE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sZ0NBQWdDLEdBQUcsZUFBZSxDQUFDO0FBQ3pEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxxQ0FBcUMsR0FBRyxvQkFBb0IsQ0FBQztBQUNuRTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sNEJBQTRCLEdBQUcsV0FBVyxDQUFDO0FBQ2pEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxnQ0FBZ0MsR0FBRyxlQUFlLENBQUM7QUFtQnpEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSw2QkFBNkIsR0FBRyxtQkFBbUIsQ0FBQztBQUMxRDtJQUNBLE1BQU0saUNBQWlDLEdBQUcsdUJBQXVCOztJQ2hEakUsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7SUFDNUIsTUFBTSxjQUFjLEdBQUcsQ0FBQzs7SUNDeEIsTUFBTSx5QkFBeUIsR0FBRyxjQUFjLENBQUM7SUFDakQsTUFBTSxtQ0FBbUMsR0FBRyx1QkFBdUIsQ0FBQztBQVNwRTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsdUJBQXVCLENBQUMsSUFBSSxFQUFFO0lBQ3ZDLEVBQUUsT0FBTztJQUNULElBQUksS0FBSyxFQUFFLENBQUMsSUFBSSxHQUFHLHlCQUF5QixDQUFDO0lBQzdDLElBQUksY0FBYyxFQUFFLENBQUMsSUFBSSxHQUFHLG1DQUFtQyxDQUFDO0lBQ2hFLEdBQUcsQ0FBQztJQUNKOztJQ3JCQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZUFBZSxDQUFDLFVBQVUsRUFBRTtJQUNyQyxFQUFFLElBQUksT0FBTyxVQUFVLEtBQUssU0FBUyxFQUFFO0lBQ3ZDLElBQUksT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUIsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLElBQUksR0FBRyxPQUFPLFVBQVUsS0FBSyxRQUFRLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztJQUNwRixFQUFFLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7SUFDdkUsSUFBSSxPQUFPLFNBQVMsQ0FBQztJQUNyQixHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sSUFBSSxDQUFDO0lBQ2Q7O0lDZEEsTUFBTSx5QkFBeUIsR0FBRyxTQUFTLENBQUM7QUFDNUM7SUFDQSxNQUFNLCtCQUErQixHQUFHLFVBQVUsQ0FBQztBQVFuRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxxQ0FBcUM7SUFDOUM7SUFDQSxFQUFFLGFBQWE7SUFDZixFQUFFO0lBQ0YsRUFBRSxNQUFNLGFBQWEsR0FBRyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUMxRDtJQUNBLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRTtJQUN0QixJQUFJLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxNQUFNLHNCQUFzQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxLQUFLO0lBQzdGLElBQUksSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLCtCQUErQixDQUFDLEVBQUU7SUFDcEQsTUFBTSxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLHlCQUF5QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3pFLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNsQyxLQUFLO0lBQ0wsSUFBSSxPQUFPLEdBQUcsQ0FBQztJQUNmLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNUO0lBQ0E7SUFDQTtJQUNBLEVBQUUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUN0RCxJQUFJLE9BQU8sc0JBQXNCLEVBQUU7SUFDbkMsR0FBRyxNQUFNO0lBQ1QsSUFBSSxPQUFPLFNBQVMsQ0FBQztJQUNyQixHQUFHO0lBQ0gsQ0FBQztBQWdDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsa0JBQWtCO0lBQzNCLEVBQUUsYUFBYTtJQUNmLEVBQUU7SUFDRixFQUFFLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUU7SUFDckYsSUFBSSxPQUFPLFNBQVMsQ0FBQztJQUNyQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRTtJQUNwQztJQUNBLElBQUksT0FBTyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksS0FBSztJQUMvQyxNQUFNLE1BQU0saUJBQWlCLEdBQUcscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUQsTUFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEtBQUs7SUFDbEUsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3pCLE9BQU8sQ0FBQyxDQUFDO0lBQ1QsTUFBTSxPQUFPLEdBQUcsQ0FBQztJQUNqQixLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDWCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8scUJBQXFCLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDOUMsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxxQkFBcUIsQ0FBQyxhQUFhLEVBQUU7SUFDOUMsRUFBRSxPQUFPLGFBQWE7SUFDdEIsS0FBSyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ2YsS0FBSyxHQUFHLENBQUMsWUFBWSxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsSUFBSSxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFHLEtBQUssTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxLQUFLO0lBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksS0FBSyxFQUFFO0lBQ3hCLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUN6QixPQUFPO0lBQ1AsTUFBTSxPQUFPLEdBQUcsQ0FBQztJQUNqQixLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDWDs7SUMxR0EsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUM7QUFDL0I7SUFDQSxJQUFJLHVCQUF1QixHQUFHLEtBQUssQ0FBQztBQXNCcEM7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQixDQUFDLElBQUksRUFBRTtJQUNsQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDckU7SUFDQTtJQUNBO0lBQ0EsRUFBRSxNQUFNLGNBQWMsR0FBRyxRQUFRLEdBQUcsTUFBTSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUM7SUFDN0UsRUFBRSxNQUFNLEtBQUssR0FBRyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDcEQ7SUFDQSxFQUFFLE1BQU0sT0FBTyxHQUFHLFFBQVEsR0FBRyxLQUFLLEVBQUUscUJBQXFCLEVBQUUsQ0FBQyxpQkFBaUIsSUFBSSxjQUFjLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFDM0c7SUFDQSxFQUFFLE9BQU87SUFDVCxJQUFJLGNBQWM7SUFDbEIsSUFBSSxPQUFPO0lBQ1gsSUFBSSxRQUFRO0lBQ1osR0FBRyxDQUFDO0lBQ0osQ0FBQztBQVVEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsMkJBQTJCLENBQUMsS0FBSyxFQUFFO0lBQzVDLEVBQUUsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDakMsSUFBSSxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU07SUFDcEcsTUFBTSxPQUFPLEVBQUUsTUFBTTtJQUNyQixNQUFNLFFBQVEsRUFBRSxPQUFPO0lBQ3ZCLE1BQU0sT0FBTyxFQUFFLFVBQVUsS0FBSyxrQkFBa0I7SUFDaEQsTUFBTSxVQUFVO0lBQ2hCLE1BQU0sR0FBRyxXQUFXO0lBQ3BCLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDUixHQUFHLE1BQU07SUFDVCxJQUFJLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHNCQUFzQixDQUFDLEtBQUssRUFBRTtJQUN2QyxFQUFFLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQ2pDLElBQUksT0FBTyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQyxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUM1QjtJQUNBLElBQUksT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNyQyxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksS0FBSyxZQUFZLElBQUksRUFBRTtJQUM3QixJQUFJLE9BQU8sd0JBQXdCLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDckQsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLGtCQUFrQixFQUFFLENBQUM7SUFDOUIsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUU7SUFDN0MsRUFBRSxNQUFNLElBQUksR0FBRyxTQUFTLEdBQUcsVUFBVSxDQUFDO0lBQ3RDLEVBQUUsT0FBTyxJQUFJLEdBQUcsU0FBUyxHQUFHLElBQUksR0FBRyxTQUFTLENBQUM7SUFDN0MsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxVQUFVLENBQUMsSUFBSSxFQUFFO0lBQzFCLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUM5QixJQUFJLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzlCLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUNwRTtJQUNBO0lBQ0EsRUFBRSxJQUFJLG1DQUFtQyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQ2pELElBQUksTUFBTSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztBQUN2RjtJQUNBLElBQUksT0FBTztJQUNYLE1BQU0sT0FBTztJQUNiLE1BQU0sUUFBUTtJQUNkLE1BQU0sSUFBSSxFQUFFLFVBQVU7SUFDdEIsTUFBTSxXQUFXLEVBQUUsSUFBSTtJQUN2QixNQUFNLGNBQWMsRUFBRSxZQUFZO0lBQ2xDLE1BQU0sZUFBZSxFQUFFLHNCQUFzQixDQUFDLFNBQVMsQ0FBQztJQUN4RDtJQUNBLE1BQU0sU0FBUyxFQUFFLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxJQUFJLFNBQVM7SUFDN0QsTUFBTSxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO0lBQ3RDLE1BQU0sRUFBRSxFQUFFLFVBQVUsQ0FBQyw0QkFBNEIsQ0FBQztJQUNsRCxNQUFNLE1BQU0sRUFBRSxVQUFVLENBQUMsZ0NBQWdDLENBQUM7SUFDMUQsTUFBTSxLQUFLLEVBQUUsMkJBQTJCLENBQUMsS0FBSyxDQUFDO0lBQy9DLEtBQUssQ0FBQztJQUNOLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQSxFQUFFLE9BQU87SUFDVCxJQUFJLE9BQU87SUFDWCxJQUFJLFFBQVE7SUFDWixJQUFJLGVBQWUsRUFBRSxDQUFDO0lBQ3RCLElBQUksSUFBSSxFQUFFLEVBQUU7SUFDWixHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLG1DQUFtQyxDQUFDLElBQUksRUFBRTtJQUNuRCxFQUFFLE1BQU0sUUFBUSxHQUFHLElBQUksRUFBRTtJQUN6QixFQUFFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDckgsQ0FBQztBQUNEO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7SUFDaEMsRUFBRSxPQUFPLE9BQU8sQ0FBQyxJQUFJLEdBQUcsV0FBVyxLQUFLLFVBQVUsQ0FBQztJQUNuRCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGFBQWEsQ0FBQyxJQUFJLEVBQUU7SUFDN0I7SUFDQTtJQUNBLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM1QyxFQUFFLE9BQU8sVUFBVSxLQUFLLGtCQUFrQixDQUFDO0lBQzNDLENBQUM7QUFDRDtJQUNBO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7SUFDbEMsRUFBRSxJQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssaUJBQWlCLEVBQUU7SUFDcEQsSUFBSSxPQUFPLFNBQVMsQ0FBQztJQUNyQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxjQUFjLEVBQUU7SUFDdEMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sTUFBTSxDQUFDLE9BQU8sSUFBSSxlQUFlLENBQUM7SUFDM0MsQ0FBQztJQUdELE1BQU0sZUFBZSxHQUFHLGlCQUFpQixDQUFDO0FBbUQxQztJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLElBQUksRUFBRTtJQUMzQixFQUFFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FBQztJQUN2QyxDQUFDO0FBY0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQixHQUFHO0lBQy9CLEVBQUUsSUFBSSxDQUFDLHVCQUF1QixFQUFFO0lBQ2hDLElBQUksY0FBYyxDQUFDLE1BQU07SUFDekI7SUFDQSxNQUFNLE9BQU8sQ0FBQyxJQUFJO0lBQ2xCLFFBQVEscUlBQXFJO0lBQzdJLE9BQU8sQ0FBQztJQUNSLEtBQUssQ0FBQyxDQUFDO0lBQ1AsSUFBSSx1QkFBdUIsR0FBRyxJQUFJLENBQUM7SUFDbkMsR0FBRztJQUNIOztJQzVSQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGVBQWU7SUFDeEIsRUFBRSxZQUFZO0lBQ2QsRUFBRTtJQUNGLEVBQUUsSUFBSSxPQUFPLGtCQUFrQixLQUFLLFNBQVMsSUFBSSxDQUFDLGtCQUFrQixFQUFFO0lBQ3RFLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLE9BQU8sR0FBRyxZQUFZLElBQUksU0FBUyxFQUFFLEVBQUUsVUFBVSxFQUFFLENBQUM7SUFDNUQsRUFBRTtJQUNGLElBQUksQ0FBQyxDQUFDLE9BQU87SUFDYjtJQUNBLEtBQUssT0FBTyxDQUFDLGdCQUFnQixJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztJQUNqRSxJQUFJO0lBQ0o7O0lDakNBLE1BQU0sbUJBQW1CLEdBQUcsWUFBWTs7SUNTeEM7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLGdCQUFnQixHQUFHLFlBQVksQ0FBQztBQVN0QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1DQUFtQyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUU7SUFDL0QsRUFBRSxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDdEM7SUFDQSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUMxRDtJQUNBO0lBQ0E7SUFDQSxFQUFFLE1BQU0sR0FBRyxHQUFHO0lBQ2QsSUFBSSxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVcsSUFBSSxtQkFBbUI7SUFDM0QsSUFBSSxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87SUFDNUIsSUFBSSxVQUFVO0lBQ2QsSUFBSSxRQUFRO0lBQ1osR0FBRyxDQUFDO0FBQ0o7SUFDQSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDO0lBQ0EsRUFBRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsa0NBQWtDLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUMzRCxFQUFFLE1BQU0sa0JBQWtCLEdBQUcsS0FBSyxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDM0QsRUFBRSxPQUFPLGtCQUFrQixDQUFDLEdBQUcsSUFBSSxtQ0FBbUMsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0csQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGlDQUFpQyxDQUFDLElBQUksRUFBRTtJQUNqRCxFQUFFLE1BQU0sTUFBTSxHQUFHLFNBQVMsRUFBRSxDQUFDO0lBQzdCLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRTtJQUNmLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQyxFQUFFLE1BQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1QyxFQUFFLE1BQU0sa0JBQWtCLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQztJQUMvQyxFQUFFLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxVQUFVLENBQUM7QUFDdkQ7SUFDQTtJQUNBO0lBQ0EsRUFBRSxNQUFNLGtCQUFrQjtJQUMxQixJQUFJLFVBQVUsRUFBRSxHQUFHLENBQUMsb0JBQW9CLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0lBQ3ZHLEVBQUUsU0FBUyx5QkFBeUIsQ0FBQyxHQUFHLEVBQUU7SUFDMUMsSUFBSSxJQUFJLE9BQU8sa0JBQWtCLEtBQUssUUFBUSxJQUFJLE9BQU8sa0JBQWtCLEtBQUssUUFBUSxFQUFFO0lBQzFGLE1BQU0sR0FBRyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0lBQ2hELEtBQUs7SUFDTCxJQUFJLE9BQU8sR0FBRyxDQUFDO0lBQ2YsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLE1BQU0sU0FBUyxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLENBQUM7SUFDbEQsRUFBRSxJQUFJLFNBQVMsRUFBRTtJQUNqQixJQUFJLE9BQU8seUJBQXlCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDaEQsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLE1BQU0sYUFBYSxHQUFHLFVBQVUsRUFBRSxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDdEQ7SUFDQTtJQUNBLEVBQUUsTUFBTSxlQUFlLEdBQUcsYUFBYSxJQUFJLHFDQUFxQyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ2hHO0lBQ0EsRUFBRSxJQUFJLGVBQWUsRUFBRTtJQUN2QixJQUFJLE9BQU8seUJBQXlCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDdEQsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLE1BQU0sR0FBRyxHQUFHLG1DQUFtQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDdEY7SUFDQTtJQUNBLEVBQUUsTUFBTSxNQUFNLEdBQUcsa0JBQWtCLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztBQUN0RTtJQUNBO0lBQ0EsRUFBRSxNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDO0lBQ3hDLEVBQUUsSUFBSSxNQUFNLEtBQUssS0FBSyxJQUFJLElBQUksRUFBRTtJQUNoQyxJQUFJLEdBQUcsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0lBQzNCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsSUFBSSxlQUFlLEVBQUUsRUFBRTtJQUN6QixJQUFJLEdBQUcsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ2xELElBQUksR0FBRyxDQUFDLFdBQVc7SUFDbkI7SUFDQTtJQUNBLE1BQU0sVUFBVSxFQUFFLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQztJQUMzQztJQUNBLE1BQU0sdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxFQUFFLHFCQUFxQixFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdGLEdBQUc7QUFDSDtJQUNBLEVBQUUseUJBQXlCLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDakM7SUFDQSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUMxQztJQUNBLEVBQUUsT0FBTyxHQUFHLENBQUM7SUFDYjs7SUMvSEE7SUFDQSxNQUFNLFNBQVMsR0FBRyxpRUFBaUUsQ0FBQztBQUNwRjtJQUNBLFNBQVMsZUFBZSxDQUFDLFFBQVEsRUFBRTtJQUNuQyxFQUFFLE9BQU8sUUFBUSxLQUFLLE1BQU0sSUFBSSxRQUFRLEtBQUssT0FBTyxDQUFDO0lBQ3JELENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLEdBQUcsRUFBRSxZQUFZLEdBQUcsS0FBSyxFQUFFO0lBQ2hELEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxHQUFHLEdBQUcsQ0FBQztJQUN6RSxFQUFFO0lBQ0YsSUFBSSxDQUFDLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsRUFBRSxZQUFZLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDekUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQy9FLElBQUk7SUFDSixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGFBQWEsQ0FBQyxHQUFHLEVBQUU7SUFDNUIsRUFBRSxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BDO0lBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFO0lBQ2Q7SUFDQSxJQUFJLGNBQWMsQ0FBQyxNQUFNO0lBQ3pCO0lBQ0EsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xELEtBQUssQ0FBQyxDQUFDO0lBQ1AsSUFBSSxPQUFPLFNBQVMsQ0FBQztJQUNyQixHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFLFFBQVEsR0FBRyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9GLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLEVBQUUsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDO0FBQzNCO0lBQ0EsRUFBRSxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLEVBQUUsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUN4QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QyxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLEVBQUU7SUFDN0IsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFNBQVMsRUFBRTtJQUNqQixJQUFJLE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakQsSUFBSSxJQUFJLFlBQVksRUFBRTtJQUN0QixNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEMsS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxpQkFBaUIsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsR0FBRyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ2xHLENBQUM7QUFDRDtJQUNBLFNBQVMsaUJBQWlCLENBQUMsVUFBVSxFQUFFO0lBQ3ZDLEVBQUUsT0FBTztJQUNULElBQUksUUFBUSxFQUFFLFVBQVUsQ0FBQyxRQUFRO0lBQ2pDLElBQUksU0FBUyxFQUFFLFVBQVUsQ0FBQyxTQUFTLElBQUksRUFBRTtJQUN6QyxJQUFJLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxJQUFJLEVBQUU7SUFDL0IsSUFBSSxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUk7SUFDekIsSUFBSSxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksSUFBSSxFQUFFO0lBQy9CLElBQUksSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLElBQUksRUFBRTtJQUMvQixJQUFJLFNBQVMsRUFBRSxVQUFVLENBQUMsU0FBUztJQUNuQyxHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLFdBQVcsQ0FBQyxHQUFHLEVBQUU7SUFDMUIsRUFBRSxJQUFJLENBQUNILGFBQVcsRUFBRTtJQUNwQixJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEdBQUcsR0FBRyxDQUFDO0FBQzVDO0lBQ0EsRUFBRSxNQUFNLGtCQUFrQixHQUFHLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUUsRUFBRSxNQUFNLDJCQUEyQixHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxTQUFTLElBQUk7SUFDM0UsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO0lBQ3pCLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixFQUFFLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQy9ELE1BQU0sT0FBTyxJQUFJLENBQUM7SUFDbEIsS0FBSztJQUNMLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRyxDQUFDLENBQUM7QUFDTDtJQUNBLEVBQUUsSUFBSSwyQkFBMkIsRUFBRTtJQUNuQyxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDakMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsc0NBQXNDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxFQUFFO0lBQ2xDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLHFDQUFxQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyRSxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRTtJQUN6QyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0QsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE9BQU8sQ0FBQyxJQUFJLEVBQUU7SUFDdkIsRUFBRSxNQUFNLFVBQVUsR0FBRyxPQUFPLElBQUksS0FBSyxRQUFRLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlGLEVBQUUsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRTtJQUMvQyxJQUFJLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLEdBQUc7SUFDSCxFQUFFLE9BQU8sVUFBVSxDQUFDO0lBQ3BCOztJQ3pIQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxHQUFHLEVBQUUsYUFBYSxHQUFHLENBQUMsUUFBUSxFQUFFO0lBQ2xFLEVBQUUsSUFBSTtJQUNOO0lBQ0EsSUFBSSxPQUFPLEtBQUssQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNsRCxHQUFHLENBQUMsT0FBTyxHQUFHLEVBQUU7SUFDaEIsSUFBSSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDdEQsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0EsU0FBUyxlQUFlO0lBQ3hCO0lBQ0EsRUFBRSxNQUFNO0lBQ1I7SUFDQSxFQUFFLEtBQUssR0FBRyxDQUFDO0lBQ1g7SUFDQSxFQUFFLE9BQU8sR0FBRyxHQUFHLEdBQUcsSUFBSTtJQUN0QixFQUFFO0lBQ0YsRUFBRSxNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzlDO0lBQ0EsRUFBRSxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxPQUFPLEVBQUU7SUFDdEMsSUFBSSxPQUFPLGVBQWUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sVUFBVSxFQUFFO0lBQ3JCLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsS0FBSztJQUNkLEVBQUUsR0FBRztJQUNMLEVBQUUsS0FBSztJQUNQLEVBQUUsS0FBSyxHQUFHLENBQUMsUUFBUTtJQUNuQixFQUFFLGFBQWEsR0FBRyxDQUFDLFFBQVE7SUFDM0IsRUFBRSxJQUFJLEdBQUcsV0FBVyxFQUFFO0lBQ3RCLEVBQUU7SUFDRixFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3BDO0lBQ0E7SUFDQSxFQUFFO0lBQ0YsSUFBSSxLQUFLLElBQUksSUFBSTtJQUNqQixJQUFJLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEtBQUssQ0FBQztJQUNoRCxLQUFLLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pELElBQUk7SUFDSixJQUFJLE9BQU8sS0FBSyxFQUFFO0lBQ2xCLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNqRDtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQzNDLElBQUksT0FBTyxXQUFXLENBQUM7SUFDdkIsR0FBRztBQUNIO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRywrQkFBK0IsQ0FBQyxFQUFFO0lBQ2pELElBQUksT0FBTyxLQUFLLEVBQUU7SUFDbEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsRUFBRSxNQUFNLGNBQWM7SUFDdEIsSUFBSSxPQUFPLENBQUMsS0FBSyxHQUFHLHlDQUF5QyxDQUFDLEtBQUssUUFBUTtJQUMzRSxTQUFTLENBQUMsS0FBSyxHQUFHLHlDQUF5QyxDQUFDO0lBQzVELFFBQVEsS0FBSyxDQUFDO0FBQ2Q7SUFDQTtJQUNBLEVBQUUsSUFBSSxjQUFjLEtBQUssQ0FBQyxFQUFFO0lBQzVCO0lBQ0EsSUFBSSxPQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlDLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUN0QixJQUFJLE9BQU8sY0FBYyxDQUFDO0lBQzFCLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxNQUFNLGVBQWUsR0FBRyxLQUFLLEVBQUU7SUFDakMsRUFBRSxJQUFJLGVBQWUsSUFBSSxPQUFPLGVBQWUsQ0FBQyxNQUFNLEtBQUssVUFBVSxFQUFFO0lBQ3ZFLElBQUksSUFBSTtJQUNSLE1BQU0sTUFBTSxTQUFTLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2pEO0lBQ0EsTUFBTSxPQUFPLEtBQUssQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLGNBQWMsR0FBRyxDQUFDLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzNFLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNsQjtJQUNBLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLE1BQU0sVUFBVSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFO0lBQ3ZELEVBQUUsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQ25CO0lBQ0E7SUFDQTtJQUNBLEVBQUUsTUFBTSxTQUFTLEdBQUcsb0JBQW9CLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDakQ7SUFDQSxFQUFFLEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFO0lBQ3BDO0lBQ0EsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsRUFBRTtJQUNwRSxNQUFNLFNBQVM7SUFDZixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksUUFBUSxJQUFJLGFBQWEsRUFBRTtJQUNuQyxNQUFNLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxtQkFBbUIsQ0FBQztJQUNqRCxNQUFNLE1BQU07SUFDWixLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzNDLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLGNBQWMsR0FBRyxDQUFDLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hHO0lBQ0EsSUFBSSxRQUFRLEVBQUUsQ0FBQztJQUNmLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkI7SUFDQTtJQUNBLEVBQUUsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWM7SUFDdkIsRUFBRSxHQUFHO0lBQ0w7SUFDQTtJQUNBLEVBQUUsS0FBSztJQUNQLEVBQUU7SUFDRixFQUFFLElBQUk7SUFDTixJQUFJLElBQUksR0FBRyxLQUFLLFFBQVEsSUFBSSxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sRUFBRTtJQUNwRixNQUFNLE9BQU8sVUFBVSxDQUFDO0lBQ3hCLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxHQUFHLEtBQUssZUFBZSxFQUFFO0lBQ2pDLE1BQU0sT0FBTyxpQkFBaUIsQ0FBQztJQUMvQixLQUFLO0FBQ0w7SUFDQTtJQUNBO0FBQ0E7SUFDQSxJQUFJLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLEtBQUssS0FBSyxNQUFNLEVBQUU7SUFDM0QsTUFBTSxPQUFPLFVBQVUsQ0FBQztJQUN4QixLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLElBQUksS0FBSyxLQUFLLE1BQU0sRUFBRTtJQUMzRCxNQUFNLE9BQU8sVUFBVSxDQUFDO0lBQ3hCLEtBQUs7QUFDTDtJQUNBO0lBQ0EsSUFBSSxJQUFJLE9BQU8sUUFBUSxLQUFLLFdBQVcsSUFBSSxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQy9ELE1BQU0sT0FBTyxZQUFZLENBQUM7SUFDMUIsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUMvQixNQUFNLE9BQU8sZ0JBQWdCLENBQUM7SUFDOUIsS0FBSztBQUNMO0lBQ0E7SUFDQSxJQUFJLElBQUksZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDakMsTUFBTSxPQUFPLGtCQUFrQixDQUFDO0lBQ2hDLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzlELE1BQU0sT0FBTyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLE9BQU8sS0FBSyxLQUFLLFVBQVUsRUFBRTtJQUNyQyxNQUFNLE9BQU8sQ0FBQyxXQUFXLEVBQUUsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JELEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7SUFDbkMsTUFBTSxPQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQyxLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7SUFDbkMsTUFBTSxPQUFPLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxLQUFLO0FBQ0w7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksTUFBTSxPQUFPLEdBQUcsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUM7SUFDQTtJQUNBLElBQUksSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDNUMsTUFBTSxPQUFPLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QyxLQUFLO0FBQ0w7SUFDQSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNoQixJQUFJLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0MsR0FBRztJQUNILENBQUM7SUFDRDtBQUNBO0lBQ0EsU0FBUyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUU7SUFDbkMsRUFBRSxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pEO0lBQ0EsRUFBRSxPQUFPLFNBQVMsRUFBRSxXQUFXLEdBQUcsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQUM7SUFDaEYsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUU7SUFDM0I7SUFDQSxFQUFFLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ2xELENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQztBQStCRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxHQUFHO0lBQ3ZCLEVBQUUsTUFBTSxLQUFLLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUM5QixFQUFFLFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRTtJQUN4QixJQUFJLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUN4QixNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7SUFDTCxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkIsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLFNBQVMsU0FBUyxDQUFDLEdBQUcsRUFBRTtJQUMxQixJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsR0FBRztJQUNILEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUM5Qjs7SUNuVEE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLE9BQU8sRUFBRSxLQUFLLEdBQUcsRUFBRSxFQUFFO0lBQzdDLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsRUFBRTtJQUMzQixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFO0lBQzlDLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUM7SUFDcEMsRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsRUFBRTtJQUN6QyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQjtJQUM1QixFQUFFLFFBQVE7SUFDVixFQUFFLFFBQVE7SUFDVixFQUFFO0lBQ0YsRUFBRSxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEM7SUFDQSxFQUFFLEtBQUssTUFBTSxZQUFZLElBQUksYUFBYSxFQUFFO0lBQzVDLElBQUksTUFBTSxnQkFBZ0IsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ2xELElBQUksTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0FBQzVEO0lBQ0EsSUFBSSxJQUFJLE1BQU0sRUFBRTtJQUNoQixNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQVFEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxVQUFVLENBQUMsS0FBSyxFQUFFO0lBQzNCLEVBQUUsTUFBTSxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0MsRUFBRSxPQUFPLE9BQU8sQ0FBQyxjQUFjLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRyxDQUFDO0FBU0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGlCQUFpQixDQUFDLFFBQVEsRUFBRTtJQUNyQyxFQUFFLE1BQU0sQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDO0FBQ3ZDO0lBQ0E7SUFDQSxFQUFFLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDekM7SUFDQSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksRUFBRTtJQUN4QixJQUFJLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQ25DLE1BQU0sS0FBSyxHQUFHLE9BQU8sSUFBSSxLQUFLLFFBQVEsR0FBRyxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xGLEtBQUssTUFBTTtJQUNYLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksS0FBSyxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3JFLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO0lBQzVCLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDeEM7SUFDQSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDakQ7SUFDQSxJQUFJLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxJQUFJLE9BQU8sWUFBWSxVQUFVLEVBQUU7SUFDdEUsTUFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdEIsS0FBSyxNQUFNO0lBQ1gsTUFBTSxJQUFJLGtCQUFrQixDQUFDO0lBQzdCLE1BQU0sSUFBSTtJQUNWLFFBQVEsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNyRCxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDbEI7SUFDQTtJQUNBO0lBQ0EsUUFBUSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ2hFLE9BQU87SUFDUCxNQUFNLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ2pDLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxHQUFHLEtBQUssR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEUsQ0FBQztBQUNEO0lBQ0EsU0FBUyxhQUFhLENBQUMsT0FBTyxFQUFFO0lBQ2hDLEVBQUUsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDeEU7SUFDQSxFQUFFLE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzdDLEVBQUUsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLEVBQUUsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7SUFDaEMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMvQixJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzVCLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztBQWlERDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsNEJBQTRCLENBQUMsVUFBVSxFQUFFO0lBQ2xELEVBQUUsTUFBTSxNQUFNLEdBQUcsT0FBTyxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUM7QUFDckc7SUFDQSxFQUFFLE9BQU87SUFDVCxJQUFJO0lBQ0osTUFBTSxJQUFJLEVBQUUsWUFBWTtJQUN4QixNQUFNLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTTtJQUMzQixNQUFNLFFBQVEsRUFBRSxVQUFVLENBQUMsUUFBUTtJQUNuQyxNQUFNLFlBQVksRUFBRSxVQUFVLENBQUMsV0FBVztJQUMxQyxNQUFNLGVBQWUsRUFBRSxVQUFVLENBQUMsY0FBYztJQUNoRCxLQUFLO0lBQ0wsSUFBSSxNQUFNO0lBQ1YsR0FBRyxDQUFDO0lBQ0osQ0FBQztBQUNEO0lBQ0EsTUFBTSw4QkFBOEIsR0FBRztJQUN2QyxFQUFFLE9BQU8sRUFBRSxTQUFTO0lBQ3BCLEVBQUUsUUFBUSxFQUFFLFNBQVM7SUFDckIsRUFBRSxVQUFVLEVBQUUsWUFBWTtJQUMxQixFQUFFLFdBQVcsRUFBRSxhQUFhO0lBQzVCLEVBQUUsS0FBSyxFQUFFLE9BQU87SUFDaEIsRUFBRSxhQUFhLEVBQUUsVUFBVTtJQUMzQixFQUFFLFdBQVcsRUFBRSxTQUFTO0lBQ3hCLEVBQUUsT0FBTyxFQUFFLFNBQVM7SUFDcEIsRUFBRSxhQUFhLEVBQUUsU0FBUztJQUMxQixFQUFFLFlBQVksRUFBRSxRQUFRO0lBQ3hCLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUTtJQUM1QixFQUFFLFFBQVEsRUFBRSxTQUFTO0lBQ3JCLEVBQUUsUUFBUSxFQUFFLFVBQVU7SUFDdEIsRUFBRSxJQUFJLEVBQUUsTUFBTTtJQUNkLEVBQUUsWUFBWSxFQUFFLFVBQVU7SUFDMUIsRUFBRSxRQUFRLEVBQUUsVUFBVTtJQUN0QixDQUFDLENBQUM7QUFDRjtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsOEJBQThCLENBQUMsSUFBSSxFQUFFO0lBQzlDLEVBQUUsT0FBTyw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxDQUFDO0FBQ0Q7SUFDQTtJQUNBLFNBQVMsK0JBQStCLENBQUMsZUFBZSxFQUFFO0lBQzFELEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUU7SUFDN0IsSUFBSSxPQUFPO0lBQ1gsR0FBRztJQUNILEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDO0lBQ2hELEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztJQUMzQixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsMEJBQTBCO0lBQ25DLEVBQUUsS0FBSztJQUNQLEVBQUUsT0FBTztJQUNULEVBQUUsTUFBTTtJQUNSLEVBQUUsR0FBRztJQUNMLEVBQUU7SUFDRixFQUFFLE1BQU0sc0JBQXNCLEdBQUcsS0FBSyxDQUFDLHFCQUFxQixFQUFFLHNCQUFzQixDQUFDO0lBQ3JGLEVBQUUsT0FBTztJQUNULElBQUksUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO0lBQzVCLElBQUksT0FBTyxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO0lBQ3JDLElBQUksSUFBSSxPQUFPLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDcEMsSUFBSSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQ3JELElBQUksSUFBSSxzQkFBc0IsSUFBSTtJQUNsQyxNQUFNLEtBQUssRUFBRSxzQkFBc0I7SUFDbkMsS0FBSyxDQUFDO0lBQ04sR0FBRyxDQUFDO0lBQ0o7O0lDL09BO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx1QkFBdUIsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0lBQ2pELEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRTtJQUNoQixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7SUFDSCxFQUFFLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUM7SUFDOUIsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQ2xELEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUMzRCxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNoRyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNwRixFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLHFCQUFxQjtJQUM5QixFQUFFLE9BQU87SUFDVCxFQUFFLEdBQUc7SUFDTCxFQUFFLFFBQVE7SUFDVixFQUFFLE1BQU07SUFDUixFQUFFO0lBQ0YsRUFBRSxNQUFNLE9BQU8sR0FBRywrQkFBK0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1RCxFQUFFLE1BQU0sZUFBZSxHQUFHO0lBQzFCLElBQUksT0FBTyxFQUFFLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO0lBQ3JDLElBQUksSUFBSSxPQUFPLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDcEMsSUFBSSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQ3JELEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxNQUFNLFlBQVk7SUFDcEIsSUFBSSxZQUFZLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUN4RztJQUNBLEVBQUUsT0FBTyxjQUFjLENBQUMsZUFBZSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQjtJQUM1QixFQUFFLEtBQUs7SUFDUCxFQUFFLEdBQUc7SUFDTCxFQUFFLFFBQVE7SUFDVixFQUFFLE1BQU07SUFDUixFQUFFO0lBQ0YsRUFBRSxNQUFNLE9BQU8sR0FBRywrQkFBK0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1RDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsRUFBRSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssY0FBYyxHQUFHLEtBQUssQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO0FBQ3ZGO0lBQ0EsRUFBRSx1QkFBdUIsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2hEO0lBQ0EsRUFBRSxNQUFNLGVBQWUsR0FBRywwQkFBMEIsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNsRjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsRUFBRSxPQUFPLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQztBQUNyQztJQUNBLEVBQUUsTUFBTSxTQUFTLEdBQUcsQ0FBQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqRCxFQUFFLE9BQU8sY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDdEQ7O0lDekVBO0FBQ0E7SUFDQTtJQUNBLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLE1BQU0sRUFBRTtJQUMvQjtJQUNBLEVBQUUsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDckU7SUFDQSxFQUFFLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsVUFBVSxDQUFDO0lBQ3pFO0lBQ0EsRUFBRSxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLFVBQVUsQ0FBQztJQUN6RSxDQUFDLEVBQUUsTUFBTSxLQUFLLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzVCO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsbUJBQW1CLENBQUMsS0FBSyxFQUFFO0lBQ3BDLEVBQUUsT0FBTyxJQUFJLFdBQVcsQ0FBQyxPQUFPLElBQUk7SUFDcEMsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkIsR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQixDQUFDLE1BQU0sRUFBRTtJQUNyQyxFQUFFLE9BQU8sSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxLQUFLO0lBQ3hDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25CLEdBQUcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLFdBQVcsQ0FBQztBQUNsQjtJQUNBLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRTtJQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUNqQyxJQUFJLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0FBQ3hCO0lBQ0EsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLEdBQUc7QUFDSDtJQUNBO0lBQ0EsR0FBRyxJQUFJO0lBQ1AsSUFBSSxXQUFXO0lBQ2YsSUFBSSxVQUFVO0lBQ2QsSUFBSTtJQUNKLElBQUksT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEtBQUs7SUFDaEQsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztJQUMxQixRQUFRLEtBQUs7SUFDYixRQUFRLE1BQU0sSUFBSTtJQUNsQixVQUFVLElBQUksQ0FBQyxXQUFXLEVBQUU7SUFDNUI7SUFDQTtJQUNBLFlBQVksT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQzdCLFdBQVcsTUFBTTtJQUNqQixZQUFZLElBQUk7SUFDaEIsY0FBYyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDM0MsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ3hCLGNBQWMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLGFBQWE7SUFDYixXQUFXO0lBQ1gsU0FBUztJQUNULFFBQVEsTUFBTSxJQUFJO0lBQ2xCLFVBQVUsSUFBSSxDQUFDLFVBQVUsRUFBRTtJQUMzQixZQUFZLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzQixXQUFXLE1BQU07SUFDakIsWUFBWSxJQUFJO0lBQ2hCLGNBQWMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUN4QixjQUFjLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QixhQUFhO0lBQ2IsV0FBVztJQUNYLFNBQVM7SUFDVCxPQUFPLENBQUMsQ0FBQztJQUNULE1BQU0sSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDOUIsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHO0FBQ0g7SUFDQTtJQUNBLEdBQUcsS0FBSztJQUNSLElBQUksVUFBVTtJQUNkLElBQUk7SUFDSixJQUFJLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzdDLEdBQUc7QUFDSDtJQUNBO0lBQ0EsR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFO0lBQ3RCLElBQUksT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEtBQUs7SUFDaEQsTUFBTSxJQUFJLEdBQUcsQ0FBQztJQUNkLE1BQU0sSUFBSSxVQUFVLENBQUM7QUFDckI7SUFDQSxNQUFNLE9BQU8sSUFBSSxDQUFDLElBQUk7SUFDdEIsUUFBUSxLQUFLLElBQUk7SUFDakIsVUFBVSxVQUFVLEdBQUcsS0FBSyxDQUFDO0lBQzdCLFVBQVUsR0FBRyxHQUFHLEtBQUssQ0FBQztJQUN0QixVQUFVLElBQUksU0FBUyxFQUFFO0lBQ3pCLFlBQVksU0FBUyxFQUFFLENBQUM7SUFDeEIsV0FBVztJQUNYLFNBQVM7SUFDVCxRQUFRLE1BQU0sSUFBSTtJQUNsQixVQUFVLFVBQVUsR0FBRyxJQUFJLENBQUM7SUFDNUIsVUFBVSxHQUFHLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLFVBQVUsSUFBSSxTQUFTLEVBQUU7SUFDekIsWUFBWSxTQUFTLEVBQUUsQ0FBQztJQUN4QixXQUFXO0lBQ1gsU0FBUztJQUNULE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTTtJQUNuQixRQUFRLElBQUksVUFBVSxFQUFFO0lBQ3hCLFVBQVUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLFVBQVUsT0FBTztJQUNqQixTQUFTO0FBQ1Q7SUFDQSxRQUFRLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUN0QixPQUFPLENBQUMsQ0FBQztJQUNULEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRztBQUNIO0lBQ0E7SUFDQSxHQUFHLGdCQUFnQixHQUFHO0lBQ3RCLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxPQUFPLEVBQUU7SUFDeEMsTUFBTSxPQUFPO0lBQ2IsS0FBSztBQUNMO0lBQ0EsSUFBSSxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2xELElBQUksSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDeEI7SUFDQSxJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJO0lBQ3RDLE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7SUFDdEIsUUFBUSxPQUFPO0lBQ2YsT0FBTztBQUNQO0lBQ0EsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRTtJQUMzQyxRQUFRLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDakMsT0FBTztBQUNQO0lBQ0EsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRTtJQUMzQyxRQUFRLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsT0FBTztBQUNQO0lBQ0EsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRztBQUNIO0lBQ0E7SUFDQSxHQUFHLFlBQVksQ0FBQyxRQUFRLEVBQUU7SUFDMUIsSUFBSSxNQUFNLFNBQVMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEtBQUs7SUFDeEMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLE9BQU8sRUFBRTtJQUMxQyxRQUFRLE9BQU87SUFDZixPQUFPO0FBQ1A7SUFDQSxNQUFNLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQzdCLFFBQVEsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzVDLFFBQVEsT0FBTztJQUNmLE9BQU87QUFDUDtJQUNBLE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDMUIsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztBQUMxQjtJQUNBLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDOUIsS0FBSyxDQUFDO0FBQ047SUFDQSxJQUFJLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBSyxLQUFLO0lBQy9CLE1BQU0sU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDeEMsS0FBSyxDQUFDO0FBQ047SUFDQSxJQUFJLE1BQU0sTUFBTSxHQUFHLENBQUMsTUFBTSxLQUFLO0lBQy9CLE1BQU0sU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDekMsS0FBSyxDQUFDO0FBQ047SUFDQSxJQUFJLElBQUk7SUFDUixNQUFNLFFBQVEsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDaEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2hCLE1BQU0sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hCLEtBQUs7SUFDTCxHQUFHO0lBQ0g7O0lDdExBO0lBQ0E7SUFDQTtJQUNBLFNBQVMscUJBQXFCO0lBQzlCLEVBQUUsVUFBVTtJQUNaLEVBQUUsS0FBSztJQUNQLEVBQUUsSUFBSTtJQUNOLEVBQUUsS0FBSyxHQUFHLENBQUM7SUFDWCxFQUFFO0lBQ0YsRUFBRSxPQUFPLElBQUksV0FBVyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSztJQUM5QyxJQUFJLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxJQUFJLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLFNBQVMsS0FBSyxVQUFVLEVBQUU7SUFDM0QsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckIsS0FBSyxNQUFNO0lBQ1gsTUFBTSxNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUMsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFO0FBQ3BEO0lBQ0EsTUFBTUEsYUFBVyxJQUFJLFNBQVMsQ0FBQyxFQUFFLElBQUksTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO0FBQ3RIO0lBQ0EsTUFBTSxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtJQUM5QixRQUFRLEtBQUssTUFBTTtJQUNuQixXQUFXLElBQUksQ0FBQyxLQUFLLElBQUkscUJBQXFCLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqRyxXQUFXLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDOUIsT0FBTyxNQUFNO0lBQ2IsUUFBUSxLQUFLLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDdkUsV0FBVyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3hCLFdBQVcsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM5QixPQUFPO0lBQ1AsS0FBSztJQUNMLEdBQUcsQ0FBQyxDQUFDO0lBQ0w7O0lDaENBLElBQUksa0JBQWtCLENBQUM7SUFDdkIsSUFBSSxhQUFhLENBQUM7SUFDbEIsSUFBSSxzQkFBc0IsQ0FBQztBQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsdUJBQXVCLENBQUMsV0FBVyxFQUFFO0lBQzlDLEVBQUUsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLGVBQWUsQ0FBQztJQUNoRCxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUU7SUFDbkIsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUNkLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM5QztJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksc0JBQXNCLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxhQUFhLEVBQUU7SUFDdEUsSUFBSSxPQUFPLHNCQUFzQixDQUFDO0lBQ2xDLEdBQUc7QUFDSDtJQUNBLEVBQUUsYUFBYSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7QUFDckM7SUFDQTtJQUNBLEVBQUUsc0JBQXNCLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxRQUFRLEtBQUs7SUFDakUsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7SUFDN0IsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLENBQUM7SUFDOUIsS0FBSztBQUNMO0lBQ0EsSUFBSSxNQUFNLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNoRDtJQUNBLElBQUksSUFBSSxNQUFNLEVBQUU7SUFDaEIsTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLEtBQUssTUFBTTtJQUNYLE1BQU0sTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2hEO0lBQ0EsTUFBTSxLQUFLLElBQUksQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDeEQsUUFBUSxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUMsUUFBUSxNQUFNLFFBQVEsR0FBRyxVQUFVLEVBQUUsUUFBUSxDQUFDO0lBQzlDLFFBQVEsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdDO0lBQ0EsUUFBUSxJQUFJLFFBQVEsSUFBSSxPQUFPLEVBQUU7SUFDakMsVUFBVSxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsT0FBTyxDQUFDO0lBQ2xDLFVBQVUsa0JBQWtCLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDN0QsVUFBVSxNQUFNO0lBQ2hCLFNBQVM7SUFDVCxPQUFPO0lBQ1AsS0FBSztBQUNMO0lBQ0EsSUFBSSxPQUFPLEdBQUcsQ0FBQztJQUNmLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNUO0lBQ0EsRUFBRSxPQUFPLHNCQUFzQixDQUFDO0lBQ2hDOztJQ25EQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHFCQUFxQixDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUU7SUFDNUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUscUJBQXFCLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDekU7SUFDQTtJQUNBLEVBQUUsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hDO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsRUFBRSxJQUFJLElBQUksRUFBRTtJQUNaLElBQUksZ0JBQWdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xDLEdBQUc7QUFDSDtJQUNBLEVBQUUsdUJBQXVCLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzlDLEVBQUUsdUJBQXVCLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzlDLEVBQUUsdUJBQXVCLENBQUMsS0FBSyxFQUFFLHFCQUFxQixDQUFDLENBQUM7SUFDeEQsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFO0lBQ3pDLEVBQUUsTUFBTTtJQUNSLElBQUksS0FBSztJQUNULElBQUksSUFBSTtJQUNSLElBQUksSUFBSTtJQUNSLElBQUksUUFBUTtJQUNaLElBQUksS0FBSztJQUNULElBQUkscUJBQXFCO0lBQ3pCLElBQUksV0FBVztJQUNmLElBQUksV0FBVztJQUNmLElBQUksZUFBZTtJQUNuQixJQUFJLFdBQVc7SUFDZixJQUFJLGtCQUFrQjtJQUN0QixJQUFJLGVBQWU7SUFDbkIsSUFBSSxJQUFJO0lBQ1IsR0FBRyxHQUFHLFNBQVMsQ0FBQztBQUNoQjtJQUNBLEVBQUUsMEJBQTBCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNuRCxFQUFFLDBCQUEwQixDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakQsRUFBRSwwQkFBMEIsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pELEVBQUUsMEJBQTBCLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUN6RDtJQUNBLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDM0Y7SUFDQSxFQUFFLElBQUksS0FBSyxFQUFFO0lBQ2IsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksZUFBZSxFQUFFO0lBQ3ZCLElBQUksSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7SUFDM0MsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLElBQUksRUFBRTtJQUNaLElBQUksSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDckIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUU7SUFDMUIsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUM7SUFDN0QsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUU7SUFDMUIsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUM7SUFDN0QsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLGVBQWUsQ0FBQyxNQUFNLEVBQUU7SUFDOUIsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLEdBQUcsZUFBZSxDQUFDLENBQUM7SUFDekUsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUU7SUFDMUIsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUM7SUFDN0QsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLGtCQUFrQixFQUFFLENBQUM7SUFDbEYsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLDBCQUEwQjtBQUNuQztJQUNBLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUU7SUFDdkIsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUMsQ0FBQztBQUNEO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFO0lBQ3ZDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ3ZFO0lBQ0EsRUFBRSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ2pDLElBQUksS0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQy9DLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRTtJQUNoQyxJQUFJLEtBQUssQ0FBQyxJQUFJLEdBQUcsRUFBRSxHQUFHLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM1QyxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDaEMsSUFBSSxLQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUMsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxFQUFFO0lBQ3BDLElBQUksS0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUcsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3hELEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxLQUFLLEVBQUU7SUFDYixJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxJQUFJLGVBQWUsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGFBQWEsRUFBRTtJQUN2RCxJQUFJLEtBQUssQ0FBQyxXQUFXLEdBQUcsZUFBZSxDQUFDO0lBQ3hDLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLHVCQUF1QixDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUU7SUFDckQsRUFBRSxNQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUM7SUFDM0UsRUFBRSxLQUFLLENBQUMsV0FBVyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxpQkFBaUIsR0FBRyxTQUFTLENBQUM7SUFDL0UsQ0FBQztBQUNEO0lBQ0EsU0FBUyx1QkFBdUIsQ0FBQyxLQUFLLEVBQUUscUJBQXFCLEVBQUU7SUFDL0QsRUFBRSxLQUFLLENBQUMscUJBQXFCLEdBQUc7SUFDaEMsSUFBSSxHQUFHLEtBQUssQ0FBQyxxQkFBcUI7SUFDbEMsSUFBSSxHQUFHLHFCQUFxQjtJQUM1QixHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLGdCQUFnQixDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUU7SUFDdkMsRUFBRSxLQUFLLENBQUMsUUFBUSxHQUFHO0lBQ25CLElBQUksS0FBSyxFQUFFLGtCQUFrQixDQUFDLElBQUksQ0FBQztJQUNuQyxJQUFJLEdBQUcsS0FBSyxDQUFDLFFBQVE7SUFDckIsR0FBRyxDQUFDO0FBQ0o7SUFDQSxFQUFFLEtBQUssQ0FBQyxxQkFBcUIsR0FBRztJQUNoQyxJQUFJLHNCQUFzQixFQUFFLGlDQUFpQyxDQUFDLElBQUksQ0FBQztJQUNuRSxJQUFJLEdBQUcsS0FBSyxDQUFDLHFCQUFxQjtJQUNsQyxHQUFHLENBQUM7QUFDSjtJQUNBLEVBQUUsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JDLEVBQUUsTUFBTSxlQUFlLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFdBQVcsQ0FBQztJQUMzRCxFQUFFLElBQUksZUFBZSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGFBQWEsRUFBRTtJQUM3RSxJQUFJLEtBQUssQ0FBQyxXQUFXLEdBQUcsZUFBZSxDQUFDO0lBQ3hDLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsdUJBQXVCLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRTtJQUNyRDtJQUNBLEVBQUUsS0FBSyxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVztJQUN2QyxNQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQztJQUN0QyxRQUFRLEtBQUssQ0FBQyxXQUFXO0lBQ3pCLFFBQVEsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDO0lBQzNCLE1BQU0sRUFBRSxDQUFDO0FBQ1Q7SUFDQTtJQUNBLEVBQUUsSUFBSSxXQUFXLEVBQUU7SUFDbkIsSUFBSSxLQUFLLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzlELEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUU7SUFDakMsSUFBSSxPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUM7SUFDN0IsR0FBRztJQUNIOztJQ2hLQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVk7SUFDckIsRUFBRSxPQUFPO0lBQ1QsRUFBRSxLQUFLO0lBQ1AsRUFBRSxJQUFJO0lBQ04sRUFBRSxLQUFLO0lBQ1AsRUFBRSxNQUFNO0lBQ1IsRUFBRSxjQUFjO0lBQ2hCLEVBQUU7SUFDRixFQUFFLE1BQU0sRUFBRSxjQUFjLEdBQUcsQ0FBQyxFQUFFLG1CQUFtQixHQUFHLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQztJQUNyRSxFQUFFLE1BQU0sUUFBUSxHQUFHO0lBQ25CLElBQUksR0FBRyxLQUFLO0lBQ1osSUFBSSxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLEtBQUssRUFBRTtJQUN4RCxJQUFJLFNBQVMsRUFBRSxLQUFLLENBQUMsU0FBUyxJQUFJLHNCQUFzQixFQUFFO0lBQzFELEdBQUcsQ0FBQztJQUNKLEVBQUUsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxPQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xGO0lBQ0EsRUFBRSxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDeEMsRUFBRSx5QkFBeUIsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDcEQ7SUFDQSxFQUFFLElBQUksTUFBTSxFQUFFO0lBQ2QsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzdDLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO0lBQ2hDLElBQUksYUFBYSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDakQsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBLEVBQUUsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDL0Q7SUFDQSxFQUFFLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtJQUN0QixJQUFJLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEQsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLHFCQUFxQixHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDMUU7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLE1BQU0sSUFBSSxHQUFHLGNBQWMsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQy9DO0lBQ0EsRUFBRSxJQUFJLGNBQWMsRUFBRTtJQUN0QixJQUFJLE1BQU0sYUFBYSxHQUFHLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4RCxJQUFJLGNBQWMsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDeEMsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFVBQVUsRUFBRTtJQUNsQixJQUFJLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNyRCxJQUFJLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDekMsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLFdBQVcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN6RSxFQUFFLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRTtJQUMxQixJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ25DLEdBQUc7QUFDSDtJQUNBLEVBQUUscUJBQXFCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hDO0lBQ0EsRUFBRSxNQUFNLGVBQWUsR0FBRztJQUMxQixJQUFJLEdBQUcscUJBQXFCO0lBQzVCO0lBQ0EsSUFBSSxHQUFHLElBQUksQ0FBQyxlQUFlO0lBQzNCLEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxNQUFNLE1BQU0sR0FBRyxxQkFBcUIsQ0FBQyxlQUFlLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hFO0lBQ0EsRUFBRSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJO0lBQzVCLElBQUksSUFBSSxHQUFHLEVBQUU7SUFDYjtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLElBQUksY0FBYyxHQUFHLENBQUMsRUFBRTtJQUNsRSxNQUFNLE9BQU8sY0FBYyxDQUFDLEdBQUcsRUFBRSxjQUFjLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUN0RSxLQUFLO0lBQ0wsSUFBSSxPQUFPLEdBQUcsQ0FBQztJQUNmLEdBQUcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0lBQzVDLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGNBQWMsR0FBRyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUM7QUFDdkU7SUFDQTtJQUNBO0lBQ0EsRUFBRSxLQUFLLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLElBQUksV0FBVyxJQUFJLG1CQUFtQixDQUFDO0FBQzlFO0lBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxPQUFPLEVBQUU7SUFDakMsSUFBSSxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUM1QixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRTtJQUMzQixJQUFJLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3RCLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxFQUFFLElBQUksT0FBTyxFQUFFLEdBQUcsRUFBRTtJQUNwQixJQUFJLE9BQU8sQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDeEQsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUU7SUFDM0M7SUFDQSxFQUFFLE1BQU0sa0JBQWtCLEdBQUcsdUJBQXVCLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbEU7SUFDQSxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxTQUFTLElBQUk7SUFDaEQsSUFBSSxTQUFTLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJO0lBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQzFCLFFBQVEsS0FBSyxDQUFDLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDNUQsT0FBTztJQUNQLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7SUFDL0I7SUFDQSxFQUFFLE1BQU0sa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0lBQ2hDLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLFNBQVMsSUFBSTtJQUNoRCxJQUFJLFNBQVMsQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxLQUFLLElBQUk7SUFDbkQsTUFBTSxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUU7SUFDMUIsUUFBUSxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUU7SUFDNUIsVUFBVSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQztJQUM5RCxTQUFTLE1BQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQ25DLFVBQVUsa0JBQWtCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUM7SUFDOUQsU0FBUztJQUNULFFBQVEsT0FBTyxLQUFLLENBQUMsUUFBUSxDQUFDO0lBQzlCLE9BQU87SUFDUCxLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUcsQ0FBQyxDQUFDO0FBQ0w7SUFDQSxFQUFFLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDcEQsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLEtBQUssQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUM7SUFDNUMsRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDMUQsRUFBRSxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztJQUN6QyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSztJQUN2RSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUM7SUFDaEIsTUFBTSxJQUFJLEVBQUUsV0FBVztJQUN2QixNQUFNLFNBQVMsRUFBRSxRQUFRO0lBQ3pCLE1BQU0sUUFBUTtJQUNkLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMseUJBQXlCLENBQUMsS0FBSyxFQUFFLGdCQUFnQixFQUFFO0lBQzVELEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0lBQ25DLElBQUksS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQztJQUNoQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLGdCQUFnQixDQUFDLENBQUM7SUFDdEYsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUU7SUFDbEQsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFO0lBQ2QsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sVUFBVSxHQUFHO0lBQ3JCLElBQUksR0FBRyxLQUFLO0lBQ1osSUFBSSxJQUFJLEtBQUssQ0FBQyxXQUFXLElBQUk7SUFDN0IsTUFBTSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLO0lBQy9DLFFBQVEsR0FBRyxDQUFDO0lBQ1osUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUk7SUFDdEIsVUFBVSxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQztJQUNwRCxTQUFTLENBQUM7SUFDVixPQUFPLENBQUMsQ0FBQztJQUNULEtBQUssQ0FBQztJQUNOLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJO0lBQ3RCLE1BQU0sSUFBSSxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxVQUFVLENBQUM7SUFDcEQsS0FBSyxDQUFDO0lBQ04sSUFBSSxJQUFJLEtBQUssQ0FBQyxRQUFRLElBQUk7SUFDMUIsTUFBTSxRQUFRLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQztJQUM1RCxLQUFLLENBQUM7SUFDTixJQUFJLElBQUksS0FBSyxDQUFDLEtBQUssSUFBSTtJQUN2QixNQUFNLEtBQUssRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDO0lBQ3RELEtBQUssQ0FBQztJQUNOLEdBQUcsQ0FBQztBQUNKO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRTtJQUNwRCxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO0FBQ3JEO0lBQ0E7SUFDQSxJQUFJLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFO0lBQ25DLE1BQU0sVUFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQy9GLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO0lBQ25CLElBQUksVUFBVSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUk7SUFDL0MsTUFBTSxPQUFPO0lBQ2IsUUFBUSxHQUFHLElBQUk7SUFDZixRQUFRLElBQUksSUFBSSxDQUFDLElBQUksSUFBSTtJQUN6QixVQUFVLElBQUksRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDO0lBQ3ZELFNBQVMsQ0FBQztJQUNWLE9BQU8sQ0FBQztJQUNSLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRTtJQUNwRCxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDL0UsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0FBQ0Q7SUFDQSxTQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsY0FBYyxFQUFFO0lBQzlDLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRTtJQUN2QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxVQUFVLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQ3pELEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNwQyxFQUFFLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyw4QkFBOEI7SUFDdkMsRUFBRSxJQUFJO0lBQ04sRUFBRTtJQUNGLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRTtJQUNiLElBQUksT0FBTyxTQUFTLENBQUM7SUFDckIsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDbkMsSUFBSSxPQUFPLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3BDLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNoQyxJQUFJLE9BQU87SUFDWCxNQUFNLGNBQWMsRUFBRSxJQUFJO0lBQzFCLEtBQUssQ0FBQztJQUNOLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLHFCQUFxQixDQUFDLElBQUksRUFBRTtJQUNyQyxFQUFFLE9BQU8sSUFBSSxZQUFZLEtBQUssSUFBSSxPQUFPLElBQUksS0FBSyxVQUFVLENBQUM7SUFDN0QsQ0FBQztBQUNEO0lBQ0EsTUFBTSxrQkFBa0IsR0FBRztJQUMzQixFQUFFLE1BQU07SUFDUixFQUFFLE9BQU87SUFDVCxFQUFFLE9BQU87SUFDVCxFQUFFLFVBQVU7SUFDWixFQUFFLE1BQU07SUFDUixFQUFFLGFBQWE7SUFDZixFQUFFLG9CQUFvQjtJQUN0QixDQUFDLEVBQUU7QUFDSDtJQUNBLFNBQVMsa0JBQWtCLENBQUMsSUFBSSxFQUFFO0lBQ2xDLEVBQUUsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksa0JBQWtCLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDMUU7O0lDclVBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFO0lBQzNDLEVBQUUsT0FBTyxlQUFlLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsOEJBQThCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM3RixDQUFDO0FBZ0JEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFO0lBQ25DLEVBQUUsT0FBTyxlQUFlLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3JELENBQUM7QUFrTUQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsWUFBWSxDQUFDLE9BQU8sRUFBRTtJQUMvQixFQUFFLE1BQU0sY0FBYyxHQUFHLGlCQUFpQixFQUFFLENBQUM7SUFDN0MsRUFBRSxNQUFNLFlBQVksR0FBRyxlQUFlLEVBQUUsQ0FBQztBQUN6QztJQUNBO0lBQ0EsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsVUFBVSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUM7QUFDbkQ7SUFDQSxFQUFFLE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQztJQUM5QixJQUFJLElBQUksRUFBRSxZQUFZLENBQUMsT0FBTyxFQUFFLElBQUksY0FBYyxDQUFDLE9BQU8sRUFBRTtJQUM1RCxJQUFJLElBQUksU0FBUyxJQUFJLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFDbkMsSUFBSSxHQUFHLE9BQU87SUFDZCxHQUFHLENBQUMsQ0FBQztBQUNMO0lBQ0E7SUFDQSxFQUFFLE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNyRCxFQUFFLElBQUksY0FBYyxFQUFFLE1BQU0sS0FBSyxJQUFJLEVBQUU7SUFDdkMsSUFBSSxhQUFhLENBQUMsY0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDeEQsR0FBRztBQUNIO0lBQ0EsRUFBRSxVQUFVLEVBQUUsQ0FBQztBQUNmO0lBQ0E7SUFDQSxFQUFFLGNBQWMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDckM7SUFDQSxFQUFFLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsVUFBVSxHQUFHO0lBQ3RCLEVBQUUsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQztJQUM3QyxFQUFFLE1BQU0sWUFBWSxHQUFHLGVBQWUsRUFBRSxDQUFDO0FBQ3pDO0lBQ0EsRUFBRSxNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUMsVUFBVSxFQUFFLElBQUksY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzNFLEVBQUUsSUFBSSxPQUFPLEVBQUU7SUFDZixJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixHQUFHO0lBQ0gsRUFBRSxrQkFBa0IsRUFBRSxDQUFDO0FBQ3ZCO0lBQ0E7SUFDQSxFQUFFLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUM5QixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQixHQUFHO0lBQzlCLEVBQUUsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQztJQUM3QyxFQUFFLE1BQU0sTUFBTSxHQUFHLFNBQVMsRUFBRSxDQUFDO0lBQzdCLEVBQUUsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzlDLEVBQUUsSUFBSSxPQUFPLElBQUksTUFBTSxFQUFFO0lBQ3pCLElBQUksTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQyxHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxjQUFjLENBQUMsR0FBRyxHQUFHLEtBQUssRUFBRTtJQUNyQztJQUNBLEVBQUUsSUFBSSxHQUFHLEVBQUU7SUFDWCxJQUFJLFVBQVUsRUFBRSxDQUFDO0lBQ2pCLElBQUksT0FBTztJQUNYLEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxrQkFBa0IsRUFBRSxDQUFDO0lBQ3ZCOztJQzVUQSxNQUFNLGtCQUFrQixHQUFHLEdBQUcsQ0FBQztBQUMvQjtJQUNBO0lBQ0EsU0FBUyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUU7SUFDakMsRUFBRSxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUMxRCxFQUFFLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQzlDLEVBQUUsT0FBTyxDQUFDLEVBQUUsUUFBUSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakYsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtJQUNqQyxFQUFFLE9BQU8sQ0FBQyxFQUFFLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNoRSxDQUFDO0FBQ0Q7SUFDQTtJQUNBLFNBQVMsWUFBWSxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUU7SUFDcEMsRUFBRSxNQUFNLE1BQU0sR0FBRztJQUNqQixJQUFJLGNBQWMsRUFBRSxrQkFBa0I7SUFDdEMsR0FBRyxDQUFDO0FBQ0o7SUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLFNBQVMsRUFBRTtJQUNyQjtJQUNBO0lBQ0EsSUFBSSxNQUFNLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUM7SUFDdEMsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLE9BQU8sRUFBRTtJQUNmLElBQUksTUFBTSxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDaEUsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLElBQUksZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ2hELENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHFDQUFxQyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFO0lBQ3JFLEVBQUUsT0FBTyxNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEY7O0lDdENBLE1BQU0scUJBQXFCLEdBQUcsRUFBRSxDQUFDO0FBcURqQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRTtJQUNqRCxFQUFFLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBQzlCO0lBQ0EsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBVyxLQUFLO0lBQ3hDO0lBQ0EsSUFBSSxJQUFJLFdBQVcsRUFBRTtJQUNyQixNQUFNLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUM5RCxLQUFLO0lBQ0wsR0FBRyxDQUFDLENBQUM7QUFDTDtJQUNBLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQztJQUMxQixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHNCQUFzQixDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUU7SUFDdEQsRUFBRSxLQUFLLE1BQU0sV0FBVyxJQUFJLFlBQVksRUFBRTtJQUMxQztJQUNBLElBQUksSUFBSSxXQUFXLEVBQUUsYUFBYSxFQUFFO0lBQ3BDLE1BQU0sV0FBVyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QyxLQUFLO0lBQ0wsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFO0lBQ2pFLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDMUMsSUFBSUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxzREFBc0QsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNHLElBQUksT0FBTztJQUNYLEdBQUc7SUFDSCxFQUFFLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXLENBQUM7QUFDbkQ7SUFDQTtJQUNBLEVBQUUsSUFBSSxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLE9BQU8sV0FBVyxDQUFDLFNBQVMsS0FBSyxVQUFVLEVBQUU7SUFDN0csSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDNUIsSUFBSSxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELEdBQUc7QUFDSDtJQUNBO0lBQ0EsRUFBRSxJQUFJLFdBQVcsQ0FBQyxLQUFLLElBQUksT0FBTyxXQUFXLENBQUMsS0FBSyxLQUFLLFVBQVUsRUFBRTtJQUNwRSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLE9BQU8sV0FBVyxDQUFDLGVBQWUsS0FBSyxVQUFVLEVBQUU7SUFDekQsSUFBSSxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtJQUNwRSxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxLQUFLLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDakYsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLE9BQU8sV0FBVyxDQUFDLFlBQVksS0FBSyxVQUFVLEVBQUU7SUFDdEQsSUFBSSxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtBQUNqRTtJQUNBLElBQUksTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLEtBQUssUUFBUSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUU7SUFDcEYsTUFBTSxFQUFFLEVBQUUsV0FBVyxDQUFDLElBQUk7SUFDMUIsS0FBSyxDQUFDLENBQUM7QUFDUDtJQUNBLElBQUksTUFBTSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3hDLEdBQUc7QUFDSDtJQUNBLEVBQUVBLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsdUJBQXVCLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxRSxDQUFDO0FBYUQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsaUJBQWlCLENBQUMsRUFBRSxFQUFFO0lBQy9CLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDWjs7SUM3SUE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsMEJBQTBCO0lBQ25DLEVBQUUsZ0JBQWdCO0lBQ2xCLEVBQUUsR0FBRztJQUNMLEVBQUUsU0FBUztJQUNYLEVBQUU7SUFDRixFQUFFLE1BQU0sZ0JBQWdCLEdBQUc7SUFDM0IsSUFBSSxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUU7SUFDN0IsSUFBSTtJQUNKLE1BQU0sU0FBUyxFQUFFLFNBQVMsSUFBSSxzQkFBc0IsRUFBRTtJQUN0RCxNQUFNLGdCQUFnQjtJQUN0QixLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osRUFBRSxPQUFPLGNBQWMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7SUFDaEU7O0lDckJBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsd0JBQXdCLENBQUMsS0FBSyxFQUFFO0lBQ3pDLEVBQUUsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7QUFDOUI7SUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRTtJQUNyQixJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDekMsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJO0lBQ047SUFDQSxJQUFJLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwRixJQUFJLElBQUksYUFBYSxFQUFFLEtBQUssRUFBRTtJQUM5QixNQUFNLGdCQUFnQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakQsTUFBTSxJQUFJLGFBQWEsQ0FBQyxJQUFJLEVBQUU7SUFDOUIsUUFBUSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0UsT0FBTztJQUNQLEtBQUs7SUFDTCxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDZDtJQUNBLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQztJQUMxQjs7SUN0QkE7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQ0FBaUMsQ0FBQyxLQUFLLEVBQUU7SUFDbEQsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3RHO0lBQ0EsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUU7SUFDcEIsSUFBSSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVc7SUFDbEMsSUFBSSxFQUFFO0lBQ04sSUFBSSxjQUFjO0lBQ2xCLElBQUksT0FBTyxFQUFFLE9BQU8sSUFBSSxFQUFFO0lBQzFCLElBQUksZUFBZSxFQUFFLEtBQUssQ0FBQyxlQUFlLElBQUksQ0FBQztJQUMvQyxJQUFJLE1BQU07SUFDVixJQUFJLFNBQVMsRUFBRSxLQUFLLENBQUMsU0FBUztJQUM5QixJQUFJLFFBQVEsRUFBRSxRQUFRLElBQUksRUFBRTtJQUM1QixJQUFJLE1BQU07SUFDVixJQUFJLFVBQVUsRUFBRSxJQUFJLEdBQUcsNkJBQTZCLENBQUM7SUFDckQsSUFBSSxjQUFjLEVBQUUsSUFBSSxHQUFHLGlDQUFpQyxDQUFDO0lBQzdELElBQUksWUFBWSxFQUFFLEtBQUssQ0FBQyxZQUFZO0lBQ3BDLElBQUksVUFBVSxFQUFFLElBQUk7SUFDcEIsR0FBRyxDQUFDO0lBQ0osQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQ0FBaUMsQ0FBQyxJQUFJLEVBQUU7SUFDakQsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUUsYUFBYTtJQUN2QixJQUFJLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztJQUM3QixJQUFJLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZTtJQUN6QyxJQUFJLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztJQUNqQyxJQUFJLFFBQVEsRUFBRTtJQUNkLE1BQU0sS0FBSyxFQUFFO0lBQ2IsUUFBUSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7SUFDL0IsUUFBUSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU87SUFDN0IsUUFBUSxjQUFjLEVBQUUsSUFBSSxDQUFDLGNBQWM7SUFDM0MsUUFBUSxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUU7SUFDbkIsUUFBUSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07SUFDM0IsUUFBUSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07SUFDM0IsUUFBUSxJQUFJLEVBQUU7SUFDZCxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUk7SUFDdEIsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDLDZCQUE2QixHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN0RixVQUFVLElBQUksSUFBSSxDQUFDLGNBQWMsSUFBSSxFQUFFLENBQUMsaUNBQWlDLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ2xHLFNBQVM7SUFDVCxPQUFPO0lBQ1AsS0FBSztJQUNMLElBQUksWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO0lBQ25DLEdBQUcsQ0FBQztJQUNKOztJQzdCQSxNQUFNLGtCQUFrQixHQUFHLDZEQUE2RCxDQUFDO0lBQ3pGLE1BQU0saUNBQWlDLEdBQUcsNERBQTRELENBQUM7QUFDdkc7SUFDQSxNQUFNLHFCQUFxQixHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNoRSxNQUFNLHdCQUF3QixHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUN6RTtJQUNBLFNBQVMsa0JBQWtCLENBQUMsT0FBTyxFQUFFO0lBQ3JDLEVBQUUsT0FBTztJQUNULElBQUksT0FBTztJQUNYLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJO0lBQ2pDLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVMsd0JBQXdCLENBQUMsT0FBTyxFQUFFO0lBQzNDLEVBQUUsT0FBTztJQUNULElBQUksT0FBTztJQUNYLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJO0lBQ3BDLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFO0lBQ2pDLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxxQkFBcUIsSUFBSSxLQUFLLENBQUM7SUFDaEYsQ0FBQztBQUNEO0lBQ0EsU0FBUyxzQkFBc0IsQ0FBQyxLQUFLLEVBQUU7SUFDdkMsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLHdCQUF3QixJQUFJLEtBQUssQ0FBQztJQUNuRixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sTUFBTSxDQUFDO0lBQ2I7QUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7QUFDQTtJQUNBO0FBQ0E7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRTtJQUN4QixJQUFJLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO0lBQzVCLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7SUFDNUIsSUFBSSxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQztJQUM1QixJQUFJLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDckIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBQy9CO0lBQ0EsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7SUFDckIsTUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkMsS0FBSyxNQUFNO0lBQ1gsTUFBTUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsK0NBQStDLENBQUMsQ0FBQztJQUNsRixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtJQUNuQixNQUFNLE1BQU0sR0FBRyxHQUFHLHFDQUFxQztJQUN2RCxRQUFRLElBQUksQ0FBQyxJQUFJO0lBQ2pCLFFBQVEsT0FBTyxDQUFDLE1BQU07SUFDdEIsUUFBUSxPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFNBQVM7SUFDN0QsT0FBTyxDQUFDO0lBQ1IsTUFBTSxJQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7SUFDMUMsUUFBUSxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNO0lBQ3BDLFFBQVEsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDOUQsUUFBUSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0I7SUFDbkMsUUFBUSxHQUFHO0lBQ1gsT0FBTyxDQUFDLENBQUM7SUFDVCxLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7SUFDNUMsSUFBSSxNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsQ0FBQztBQUM1QjtJQUNBO0lBQ0EsSUFBSSxJQUFJLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxFQUFFO0lBQzVDLE1BQU1BLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDcEQsTUFBTSxPQUFPLE9BQU8sQ0FBQztJQUNyQixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sZUFBZSxHQUFHO0lBQzVCLE1BQU0sUUFBUSxFQUFFLE9BQU87SUFDdkIsTUFBTSxHQUFHLElBQUk7SUFDYixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksSUFBSSxDQUFDLFFBQVE7SUFDakIsTUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxFQUFFLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLO0lBQ3BFLFFBQVEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsZUFBZSxFQUFFLEtBQUssQ0FBQztJQUN6RCxPQUFPO0lBQ1AsS0FBSyxDQUFDO0FBQ047SUFDQSxJQUFJLE9BQU8sZUFBZSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxjQUFjO0lBQ2pCLElBQUksT0FBTztJQUNYLElBQUksS0FBSztJQUNULElBQUksSUFBSTtJQUNSLElBQUksWUFBWTtJQUNoQixJQUFJO0lBQ0osSUFBSSxNQUFNLGVBQWUsR0FBRztJQUM1QixNQUFNLFFBQVEsRUFBRSxLQUFLLEVBQUU7SUFDdkIsTUFBTSxHQUFHLElBQUk7SUFDYixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksTUFBTSxZQUFZLEdBQUcscUJBQXFCLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwRjtJQUNBLElBQUksTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztJQUM5QyxRQUFRLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsS0FBSyxFQUFFLGVBQWUsQ0FBQztJQUNuRSxRQUFRLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUM7QUFDMUQ7SUFDQSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsZUFBZSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6RztJQUNBLElBQUksT0FBTyxlQUFlLENBQUMsUUFBUSxDQUFDO0lBQ3BDLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRTtJQUMzQyxJQUFJLE1BQU0sT0FBTyxHQUFHLEtBQUssRUFBRSxDQUFDO0FBQzVCO0lBQ0E7SUFDQSxJQUFJLElBQUksSUFBSSxFQUFFLGlCQUFpQixJQUFJLHVCQUF1QixDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0lBQ3BGLE1BQU1BLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDcEQsTUFBTSxPQUFPLE9BQU8sQ0FBQztJQUNyQixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sZUFBZSxHQUFHO0lBQzVCLE1BQU0sUUFBUSxFQUFFLE9BQU87SUFDdkIsTUFBTSxHQUFHLElBQUk7SUFDYixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksTUFBTSxxQkFBcUIsR0FBRyxLQUFLLENBQUMscUJBQXFCLElBQUksRUFBRSxDQUFDO0lBQ3BFLElBQUksTUFBTSxpQkFBaUIsR0FBRyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQztJQUN0RSxJQUFJLE1BQU0sMEJBQTBCLEdBQUcscUJBQXFCLENBQUMsMEJBQTBCLENBQUM7QUFDeEY7SUFDQSxJQUFJLElBQUksQ0FBQyxRQUFRO0lBQ2pCLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixJQUFJLFlBQVksRUFBRSwwQkFBMEIsQ0FBQztJQUMvRyxLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksT0FBTyxlQUFlLENBQUMsUUFBUSxDQUFDO0lBQ3BDLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsY0FBYyxDQUFDLE9BQU8sRUFBRTtJQUMzQixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUI7SUFDQSxJQUFJLGFBQWEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUM1QyxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsTUFBTSxHQUFHO0lBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDckIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxVQUFVLEdBQUc7SUFDaEIsSUFBSSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGNBQWMsR0FBRztJQUNwQixJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7SUFDbkMsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLFlBQVksR0FBRztJQUNsQixJQUFJLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUMzQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFO0lBQ2xCLElBQUksTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN0QyxJQUFJLElBQUksU0FBUyxFQUFFO0lBQ25CLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN6QixNQUFNLE9BQU8sSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUk7SUFDMUUsUUFBUSxPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixJQUFJLGNBQWMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3JHLE9BQU8sQ0FBQyxDQUFDO0lBQ1QsS0FBSyxNQUFNO0lBQ1gsTUFBTSxPQUFPLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZDLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFO0lBQ2xCLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUk7SUFDOUMsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN4QyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDekIsTUFBTSxPQUFPLE1BQU0sQ0FBQztJQUNwQixLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsa0JBQWtCLEdBQUc7SUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUNqQyxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGlCQUFpQixDQUFDLGNBQWMsRUFBRTtJQUNyQyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDL0MsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLElBQUksR0FBRztJQUNWLElBQUk7SUFDSixNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUU7SUFDdkI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2pGLE1BQU07SUFDTixNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQ2hDLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxvQkFBb0IsQ0FBQyxlQUFlLEVBQUU7SUFDekMsSUFBSSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLEVBQUU7SUFDaEQsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGNBQWMsQ0FBQyxXQUFXLEVBQUU7SUFDL0IsSUFBSSxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BFO0lBQ0E7SUFDQSxJQUFJLGdCQUFnQixDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzVEO0lBQ0EsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7SUFDN0IsTUFBTSxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ2xELEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUMvQixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzlDO0lBQ0EsSUFBSSxJQUFJLEdBQUcsR0FBRyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ25HO0lBQ0EsSUFBSSxLQUFLLE1BQU0sVUFBVSxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksRUFBRSxFQUFFO0lBQ3JELE1BQU0sR0FBRyxHQUFHLGlCQUFpQixDQUFDLEdBQUcsRUFBRSw0QkFBNEIsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzdFLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzQyxJQUFJLElBQUksT0FBTyxFQUFFO0lBQ2pCLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsWUFBWSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDM0YsS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRTtJQUN4QjtJQUNBLElBQUksTUFBTSxFQUFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsdUJBQXVCLEdBQUcsbUJBQW1CLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZILElBQUksSUFBSSxZQUFZLElBQUksT0FBTyxFQUFFO0lBQ2pDLE1BQU0sTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7SUFDL0MsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixFQUFFO0lBQ3pELFFBQVFBLGFBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLENBQUM7SUFDdEUsUUFBUSxPQUFPO0lBQ2YsT0FBTztJQUNQLE1BQU0sWUFBWSxDQUFDLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBTyxJQUFJLG1CQUFtQixDQUFDO0lBQ3pFLE1BQU0sWUFBWSxDQUFDLFdBQVcsR0FBRyxZQUFZLENBQUMsV0FBVyxJQUFJLHVCQUF1QixDQUFDO0lBQ3JGLE1BQU0sT0FBTyxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUM7SUFDbkMsS0FBSyxNQUFNO0lBQ1gsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixFQUFFO0lBQ3BELFFBQVFBLGFBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLENBQUM7SUFDdEUsUUFBUSxPQUFPO0lBQ2YsT0FBTztJQUNQLE1BQU0sT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLG1CQUFtQixDQUFDO0lBQy9ELE1BQU0sT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxJQUFJLHVCQUF1QixDQUFDO0lBQzNFLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUM1QztJQUNBLElBQUksTUFBTSxHQUFHLEdBQUcscUJBQXFCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN6RztJQUNBO0lBQ0E7SUFDQSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDM0IsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUU7SUFDbkQsSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUU7SUFDekM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzFDLE1BQU1BLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEcsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDO0lBQy9ELEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7SUFDdEIsSUFBSSxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7QUFDaEU7SUFDQTtJQUNBLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN6QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSSxPQUFPLE1BQU07SUFDakI7SUFDQSxNQUFNLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDOUMsTUFBTSxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRTtJQUN4QixRQUFRLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLE9BQU87SUFDUCxLQUFLLENBQUM7SUFDTixHQUFHO0FBQ0g7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxFQUFFO0lBQ3ZCLElBQUksTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QyxJQUFJLElBQUksU0FBUyxFQUFFO0lBQ25CLE1BQU0sU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN2RCxLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxZQUFZLENBQUMsUUFBUSxFQUFFO0lBQzFCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUMxQztJQUNBLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtJQUM5QyxNQUFNLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLElBQUk7SUFDakUsUUFBUUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsK0JBQStCLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDN0UsUUFBUSxPQUFPLE1BQU0sQ0FBQztJQUN0QixPQUFPLENBQUMsQ0FBQztJQUNULEtBQUs7QUFDTDtJQUNBLElBQUlBLGFBQVcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDdEQ7SUFDQSxJQUFJLE9BQU8sbUJBQW1CLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDbkMsR0FBRztBQUNIO0lBQ0E7QUFDQTtJQUNBO0lBQ0EsR0FBRyxrQkFBa0IsR0FBRztJQUN4QixJQUFJLE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQzNDLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDL0QsSUFBSSxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDL0MsR0FBRztBQUNIO0lBQ0E7SUFDQSxHQUFHLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUU7SUFDM0MsSUFBSSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxLQUFLLE9BQU8sQ0FBQztJQUMxQyxJQUFJLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN4QixJQUFJLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDO0FBQy9DO0lBQ0EsSUFBSSxJQUFJLFVBQVUsRUFBRTtJQUNwQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDckI7SUFDQSxNQUFNLEtBQUssTUFBTSxFQUFFLElBQUksVUFBVSxFQUFFO0lBQ25DLFFBQVEsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQztJQUN2QyxRQUFRLElBQUksU0FBUyxFQUFFLE9BQU8sS0FBSyxLQUFLLEVBQUU7SUFDMUMsVUFBVSxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ3pCLFVBQVUsTUFBTTtJQUNoQixTQUFTO0lBQ1QsT0FBTztJQUNQLEtBQUs7QUFDTDtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksTUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQztJQUN2RCxJQUFJLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxrQkFBa0IsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsTUFBTSxrQkFBa0IsSUFBSSxPQUFPLENBQUMsQ0FBQztBQUNoSDtJQUNBLElBQUksSUFBSSxtQkFBbUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsQ0FBQyxPQUFPLEVBQUU7SUFDN0IsUUFBUSxJQUFJLE9BQU8sSUFBSSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUM3QyxRQUFRLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDO0lBQzVELE9BQU8sQ0FBQyxDQUFDO0lBQ1QsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsdUJBQXVCLENBQUMsT0FBTyxFQUFFO0lBQ3BDLElBQUksT0FBTyxJQUFJLFdBQVcsQ0FBQyxPQUFPLElBQUk7SUFDdEMsTUFBTSxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDckIsTUFBTSxNQUFNLElBQUksR0FBRyxDQUFDLENBQUM7QUFDckI7SUFDQSxNQUFNLE1BQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQyxNQUFNO0lBQ3pDLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsRUFBRTtJQUN0QyxVQUFVLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsQyxVQUFVLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixTQUFTLE1BQU07SUFDZixVQUFVLE1BQU0sSUFBSSxJQUFJLENBQUM7SUFDekIsVUFBVSxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUksT0FBTyxFQUFFO0lBQzVDLFlBQVksYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BDLFlBQVksT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLFdBQVc7SUFDWCxTQUFTO0lBQ1QsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2YsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHO0FBQ0g7SUFDQTtJQUNBLEdBQUcsVUFBVSxHQUFHO0lBQ2hCLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQztJQUNoRixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxhQUFhO0lBQ2hCLElBQUksS0FBSztJQUNULElBQUksSUFBSTtJQUNSLElBQUksWUFBWTtJQUNoQixJQUFJLGNBQWM7SUFDbEIsSUFBSTtJQUNKLElBQUksTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3RDLElBQUksTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDekQsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxZQUFZLEVBQUUsTUFBTSxFQUFFO0lBQ3BELE1BQU0sSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7SUFDdkMsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM5QztJQUNBLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUU7SUFDckIsTUFBTSxjQUFjLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JFLEtBQUs7QUFDTDtJQUNBLElBQUksT0FBTyxZQUFZLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJO0lBQzlGLE1BQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO0lBQ3hCLFFBQVEsT0FBTyxHQUFHLENBQUM7SUFDbkIsT0FBTztBQUNQO0lBQ0EsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQztJQUNBLE1BQU0sR0FBRyxDQUFDLFFBQVEsR0FBRztJQUNyQixRQUFRLEtBQUssRUFBRSx3QkFBd0IsQ0FBQyxZQUFZLENBQUM7SUFDckQsUUFBUSxHQUFHLEdBQUcsQ0FBQyxRQUFRO0lBQ3ZCLE9BQU8sQ0FBQztBQUNSO0lBQ0EsTUFBTSxNQUFNLHNCQUFzQixHQUFHLGtDQUFrQyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztBQUM1RjtJQUNBLE1BQU0sR0FBRyxDQUFDLHFCQUFxQixHQUFHO0lBQ2xDLFFBQVEsc0JBQXNCO0lBQzlCLFFBQVEsR0FBRyxHQUFHLENBQUMscUJBQXFCO0lBQ3BDLE9BQU8sQ0FBQztBQUNSO0lBQ0EsTUFBTSxPQUFPLEdBQUcsQ0FBQztJQUNqQixLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsYUFBYTtJQUNoQixJQUFJLEtBQUs7SUFDVCxJQUFJLElBQUksR0FBRyxFQUFFO0lBQ2IsSUFBSSxZQUFZLEdBQUcsZUFBZSxFQUFFO0lBQ3BDLElBQUksY0FBYyxHQUFHLGlCQUFpQixFQUFFO0lBQ3hDLElBQUk7SUFDSixJQUFJLElBQUlBLGFBQVcsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDNUMsTUFBTSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsdUJBQXVCLEVBQUUsd0JBQXdCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEcsS0FBSztBQUNMO0lBQ0EsSUFBSSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUMsSUFBSTtJQUM3RSxNQUFNLFVBQVUsSUFBSTtJQUNwQixRQUFRLE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQztJQUNuQyxPQUFPO0lBQ1AsTUFBTSxNQUFNLElBQUk7SUFDaEIsUUFBUSxJQUFJQSxhQUFXLEVBQUU7SUFDekIsVUFBVSxJQUFJLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQzlDLFlBQVksTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkMsV0FBVyxNQUFNLElBQUksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEVBQUU7SUFDL0MsWUFBWSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN4QyxXQUFXLE1BQU07SUFDakIsWUFBWSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLFdBQVc7SUFDWCxTQUFTO0lBQ1QsUUFBUSxPQUFPLFNBQVMsQ0FBQztJQUN6QixPQUFPO0lBQ1AsS0FBSyxDQUFDO0lBQ04sR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGFBQWE7SUFDaEIsSUFBSSxLQUFLO0lBQ1QsSUFBSSxJQUFJO0lBQ1IsSUFBSSxZQUFZO0lBQ2hCLElBQUksY0FBYztJQUNsQixJQUFJO0lBQ0osSUFBSSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDdEMsSUFBSSxNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsT0FBTyxDQUFDO0FBQ25DO0lBQ0EsSUFBSSxNQUFNLGFBQWEsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwRCxJQUFJLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxJQUFJLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDO0lBQzVDLElBQUksTUFBTSxlQUFlLEdBQUcsQ0FBQyx1QkFBdUIsRUFBRSxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDcEU7SUFDQTtJQUNBO0lBQ0E7SUFDQSxJQUFJLE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxVQUFVLEtBQUssV0FBVyxHQUFHLFNBQVMsR0FBRyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDekcsSUFBSSxJQUFJLE9BQU8sSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsZ0JBQWdCLEVBQUU7SUFDN0YsTUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RELE1BQU0sT0FBTyxtQkFBbUI7SUFDaEMsUUFBUSx3QkFBd0I7SUFDaEMsVUFBVSxDQUFDLGlGQUFpRixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDM0csU0FBUztJQUNULE9BQU8sQ0FBQztJQUNSLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxZQUFZLElBQUksU0FBUyxLQUFLLGNBQWMsR0FBRyxRQUFRLEdBQUcsU0FBUyxDQUFDLEVBQUU7QUFDaEY7SUFDQSxJQUFJLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxjQUFjLENBQUM7SUFDeEUsT0FBTyxJQUFJLENBQUMsUUFBUSxJQUFJO0lBQ3hCLFFBQVEsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO0lBQy9CLFVBQVUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ25FLFVBQVUsTUFBTSx3QkFBd0IsQ0FBQywwREFBMEQsQ0FBQyxDQUFDO0lBQ3JHLFNBQVM7QUFDVDtJQUNBLFFBQVEsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxVQUFVLEtBQUssSUFBSSxDQUFDO0lBQ2xGLFFBQVEsSUFBSSxtQkFBbUIsRUFBRTtJQUNqQyxVQUFVLE9BQU8sUUFBUSxDQUFDO0lBQzFCLFNBQVM7QUFDVDtJQUNBLFFBQVEsTUFBTSxNQUFNLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDeEUsUUFBUSxPQUFPLHlCQUF5QixDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsQ0FBQztJQUNsRSxPQUFPLENBQUM7SUFDUixPQUFPLElBQUksQ0FBQyxjQUFjLElBQUk7SUFDOUIsUUFBUSxJQUFJLGNBQWMsS0FBSyxJQUFJLEVBQUU7SUFDckMsVUFBVSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQy9ELFVBQVUsSUFBSSxhQUFhLEVBQUU7SUFDN0IsWUFBWSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQztJQUM1QztJQUNBLFlBQVksTUFBTSxTQUFTLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDL0MsWUFBWSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN0RSxXQUFXO0lBQ1gsVUFBVSxNQUFNLHdCQUF3QixDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsd0NBQXdDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZHLFNBQVM7QUFDVDtJQUNBLFFBQVEsTUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLFVBQVUsRUFBRSxJQUFJLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNqRixRQUFRLElBQUksT0FBTyxJQUFJLE9BQU8sRUFBRTtJQUNoQyxVQUFVLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDaEUsU0FBUztBQUNUO0lBQ0EsUUFBUSxJQUFJLGFBQWEsRUFBRTtJQUMzQixVQUFVLE1BQU0sZUFBZSxHQUFHLGNBQWMsQ0FBQyxxQkFBcUIsRUFBRSx5QkFBeUIsSUFBSSxDQUFDLENBQUM7SUFDdkcsVUFBVSxNQUFNLGNBQWMsR0FBRyxjQUFjLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN4RjtJQUNBLFVBQVUsTUFBTSxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsY0FBYyxDQUFDO0lBQ3BFLFVBQVUsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLEVBQUU7SUFDcEMsWUFBWSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdFLFdBQVc7SUFDWCxTQUFTO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxRQUFRLE1BQU0sZUFBZSxHQUFHLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQztJQUNoRSxRQUFRLElBQUksYUFBYSxJQUFJLGVBQWUsSUFBSSxjQUFjLENBQUMsV0FBVyxLQUFLLEtBQUssQ0FBQyxXQUFXLEVBQUU7SUFDbEcsVUFBVSxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUM7SUFDbEMsVUFBVSxjQUFjLENBQUMsZ0JBQWdCLEdBQUc7SUFDNUMsWUFBWSxHQUFHLGVBQWU7SUFDOUIsWUFBWSxNQUFNO0lBQ2xCLFdBQVcsQ0FBQztJQUNaLFNBQVM7QUFDVDtJQUNBLFFBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDN0MsUUFBUSxPQUFPLGNBQWMsQ0FBQztJQUM5QixPQUFPLENBQUM7SUFDUixPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxJQUFJO0lBQzVCLFFBQVEsSUFBSSxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtJQUN4RSxVQUFVLE1BQU0sTUFBTSxDQUFDO0lBQ3ZCLFNBQVM7QUFDVDtJQUNBLFFBQVEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtJQUN0QyxVQUFVLElBQUksRUFBRTtJQUNoQixZQUFZLFVBQVUsRUFBRSxJQUFJO0lBQzVCLFdBQVc7SUFDWCxVQUFVLGlCQUFpQixFQUFFLE1BQU07SUFDbkMsU0FBUyxDQUFDLENBQUM7SUFDWCxRQUFRLE1BQU0sa0JBQWtCO0lBQ2hDLFVBQVUsQ0FBQywySEFBMkgsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNoSixTQUFTLENBQUM7SUFDVixPQUFPLENBQUMsQ0FBQztJQUNULEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRTtJQUNyQixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUMxQixJQUFJLEtBQUssT0FBTyxDQUFDLElBQUk7SUFDckIsTUFBTSxLQUFLLElBQUk7SUFDZixRQUFRLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUM5QixRQUFRLE9BQU8sS0FBSyxDQUFDO0lBQ3JCLE9BQU87SUFDUCxNQUFNLE1BQU0sSUFBSTtJQUNoQixRQUFRLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUM5QixRQUFRLE9BQU8sTUFBTSxDQUFDO0lBQ3RCLE9BQU87SUFDUCxLQUFLLENBQUM7SUFDTixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGNBQWMsR0FBRztJQUNwQixJQUFJLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDcEMsSUFBSSxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN4QixJQUFJLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsS0FBSztJQUM3RCxNQUFNLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUNqRCxNQUFNLE9BQU87SUFDYixRQUFRLE1BQU07SUFDZCxRQUFRLFFBQVE7SUFDaEIsUUFBUSxRQUFRO0lBQ2hCLE9BQU8sQ0FBQztJQUNSLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxjQUFjLEdBQUc7SUFDcEIsSUFBSUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUN0RDtJQUNBLElBQUksTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQzNDO0lBQ0EsSUFBSSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0lBQy9CLE1BQU1BLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDdkQsTUFBTSxPQUFPO0lBQ2IsS0FBSztBQUNMO0lBQ0E7SUFDQSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ3BCLE1BQU1BLGFBQVcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDM0UsTUFBTSxPQUFPO0lBQ2IsS0FBSztBQUNMO0lBQ0EsSUFBSUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDN0Q7SUFDQSxJQUFJLE1BQU0sUUFBUSxHQUFHLDBCQUEwQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDMUc7SUFDQTtJQUNBO0lBQ0EsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsQ0FBQztBQVlEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx5QkFBeUI7SUFDbEMsRUFBRSxnQkFBZ0I7SUFDbEIsRUFBRSxlQUFlO0lBQ2pCLEVBQUU7SUFDRixFQUFFLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxFQUFFLGVBQWUsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO0lBQ3hGLEVBQUUsSUFBSSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtJQUNwQyxJQUFJLE9BQU8sZ0JBQWdCLENBQUMsSUFBSTtJQUNoQyxNQUFNLEtBQUssSUFBSTtJQUNmLFFBQVEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO0lBQ3JELFVBQVUsTUFBTSxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RELFNBQVM7SUFDVCxRQUFRLE9BQU8sS0FBSyxDQUFDO0lBQ3JCLE9BQU87SUFDUCxNQUFNLENBQUMsSUFBSTtJQUNYLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQyxDQUFDLEVBQUUsZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsT0FBTztJQUNQLEtBQUssQ0FBQztJQUNOLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLElBQUksZ0JBQWdCLEtBQUssSUFBSSxFQUFFO0lBQzVFLElBQUksTUFBTSxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2hELEdBQUc7SUFDSCxFQUFFLE9BQU8sZ0JBQWdCLENBQUM7SUFDMUIsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQkFBaUI7SUFDMUIsRUFBRSxNQUFNO0lBQ1IsRUFBRSxPQUFPO0lBQ1QsRUFBRSxLQUFLO0lBQ1AsRUFBRSxJQUFJO0lBQ04sRUFBRTtJQUNGLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxxQkFBcUIsRUFBRSxjQUFjLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFDeEUsRUFBRSxJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUM7QUFDN0I7SUFDQSxFQUFFLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLFVBQVUsRUFBRTtJQUNsRCxJQUFJLE9BQU8sVUFBVSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM1QyxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksa0JBQWtCLENBQUMsY0FBYyxDQUFDLEVBQUU7SUFDMUMsSUFBSSxJQUFJLGNBQWMsRUFBRTtJQUN4QjtJQUNBLE1BQU0sTUFBTSxxQkFBcUIsR0FBRyxjQUFjLENBQUMsaUNBQWlDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUN0RyxNQUFNLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtJQUNsQyxRQUFRLG1CQUFtQixFQUFFLENBQUM7SUFDOUIsT0FBTyxNQUFNO0lBQ2I7SUFDQSxRQUFRLGNBQWMsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLGlDQUFpQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztJQUNoRyxPQUFPO0FBQ1A7SUFDQTtJQUNBLE1BQU0sSUFBSSxjQUFjLENBQUMsS0FBSyxFQUFFO0lBQ2hDLFFBQVEsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0lBQ2xDLFFBQVEsS0FBSyxNQUFNLElBQUksSUFBSSxjQUFjLENBQUMsS0FBSyxFQUFFO0lBQ2pELFVBQVUsTUFBTSxhQUFhLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JELFVBQVUsSUFBSSxDQUFDLGFBQWEsRUFBRTtJQUM5QixZQUFZLG1CQUFtQixFQUFFLENBQUM7SUFDbEMsWUFBWSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RDLFdBQVcsTUFBTTtJQUNqQixZQUFZLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDL0MsV0FBVztJQUNYLFNBQVM7SUFDVCxRQUFRLGNBQWMsQ0FBQyxLQUFLLEdBQUcsY0FBYyxDQUFDO0lBQzlDLE9BQU87SUFDUCxLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUkscUJBQXFCLEVBQUU7SUFDL0IsTUFBTSxJQUFJLGNBQWMsQ0FBQyxLQUFLLEVBQUU7SUFDaEM7SUFDQTtJQUNBLFFBQVEsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDNUQsUUFBUSxjQUFjLENBQUMscUJBQXFCLEdBQUc7SUFDL0MsVUFBVSxHQUFHLEtBQUssQ0FBQyxxQkFBcUI7SUFDeEMsVUFBVSx5QkFBeUIsRUFBRSxlQUFlO0lBQ3BELFNBQVMsQ0FBQztJQUNWLE9BQU87SUFDUCxNQUFNLE9BQU8scUJBQXFCLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQzFELEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sY0FBYyxDQUFDO0lBQ3hCLENBQUM7QUFDRDtJQUNBLFNBQVMsWUFBWSxDQUFDLEtBQUssRUFBRTtJQUM3QixFQUFFLE9BQU8sS0FBSyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUM7SUFDbEMsQ0FBQztBQUNEO0lBQ0EsU0FBUyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUU7SUFDbkMsRUFBRSxPQUFPLEtBQUssQ0FBQyxJQUFJLEtBQUssYUFBYSxDQUFDO0lBQ3RDOztJQ3Y2QkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx5QkFBeUIsQ0FBQyxHQUFHLEVBQUU7SUFDeEMsRUFBRSxPQUFPO0lBQ1QsSUFBSTtJQUNKLE1BQU0sSUFBSSxFQUFFLFVBQVU7SUFDdEIsS0FBSztJQUNMLElBQUksR0FBRztJQUNQLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMscUJBQXFCO0lBQzlCLEVBQUUsSUFBSTtJQUNOLEVBQUUsUUFBUTtJQUNWLEVBQUUsTUFBTTtJQUNSLEVBQUUsR0FBRztJQUNMLEVBQUU7SUFDRixFQUFFLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNyQjtJQUNBLEVBQUUsSUFBSSxRQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ3JCLElBQUksT0FBTyxDQUFDLEdBQUcsR0FBRztJQUNsQixNQUFNLElBQUksRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUk7SUFDN0IsTUFBTSxPQUFPLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPO0lBQ25DLEtBQUssQ0FBQztJQUNOLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7SUFDekIsSUFBSSxPQUFPLENBQUMsR0FBRyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNuQyxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQztJQUN0RTs7SUNwQ0EsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO0FBMkkvQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMseUJBQXlCLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRTtJQUMzRCxFQUFFLE1BQU0sU0FBUyxHQUFHLGNBQWMsSUFBSSx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2pGLEVBQUUsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtJQUM5QixJQUFJLE9BQU87SUFDWCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUM1QyxFQUFFLE1BQU0sUUFBUSxHQUFHLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxhQUFhLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDcEg7SUFDQTtJQUNBLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDdkI7SUFDQSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDM0I7SUFDQTtJQUNBO0lBQ0EsRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDOztJQy9LQSxNQUFNLHdCQUF3QixHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUNyRTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUU7SUFDbEMsRUFBRSxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDcEI7SUFDQSxFQUFFLFNBQVMsT0FBTyxHQUFHO0lBQ3JCLElBQUksT0FBTyxLQUFLLEtBQUssU0FBUyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3hELEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxFQUFFO0lBQ3hCLElBQUksT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsU0FBUyxHQUFHLENBQUMsWUFBWSxFQUFFO0lBQzdCLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFO0lBQ3BCLE1BQU0sT0FBTyxtQkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBQzNELEtBQUs7QUFDTDtJQUNBO0lBQ0EsSUFBSSxNQUFNLElBQUksR0FBRyxZQUFZLEVBQUUsQ0FBQztJQUNoQyxJQUFJLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUNyQyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsS0FBSztJQUNMLElBQUksS0FBSyxJQUFJO0lBQ2IsT0FBTyxJQUFJLENBQUMsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0I7SUFDQTtJQUNBO0lBQ0EsT0FBTyxJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ2xCLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTTtJQUN0QztJQUNBLFNBQVMsQ0FBQztJQUNWLE9BQU8sQ0FBQztJQUNSLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsRUFBRSxTQUFTLEtBQUssQ0FBQyxPQUFPLEVBQUU7SUFDMUIsSUFBSSxPQUFPLElBQUksV0FBVyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSztJQUNoRCxNQUFNLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDbEM7SUFDQSxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUU7SUFDcEIsUUFBUSxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixPQUFPO0FBQ1A7SUFDQTtJQUNBLE1BQU0sTUFBTSxrQkFBa0IsR0FBRyxVQUFVLENBQUMsTUFBTTtJQUNsRCxRQUFRLElBQUksT0FBTyxJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUU7SUFDcEMsVUFBVSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekIsU0FBUztJQUNULE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNsQjtJQUNBO0lBQ0EsTUFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSTtJQUM3QixRQUFRLEtBQUssbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU07SUFDbEQsVUFBVSxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUU7SUFDMUIsWUFBWSxZQUFZLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUM3QyxZQUFZLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixXQUFXO0lBQ1gsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ25CLE9BQU8sQ0FBQyxDQUFDO0lBQ1QsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU87SUFDVCxJQUFJLENBQUMsRUFBRSxNQUFNO0lBQ2IsSUFBSSxHQUFHO0lBQ1AsSUFBSSxLQUFLO0lBQ1QsR0FBRyxDQUFDO0lBQ0o7O0lDbkdBO0FBQ0E7SUFDQSxNQUFNLG1CQUFtQixHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDdEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO0lBQ3pELEVBQUUsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ2hELEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRTtJQUMzQixJQUFJLE9BQU8sV0FBVyxHQUFHLElBQUksQ0FBQztJQUM5QixHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUU7SUFDMUIsSUFBSSxPQUFPLFVBQVUsR0FBRyxHQUFHLENBQUM7SUFDNUIsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLG1CQUFtQixDQUFDO0lBQzdCLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRTtJQUM3QyxFQUFFLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsYUFBYSxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtJQUMvRCxFQUFFLE9BQU8sYUFBYSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDbkQsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZ0JBQWdCO0lBQ3pCLEVBQUUsTUFBTTtJQUNSLEVBQUUsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0lBQ3pCLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFDbEIsRUFBRTtJQUNGLEVBQUUsTUFBTSxpQkFBaUIsR0FBRztJQUM1QixJQUFJLEdBQUcsTUFBTTtJQUNiLEdBQUcsQ0FBQztBQUNKO0lBQ0E7SUFDQTtJQUNBLEVBQUUsTUFBTSxlQUFlLEdBQUcsT0FBTyxHQUFHLHNCQUFzQixDQUFDLENBQUM7SUFDNUQsRUFBRSxNQUFNLGdCQUFnQixHQUFHLE9BQU8sR0FBRyxhQUFhLENBQUMsQ0FBQztBQUNwRDtJQUNBLEVBQUUsSUFBSSxlQUFlLEVBQUU7SUFDdkI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSSxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0lBQzNELE1BQU0sTUFBTSxDQUFDLFVBQVUsRUFBRSxVQUFVLE1BQU0sVUFBVSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDNUUsTUFBTSxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ25ELE1BQU0sTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxXQUFXLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQztJQUNwRSxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUU7SUFDdkIsUUFBUSxpQkFBaUIsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQztJQUM1QyxPQUFPLE1BQU07SUFDYixRQUFRLEtBQUssTUFBTSxRQUFRLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUN0RCxVQUFVLElBQUksUUFBUSxLQUFLLGVBQWUsRUFBRTtJQUM1QztJQUNBLFlBQVksSUFBSSxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtJQUN6RSxjQUFjLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7SUFDeEQsYUFBYTtJQUNiLFdBQVcsTUFBTTtJQUNqQixZQUFZLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7SUFDdEQsV0FBVztJQUNYLFNBQVM7SUFDVCxPQUFPO0lBQ1AsS0FBSztJQUNMLEdBQUcsTUFBTSxJQUFJLGdCQUFnQixFQUFFO0lBQy9CLElBQUksaUJBQWlCLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxxQkFBcUIsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMvRSxHQUFHLE1BQU0sSUFBSSxVQUFVLEtBQUssR0FBRyxFQUFFO0lBQ2pDLElBQUksaUJBQWlCLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQzVDLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxpQkFBaUIsQ0FBQztJQUMzQjs7SUMvRkEsTUFBTSw2QkFBNkIsR0FBRyxFQUFFLENBQUM7QUFDekM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGVBQWU7SUFDeEIsRUFBRSxPQUFPO0lBQ1QsRUFBRSxXQUFXO0lBQ2IsRUFBRSxNQUFNLEdBQUcsaUJBQWlCO0lBQzVCLElBQUksT0FBTyxDQUFDLFVBQVUsSUFBSSw2QkFBNkI7SUFDdkQsR0FBRztJQUNILEVBQUU7SUFDRixFQUFFLElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUN0QixFQUFFLE1BQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbkQ7SUFDQSxFQUFFLFNBQVMsSUFBSSxDQUFDLFFBQVEsRUFBRTtJQUMxQixJQUFJLE1BQU0scUJBQXFCLEdBQUcsRUFBRSxDQUFDO0FBQ3JDO0lBQ0E7SUFDQSxJQUFJLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLEtBQUs7SUFDbEQsTUFBTSxNQUFNLFlBQVksR0FBRyw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRSxNQUFNLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsRUFBRTtJQUNuRCxRQUFRLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxtQkFBbUIsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0RSxPQUFPLE1BQU07SUFDYixRQUFRLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxPQUFPO0lBQ1AsS0FBSyxDQUFDLENBQUM7QUFDUDtJQUNBO0lBQ0EsSUFBSSxJQUFJLHFCQUFxQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDNUMsTUFBTSxPQUFPLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxnQkFBZ0IsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLHFCQUFxQixFQUFFLENBQUM7QUFDakY7SUFDQTtJQUNBLElBQUksTUFBTSxrQkFBa0IsR0FBRyxDQUFDLE1BQU0sS0FBSztJQUMzQyxNQUFNLG1CQUFtQixDQUFDLGdCQUFnQixFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksS0FBSztJQUM1RCxRQUFRLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsOEJBQThCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNqRixPQUFPLENBQUMsQ0FBQztJQUNULEtBQUssQ0FBQztBQUNOO0lBQ0EsSUFBSSxNQUFNLFdBQVcsR0FBRztJQUN4QixNQUFNLFdBQVcsQ0FBQyxFQUFFLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJO0lBQ3JFLFFBQVEsUUFBUSxJQUFJO0lBQ3BCO0lBQ0EsVUFBVSxJQUFJLFFBQVEsQ0FBQyxVQUFVLEtBQUssU0FBUyxLQUFLLFFBQVEsQ0FBQyxVQUFVLEdBQUcsR0FBRyxJQUFJLFFBQVEsQ0FBQyxVQUFVLElBQUksR0FBRyxDQUFDLEVBQUU7SUFDOUcsWUFBWUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxrQ0FBa0MsRUFBRSxRQUFRLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDbEgsV0FBVztBQUNYO0lBQ0EsVUFBVSxVQUFVLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzlELFVBQVUsT0FBTyxRQUFRLENBQUM7SUFDMUIsU0FBUztJQUNULFFBQVEsS0FBSyxJQUFJO0lBQ2pCLFVBQVUsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDOUMsVUFBVUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsOENBQThDLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDN0YsVUFBVSxNQUFNLEtBQUssQ0FBQztJQUN0QixTQUFTO0lBQ1QsT0FBTyxDQUFDO0FBQ1I7SUFDQSxJQUFJLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJO0lBQ3ZDLE1BQU0sTUFBTSxJQUFJLE1BQU07SUFDdEIsTUFBTSxLQUFLLElBQUk7SUFDZixRQUFRLElBQUksS0FBSyxLQUFLLHdCQUF3QixFQUFFO0lBQ2hELFVBQVVBLGFBQVcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7SUFDdkYsVUFBVSxrQkFBa0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQy9DLFVBQVUsT0FBTyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN6QyxTQUFTLE1BQU07SUFDZixVQUFVLE1BQU0sS0FBSyxDQUFDO0lBQ3RCLFNBQVM7SUFDVCxPQUFPO0lBQ1AsS0FBSyxDQUFDO0lBQ04sR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJO0lBQ1IsSUFBSSxLQUFLO0lBQ1QsR0FBRyxDQUFDO0lBQ0o7O0lDeEZBO0lBQ0E7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxzQkFBc0IsQ0FBQyxnQkFBZ0IsRUFBRTtJQUNsRCxFQUFFLElBQUksZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFVBQVUsS0FBSyxTQUFTLEVBQUU7SUFDdkQsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUc7SUFDNUIsTUFBTSxHQUFHLGdCQUFnQixDQUFDLElBQUk7SUFDOUIsTUFBTSxVQUFVLEVBQUUsVUFBVTtJQUM1QixLQUFLLENBQUM7SUFDTixHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx5QkFBeUIsQ0FBQyxPQUFPLEVBQUU7SUFDNUMsRUFBRSxJQUFJLFlBQVksSUFBSSxPQUFPLEVBQUU7SUFDL0IsSUFBSSxJQUFJLE9BQU8sQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLEtBQUssU0FBUyxFQUFFO0lBQ3JELE1BQU0sT0FBTyxDQUFDLEtBQUssR0FBRztJQUN0QixRQUFRLEdBQUcsT0FBTyxDQUFDLEtBQUs7SUFDeEIsUUFBUSxVQUFVLEVBQUUsVUFBVTtJQUM5QixPQUFPLENBQUM7SUFDUixLQUFLO0lBQ0wsR0FBRyxNQUFNO0lBQ1QsSUFBSSxJQUFJLE9BQU8sQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFO0lBQ3pDLE1BQU0sT0FBTyxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7SUFDckMsS0FBSztJQUNMLEdBQUc7SUFDSDs7SUM5QkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFBRTtJQUN6RSxFQUFFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDO0FBQzNDO0lBQ0EsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRTtJQUNyQixJQUFJLFFBQVEsQ0FBQyxHQUFHLEdBQUc7SUFDbkIsTUFBTSxJQUFJLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN2QyxNQUFNLFFBQVEsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSztJQUNuQyxRQUFRLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN6QyxRQUFRLE9BQU8sRUFBRSxXQUFXO0lBQzVCLE9BQU8sQ0FBQyxDQUFDO0lBQ1QsTUFBTSxPQUFPLEVBQUUsV0FBVztJQUMxQixLQUFLLENBQUM7SUFDTixHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQy9COztJQzFCQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxDQUFDO0FBQ2hDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxhQUFhLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRTtJQUN6QyxFQUFFLE1BQU0sTUFBTSxHQUFHLFNBQVMsRUFBRSxDQUFDO0lBQzdCLEVBQUUsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQztBQUM3QztJQUNBLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxPQUFPO0FBQ3RCO0lBQ0EsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEdBQUcsSUFBSSxFQUFFLGNBQWMsR0FBRyxtQkFBbUIsRUFBRSxHQUFHLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUNoRztJQUNBLEVBQUUsSUFBSSxjQUFjLElBQUksQ0FBQyxFQUFFLE9BQU87QUFDbEM7SUFDQSxFQUFFLE1BQU0sU0FBUyxHQUFHLHNCQUFzQixFQUFFLENBQUM7SUFDN0MsRUFBRSxNQUFNLGdCQUFnQixHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsVUFBVSxFQUFFLENBQUM7SUFDeEQsRUFBRSxNQUFNLGVBQWUsR0FBRyxnQkFBZ0I7SUFDMUMsT0FBTyxjQUFjLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZCO0lBQ0EsRUFBRSxJQUFJLGVBQWUsS0FBSyxJQUFJLEVBQUUsT0FBTztBQUN2QztJQUNBLEVBQUUsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO0lBQ25CLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUQsR0FBRztBQUNIO0lBQ0EsRUFBRSxjQUFjLENBQUMsYUFBYSxDQUFDLGVBQWUsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNoRTs7SUNuQ0EsSUFBSSx3QkFBd0IsQ0FBQztBQUM3QjtJQUNBLE1BQU1JLGtCQUFnQixHQUFHLGtCQUFrQixDQUFDO0FBQzVDO0lBQ0EsTUFBTSxhQUFhLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztBQUNwQztJQUNBLE1BQU0sNEJBQTRCLElBQUksTUFBTTtJQUM1QyxFQUFFLE9BQU87SUFDVCxJQUFJLElBQUksRUFBRUEsa0JBQWdCO0lBQzFCLElBQUksU0FBUyxHQUFHO0lBQ2hCO0lBQ0EsTUFBTSx3QkFBd0IsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUM3RDtJQUNBO0lBQ0E7SUFDQSxNQUFNLElBQUk7SUFDVixRQUFRLFFBQVEsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFdBQVcsR0FBRyxJQUFJLEVBQUU7SUFDMUQsVUFBVSxNQUFNLGdCQUFnQixHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdELFVBQVUsTUFBTSxPQUFPO0lBQ3ZCLFlBQVksYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLGdCQUFnQixLQUFLLFNBQVMsR0FBRyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7SUFDeEcsVUFBVSxPQUFPLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0QsU0FBUyxDQUFDO0lBQ1YsT0FBTyxDQUFDLE1BQU07SUFDZDtJQUNBLE9BQU87SUFDUCxLQUFLO0lBQ0wsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO0lBQ2xCLE1BQU0sYUFBYSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdEMsS0FBSztJQUNMLEdBQUcsQ0FBQztJQUNKLENBQUMsQ0FBQyxFQUFFO0FBQ0o7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSwyQkFBMkIsR0FBRyxpQkFBaUIsQ0FBQyw0QkFBNEIsQ0FBQzs7SUN4Q25GO0lBQ0E7SUFDQSxNQUFNLHFCQUFxQixHQUFHO0lBQzlCLEVBQUUsbUJBQW1CO0lBQ3JCLEVBQUUsK0NBQStDO0lBQ2pELEVBQUUsaUVBQWlFO0lBQ25FLEVBQUUsdUNBQXVDO0lBQ3pDLEVBQUUsNEJBQTRCO0lBQzlCLEVBQUUsd0RBQXdEO0lBQzFELEVBQUUsb0RBQW9EO0lBQ3RELEVBQUUsK0dBQStHO0lBQ2pILEVBQUUsK0NBQStDO0lBQ2pELEVBQUUsK0hBQStIO0lBQ2pJLEVBQUUsc0RBQXNEO0lBQ3hELENBQUMsQ0FBQztBQUNGO0lBQ0E7QUFDQTtJQUNBLE1BQU1BLGtCQUFnQixHQUFHLGNBQWMsQ0FBQztBQUN4QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSx1QkFBdUIsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLEtBQUs7SUFDcEUsRUFBRSxJQUFJLGFBQWEsQ0FBQztJQUNwQixFQUFFLE9BQU87SUFDVCxJQUFJLElBQUksRUFBRUEsa0JBQWdCO0lBQzFCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtJQUNsQixNQUFNLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNoRCxNQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQzVELEtBQUs7SUFDTCxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtJQUN2QyxNQUFNLElBQUksQ0FBQyxhQUFhLEVBQUU7SUFDMUIsUUFBUSxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDbEQsUUFBUSxhQUFhLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztJQUM5RCxPQUFPO0lBQ1AsTUFBTSxPQUFPQyxrQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLEdBQUcsSUFBSSxHQUFHLEtBQUssQ0FBQztJQUNuRSxLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSx5QkFBeUIsR0FBRyxpQkFBaUIsRUFBRSxDQUFDLE9BQU8sR0FBRyxFQUFFLEtBQUs7SUFDdkUsRUFBRSxPQUFPO0lBQ1QsSUFBSSxHQUFHLHVCQUF1QixDQUFDLE9BQU8sQ0FBQztJQUN2QyxJQUFJLElBQUksRUFBRSxnQkFBZ0I7SUFDMUIsR0FBRyxDQUFDO0lBQ0osQ0FBQyxHQUFHLENBQUM7QUFDTDtJQUNBLFNBQVMsYUFBYTtJQUN0QixFQUFFLGVBQWUsR0FBRyxFQUFFO0lBQ3RCLEVBQUUsYUFBYSxHQUFHLEVBQUU7SUFDcEIsRUFBRTtJQUNGLEVBQUUsT0FBTztJQUNULElBQUksU0FBUyxFQUFFLENBQUMsSUFBSSxlQUFlLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksYUFBYSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN6RixJQUFJLFFBQVEsRUFBRSxDQUFDLElBQUksZUFBZSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLGFBQWEsQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDLENBQUM7SUFDdEYsSUFBSSxZQUFZLEVBQUU7SUFDbEIsTUFBTSxJQUFJLGVBQWUsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDO0lBQzdDLE1BQU0sSUFBSSxhQUFhLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQztJQUMzQyxNQUFNLElBQUksZUFBZSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRyxxQkFBcUIsQ0FBQztJQUM1RSxLQUFLO0lBQ0wsSUFBSSxrQkFBa0IsRUFBRSxDQUFDLElBQUksZUFBZSxDQUFDLGtCQUFrQixJQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksYUFBYSxDQUFDLGtCQUFrQixJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BILEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVNBLGtCQUFnQixDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUU7SUFDMUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRTtJQUNuQjtJQUNBLElBQUksSUFBSSxlQUFlLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtJQUN0RCxNQUFNTCxhQUFXO0lBQ2pCLFFBQVEsTUFBTSxDQUFDLElBQUk7SUFDbkIsVUFBVSxDQUFDLHVFQUF1RSxFQUFFLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDaEgsU0FBUyxDQUFDO0lBQ1YsTUFBTSxPQUFPLElBQUksQ0FBQztJQUNsQixLQUFLO0lBQ0wsSUFBSSxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUNoQyxNQUFNQSxhQUFXO0lBQ2pCLFFBQVEsTUFBTSxDQUFDLElBQUk7SUFDbkIsVUFBVSxDQUFDLG9GQUFvRixFQUFFLG1CQUFtQjtBQUNwSCxZQUFZLEtBQUs7QUFDakIsV0FBVyxDQUFDLENBQUM7SUFDYixTQUFTLENBQUM7SUFDVixNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7SUFDTCxJQUFJLElBQUksWUFBWSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7SUFDL0MsTUFBTUEsYUFBVztJQUNqQixRQUFRLE1BQU0sQ0FBQyxJQUFJO0lBQ25CLFVBQVUsQ0FBQyxtRUFBbUUsRUFBRSxtQkFBbUI7QUFDbkcsWUFBWSxLQUFLO0FBQ2pCLFdBQVcsQ0FBQyxRQUFRLEVBQUUsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNqRCxTQUFTLENBQUM7SUFDVixNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7SUFDTCxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUNsRCxNQUFNQSxhQUFXO0lBQ2pCLFFBQVEsTUFBTSxDQUFDLElBQUk7SUFDbkIsVUFBVSxDQUFDLHdFQUF3RSxFQUFFLG1CQUFtQjtBQUN4RyxZQUFZLEtBQUs7QUFDakIsV0FBVyxDQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2pELFNBQVMsQ0FBQztJQUNWLE1BQU0sT0FBTyxJQUFJLENBQUM7SUFDbEIsS0FBSztJQUNMLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFO0lBQzNDO0FBQ0E7SUFDQSxJQUFJLElBQUkscUJBQXFCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO0lBQ2xFLE1BQU1BLGFBQVc7SUFDakIsUUFBUSxNQUFNLENBQUMsSUFBSTtJQUNuQixVQUFVLENBQUMsNkVBQTZFLEVBQUUsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN0SCxTQUFTLENBQUM7SUFDVixNQUFNLE9BQU8sSUFBSSxDQUFDO0lBQ2xCLEtBQUs7SUFDTCxHQUFHO0lBQ0gsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDRDtJQUNBLFNBQVMsZUFBZSxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUU7SUFDOUMsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRTtJQUM3QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQzFHLENBQUM7QUFDRDtJQUNBLFNBQVMscUJBQXFCLENBQUMsS0FBSyxFQUFFLGtCQUFrQixFQUFFO0lBQzFELEVBQUUsSUFBSSxDQUFDLGtCQUFrQixFQUFFLE1BQU0sRUFBRTtJQUNuQyxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztJQUNqQyxFQUFFLE9BQU8sSUFBSSxHQUFHLHdCQUF3QixDQUFDLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMzRSxDQUFDO0FBQ0Q7SUFDQSxTQUFTLFlBQVksQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFO0lBQ3ZDLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUU7SUFDekIsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsRUFBRSxNQUFNLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsS0FBSyxHQUFHLHdCQUF3QixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNoRSxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFO0lBQ3pDLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUU7SUFDMUIsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0lBQ0gsRUFBRSxNQUFNLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLHdCQUF3QixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNoRSxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7SUFDdkMsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDL0MsSUFBSSxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUI7SUFDQSxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxRQUFRLEtBQUssYUFBYSxJQUFJLEtBQUssQ0FBQyxRQUFRLEtBQUssZUFBZSxFQUFFO0lBQ3pGLE1BQU0sT0FBTyxLQUFLLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQztJQUNwQyxLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7QUFDRDtJQUNBLFNBQVMsa0JBQWtCLENBQUMsS0FBSyxFQUFFO0lBQ25DLEVBQUUsSUFBSTtJQUNOO0lBQ0E7SUFDQSxJQUFJLE1BQU0sYUFBYSxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM5RCxPQUFPLE9BQU8sRUFBRTtJQUNoQixPQUFPLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLFNBQVMsRUFBRSxTQUFTLEtBQUssU0FBUyxJQUFJLEtBQUssQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ25HLElBQUksTUFBTSxNQUFNLEdBQUcsYUFBYSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUM7SUFDckQsSUFBSSxPQUFPLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDcEQsR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFFO0lBQ2YsSUFBSUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyw2QkFBNkIsRUFBRSxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5RixJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7SUFDSCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGVBQWUsQ0FBQyxLQUFLLEVBQUU7SUFDaEM7SUFDQSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7SUFDeEMsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFO0lBQ0Y7SUFDQSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU87SUFDbEI7SUFDQSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsVUFBVSxLQUFLLEtBQUssQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3BILElBQUk7SUFDSjs7SUMxTkE7SUFDQTtJQUNBO0lBQ0EsU0FBUywyQkFBMkI7SUFDcEMsRUFBRSxnQ0FBZ0M7SUFDbEMsRUFBRSxNQUFNO0lBQ1IsRUFBRSxHQUFHO0lBQ0wsRUFBRSxLQUFLO0lBQ1AsRUFBRSxLQUFLO0lBQ1AsRUFBRSxJQUFJO0lBQ04sRUFBRTtJQUNGLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsTUFBTSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsRUFBRTtJQUN6RixJQUFJLE9BQU87SUFDWCxHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsTUFBTSxpQkFBaUI7SUFDekIsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7QUFDOUc7SUFDQTtJQUNBLEVBQUUsSUFBSSxpQkFBaUIsRUFBRTtJQUN6QixJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLDRCQUE0QjtJQUN6RCxNQUFNLGdDQUFnQztJQUN0QyxNQUFNLE1BQU07SUFDWixNQUFNLEtBQUs7SUFDWCxNQUFNLElBQUksQ0FBQyxpQkFBaUI7SUFDNUIsTUFBTSxHQUFHO0lBQ1QsTUFBTSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU07SUFDNUIsTUFBTSxpQkFBaUI7SUFDdkIsTUFBTSxDQUFDO0lBQ1AsS0FBSyxDQUFDO0lBQ04sR0FBRztJQUNILENBQUM7QUFDRDtJQUNBLFNBQVMsNEJBQTRCO0lBQ3JDLEVBQUUsZ0NBQWdDO0lBQ2xDLEVBQUUsTUFBTTtJQUNSLEVBQUUsS0FBSztJQUNQLEVBQUUsS0FBSztJQUNQLEVBQUUsR0FBRztJQUNMLEVBQUUsY0FBYztJQUNoQixFQUFFLFNBQVM7SUFDWCxFQUFFLFdBQVc7SUFDYixFQUFFO0lBQ0YsRUFBRSxJQUFJLGNBQWMsQ0FBQyxNQUFNLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtJQUMxQyxJQUFJLE9BQU8sY0FBYyxDQUFDO0lBQzFCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxhQUFhLEdBQUcsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDO0FBQzFDO0lBQ0E7SUFDQSxFQUFFLElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRTtJQUN2QyxJQUFJLDJDQUEyQyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN4RSxJQUFJLE1BQU0sWUFBWSxHQUFHLGdDQUFnQyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5RSxJQUFJLE1BQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUM7SUFDaEQsSUFBSSwwQ0FBMEMsQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMvRixJQUFJLGFBQWEsR0FBRyw0QkFBNEI7SUFDaEQsTUFBTSxnQ0FBZ0M7SUFDdEMsTUFBTSxNQUFNO0lBQ1osTUFBTSxLQUFLO0lBQ1gsTUFBTSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ2hCLE1BQU0sR0FBRztJQUNULE1BQU0sQ0FBQyxZQUFZLEVBQUUsR0FBRyxhQUFhLENBQUM7SUFDdEMsTUFBTSxZQUFZO0lBQ2xCLE1BQU0sY0FBYztJQUNwQixLQUFLLENBQUM7SUFDTixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQ25DLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFLO0lBQzVDLE1BQU0sSUFBSSxZQUFZLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxFQUFFO0lBQzNDLFFBQVEsMkNBQTJDLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzVFLFFBQVEsTUFBTSxZQUFZLEdBQUcsZ0NBQWdDLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ2xGLFFBQVEsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQztJQUNwRCxRQUFRLDBDQUEwQyxDQUFDLFlBQVksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzlHLFFBQVEsYUFBYSxHQUFHLDRCQUE0QjtJQUNwRCxVQUFVLGdDQUFnQztJQUMxQyxVQUFVLE1BQU07SUFDaEIsVUFBVSxLQUFLO0lBQ2YsVUFBVSxVQUFVO0lBQ3BCLFVBQVUsR0FBRztJQUNiLFVBQVUsQ0FBQyxZQUFZLEVBQUUsR0FBRyxhQUFhLENBQUM7SUFDMUMsVUFBVSxZQUFZO0lBQ3RCLFVBQVUsY0FBYztJQUN4QixTQUFTLENBQUM7SUFDVixPQUFPO0lBQ1AsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUM7QUFDRDtJQUNBLFNBQVMsMkNBQTJDLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRTtJQUM3RTtJQUNBLEVBQUUsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsU0FBUyxJQUFJLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFDbEY7SUFDQSxFQUFFLFNBQVMsQ0FBQyxTQUFTLEdBQUc7SUFDeEIsSUFBSSxHQUFHLFNBQVMsQ0FBQyxTQUFTO0lBQzFCLElBQUksSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLGdCQUFnQixJQUFJLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDNUUsSUFBSSxZQUFZLEVBQUUsV0FBVztJQUM3QixHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLDBDQUEwQztJQUNuRCxFQUFFLFNBQVM7SUFDWCxFQUFFLE1BQU07SUFDUixFQUFFLFdBQVc7SUFDYixFQUFFLFFBQVE7SUFDVixFQUFFO0lBQ0Y7SUFDQSxFQUFFLFNBQVMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ2xGO0lBQ0EsRUFBRSxTQUFTLENBQUMsU0FBUyxHQUFHO0lBQ3hCLElBQUksR0FBRyxTQUFTLENBQUMsU0FBUztJQUMxQixJQUFJLElBQUksRUFBRSxTQUFTO0lBQ25CLElBQUksTUFBTTtJQUNWLElBQUksWUFBWSxFQUFFLFdBQVc7SUFDN0IsSUFBSSxTQUFTLEVBQUUsUUFBUTtJQUN2QixHQUFHLENBQUM7SUFDSjs7SUN0SEE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxnQ0FBZ0MsQ0FBQyxPQUFPLEVBQUU7SUFDbkQsRUFBRSxNQUFNLElBQUksR0FBRyxTQUFTLENBQUM7SUFDekIsRUFBRSxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVCLEVBQUUsZUFBZSxDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQzNDLENBQUM7QUFDRDtJQUNBLFNBQVMsaUJBQWlCLEdBQUc7SUFDN0IsRUFBRSxJQUFJLEVBQUUsU0FBUyxJQUFJLFVBQVUsQ0FBQyxFQUFFO0lBQ2xDLElBQUksT0FBTztJQUNYLEdBQUc7QUFDSDtJQUNBLEVBQUUsY0FBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEtBQUssRUFBRTtJQUMxQyxJQUFJLElBQUksRUFBRSxLQUFLLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ3hDLE1BQU0sT0FBTztJQUNiLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFVBQVUscUJBQXFCLEVBQUU7SUFDckUsTUFBTSxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxxQkFBcUIsQ0FBQztBQUM1RDtJQUNBLE1BQU0sT0FBTyxVQUFVLEdBQUcsSUFBSSxFQUFFO0lBQ2hDLFFBQVEsTUFBTSxXQUFXLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUM7SUFDNUMsUUFBUSxlQUFlLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ2hEO0lBQ0EsUUFBUSxNQUFNLEdBQUcsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRCxRQUFRLEdBQUcsRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3QyxPQUFPLENBQUM7SUFDUixLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUcsQ0FBQyxDQUFDO0lBQ0w7O0lDdkNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsdUJBQXVCLENBQUMsS0FBSyxFQUFFO0lBQ3hDLEVBQUU7SUFDRixJQUFJLEtBQUssS0FBSyxNQUFNLEdBQUcsU0FBUyxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxHQUFHLEtBQUs7SUFDeEgsS0FBSztJQUNMOztJQ0xBLE1BQU1JLGtCQUFnQixHQUFHLFFBQVEsQ0FBQztBQUNsQztJQUNBLE1BQU0sa0JBQWtCLElBQUksTUFBTTtJQUNsQyxFQUFFLElBQUksYUFBYSxDQUFDO0FBQ3BCO0lBQ0EsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUVBLGtCQUFnQjtJQUMxQixJQUFJLFlBQVksQ0FBQyxZQUFZLEVBQUU7SUFDL0I7SUFDQTtJQUNBLE1BQU0sSUFBSSxZQUFZLENBQUMsSUFBSSxFQUFFO0lBQzdCLFFBQVEsT0FBTyxZQUFZLENBQUM7SUFDNUIsT0FBTztBQUNQO0lBQ0E7SUFDQSxNQUFNLElBQUk7SUFDVixRQUFRLElBQUksZ0JBQWdCLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxFQUFFO0lBQzNELFVBQVVKLGFBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLHNFQUFzRSxDQUFDLENBQUM7SUFDN0csVUFBVSxPQUFPLElBQUksQ0FBQztJQUN0QixTQUFTO0lBQ1QsT0FBTyxDQUFDLE9BQU8sR0FBRyxFQUFFLEVBQUU7QUFDdEI7SUFDQSxNQUFNLFFBQVEsYUFBYSxHQUFHLFlBQVksRUFBRTtJQUM1QyxLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLEVBQUU7QUFDSjtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0saUJBQWlCLEdBQUcsaUJBQWlCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNoRTtJQUNBO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsYUFBYSxFQUFFO0lBQ3ZELEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRTtJQUN0QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxtQkFBbUIsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLEVBQUU7SUFDeEQsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUkscUJBQXFCLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxFQUFFO0lBQzFELElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDRDtJQUNBLFNBQVMsbUJBQW1CLENBQUMsWUFBWSxFQUFFLGFBQWEsRUFBRTtJQUMxRCxFQUFFLE1BQU0sY0FBYyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7SUFDOUMsRUFBRSxNQUFNLGVBQWUsR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDO0FBQ2hEO0lBQ0E7SUFDQSxFQUFFLElBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxlQUFlLEVBQUU7SUFDM0MsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLGVBQWUsTUFBTSxDQUFDLGNBQWMsSUFBSSxlQUFlLENBQUMsRUFBRTtJQUNwRixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxjQUFjLEtBQUssZUFBZSxFQUFFO0lBQzFDLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxFQUFFO0lBQ3hELElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxFQUFFO0lBQ3ZELElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7QUFDRDtJQUNBLFNBQVMscUJBQXFCLENBQUMsWUFBWSxFQUFFLGFBQWEsRUFBRTtJQUM1RCxFQUFFLE1BQU0saUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDbEUsRUFBRSxNQUFNLGdCQUFnQixHQUFHLHNCQUFzQixDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2hFO0lBQ0EsRUFBRSxJQUFJLENBQUMsaUJBQWlCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtJQUMvQyxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLENBQUMsSUFBSSxJQUFJLGlCQUFpQixDQUFDLEtBQUssS0FBSyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7SUFDOUcsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLEVBQUU7SUFDeEQsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLEVBQUU7SUFDdkQsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztBQUNEO0lBQ0EsU0FBUyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsYUFBYSxFQUFFO0lBQ3hELEVBQUUsSUFBSSxhQUFhLEdBQUcsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdkQsRUFBRSxJQUFJLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN6RDtJQUNBO0lBQ0EsRUFBRSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsY0FBYyxFQUFFO0lBQ3pDLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxjQUFjLE1BQU0sQ0FBQyxhQUFhLElBQUksY0FBYyxDQUFDLEVBQUU7SUFDaEYsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLGFBQWEsR0FBRyxhQUFhLEVBQUU7SUFDakMsRUFBRSxjQUFjLEdBQUcsY0FBYyxFQUFFO0FBQ25DO0lBQ0E7SUFDQSxFQUFFLElBQUksY0FBYyxDQUFDLE1BQU0sS0FBSyxhQUFhLENBQUMsTUFBTSxFQUFFO0lBQ3RELElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0E7SUFDQSxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0lBQ2xEO0lBQ0EsSUFBSSxNQUFNLE1BQU0sR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckM7SUFDQSxJQUFJLE1BQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQztJQUNBLElBQUk7SUFDSixNQUFNLE1BQU0sQ0FBQyxRQUFRLEtBQUssTUFBTSxDQUFDLFFBQVE7SUFDekMsTUFBTSxNQUFNLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxNQUFNO0lBQ3JDLE1BQU0sTUFBTSxDQUFDLEtBQUssS0FBSyxNQUFNLENBQUMsS0FBSztJQUNuQyxNQUFNLE1BQU0sQ0FBQyxRQUFRLEtBQUssTUFBTSxDQUFDLFFBQVE7SUFDekMsTUFBTTtJQUNOLE1BQU0sT0FBTyxLQUFLLENBQUM7SUFDbkIsS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGtCQUFrQixDQUFDLFlBQVksRUFBRSxhQUFhLEVBQUU7SUFDekQsRUFBRSxJQUFJLGtCQUFrQixHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUM7SUFDcEQsRUFBRSxJQUFJLG1CQUFtQixHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUM7QUFDdEQ7SUFDQTtJQUNBLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsbUJBQW1CLEVBQUU7SUFDbkQsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsbUJBQW1CLE1BQU0sQ0FBQyxrQkFBa0IsSUFBSSxtQkFBbUIsQ0FBQyxFQUFFO0lBQ3BHLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxrQkFBa0IsR0FBRyxrQkFBa0IsRUFBRTtJQUMzQyxFQUFFLG1CQUFtQixHQUFHLG1CQUFtQixFQUFFO0FBQzdDO0lBQ0E7SUFDQSxFQUFFLElBQUk7SUFDTixJQUFJLE9BQU8sQ0FBQyxFQUFFLGtCQUFrQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1RSxHQUFHLENBQUMsT0FBTyxHQUFHLEVBQUU7SUFDaEIsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0EsU0FBUyxzQkFBc0IsQ0FBQyxLQUFLLEVBQUU7SUFDdkMsRUFBRSxPQUFPLEtBQUssQ0FBQyxTQUFTLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlEOztJQy9LQTtBQW9GQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsR0FBRyxFQUFFO0lBQ3ZCLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRTtJQUNaLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsOERBQThELENBQUMsQ0FBQztBQUMxRjtJQUNBLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNkLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMvQixFQUFFLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbEMsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNsQixJQUFJLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xCLElBQUksUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDdEIsSUFBSSxNQUFNLEVBQUUsS0FBSztJQUNqQixJQUFJLElBQUksRUFBRSxRQUFRO0lBQ2xCLElBQUksUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsUUFBUTtJQUN6QyxHQUFHLENBQUM7SUFDSjs7SUNsSEE7SUFDQTtJQUNBO0lBQ0EsU0FBUyx1Q0FBdUMsQ0FBQyxVQUFVLEVBQUU7SUFDN0Q7SUFDQSxFQUFFLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtJQUNoQyxJQUFJLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLEdBQUcsTUFBTSxJQUFJLFVBQVUsSUFBSSxHQUFHLElBQUksVUFBVSxHQUFHLEdBQUcsRUFBRTtJQUNwRCxJQUFJLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLEdBQUcsTUFBTSxJQUFJLFVBQVUsSUFBSSxHQUFHLEVBQUU7SUFDaEMsSUFBSSxPQUFPLE9BQU8sQ0FBQztJQUNuQixHQUFHLE1BQU07SUFDVCxJQUFJLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLEdBQUc7SUFDSDs7SUNWQSxNQUFNRSxRQUFNLEdBQUcsVUFBVSxFQUFFO0FBaUQzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZUFBZSxHQUFHO0lBQzNCLEVBQUUsT0FBTyxTQUFTLElBQUlBLFFBQU0sSUFBSSxDQUFDLENBQUNBLFFBQU0sQ0FBQyxPQUFPLENBQUM7SUFDakQsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxhQUFhLEdBQUc7SUFDekIsRUFBRSxJQUFJLEVBQUUsT0FBTyxJQUFJQSxRQUFNLENBQUMsRUFBRTtJQUM1QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSTtJQUNOLElBQUksSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUNsQixJQUFJLElBQUksT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDMUMsSUFBSSxJQUFJLFFBQVEsRUFBRSxDQUFDO0lBQ25CLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2QsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQixDQUFDLElBQUksRUFBRTtJQUNoQyxFQUFFLE9BQU8sSUFBSSxJQUFJLGtEQUFrRCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUMxRixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQixHQUFHO0lBQy9CLEVBQUUsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLEVBQUU7SUFDdkMsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRTtJQUN4QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksZ0JBQWdCLENBQUNBLFFBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUN0QyxJQUFJLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQSxFQUFFLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztJQUNyQixFQUFFLE1BQU0sR0FBRyxHQUFHQSxRQUFNLENBQUMsUUFBUSxDQUFDO0lBQzlCO0lBQ0EsRUFBRSxJQUFJLEdBQUcsSUFBSSxRQUFRLEdBQUcsQ0FBQyxhQUFhLEVBQUUsS0FBSyxVQUFVLEVBQUU7SUFDekQsSUFBSSxJQUFJO0lBQ1IsTUFBTSxNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELE1BQU0sT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7SUFDNUIsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxNQUFNLElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxLQUFLLEVBQUU7SUFDeEM7SUFDQSxRQUFRLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9ELE9BQU87SUFDUCxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BDLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNsQixNQUFNRixhQUFXO0lBQ2pCLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQyxpRkFBaUYsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM1RyxLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLE1BQU0sQ0FBQztJQUNoQjs7SUNqSUE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsOEJBQThCO0lBQ3ZDLEVBQUUsT0FBTztJQUNULEVBQUUsb0JBQW9CO0lBQ3RCLEVBQUU7SUFDRixFQUFFLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQztJQUN2QixFQUFFLFVBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUIsRUFBRSxlQUFlLENBQUMsSUFBSSxFQUFFLE1BQU0sZUFBZSxDQUFDLFNBQVMsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7SUFDaEYsQ0FBQztBQWVEO0lBQ0EsU0FBUyxlQUFlLENBQUMsZUFBZSxFQUFFLG9CQUFvQixHQUFHLEtBQUssRUFBRTtJQUN4RSxFQUFFLElBQUksb0JBQW9CLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxFQUFFO0lBQ3RELElBQUksT0FBTztJQUNYLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsVUFBVSxhQUFhLEVBQUU7SUFDckQsSUFBSSxPQUFPLFVBQVUsR0FBRyxJQUFJLEVBQUU7SUFDOUI7SUFDQTtBQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLE1BQU0sWUFBWSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7QUFDdkM7SUFDQSxNQUFNLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ25ELE1BQU0sTUFBTSxXQUFXLEdBQUc7SUFDMUIsUUFBUSxJQUFJO0lBQ1osUUFBUSxTQUFTLEVBQUU7SUFDbkIsVUFBVSxNQUFNO0lBQ2hCLFVBQVUsR0FBRztJQUNiLFNBQVM7SUFDVCxRQUFRLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxHQUFHLElBQUk7SUFDbkQ7SUFDQSxRQUFRLFlBQVk7SUFDcEIsUUFBUSxPQUFPLEVBQUUsdUJBQXVCLENBQUMsSUFBSSxDQUFDO0lBQzlDLE9BQU8sQ0FBQztBQUNSO0lBQ0E7SUFDQSxNQUFNLElBQUksQ0FBQyxlQUFlLEVBQUU7SUFDNUIsUUFBUSxlQUFlLENBQUMsT0FBTyxFQUFFO0lBQ2pDLFVBQVUsR0FBRyxXQUFXO0lBQ3hCLFNBQVMsQ0FBQyxDQUFDO0lBQ1gsT0FBTztBQUNQO0lBQ0E7SUFDQSxNQUFNLE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSTtJQUN2RCxRQUFRLE9BQU8sUUFBUSxLQUFLO0lBQzVCLFVBQVUsSUFBSSxlQUFlLEVBQUU7SUFDL0IsWUFBWSxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdEMsV0FBVyxNQUFNO0lBQ2pCLFlBQVksZUFBZSxDQUFDLE9BQU8sRUFBRTtJQUNyQyxjQUFjLEdBQUcsV0FBVztJQUM1QixjQUFjLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxHQUFHLElBQUk7SUFDdkQsY0FBYyxRQUFRO0lBQ3RCLGFBQWEsQ0FBQyxDQUFDO0lBQ2YsV0FBVztBQUNYO0lBQ0EsVUFBVSxPQUFPLFFBQVEsQ0FBQztJQUMxQixTQUFTO0lBQ1QsUUFBUSxDQUFDLEtBQUssS0FBSztJQUNuQixVQUFVLGVBQWUsQ0FBQyxPQUFPLEVBQUU7SUFDbkMsWUFBWSxHQUFHLFdBQVc7SUFDMUIsWUFBWSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxJQUFJO0lBQ3JELFlBQVksS0FBSztJQUNqQixXQUFXLENBQUMsQ0FBQztBQUNiO0lBQ0EsVUFBVSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtJQUMzRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFlBQVksS0FBSyxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDO0lBQzdDLFlBQVksd0JBQXdCLENBQUMsS0FBSyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5RCxXQUFXO0FBQ1g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsVUFBVTtJQUNWLFlBQVksS0FBSyxZQUFZLFNBQVM7SUFDdEMsYUFBYSxLQUFLLENBQUMsT0FBTyxLQUFLLGlCQUFpQjtJQUNoRCxjQUFjLEtBQUssQ0FBQyxPQUFPLEtBQUssYUFBYTtJQUM3QyxjQUFjLEtBQUssQ0FBQyxPQUFPLEtBQUssaURBQWlELENBQUM7SUFDbEYsWUFBWTtJQUNaLFlBQVksSUFBSTtJQUNoQixjQUFjLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0QsY0FBYyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9ELGFBQWEsQ0FBQyxNQUFNO0lBQ3BCO0lBQ0EsYUFBYTtJQUNiLFdBQVc7QUFDWDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFVBQVUsTUFBTSxLQUFLLENBQUM7SUFDdEIsU0FBUztJQUNULE9BQU8sQ0FBQztJQUNSLEtBQUssQ0FBQztJQUNOLEdBQUcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQXNFRDtJQUNBLFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUU7SUFDNUIsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUM1RCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGtCQUFrQixDQUFDLFFBQVEsRUFBRTtJQUN0QyxFQUFFLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFO0lBQ3BDLElBQUksT0FBTyxRQUFRLENBQUM7SUFDcEIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFO0lBQ2pCLElBQUksT0FBTyxFQUFFLENBQUM7SUFDZCxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksT0FBTyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsRUFBRTtJQUNoQyxJQUFJLE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQztJQUN4QixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksUUFBUSxDQUFDLFFBQVEsRUFBRTtJQUN6QixJQUFJLE9BQU8sUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9CLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLFNBQVMsRUFBRTtJQUNuQyxFQUFFLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDOUIsSUFBSSxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDdEMsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0lBQzlCLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsR0FBRyxTQUFTLEVBQUU7QUFDdEM7SUFDQSxJQUFJLE9BQU87SUFDWCxNQUFNLEdBQUcsRUFBRSxrQkFBa0IsQ0FBQyxHQUFHLENBQUM7SUFDbEMsTUFBTSxNQUFNLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLEtBQUs7SUFDdkYsS0FBSyxDQUFDO0lBQ04sR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0IsRUFBRSxPQUFPO0lBQ1QsSUFBSSxHQUFHLEVBQUUsa0JBQWtCLENBQUMsR0FBRyxFQUFFO0lBQ2pDLElBQUksTUFBTSxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxLQUFLO0lBQzdFLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVMsdUJBQXVCLENBQUMsU0FBUyxFQUFFO0lBQzVDLEVBQUUsTUFBTSxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUMsR0FBRyxTQUFTLENBQUM7QUFDdkQ7SUFDQSxFQUFFLElBQUk7SUFDTixJQUFJO0lBQ0osTUFBTSxPQUFPLGVBQWUsS0FBSyxRQUFRO0lBQ3pDLE1BQU0sZUFBZSxLQUFLLElBQUk7SUFDOUIsTUFBTSxTQUFTLElBQUksZUFBZTtJQUNsQyxNQUFNLGVBQWUsQ0FBQyxPQUFPO0lBQzdCLE1BQU07SUFDTixNQUFNLE9BQU8sSUFBSSxPQUFPLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ25ELEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxTQUFTLENBQUMsZUFBZSxDQUFDLEVBQUU7SUFDcEMsTUFBTSxPQUFPLElBQUksT0FBTyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsRCxLQUFLO0lBQ0wsR0FBRyxDQUFDLE1BQU07SUFDVjtJQUNBLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTztJQUNUOztJQ2pSQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBVUE7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksR0FBRztJQUN4QjtJQUNBLDhCQUE4QixPQUFPLEtBQUssQ0FBQztJQUMzQzs7SUM1QkEsTUFBTUUsUUFBTSxHQUFHLFVBQVUsRUFBRTtBQUMzQjtJQUNBLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsbUJBQW1CLEdBQUc7SUFDL0IsRUFBRSxPQUFPLGFBQWEsR0FBRyxDQUFDLENBQUM7SUFDM0IsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxpQkFBaUIsR0FBRztJQUM3QjtJQUNBLEVBQUUsYUFBYSxFQUFFLENBQUM7SUFDbEIsRUFBRSxVQUFVLENBQUMsTUFBTTtJQUNuQixJQUFJLGFBQWEsRUFBRSxDQUFDO0lBQ3BCLEdBQUcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQUNEO0lBQ0E7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsSUFBSTtJQUNiLEVBQUUsRUFBRTtJQUNKLEVBQUUsT0FBTztBQUNUO0lBQ0EsR0FBRyxFQUFFO0lBQ0wsRUFBRTtJQUNGO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsRUFBRSxTQUFTLFVBQVUsQ0FBQyxFQUFFLEVBQUU7SUFDMUIsSUFBSSxPQUFPLE9BQU8sRUFBRSxLQUFLLFVBQVUsQ0FBQztJQUNwQyxHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDdkIsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUNkLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSTtJQUNOO0lBQ0E7SUFDQSxJQUFJLE1BQU0sT0FBTyxHQUFHLENBQUMsRUFBRSxHQUFHLGtCQUFrQixDQUFDO0lBQzdDLElBQUksSUFBSSxPQUFPLEVBQUU7SUFDakIsTUFBTSxJQUFJLE9BQU8sT0FBTyxLQUFLLFVBQVUsRUFBRTtJQUN6QyxRQUFRLE9BQU8sT0FBTyxDQUFDO0lBQ3ZCLE9BQU8sTUFBTTtJQUNiO0lBQ0E7SUFDQSxRQUFRLE9BQU8sRUFBRSxDQUFDO0lBQ2xCLE9BQU87SUFDUCxLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksSUFBSSxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNqQyxNQUFNLE9BQU8sRUFBRSxDQUFDO0lBQ2hCLEtBQUs7SUFDTCxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDZDtJQUNBO0lBQ0E7SUFDQSxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBQ2QsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBLEVBQUUsTUFBTSxhQUFhLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRTtJQUM1QyxJQUFJLElBQUk7SUFDUjtJQUNBLE1BQU0sTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDbkU7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzlDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRTtJQUNqQixNQUFNLGlCQUFpQixFQUFFLENBQUM7QUFDMUI7SUFDQSxNQUFNLFNBQVMsQ0FBQyxLQUFLLElBQUk7SUFDekIsUUFBUSxLQUFLLENBQUMsaUJBQWlCLENBQUMsS0FBSyxJQUFJO0lBQ3pDLFVBQVUsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO0lBQ2pDLFlBQVkscUJBQXFCLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMvRCxZQUFZLHFCQUFxQixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDNUQsV0FBVztBQUNYO0lBQ0EsVUFBVSxLQUFLLENBQUMsS0FBSyxHQUFHO0lBQ3hCLFlBQVksR0FBRyxLQUFLLENBQUMsS0FBSztJQUMxQixZQUFZLFNBQVMsRUFBRSxJQUFJO0lBQzNCLFdBQVcsQ0FBQztBQUNaO0lBQ0EsVUFBVSxPQUFPLEtBQUssQ0FBQztJQUN2QixTQUFTLENBQUMsQ0FBQztBQUNYO0lBQ0EsUUFBUSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3QixPQUFPLENBQUMsQ0FBQztBQUNUO0lBQ0EsTUFBTSxNQUFNLEVBQUUsQ0FBQztJQUNmLEtBQUs7SUFDTCxHQUFHLEVBQUU7QUFDTDtJQUNBO0lBQ0EsRUFBRSxJQUFJO0lBQ04sSUFBSSxLQUFLLE1BQU0sUUFBUSxJQUFJLEVBQUUsRUFBRTtJQUMvQixNQUFNLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRTtJQUM5RCxRQUFRLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDakQsT0FBTztJQUNQLEtBQUs7SUFDTCxHQUFHLENBQUMsTUFBTTtJQUNWO0lBQ0E7SUFDQSxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0EsRUFBRSxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDekM7SUFDQSxFQUFFLHdCQUF3QixDQUFDLEVBQUUsRUFBRSxvQkFBb0IsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUNwRTtJQUNBO0lBQ0EsRUFBRSxJQUFJO0lBQ047SUFDQSxJQUFJLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDOUUsSUFBSSxJQUFJLFVBQVUsQ0FBQyxZQUFZLEVBQUU7SUFDakMsTUFBTSxNQUFNLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUU7SUFDbkQsUUFBUSxHQUFHLEdBQUc7SUFDZCxVQUFVLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQztJQUN6QixTQUFTO0lBQ1QsT0FBTyxDQUFDLENBQUM7SUFDVCxLQUFLO0lBQ0wsR0FBRyxDQUFDLE1BQU07SUFDVjtJQUNBO0lBQ0EsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLGFBQWEsQ0FBQztJQUN2Qjs7SUN2SkE7SUFDQTtJQUNBO0lBQ0EsU0FBUyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFO0lBQzdDO0lBQ0EsRUFBRSxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbkQ7SUFDQSxFQUFFLE1BQU0sU0FBUyxHQUFHO0lBQ3BCLElBQUksSUFBSSxFQUFFLFdBQVcsQ0FBQyxFQUFFLENBQUM7SUFDekIsSUFBSSxLQUFLLEVBQUUsY0FBYyxDQUFDLEVBQUUsQ0FBQztJQUM3QixHQUFHLENBQUM7QUFDSjtJQUNBLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO0lBQ3JCLElBQUksU0FBUyxDQUFDLFVBQVUsR0FBRyxFQUFFLE1BQU0sRUFBRSxDQUFDO0lBQ3RDLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxTQUFTLENBQUMsS0FBSyxLQUFLLEVBQUUsRUFBRTtJQUM5RCxJQUFJLFNBQVMsQ0FBQyxLQUFLLEdBQUcsNEJBQTRCLENBQUM7SUFDbkQsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0FBQ0Q7SUFDQSxTQUFTLG9CQUFvQjtJQUM3QixFQUFFLFdBQVc7SUFDYixFQUFFLFNBQVM7SUFDWCxFQUFFLGtCQUFrQjtJQUNwQixFQUFFLG9CQUFvQjtJQUN0QixFQUFFO0lBQ0YsRUFBRSxNQUFNLE1BQU0sR0FBRyxTQUFTLEVBQUUsQ0FBQztJQUM3QixFQUFFLE1BQU0sY0FBYyxHQUFHLE1BQU0sRUFBRSxVQUFVLEVBQUUsQ0FBQyxjQUFjLENBQUM7QUFDN0Q7SUFDQTtJQUNBLEVBQUUsTUFBTSxhQUFhLEdBQUcsMEJBQTBCLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDOUQ7SUFDQSxFQUFFLE1BQU0sS0FBSyxHQUFHO0lBQ2hCLElBQUksY0FBYyxFQUFFLGVBQWUsQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDO0lBQzlELEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxJQUFJLGFBQWEsRUFBRTtJQUNyQixJQUFJLE9BQU87SUFDWCxNQUFNLFNBQVMsRUFBRTtJQUNqQixRQUFRLE1BQU0sRUFBRSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNoRSxPQUFPO0lBQ1AsTUFBTSxLQUFLO0lBQ1gsS0FBSyxDQUFDO0lBQ04sR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLEtBQUssR0FBRztJQUNoQixJQUFJLFNBQVMsRUFBRTtJQUNmLE1BQU0sTUFBTSxFQUFFO0lBQ2QsUUFBUTtJQUNSLFVBQVUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxPQUFPO0lBQ3ZILFVBQVUsS0FBSyxFQUFFLCtCQUErQixDQUFDLFNBQVMsRUFBRSxFQUFFLG9CQUFvQixFQUFFLENBQUM7SUFDckYsU0FBUztJQUNULE9BQU87SUFDUCxLQUFLO0lBQ0wsSUFBSSxLQUFLO0lBQ1QsR0FBRyxFQUFFO0FBQ0w7SUFDQSxFQUFFLElBQUksa0JBQWtCLEVBQUU7SUFDMUIsSUFBSSxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUNyRSxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtJQUN2QjtJQUNBO0lBQ0EsTUFBTSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxNQUFNLEVBQUUsQ0FBQztJQUN4RCxLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDRDtJQUNBLFNBQVMsY0FBYyxDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUU7SUFDekMsRUFBRSxPQUFPO0lBQ1QsSUFBSSxTQUFTLEVBQUU7SUFDZixNQUFNLE1BQU0sRUFBRSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNuRCxLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQjtJQUN6QixFQUFFLFdBQVc7SUFDYixFQUFFLEVBQUU7SUFDSixFQUFFO0lBQ0Y7SUFDQTtJQUNBO0lBQ0EsRUFBRSxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO0FBQ3JEO0lBQ0EsRUFBRSxNQUFNLFNBQVMsR0FBRyw0QkFBNEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNyRCxFQUFFLE1BQU0sV0FBVyxHQUFHLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9DO0lBQ0EsRUFBRSxJQUFJO0lBQ04sSUFBSSxPQUFPLFdBQVcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzNELEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUNkO0lBQ0EsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7QUFDRDtJQUNBO0lBQ0EsTUFBTSxtQkFBbUIsR0FBRyw2QkFBNkIsQ0FBQztBQUMxRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLDRCQUE0QixDQUFDLEVBQUUsRUFBRTtJQUMxQyxFQUFFLElBQUksRUFBRSxJQUFJLG1CQUFtQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDbEQsSUFBSSxPQUFPLENBQUMsQ0FBQztJQUNiLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUU7SUFDbEMsRUFBRSxJQUFJLE9BQU8sRUFBRSxDQUFDLFdBQVcsS0FBSyxRQUFRLEVBQUU7SUFDMUMsSUFBSSxPQUFPLEVBQUUsQ0FBQyxXQUFXLENBQUM7SUFDMUIsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNYLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQSxTQUFTLHNCQUFzQixDQUFDLFNBQVMsRUFBRTtJQUMzQztJQUNBO0lBQ0EsRUFBRSxJQUFJLE9BQU8sV0FBVyxLQUFLLFdBQVcsSUFBSSxPQUFPLFdBQVcsQ0FBQyxTQUFTLEtBQUssV0FBVyxFQUFFO0lBQzFGO0lBQ0EsSUFBSSxPQUFPLFNBQVMsWUFBWSxXQUFXLENBQUMsU0FBUyxDQUFDO0lBQ3RELEdBQUcsTUFBTTtJQUNULElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztJQUNILENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFdBQVcsQ0FBQyxFQUFFLEVBQUU7SUFDekIsRUFBRSxNQUFNLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDO0FBQ3hCO0lBQ0E7SUFDQTtJQUNBLEVBQUUsSUFBSSxDQUFDLElBQUksSUFBSSxzQkFBc0IsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUMzQztJQUNBLElBQUksTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQztJQUMvRixJQUFJLE9BQU8sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyx1QkFBdUIsQ0FBQztJQUN0RSxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLEVBQUUsRUFBRTtJQUM1QixFQUFFLE1BQU0sT0FBTyxHQUFHLEVBQUUsRUFBRSxPQUFPLENBQUM7QUFDOUI7SUFDQSxFQUFFLElBQUksc0JBQXNCLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDbEM7SUFDQSxJQUFJLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQzdELE1BQU0sT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLEtBQUs7SUFDTCxJQUFJLE9BQU8sZ0JBQWdCLENBQUM7SUFDNUIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFO0lBQ2hCLElBQUksT0FBTyxrQkFBa0IsQ0FBQztJQUM5QixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtJQUNsRSxJQUFJLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7SUFDakMsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsa0JBQWtCO0lBQzNCLEVBQUUsV0FBVztJQUNiLEVBQUUsU0FBUztJQUNYLEVBQUUsSUFBSTtJQUNOLEVBQUUsZ0JBQWdCO0lBQ2xCLEVBQUU7SUFDRixFQUFFLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxFQUFFLGtCQUFrQixJQUFJLFNBQVMsQ0FBQztJQUNuRSxFQUFFLE1BQU0sS0FBSyxHQUFHLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUNwRyxFQUFFLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9CLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUM7SUFDeEIsRUFBRSxJQUFJLElBQUksRUFBRSxRQUFRLEVBQUU7SUFDdEIsSUFBSSxLQUFLLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDbkMsR0FBRztJQUNILEVBQUUsT0FBTyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZ0JBQWdCO0lBQ3pCLEVBQUUsV0FBVztJQUNiLEVBQUUsT0FBTztJQUNULEVBQUUsS0FBSyxHQUFHLE1BQU07SUFDaEIsRUFBRSxJQUFJO0lBQ04sRUFBRSxnQkFBZ0I7SUFDbEIsRUFBRTtJQUNGLEVBQUUsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLEVBQUUsa0JBQWtCLElBQUksU0FBUyxDQUFDO0lBQ25FLEVBQUUsTUFBTSxLQUFLLEdBQUcsZUFBZSxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUM1RixFQUFFLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3RCLEVBQUUsSUFBSSxJQUFJLEVBQUUsUUFBUSxFQUFFO0lBQ3RCLElBQUksS0FBSyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ25DLEdBQUc7SUFDSCxFQUFFLE9BQU8sbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxxQkFBcUI7SUFDOUIsRUFBRSxXQUFXO0lBQ2IsRUFBRSxTQUFTO0lBQ1gsRUFBRSxrQkFBa0I7SUFDcEIsRUFBRSxnQkFBZ0I7SUFDbEIsRUFBRSxvQkFBb0I7SUFDdEIsRUFBRTtJQUNGLEVBQUUsSUFBSSxLQUFLLENBQUM7QUFDWjtJQUNBLEVBQUUsSUFBSUQsY0FBWSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssRUFBRTtJQUN0RDtJQUNBLElBQUksTUFBTSxVQUFVLEdBQUcsU0FBUyxFQUFFO0lBQ2xDLElBQUksT0FBTyxjQUFjLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUMxRCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsSUFBSSxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksY0FBYyxDQUFDLFNBQVMsRUFBRSxFQUFFO0lBQzNELElBQUksTUFBTSxZQUFZLEdBQUcsU0FBUyxFQUFFO0FBQ3BDO0lBQ0EsSUFBSSxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUUsRUFBRTtJQUNqQyxNQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsV0FBVyxFQUFFLFNBQVMsRUFBRSxDQUFDO0lBQ3RELEtBQUssTUFBTTtJQUNYLE1BQU0sTUFBTSxJQUFJLEdBQUcsWUFBWSxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsWUFBWSxDQUFDLEdBQUcsVUFBVSxHQUFHLGNBQWMsQ0FBQyxDQUFDO0lBQ2pHLE1BQU0sTUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQU8sR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDdkYsTUFBTSxLQUFLLEdBQUcsZUFBZSxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUMxRixNQUFNLHFCQUFxQixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QyxLQUFLO0lBQ0wsSUFBSSxJQUFJLE1BQU0sSUFBSSxZQUFZLEVBQUU7SUFDaEM7SUFDQSxNQUFNLEtBQUssQ0FBQyxJQUFJLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbEYsS0FBSztBQUNMO0lBQ0EsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0lBQ0gsRUFBRSxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUMxQjtJQUNBLElBQUksT0FBTyxjQUFjLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ2xELEdBQUc7SUFDSCxFQUFFLElBQUksYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUN0RDtJQUNBO0lBQ0E7SUFDQSxJQUFJLE1BQU0sZUFBZSxHQUFHLFNBQVMsRUFBRTtJQUN2QyxJQUFJLEtBQUssR0FBRyxvQkFBb0IsQ0FBQyxXQUFXLEVBQUUsZUFBZSxFQUFFLGtCQUFrQixFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDekcsSUFBSSxxQkFBcUIsQ0FBQyxLQUFLLEVBQUU7SUFDakMsTUFBTSxTQUFTLEVBQUUsSUFBSTtJQUNyQixLQUFLLENBQUMsQ0FBQztJQUNQLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsRUFBRSxLQUFLLEdBQUcsZUFBZSxDQUFDLFdBQVcsRUFBRSxTQUFTLEdBQUcsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUN6RixFQUFFLHFCQUFxQixDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMxRCxFQUFFLHFCQUFxQixDQUFDLEtBQUssRUFBRTtJQUMvQixJQUFJLFNBQVMsRUFBRSxJQUFJO0lBQ25CLEdBQUcsQ0FBQyxDQUFDO0FBQ0w7SUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0EsU0FBUyxlQUFlO0lBQ3hCLEVBQUUsV0FBVztJQUNiLEVBQUUsT0FBTztJQUNULEVBQUUsa0JBQWtCO0lBQ3BCLEVBQUUsZ0JBQWdCO0lBQ2xCLEVBQUU7SUFDRixFQUFFLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNuQjtJQUNBLEVBQUUsSUFBSSxnQkFBZ0IsSUFBSSxrQkFBa0IsRUFBRTtJQUM5QyxJQUFJLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3JFLElBQUksSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO0lBQ3ZCLE1BQU0sS0FBSyxDQUFDLFNBQVMsR0FBRztJQUN4QixRQUFRLE1BQU0sRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDO0lBQzVELE9BQU8sQ0FBQztJQUNSLEtBQUs7SUFDTCxJQUFJLHFCQUFxQixDQUFDLEtBQUssRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUN0QyxJQUFJLE1BQU0sRUFBRSwwQkFBMEIsRUFBRSwwQkFBMEIsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUMvRTtJQUNBLElBQUksS0FBSyxDQUFDLFFBQVEsR0FBRztJQUNyQixNQUFNLE9BQU8sRUFBRSwwQkFBMEI7SUFDekMsTUFBTSxNQUFNLEVBQUUsMEJBQTBCO0lBQ3hDLEtBQUssQ0FBQztJQUNOLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztBQUNIO0lBQ0EsRUFBRSxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUMxQixFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0EsU0FBUywrQkFBK0I7SUFDeEMsRUFBRSxTQUFTO0lBQ1gsRUFBRSxFQUFFLG9CQUFvQixFQUFFO0lBQzFCLEVBQUU7SUFDRixFQUFFLE1BQU0sSUFBSSxHQUFHLDhCQUE4QixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3pELEVBQUUsTUFBTSxXQUFXLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsV0FBVyxDQUFDO0FBQy9FO0lBQ0E7SUFDQTtJQUNBLEVBQUUsSUFBSUEsY0FBWSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0lBQy9CLElBQUksT0FBTyxDQUFDLGlDQUFpQyxFQUFFLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25HLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7SUFDMUIsSUFBSSxNQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ3hGLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxDQUFDLG1CQUFtQixFQUFFLFdBQVcsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0FBQ0Q7SUFDQSxTQUFTLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtJQUNqQyxFQUFFLElBQUk7SUFDTixJQUFJLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakQsSUFBSSxPQUFPLFNBQVMsR0FBRyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUM7SUFDOUQsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2Q7SUFDQSxHQUFHO0lBQ0gsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLDBCQUEwQixDQUFDLEdBQUcsRUFBRTtJQUN6QyxFQUFFLEtBQUssTUFBTSxJQUFJLElBQUksR0FBRyxFQUFFO0lBQzFCLElBQUksSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFO0lBQ3pELE1BQU0sTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLE1BQU0sSUFBSSxLQUFLLFlBQVksS0FBSyxFQUFFO0lBQ2xDLFFBQVEsT0FBTyxLQUFLLENBQUM7SUFDckIsT0FBTztJQUNQLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sU0FBUyxDQUFDO0lBQ25COztJQzlYQSxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQztBQUNwQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLGFBQWEsU0FBUyxNQUFNLENBQUM7QUFDbkM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFFO0lBQ3hCLElBQUksTUFBTSxJQUFJLEdBQUc7SUFDakI7SUFDQSxNQUFNLDBCQUEwQixFQUFFLElBQUk7SUFDdEMsTUFBTSxHQUFHLE9BQU87SUFDaEIsS0FBSyxDQUFDO0lBQ04sSUFBSSxNQUFNLFNBQVMsR0FBR0MsUUFBTSxDQUFDLGlCQUFpQixJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ2pFLElBQUksZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzlEO0lBQ0EsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEI7SUFDQTtJQUNBLElBQUksTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLElBQUksTUFBTSxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO0lBQzdELElBQUksTUFBTSxVQUFVLEdBQUcsWUFBWSxFQUFFLFVBQVUsQ0FBQztBQUNoRDtJQUNBLElBQUksSUFBSSxJQUFJLENBQUMsaUJBQWlCLElBQUlBLFFBQU0sQ0FBQyxRQUFRLEVBQUU7SUFDbkQsTUFBTUEsUUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRSxNQUFNO0lBQ2pFLFFBQVEsSUFBSUEsUUFBTSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEtBQUssUUFBUSxFQUFFO0lBQzFELFVBQVUsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ2hDLFVBQVUsSUFBSSxVQUFVLEVBQUU7SUFDMUIsWUFBWSx5QkFBeUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxXQUFXO0lBQ1gsU0FBUztJQUNULE9BQU8sQ0FBQyxDQUFDO0lBQ1QsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLFVBQVUsRUFBRTtJQUNwQixNQUFNLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLE1BQU07SUFDL0IsUUFBUSx5QkFBeUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMxQyxPQUFPLENBQUMsQ0FBQztBQUNUO0lBQ0EsTUFBTSxNQUFNLENBQUMsRUFBRSxDQUFDLGlCQUFpQixFQUFFLE1BQU07SUFDekMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRTtJQUN6QyxVQUFVLFlBQVksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUNwRCxTQUFTO0FBQ1Q7SUFDQSxRQUFRLE1BQU0sQ0FBQyxvQkFBb0IsR0FBRyxVQUFVLENBQUMsTUFBTTtJQUN2RCxVQUFVLHlCQUF5QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzVDLFNBQVMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO0lBQ25DLE9BQU8sQ0FBQyxDQUFDO0lBQ1QsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLGNBQWMsRUFBRTtJQUN4QixNQUFNLE1BQU0sQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUM1RCxNQUFNLE1BQU0sQ0FBQyxFQUFFLENBQUMsbUJBQW1CLEVBQUUseUJBQXlCLENBQUMsQ0FBQztJQUNoRSxLQUFLO0lBQ0wsR0FBRztBQUNIO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsR0FBRyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFO0lBQ3ZDLElBQUksT0FBTyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUMxRyxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLGdCQUFnQjtJQUNuQixJQUFJLE9BQU87SUFDWCxJQUFJLEtBQUssR0FBRyxNQUFNO0lBQ2xCLElBQUksSUFBSTtJQUNSLElBQUk7SUFDSixJQUFJLE9BQU8sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdHLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEdBQUcsYUFBYTtJQUNoQixJQUFJLEtBQUs7SUFDVCxJQUFJLElBQUk7SUFDUixJQUFJLFlBQVk7SUFDaEIsSUFBSSxjQUFjO0lBQ2xCLElBQUk7SUFDSixJQUFJLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsSUFBSSxZQUFZLENBQUM7QUFDcEQ7SUFDQSxJQUFJLE9BQU8sS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQztJQUMxRSxHQUFHO0lBQ0g7O0lDeEdBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNRixhQUFXLElBQUksT0FBTyxnQkFBZ0IsS0FBSyxXQUFXLElBQUksZ0JBQWdCLENBQUM7O0lDSGpGLE1BQU0sTUFBTSxHQUFHLFVBQVU7QUFDekI7SUFDQTs7SUNEQSxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQztBQUMvQjtJQUNBLElBQUksZUFBZSxDQUFDO0lBQ3BCLElBQUkscUJBQXFCLENBQUM7SUFDMUIsSUFBSSx5QkFBeUIsQ0FBQztBQUM5QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsc0NBQXNDLENBQUMsT0FBTyxFQUFFO0lBQ3pELEVBQUUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QixFQUFFLGVBQWUsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDdkMsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGFBQWEsR0FBRztJQUN6QixFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO0lBQ3hCLElBQUksT0FBTztJQUNYLEdBQUc7QUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsTUFBTSxpQkFBaUIsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM5RCxFQUFFLE1BQU0scUJBQXFCLEdBQUcsbUJBQW1CLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDN0UsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxRSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLHFCQUFxQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzdFO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLEVBQUUsQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxLQUFLO0lBQzlDLElBQUksTUFBTSxZQUFZLEdBQUcsTUFBTSxFQUFFO0lBQ2pDLElBQUksTUFBTSxLQUFLLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFNBQVMsQ0FBQztBQUNsRDtJQUNBO0lBQ0EsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxFQUFFO0lBQ3RELE1BQU0sT0FBTztJQUNiLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxrQkFBa0IsRUFBRSxVQUFVLHdCQUF3QixFQUFFO0lBQ3hFLE1BQU0sT0FBTyxXQUFXLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFO0lBQ2pELFFBQVEsSUFBSSxJQUFJLEtBQUssT0FBTyxJQUFJLElBQUksSUFBSSxVQUFVLEVBQUU7SUFDcEQsVUFBVSxJQUFJO0lBQ2QsWUFBWSxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQUMsbUNBQW1DO0lBQ3RFLGNBQWMsSUFBSSxDQUFDLG1DQUFtQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzlELFlBQVksTUFBTSxjQUFjLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3hGO0lBQ0EsWUFBWSxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRTtJQUN6QyxjQUFjLE1BQU0sT0FBTyxHQUFHLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDckUsY0FBYyxjQUFjLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUMvQyxjQUFjLHdCQUF3QixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMxRSxhQUFhO0FBQ2I7SUFDQSxZQUFZLGNBQWMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN0QyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDdEI7SUFDQTtJQUNBLFdBQVc7SUFDWCxTQUFTO0FBQ1Q7SUFDQSxRQUFRLE9BQU8sd0JBQXdCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVFLE9BQU8sQ0FBQztJQUNSLEtBQUssQ0FBQyxDQUFDO0FBQ1A7SUFDQSxJQUFJLElBQUk7SUFDUixNQUFNLEtBQUs7SUFDWCxNQUFNLHFCQUFxQjtJQUMzQixNQUFNLFVBQVUsMkJBQTJCLEVBQUU7SUFDN0MsUUFBUSxPQUFPLFdBQVcsSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUU7SUFDbkQsVUFBVSxJQUFJLElBQUksS0FBSyxPQUFPLElBQUksSUFBSSxJQUFJLFVBQVUsRUFBRTtJQUN0RCxZQUFZLElBQUk7SUFDaEIsY0FBYyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsbUNBQW1DLElBQUksRUFBRSxDQUFDO0lBQzlFLGNBQWMsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BEO0lBQ0EsY0FBYyxJQUFJLGNBQWMsRUFBRTtJQUNsQyxnQkFBZ0IsY0FBYyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzFDO0lBQ0EsZ0JBQWdCLElBQUksY0FBYyxDQUFDLFFBQVEsSUFBSSxDQUFDLEVBQUU7SUFDbEQsa0JBQWtCLDJCQUEyQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDaEcsa0JBQWtCLGNBQWMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0lBQ3JELGtCQUFrQixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QyxpQkFBaUI7QUFDakI7SUFDQTtJQUNBLGdCQUFnQixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtJQUN4RCxrQkFBa0IsT0FBTyxJQUFJLENBQUMsbUNBQW1DLENBQUM7SUFDbEUsaUJBQWlCO0lBQ2pCLGVBQWU7SUFDZixhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDeEI7SUFDQTtJQUNBLGFBQWE7SUFDYixXQUFXO0FBQ1g7SUFDQSxVQUFVLE9BQU8sMkJBQTJCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2pGLFNBQVMsQ0FBQztJQUNWLE9BQU87SUFDUCxLQUFLLENBQUM7SUFDTixHQUFHLENBQUMsQ0FBQztJQUNMLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsNEJBQTRCLENBQUMsS0FBSyxFQUFFO0lBQzdDO0lBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUsscUJBQXFCLEVBQUU7SUFDNUMsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUk7SUFDTjtJQUNBO0lBQ0EsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxLQUFLLHlCQUF5QixFQUFFO0lBQ2xGLE1BQU0sT0FBTyxLQUFLLENBQUM7SUFDbkIsS0FBSztJQUNMLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUNkO0lBQ0E7SUFDQSxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUU7SUFDL0M7SUFDQSxFQUFFLElBQUksU0FBUyxLQUFLLFVBQVUsRUFBRTtJQUNoQyxJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7SUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0EsRUFBRSxJQUFJLE1BQU0sQ0FBQyxPQUFPLEtBQUssT0FBTyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEtBQUssVUFBVSxJQUFJLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTtJQUMvRixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLG1CQUFtQjtJQUM1QixFQUFFLE9BQU87SUFDVCxFQUFFLGNBQWMsR0FBRyxLQUFLO0lBQ3hCLEVBQUU7SUFDRixFQUFFLE9BQU8sQ0FBQyxLQUFLLEtBQUs7SUFDcEI7SUFDQTtJQUNBO0lBQ0EsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0lBQzVDLE1BQU0sT0FBTztJQUNiLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pDO0lBQ0E7SUFDQSxJQUFJLElBQUksa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRTtJQUNoRCxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksd0JBQXdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzdEO0lBQ0EsSUFBSSxJQUFJLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUU7SUFDckM7SUFDQSxNQUFNLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUM3RCxLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLEtBQUssVUFBVSxHQUFHLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQ2xFO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSSxJQUFJLENBQUMsNEJBQTRCLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDOUMsTUFBTSxNQUFNLFdBQVcsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxDQUFDO0lBQ2xFLE1BQU0sT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNCLE1BQU0scUJBQXFCLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztJQUN6QyxNQUFNLHlCQUF5QixHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztJQUN4RSxLQUFLO0FBQ0w7SUFDQTtJQUNBLElBQUksWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ2xDLElBQUksZUFBZSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTTtJQUM5QyxNQUFNLHlCQUF5QixHQUFHLFNBQVMsQ0FBQztJQUM1QyxNQUFNLHFCQUFxQixHQUFHLFNBQVMsQ0FBQztJQUN4QyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUMxQixHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7SUFDL0IsRUFBRSxJQUFJO0lBQ04sSUFBSSxPQUFPLEtBQUssQ0FBQyxNQUFNLEVBQUU7SUFDekIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2Q7SUFDQTtJQUNBLElBQUksT0FBTyxJQUFJLENBQUM7SUFDaEIsR0FBRztJQUNIOztJQ3hOQSxJQUFJLFFBQVEsQ0FBQztBQUNiO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsZ0NBQWdDLENBQUMsT0FBTyxFQUFFO0lBQ25ELEVBQUUsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDO0lBQ3pCLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QixFQUFFLGVBQWUsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUMzQyxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7SUFDQSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsTUFBTTtJQUM1QyxJQUFJLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0lBQ3BDO0lBQ0EsSUFBSSxNQUFNLElBQUksR0FBRyxRQUFRLENBQUM7SUFDMUIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ2xCO0lBQ0EsSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFLEVBQUU7SUFDckIsTUFBTSxPQUFPO0lBQ2IsS0FBSztBQUNMO0lBQ0EsSUFBSSxNQUFNLFdBQVcsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRTtJQUN0QyxJQUFJLGVBQWUsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUMsR0FBRyxDQUFDLENBQUM7QUFDTDtJQUNBO0lBQ0EsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLEVBQUU7SUFDMUIsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0EsRUFBRSxTQUFTLDBCQUEwQixDQUFDLHVCQUF1QixFQUFFO0lBQy9ELElBQUksT0FBTyxXQUFXLEdBQUcsSUFBSSxFQUFFO0lBQy9CLE1BQU0sTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUN4RCxNQUFNLElBQUksR0FBRyxFQUFFO0lBQ2Y7SUFDQSxRQUFRLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQztJQUM5QixRQUFRLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMvQjtJQUNBLFFBQVEsUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUN0QjtJQUNBLFFBQVEsSUFBSSxJQUFJLEtBQUssRUFBRSxFQUFFO0lBQ3pCLFVBQVUsT0FBTyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzNELFNBQVM7QUFDVDtJQUNBLFFBQVEsTUFBTSxXQUFXLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUU7SUFDMUMsUUFBUSxlQUFlLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ2hELE9BQU87SUFDUCxNQUFNLE9BQU8sdUJBQXVCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN2RCxLQUFLLENBQUM7SUFDTixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0lBQ2hFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsY0FBYyxFQUFFLDBCQUEwQixDQUFDLENBQUM7SUFDbkU7O0lDL0RBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLE1BQU0scUJBQXFCLEdBQUcsRUFBRSxDQUFDO0FBQ2pDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyx1QkFBdUI7SUFDaEMsRUFBRSxJQUFJO0lBQ04sRUFBRTtJQUNGLEVBQUUsTUFBTSxNQUFNLEdBQUcscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0MsRUFBRSxJQUFJLE1BQU0sRUFBRTtJQUNkLElBQUksT0FBTyxNQUFNLENBQUM7SUFDbEIsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDM0I7SUFDQTtJQUNBLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUM5QixJQUFJLFFBQVEscUJBQXFCLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRztJQUM5RCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFDbkM7SUFDQSxFQUFFLElBQUksUUFBUSxJQUFJLE9BQU8sUUFBUSxDQUFDLGFBQWEsS0FBSyxVQUFVLEVBQUU7SUFDaEUsSUFBSSxJQUFJO0lBQ1IsTUFBTSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZELE1BQU0sT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7SUFDNUIsTUFBTSxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN6QyxNQUFNLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUM7SUFDbEQsTUFBTSxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsRUFBRTtJQUNqQyxRQUFRLElBQUksR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDcEMsT0FBTztJQUNQLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDekMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2hCO0lBQ0EsTUFBTUEsYUFBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxvQ0FBb0MsRUFBRSxJQUFJLENBQUMsMEJBQTBCLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RILEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQTtJQUNBO0lBQ0EsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ2IsSUFBSSxPQUFPLElBQUksQ0FBQztJQUNoQixHQUFHO0FBQ0g7SUFDQSxFQUFFLFFBQVEscUJBQXFCLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRztJQUM1RCxDQUFDO0FBQ0Q7SUFDQTtJQUNBLFNBQVMseUJBQXlCLENBQUMsSUFBSSxFQUFFO0lBQ3pDLEVBQUUscUJBQXFCLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDO0lBQzFDOztJQy9EQSxNQUFNLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDO0FBQ2hEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsNEJBQTRCLENBQUMsT0FBTyxFQUFFO0lBQy9DLEVBQUUsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QixFQUFFLGVBQWUsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDdkMsQ0FBQztBQUNEO0lBQ0E7SUFDQSxTQUFTLGFBQWEsR0FBRztJQUN6QixFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxjQUFjLEVBQUU7SUFDakMsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0EsRUFBRSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDO0FBQzVDO0lBQ0E7SUFDQSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtJQUMzQyxJQUFJLEtBQUs7SUFDVCxNQUFNLFlBQVk7SUFDbEIsTUFBTSxjQUFjO0lBQ3BCLE1BQU0sZUFBZTtBQUNyQjtJQUNBO0lBQ0EsTUFBTTtJQUNOO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLE1BQU0sWUFBWSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7QUFDdkM7SUFDQSxNQUFNLE1BQU0sY0FBYyxHQUFHLGtCQUFrQixFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ3pEO0lBQ0E7SUFDQTtJQUNBLE1BQU0sTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxTQUFTLENBQUM7SUFDakcsTUFBTSxNQUFNLEdBQUcsR0FBRyxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckQ7SUFDQSxNQUFNLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFDM0IsUUFBUSxPQUFPLFlBQVksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQ25FLE9BQU87QUFDUDtJQUNBLE1BQU0sY0FBYyxDQUFDLG1CQUFtQixDQUFDLEdBQUc7SUFDNUMsUUFBUSxNQUFNO0lBQ2QsUUFBUSxHQUFHO0lBQ1gsUUFBUSxlQUFlLEVBQUUsRUFBRTtJQUMzQixPQUFPLENBQUM7QUFDUjtJQUNBO0lBQ0EsTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRTtJQUN4RCxRQUFRLGNBQWMsQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUM7SUFDckQsT0FBTztBQUNQO0lBQ0EsTUFBTSxNQUFNLHlCQUF5QixHQUFHLE1BQU07SUFDOUM7SUFDQSxRQUFRLE1BQU0sT0FBTyxHQUFHLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQzVEO0lBQ0EsUUFBUSxJQUFJLENBQUMsT0FBTyxFQUFFO0lBQ3RCLFVBQVUsT0FBTztJQUNqQixTQUFTO0FBQ1Q7SUFDQSxRQUFRLElBQUksY0FBYyxDQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUU7SUFDN0MsVUFBVSxJQUFJO0lBQ2Q7SUFDQTtJQUNBLFlBQVksT0FBTyxDQUFDLFdBQVcsR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDO0lBQ3hELFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUN0QjtJQUNBLFdBQVc7QUFDWDtJQUNBLFVBQVUsTUFBTSxXQUFXLEdBQUc7SUFDOUIsWUFBWSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxJQUFJO0lBQ3JELFlBQVksY0FBYztJQUMxQixZQUFZLEdBQUcsRUFBRSxjQUFjO0lBQy9CLFlBQVksWUFBWTtJQUN4QixXQUFXLENBQUM7SUFDWixVQUFVLGVBQWUsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDOUMsU0FBUztJQUNULE9BQU8sQ0FBQztBQUNSO0lBQ0EsTUFBTSxJQUFJLG9CQUFvQixJQUFJLGNBQWMsSUFBSSxPQUFPLGNBQWMsQ0FBQyxrQkFBa0IsS0FBSyxVQUFVLEVBQUU7SUFDN0csUUFBUSxjQUFjLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLGtCQUFrQixFQUFFO0lBQ3pGLFVBQVUsS0FBSyxDQUFDLDBCQUEwQixFQUFFLHlCQUF5QixFQUFFLDBCQUEwQixFQUFFO0lBQ25HLFlBQVkseUJBQXlCLEVBQUUsQ0FBQztJQUN4QyxZQUFZLE9BQU8sMEJBQTBCLENBQUMsS0FBSyxDQUFDLHlCQUF5QixFQUFFLDBCQUEwQixDQUFDLENBQUM7SUFDM0csV0FBVztJQUNYLFNBQVMsQ0FBQyxDQUFDO0lBQ1gsT0FBTyxNQUFNO0lBQ2IsUUFBUSxjQUFjLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUseUJBQXlCLENBQUMsQ0FBQztJQUN2RixPQUFPO0FBQ1A7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLGNBQWMsQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLEVBQUU7SUFDbkYsUUFBUSxLQUFLO0lBQ2IsVUFBVSx3QkFBd0I7SUFDbEMsVUFBVSx1QkFBdUI7SUFDakMsVUFBVSx3QkFBd0I7SUFDbEMsVUFBVTtJQUNWLFVBQVUsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsR0FBRyx3QkFBd0IsQ0FBQztBQUMzRDtJQUNBLFVBQVUsTUFBTSxPQUFPLEdBQUcsdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUN2RTtJQUNBLFVBQVUsSUFBSSxPQUFPLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUM5RCxZQUFZLE9BQU8sQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ2xFLFdBQVc7QUFDWDtJQUNBLFVBQVUsT0FBTyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEVBQUUsd0JBQXdCLENBQUMsQ0FBQztJQUNuRyxTQUFTO0lBQ1QsT0FBTyxDQUFDLENBQUM7QUFDVDtJQUNBLE1BQU0sT0FBTyxZQUFZLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUNqRSxLQUFLO0lBQ0wsR0FBRyxDQUFDLENBQUM7QUFDTDtJQUNBO0lBQ0EsRUFBRSxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7SUFDM0MsSUFBSSxLQUFLLENBQUMsWUFBWSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUU7SUFDbkQsTUFBTSxNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUM3RDtJQUNBLE1BQU0sSUFBSSxDQUFDLGFBQWEsRUFBRTtJQUMxQixRQUFRLE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDN0QsT0FBTztBQUNQO0lBQ0EsTUFBTSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUU7SUFDekMsUUFBUSxhQUFhLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QyxPQUFPO0FBQ1A7SUFDQSxNQUFNLE1BQU0sV0FBVyxHQUFHO0lBQzFCLFFBQVEsY0FBYyxFQUFFLGtCQUFrQixFQUFFLEdBQUcsSUFBSTtJQUNuRCxRQUFRLEdBQUcsRUFBRSxXQUFXO0lBQ3hCLE9BQU8sQ0FBQztJQUNSLE1BQU0sZUFBZSxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztBQUMxQztJQUNBLE1BQU0sT0FBTyxZQUFZLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUMzRCxLQUFLO0lBQ0wsR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGNBQWMsQ0FBQyxHQUFHLEVBQUU7SUFDN0IsRUFBRSxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUNyQixJQUFJLE9BQU8sR0FBRyxDQUFDO0lBQ2YsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJO0lBQ047SUFDQTtJQUNBLElBQUksT0FBTyxDQUFDLEdBQUcsR0FBRyxRQUFRLEVBQUUsQ0FBQztJQUM3QixHQUFHLENBQUMsTUFBTSxFQUFFO0FBQ1o7SUFDQSxFQUFFLE9BQU8sU0FBUyxDQUFDO0lBQ25COztJQzFLQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGtCQUFrQjtJQUMzQixFQUFFLE9BQU87SUFDVCxFQUFFLFdBQVcsR0FBRyx1QkFBdUIsQ0FBQyxPQUFPLENBQUM7SUFDaEQsRUFBRTtJQUNGLEVBQUUsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLEVBQUUsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCO0lBQ0EsRUFBRSxTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUU7SUFDaEMsSUFBSSxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUM1QyxJQUFJLGVBQWUsSUFBSSxXQUFXLENBQUM7SUFDbkMsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUNuQjtJQUNBLElBQUksTUFBTSxjQUFjLEdBQUc7SUFDM0IsTUFBTSxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7SUFDeEIsTUFBTSxNQUFNLEVBQUUsTUFBTTtJQUNwQixNQUFNLGNBQWMsRUFBRSxlQUFlO0lBQ3JDLE1BQU0sT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLFNBQVMsRUFBRSxlQUFlLElBQUksS0FBSyxJQUFJLFlBQVksR0FBRyxFQUFFO0lBQzlELE1BQU0sR0FBRyxPQUFPLENBQUMsWUFBWTtJQUM3QixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtJQUN0QixNQUFNLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sT0FBTyxtQkFBbUIsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0lBQ3RFLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSTtJQUNSO0lBQ0EsTUFBTSxPQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUk7SUFDdkUsUUFBUSxlQUFlLElBQUksV0FBVyxDQUFDO0lBQ3ZDLFFBQVEsWUFBWSxFQUFFLENBQUM7SUFDdkIsUUFBUSxPQUFPO0lBQ2YsVUFBVSxVQUFVLEVBQUUsUUFBUSxDQUFDLE1BQU07SUFDckMsVUFBVSxPQUFPLEVBQUU7SUFDbkIsWUFBWSxzQkFBc0IsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQztJQUNoRixZQUFZLGFBQWEsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7SUFDOUQsV0FBVztJQUNYLFNBQVMsQ0FBQztJQUNWLE9BQU8sQ0FBQyxDQUFDO0lBQ1QsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2hCLE1BQU0seUJBQXlCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDekMsTUFBTSxlQUFlLElBQUksV0FBVyxDQUFDO0lBQ3JDLE1BQU0sWUFBWSxFQUFFLENBQUM7SUFDckIsTUFBTSxPQUFPLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLEtBQUs7SUFDTCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sZUFBZSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMvQzs7SUN0REEsTUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDO0lBRTNCLE1BQU0sY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUMxQjtJQUNBLFNBQVMsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUNwRCxFQUFFLE1BQU0sS0FBSyxHQUFHO0lBQ2hCLElBQUksUUFBUTtJQUNaLElBQUksUUFBUSxFQUFFLElBQUksS0FBSyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsSUFBSTtJQUM5RCxJQUFJLE1BQU0sRUFBRSxJQUFJO0lBQ2hCLEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7SUFDNUIsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUMxQixHQUFHO0FBQ0g7SUFDQSxFQUFFLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtJQUMzQixJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLG1CQUFtQixHQUFHLHdDQUF3QyxDQUFDO0FBQ3JFO0lBQ0E7SUFDQSxNQUFNLFdBQVc7SUFDakIsRUFBRSw0SUFBNEksQ0FBQztBQUMvSTtJQUNBLE1BQU0sZUFBZSxHQUFHLCtCQUErQixDQUFDO0FBQ3hEO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLElBQUk7SUFDcEM7SUFDQSxFQUFFLE1BQU0sU0FBUyxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNwRDtJQUNBLEVBQUUsSUFBSSxTQUFTLEVBQUU7SUFDakIsSUFBSSxNQUFNLEdBQUcsUUFBUSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDOUMsSUFBSSxPQUFPLFdBQVcsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoRSxHQUFHO0FBQ0g7SUFDQSxFQUFFLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDeEM7SUFDQSxFQUFFLElBQUksS0FBSyxFQUFFO0lBQ2IsSUFBSSxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUQ7SUFDQSxJQUFJLElBQUksTUFBTSxFQUFFO0lBQ2hCLE1BQU0sTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUN2RDtJQUNBLE1BQU0sSUFBSSxRQUFRLEVBQUU7SUFDcEI7SUFDQSxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0IsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9CLFFBQVEsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQixPQUFPO0lBQ1AsS0FBSztBQUNMO0lBQ0E7SUFDQTtJQUNBLElBQUksTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsR0FBRyw2QkFBNkIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkc7SUFDQSxJQUFJLE9BQU8sV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7SUFDM0csR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPO0lBQ1QsQ0FBQyxDQUFDO0FBQ0Y7SUFDQSxNQUFNLHFCQUFxQixHQUFHLENBQUMsZUFBZSxFQUFFLG1CQUFtQixDQUFDLENBQUM7QUFDckU7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLFVBQVU7SUFDaEIsRUFBRSxzSUFBc0ksQ0FBQztJQUN6SSxNQUFNLGNBQWMsR0FBRywrQ0FBK0MsQ0FBQztBQUN2RTtJQUNBLE1BQU0sS0FBSyxHQUFHLElBQUksSUFBSTtJQUN0QixFQUFFLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDdkM7SUFDQSxFQUFFLElBQUksS0FBSyxFQUFFO0lBQ2IsSUFBSSxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNoRSxJQUFJLElBQUksTUFBTSxFQUFFO0lBQ2hCLE1BQU0sTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUN0RDtJQUNBLE1BQU0sSUFBSSxRQUFRLEVBQUU7SUFDcEI7SUFDQSxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO0lBQ3RDLFFBQVEsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQixRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0IsUUFBUSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3RCLE9BQU87SUFDUCxLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QixJQUFJLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQztJQUM1QyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxHQUFHLDZCQUE2QixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNyRTtJQUNBLElBQUksT0FBTyxXQUFXLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztJQUMzRyxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU87SUFDVCxDQUFDLENBQUM7QUFDRjtJQUNBLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFnQ3JEO0lBQ0EsTUFBTSx1QkFBdUIsR0FBRyxDQUFDLHFCQUFxQixFQUFFLG9CQUFvQixDQUFDLENBQUM7QUFDOUU7SUFDQSxNQUFNLGtCQUFrQixHQUFHLGlCQUFpQixDQUFDLEdBQUcsdUJBQXVCLENBQUMsQ0FBQztBQUN6RTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLDZCQUE2QixHQUFHLENBQUMsSUFBSSxFQUFFLFFBQVEsS0FBSztJQUMxRCxFQUFFLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLEVBQUUsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0U7SUFDQSxFQUFFLE9BQU8saUJBQWlCLElBQUksb0JBQW9CO0lBQ2xELE1BQU07SUFDTixRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxnQkFBZ0I7SUFDM0UsUUFBUSxpQkFBaUIsR0FBRyxDQUFDLGlCQUFpQixFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUMvRixPQUFPO0lBQ1AsTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDOztJQ3pMRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSxXQUFXLElBQUksT0FBTyxnQkFBZ0IsS0FBSyxXQUFXLElBQUksZ0JBQWdCLENBQUM7O0lDQWpGO0FBQ0E7QUFDQTtJQUNBO0lBQ0EsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUM7QUFDdkM7SUFDQSxNQUFNSSxrQkFBZ0IsR0FBRyxhQUFhLENBQUM7QUFDdkM7SUFDQSxNQUFNLHVCQUF1QixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsS0FBSztJQUNuRCxFQUFFLE1BQU0sUUFBUSxHQUFHO0lBQ25CLElBQUksT0FBTyxFQUFFLElBQUk7SUFDakIsSUFBSSxHQUFHLEVBQUUsSUFBSTtJQUNiLElBQUksS0FBSyxFQUFFLElBQUk7SUFDZixJQUFJLE9BQU8sRUFBRSxJQUFJO0lBQ2pCLElBQUksTUFBTSxFQUFFLElBQUk7SUFDaEIsSUFBSSxHQUFHLEVBQUUsSUFBSTtJQUNiLElBQUksR0FBRyxPQUFPO0lBQ2QsR0FBRyxDQUFDO0FBQ0o7SUFDQSxFQUFFLE9BQU87SUFDVCxJQUFJLElBQUksRUFBRUEsa0JBQWdCO0lBQzFCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtJQUNsQjtJQUNBLE1BQU0sSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFO0lBQzVCLFFBQVEsZ0NBQWdDLENBQUMsNEJBQTRCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUMvRSxPQUFPO0lBQ1AsTUFBTSxJQUFJLFFBQVEsQ0FBQyxHQUFHLEVBQUU7SUFDeEIsUUFBUSxzQ0FBc0MsQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0YsT0FBTztJQUNQLE1BQU0sSUFBSSxRQUFRLENBQUMsR0FBRyxFQUFFO0lBQ3hCLFFBQVEsNEJBQTRCLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUN2RSxPQUFPO0lBQ1AsTUFBTSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDMUIsUUFBUSw4QkFBOEIsQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzNFLE9BQU87SUFDUCxNQUFNLElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRTtJQUM1QixRQUFRLGdDQUFnQyxDQUFDLDRCQUE0QixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDL0UsT0FBTztJQUNQLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFO0lBQzNCLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSwyQkFBMkIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzFFLE9BQU87SUFDUCxLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLEVBQUU7QUFDSjtJQUNBLE1BQU0sc0JBQXNCLEdBQUcsaUJBQWlCLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUMxRTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsMkJBQTJCLENBQUMsTUFBTSxFQUFFO0lBQzdDLEVBQUUsT0FBTyxTQUFTLG1CQUFtQixDQUFDLEtBQUssRUFBRTtJQUM3QyxJQUFJLElBQUksU0FBUyxFQUFFLEtBQUssTUFBTSxFQUFFO0lBQ2hDLE1BQU0sT0FBTztJQUNiLEtBQUs7QUFDTDtJQUNBLElBQUksYUFBYTtJQUNqQixNQUFNO0lBQ04sUUFBUSxRQUFRLEVBQUUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLElBQUksS0FBSyxhQUFhLEdBQUcsYUFBYSxHQUFHLE9BQU8sQ0FBQyxDQUFDO0lBQ3BGLFFBQVEsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO0lBQ2hDLFFBQVEsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO0lBQzFCLFFBQVEsT0FBTyxFQUFFLG1CQUFtQixDQUFDLEtBQUssQ0FBQztJQUMzQyxPQUFPO0lBQ1AsTUFBTTtJQUNOLFFBQVEsS0FBSztJQUNiLE9BQU87SUFDUCxLQUFLLENBQUM7SUFDTixHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsd0JBQXdCO0lBQ2pDLEVBQUUsTUFBTTtJQUNSLEVBQUUsR0FBRztJQUNMLEVBQUU7SUFDRixFQUFFLE9BQU8sU0FBUyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUU7SUFDbkQsSUFBSSxJQUFJLFNBQVMsRUFBRSxLQUFLLE1BQU0sRUFBRTtJQUNoQyxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksTUFBTSxDQUFDO0lBQ2YsSUFBSSxJQUFJLGFBQWEsQ0FBQztJQUN0QixJQUFJLElBQUksUUFBUSxHQUFHLE9BQU8sR0FBRyxLQUFLLFFBQVEsR0FBRyxHQUFHLENBQUMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDO0FBQ2hGO0lBQ0EsSUFBSSxJQUFJLGVBQWU7SUFDdkIsTUFBTSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksT0FBTyxHQUFHLENBQUMsZUFBZSxLQUFLLFFBQVEsR0FBRyxHQUFHLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQztJQUMzRyxJQUFJLElBQUksZUFBZSxJQUFJLGVBQWUsR0FBRyx5QkFBeUIsRUFBRTtJQUN4RSxNQUFNLFdBQVc7SUFDakIsUUFBUSxNQUFNLENBQUMsSUFBSTtJQUNuQixVQUFVLENBQUMsc0NBQXNDLEVBQUUseUJBQXlCLENBQUMsaUJBQWlCLEVBQUUsZUFBZSxDQUFDLGlDQUFpQyxFQUFFLHlCQUF5QixDQUFDLFNBQVMsQ0FBQztJQUN2TCxTQUFTLENBQUM7SUFDVixNQUFNLGVBQWUsR0FBRyx5QkFBeUIsQ0FBQztJQUNsRCxLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFO0lBQ3RDLE1BQU0sUUFBUSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDNUIsS0FBSztBQUNMO0lBQ0E7SUFDQSxJQUFJLElBQUk7SUFDUixNQUFNLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLEVBQUU7SUFDdkMsTUFBTSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7QUFDN0Q7SUFDQSxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUN4RSxNQUFNLGFBQWEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoRCxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDaEIsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDO0lBQzNCLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtJQUM3QixNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sVUFBVSxHQUFHO0lBQ3ZCLE1BQU0sUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QyxNQUFNLE9BQU8sRUFBRSxNQUFNO0lBQ3JCLEtBQUssQ0FBQztBQUNOO0lBQ0EsSUFBSSxJQUFJLGFBQWEsRUFBRTtJQUN2QixNQUFNLFVBQVUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxtQkFBbUIsRUFBRSxhQUFhLEVBQUUsQ0FBQztJQUMvRCxLQUFLO0FBQ0w7SUFDQSxJQUFJLGFBQWEsQ0FBQyxVQUFVLEVBQUU7SUFDOUIsTUFBTSxLQUFLLEVBQUUsV0FBVyxDQUFDLEtBQUs7SUFDOUIsTUFBTSxJQUFJLEVBQUUsV0FBVyxDQUFDLElBQUk7SUFDNUIsTUFBTSxNQUFNLEVBQUUsV0FBVyxDQUFDLE1BQU07SUFDaEMsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLDRCQUE0QixDQUFDLE1BQU0sRUFBRTtJQUM5QyxFQUFFLE9BQU8sU0FBUyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUU7SUFDbEQsSUFBSSxJQUFJLFNBQVMsRUFBRSxLQUFLLE1BQU0sRUFBRTtJQUNoQyxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sVUFBVSxHQUFHO0lBQ3ZCLE1BQU0sUUFBUSxFQUFFLFNBQVM7SUFDekIsTUFBTSxJQUFJLEVBQUU7SUFDWixRQUFRLFNBQVMsRUFBRSxXQUFXLENBQUMsSUFBSTtJQUNuQyxRQUFRLE1BQU0sRUFBRSxTQUFTO0lBQ3pCLE9BQU87SUFDUCxNQUFNLEtBQUssRUFBRSx1QkFBdUIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBQ3ZELE1BQU0sT0FBTyxFQUFFLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQztJQUM5QyxLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksSUFBSSxXQUFXLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtJQUN4QyxNQUFNLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUU7SUFDekMsUUFBUSxVQUFVLENBQUMsT0FBTyxHQUFHLENBQUMsa0JBQWtCLEVBQUUsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQztJQUNqSCxRQUFRLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELE9BQU8sTUFBTTtJQUNiO0lBQ0EsUUFBUSxPQUFPO0lBQ2YsT0FBTztJQUNQLEtBQUs7QUFDTDtJQUNBLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRTtJQUM5QixNQUFNLEtBQUssRUFBRSxXQUFXLENBQUMsSUFBSTtJQUM3QixNQUFNLEtBQUssRUFBRSxXQUFXLENBQUMsS0FBSztJQUM5QixLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsd0JBQXdCLENBQUMsTUFBTSxFQUFFO0lBQzFDLEVBQUUsT0FBTyxTQUFTLGNBQWMsQ0FBQyxXQUFXLEVBQUU7SUFDOUMsSUFBSSxJQUFJLFNBQVMsRUFBRSxLQUFLLE1BQU0sRUFBRTtJQUNoQyxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLEdBQUcsV0FBVyxDQUFDO0FBQ3pEO0lBQ0EsSUFBSSxNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDL0Q7SUFDQTtJQUNBLElBQUksSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLGFBQWEsRUFBRTtJQUM1RCxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxhQUFhLENBQUM7QUFDN0Q7SUFDQSxJQUFJLE1BQU0sSUFBSSxHQUFHO0lBQ2pCLE1BQU0sTUFBTTtJQUNaLE1BQU0sR0FBRztJQUNULE1BQU0sV0FBVztJQUNqQixLQUFLLENBQUM7QUFDTjtJQUNBLElBQUksTUFBTSxJQUFJLEdBQUc7SUFDakIsTUFBTSxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUc7SUFDMUIsTUFBTSxLQUFLLEVBQUUsSUFBSTtJQUNqQixNQUFNLGNBQWM7SUFDcEIsTUFBTSxZQUFZO0lBQ2xCLEtBQUssQ0FBQztBQUNOO0lBQ0EsSUFBSSxNQUFNLFVBQVUsR0FBRztJQUN2QixNQUFNLFFBQVEsRUFBRSxLQUFLO0lBQ3JCLE1BQU0sSUFBSTtJQUNWLE1BQU0sSUFBSSxFQUFFLE1BQU07SUFDbEIsTUFBTSxLQUFLLEVBQUUsdUNBQXVDLENBQUMsV0FBVyxDQUFDO0lBQ2pFLEtBQUssQ0FBQztBQUNOO0lBQ0EsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN0RTtJQUNBLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNwQyxHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLDBCQUEwQixDQUFDLE1BQU0sRUFBRTtJQUM1QyxFQUFFLE9BQU8sU0FBUyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUU7SUFDaEQsSUFBSSxJQUFJLFNBQVMsRUFBRSxLQUFLLE1BQU0sRUFBRTtJQUNoQyxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLEdBQUcsV0FBVyxDQUFDO0FBQ3pEO0lBQ0E7SUFDQSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDdkIsTUFBTSxPQUFPO0lBQ2IsS0FBSztBQUNMO0lBQ0EsSUFBSSxJQUFJLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sS0FBSyxNQUFNLEVBQUU7SUFDbEc7SUFDQSxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLENBQUM7SUFDTCxNQUFNLE1BQU0sRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU07SUFDMUMsTUFBTSxHQUFHLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHO0lBQ3BDLEtBQUssRUFBRTtBQUNQO0lBQ0EsSUFBSSxJQUFJLFdBQVcsQ0FBQyxLQUFLLEVBQUU7SUFDM0IsTUFBTSxNQUFNLElBQUksR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO0lBQ3pDLE1BQU0sTUFBTSxJQUFJLEdBQUc7SUFDbkIsUUFBUSxJQUFJLEVBQUUsV0FBVyxDQUFDLEtBQUs7SUFDL0IsUUFBUSxLQUFLLEVBQUUsV0FBVyxDQUFDLElBQUk7SUFDL0IsUUFBUSxjQUFjO0lBQ3RCLFFBQVEsWUFBWTtJQUNwQixPQUFPLENBQUM7QUFDUjtJQUNBLE1BQU0sTUFBTSxVQUFVLEdBQUc7SUFDekIsUUFBUSxRQUFRLEVBQUUsT0FBTztJQUN6QixRQUFRLElBQUk7SUFDWixRQUFRLEtBQUssRUFBRSxPQUFPO0lBQ3RCLFFBQVEsSUFBSSxFQUFFLE1BQU07SUFDcEIsT0FBTyxFQUFFO0FBQ1Q7SUFDQSxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUNBQWlDLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ3hFO0lBQ0EsTUFBTSxhQUFhLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLEtBQUssTUFBTTtJQUNYLE1BQU0sTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRTtJQUM3QyxNQUFNLE1BQU0sSUFBSSxHQUFHO0lBQ25CLFFBQVEsR0FBRyxXQUFXLENBQUMsU0FBUztJQUNoQyxRQUFRLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTTtJQUNyQyxPQUFPLENBQUM7QUFDUjtJQUNBLE1BQU0sV0FBVyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQztJQUM5QyxNQUFNLFdBQVcsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUM7SUFDL0MsTUFBTSxRQUFRLEVBQUUsTUFBTSxDQUFDO0FBQ3ZCO0lBQ0EsTUFBTSxNQUFNLElBQUksR0FBRztJQUNuQixRQUFRLEtBQUssRUFBRSxXQUFXLENBQUMsSUFBSTtJQUMvQixRQUFRLFFBQVE7SUFDaEIsUUFBUSxjQUFjO0lBQ3RCLFFBQVEsWUFBWTtJQUNwQixPQUFPLENBQUM7QUFDUjtJQUNBLE1BQU0sTUFBTSxVQUFVLEdBQUc7SUFDekIsUUFBUSxRQUFRLEVBQUUsT0FBTztJQUN6QixRQUFRLElBQUk7SUFDWixRQUFRLElBQUksRUFBRSxNQUFNO0lBQ3BCLFFBQVEsS0FBSyxFQUFFLHVDQUF1QyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDeEUsT0FBTyxDQUFDO0FBQ1I7SUFDQSxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUNBQWlDLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ3hFO0lBQ0EsTUFBTSxhQUFhLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLEtBQUs7SUFDTCxHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLDRCQUE0QixDQUFDLE1BQU0sRUFBRTtJQUM5QyxFQUFFLE9BQU8sU0FBUyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUU7SUFDbEQsSUFBSSxJQUFJLFNBQVMsRUFBRSxLQUFLLE1BQU0sRUFBRTtJQUNoQyxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLElBQUksSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDaEMsSUFBSSxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsRUFBRSxDQUFDO0lBQzVCLElBQUksTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDRixRQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JELElBQUksSUFBSSxVQUFVLEdBQUcsSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDdkQsSUFBSSxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbEM7SUFDQTtJQUNBLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUU7SUFDM0IsTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDO0lBQzdCLEtBQUs7QUFDTDtJQUNBO0lBQ0E7SUFDQSxJQUFJLElBQUksU0FBUyxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksRUFBRTtJQUN0RixNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO0lBQzdCLEtBQUs7SUFDTCxJQUFJLElBQUksU0FBUyxDQUFDLFFBQVEsS0FBSyxVQUFVLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLElBQUksRUFBRTtJQUMxRixNQUFNLElBQUksR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDO0lBQ2pDLEtBQUs7QUFDTDtJQUNBLElBQUksYUFBYSxDQUFDO0lBQ2xCLE1BQU0sUUFBUSxFQUFFLFlBQVk7SUFDNUIsTUFBTSxJQUFJLEVBQUU7SUFDWixRQUFRLElBQUk7SUFDWixRQUFRLEVBQUU7SUFDVixPQUFPO0lBQ1AsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztJQUN0Qzs7SUMvVUEsTUFBTSxvQkFBb0IsR0FBRztJQUM3QixFQUFFLGFBQWE7SUFDZixFQUFFLFFBQVE7SUFDVixFQUFFLE1BQU07SUFDUixFQUFFLGtCQUFrQjtJQUNwQixFQUFFLGdCQUFnQjtJQUNsQixFQUFFLGtCQUFrQjtJQUNwQixFQUFFLG1CQUFtQjtJQUNyQixFQUFFLGlCQUFpQjtJQUNuQixFQUFFLGFBQWE7SUFDZixFQUFFLFlBQVk7SUFDZCxFQUFFLG9CQUFvQjtJQUN0QixFQUFFLGFBQWE7SUFDZixFQUFFLFlBQVk7SUFDZCxFQUFFLGdCQUFnQjtJQUNsQixFQUFFLGNBQWM7SUFDaEIsRUFBRSxpQkFBaUI7SUFDbkIsRUFBRSxhQUFhO0lBQ2YsRUFBRSxhQUFhO0lBQ2YsRUFBRSxjQUFjO0lBQ2hCLEVBQUUsb0JBQW9CO0lBQ3RCLEVBQUUsUUFBUTtJQUNWLEVBQUUsY0FBYztJQUNoQixFQUFFLFdBQVc7SUFDYixFQUFFLGNBQWM7SUFDaEIsRUFBRSxlQUFlO0lBQ2pCLEVBQUUsV0FBVztJQUNiLEVBQUUsaUJBQWlCO0lBQ25CLEVBQUUsUUFBUTtJQUNWLEVBQUUsZ0JBQWdCO0lBQ2xCLEVBQUUsMkJBQTJCO0lBQzdCLEVBQUUsc0JBQXNCO0lBQ3hCLENBQUMsQ0FBQztBQUNGO0lBQ0EsTUFBTUUsa0JBQWdCLEdBQUcsa0JBQWtCLENBQUM7QUFDNUM7SUFDQSxNQUFNLDRCQUE0QixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsS0FBSztJQUN4RCxFQUFFLE1BQU0sUUFBUSxHQUFHO0lBQ25CLElBQUksY0FBYyxFQUFFLElBQUk7SUFDeEIsSUFBSSxXQUFXLEVBQUUsSUFBSTtJQUNyQixJQUFJLHFCQUFxQixFQUFFLElBQUk7SUFDL0IsSUFBSSxXQUFXLEVBQUUsSUFBSTtJQUNyQixJQUFJLFVBQVUsRUFBRSxJQUFJO0lBQ3BCLElBQUksR0FBRyxPQUFPO0lBQ2QsR0FBRyxDQUFDO0FBQ0o7SUFDQSxFQUFFLE9BQU87SUFDVCxJQUFJLElBQUksRUFBRUEsa0JBQWdCO0lBQzFCO0lBQ0E7SUFDQSxJQUFJLFNBQVMsR0FBRztJQUNoQixNQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRTtJQUMvQixRQUFRLElBQUksQ0FBQ0YsUUFBTSxFQUFFLFlBQVksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RELE9BQU87QUFDUDtJQUNBLE1BQU0sSUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFO0lBQ2hDLFFBQVEsSUFBSSxDQUFDQSxRQUFNLEVBQUUsYUFBYSxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDdkQsT0FBTztBQUNQO0lBQ0EsTUFBTSxJQUFJLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRTtJQUMxQyxRQUFRLElBQUksQ0FBQ0EsUUFBTSxFQUFFLHVCQUF1QixFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hELE9BQU87QUFDUDtJQUNBLE1BQU0sSUFBSSxRQUFRLENBQUMsY0FBYyxJQUFJLGdCQUFnQixJQUFJQSxRQUFNLEVBQUU7SUFDakUsUUFBUSxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekQsT0FBTztBQUNQO0lBQ0EsTUFBTSxNQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7SUFDckQsTUFBTSxJQUFJLGlCQUFpQixFQUFFO0lBQzdCLFFBQVEsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixDQUFDO0lBQ3hHLFFBQVEsV0FBVyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzlDLE9BQU87SUFDUCxLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLEVBQUU7QUFDSjtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sMkJBQTJCLEdBQUcsaUJBQWlCLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUNwRjtJQUNBLFNBQVMsaUJBQWlCLENBQUMsUUFBUSxFQUFFO0lBQ3JDLEVBQUUsT0FBTyxXQUFXLEdBQUcsSUFBSSxFQUFFO0lBQzdCLElBQUksTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFO0lBQ3JDLE1BQU0sU0FBUyxFQUFFO0lBQ2pCLFFBQVEsSUFBSSxFQUFFLEVBQUUsUUFBUSxFQUFFLGVBQWUsQ0FBQyxRQUFRLENBQUMsRUFBRTtJQUNyRCxRQUFRLE9BQU8sRUFBRSxLQUFLO0lBQ3RCLFFBQVEsSUFBSSxFQUFFLFlBQVk7SUFDMUIsT0FBTztJQUNQLEtBQUssQ0FBQyxDQUFDO0lBQ1AsSUFBSSxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVMsUUFBUSxDQUFDLFFBQVEsRUFBRTtJQUM1QixFQUFFLE9BQU8sV0FBVyxRQUFRLEVBQUU7SUFDOUIsSUFBSSxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFO0lBQ2hDLE1BQU0sSUFBSSxDQUFDLFFBQVEsRUFBRTtJQUNyQixRQUFRLFNBQVMsRUFBRTtJQUNuQixVQUFVLElBQUksRUFBRTtJQUNoQixZQUFZLFFBQVEsRUFBRSx1QkFBdUI7SUFDN0MsWUFBWSxPQUFPLEVBQUUsZUFBZSxDQUFDLFFBQVEsQ0FBQztJQUM5QyxXQUFXO0lBQ1gsVUFBVSxPQUFPLEVBQUUsS0FBSztJQUN4QixVQUFVLElBQUksRUFBRSxZQUFZO0lBQzVCLFNBQVM7SUFDVCxPQUFPLENBQUM7SUFDUixLQUFLLENBQUMsQ0FBQztJQUNQLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVMsUUFBUSxDQUFDLFlBQVksRUFBRTtJQUNoQyxFQUFFLE9BQU8sV0FBVyxHQUFHLElBQUksRUFBRTtJQUM3QjtJQUNBLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDO0lBQ3JCLElBQUksTUFBTSxtQkFBbUIsR0FBRyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixDQUFDLENBQUM7QUFDMUY7SUFDQSxJQUFJLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUk7SUFDeEMsTUFBTSxJQUFJLElBQUksSUFBSSxHQUFHLElBQUksT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0lBQzFELFFBQVEsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsVUFBVSxRQUFRLEVBQUU7SUFDNUMsVUFBVSxNQUFNLFdBQVcsR0FBRztJQUM5QixZQUFZLFNBQVMsRUFBRTtJQUN2QixjQUFjLElBQUksRUFBRTtJQUNwQixnQkFBZ0IsUUFBUSxFQUFFLElBQUk7SUFDOUIsZ0JBQWdCLE9BQU8sRUFBRSxlQUFlLENBQUMsUUFBUSxDQUFDO0lBQ2xELGVBQWU7SUFDZixjQUFjLE9BQU8sRUFBRSxLQUFLO0lBQzVCLGNBQWMsSUFBSSxFQUFFLFlBQVk7SUFDaEMsYUFBYTtJQUNiLFdBQVcsQ0FBQztBQUNaO0lBQ0E7SUFDQSxVQUFVLE1BQU0sZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDakUsVUFBVSxJQUFJLGdCQUFnQixFQUFFO0lBQ2hDLFlBQVksV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ25GLFdBQVc7QUFDWDtJQUNBO0lBQ0EsVUFBVSxPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDN0MsU0FBUyxDQUFDLENBQUM7SUFDWCxPQUFPO0lBQ1AsS0FBSyxDQUFDLENBQUM7QUFDUDtJQUNBLElBQUksT0FBTyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMxQyxHQUFHLENBQUM7SUFDSixDQUFDO0FBQ0Q7SUFDQSxTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtJQUNsQyxFQUFFLE1BQU0sWUFBWSxHQUFHQSxRQUFNLEVBQUU7SUFDL0IsRUFBRSxNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsU0FBUyxDQUFDO0FBQ2hEO0lBQ0E7SUFDQSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsY0FBYyxHQUFHLGtCQUFrQixDQUFDLEVBQUU7SUFDcEQsSUFBSSxPQUFPO0lBQ1gsR0FBRztBQUNIO0lBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLGtCQUFrQixFQUFFLFVBQVUsUUFBUTtBQUNwRDtJQUNBLENBQUM7SUFDRCxJQUFJLE9BQU8sV0FBVyxTQUFTLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRTtJQUM5QyxNQUFNLElBQUk7SUFDVixRQUFRLElBQUkscUJBQXFCLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDdkM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsVUFBVSxFQUFFLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFO0lBQ2hELFlBQVksU0FBUyxFQUFFO0lBQ3ZCLGNBQWMsSUFBSSxFQUFFO0lBQ3BCLGdCQUFnQixRQUFRLEVBQUUsYUFBYTtJQUN2QyxnQkFBZ0IsT0FBTyxFQUFFLGVBQWUsQ0FBQyxFQUFFLENBQUM7SUFDNUMsZ0JBQWdCLE1BQU07SUFDdEIsZUFBZTtJQUNmLGNBQWMsT0FBTyxFQUFFLEtBQUs7SUFDNUIsY0FBYyxJQUFJLEVBQUUsWUFBWTtJQUNoQyxhQUFhO0lBQ2IsV0FBVyxDQUFDLENBQUM7SUFDYixTQUFTO0lBQ1QsT0FBTyxDQUFDLE1BQU07SUFDZDtJQUNBLE9BQU87QUFDUDtJQUNBLE1BQU0sT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRTtJQUNsQyxRQUFRLFNBQVM7SUFDakIsUUFBUSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ2pCLFVBQVUsU0FBUyxFQUFFO0lBQ3JCLFlBQVksSUFBSSxFQUFFO0lBQ2xCLGNBQWMsUUFBUSxFQUFFLGtCQUFrQjtJQUMxQyxjQUFjLE9BQU8sRUFBRSxlQUFlLENBQUMsRUFBRSxDQUFDO0lBQzFDLGNBQWMsTUFBTTtJQUNwQixhQUFhO0lBQ2IsWUFBWSxPQUFPLEVBQUUsS0FBSztJQUMxQixZQUFZLElBQUksRUFBRSxZQUFZO0lBQzlCLFdBQVc7SUFDWCxTQUFTLENBQUM7SUFDVixRQUFRLE9BQU87SUFDZixPQUFPLENBQUMsQ0FBQztJQUNULEtBQUssQ0FBQztJQUNOLEdBQUcsQ0FBQyxDQUFDO0FBQ0w7SUFDQSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUscUJBQXFCLEVBQUUsVUFBVSwyQkFBMkI7QUFDMUU7SUFDQSxDQUFDO0lBQ0QsSUFBSSxPQUFPLFdBQVcsU0FBUyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUU7SUFDOUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sSUFBSTtJQUNWLFFBQVEsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQztJQUM5RCxRQUFRLElBQUksb0JBQW9CLEVBQUU7SUFDbEMsVUFBVSwyQkFBMkIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxvQkFBb0IsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRixTQUFTO0lBQ1QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2xCO0lBQ0EsT0FBTztJQUNQLE1BQU0sT0FBTywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUUsS0FBSyxDQUFDO0lBQ04sR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtJQUNwQyxFQUFFLE9BQU8sT0FBTyxDQUFDLEdBQUcsR0FBRyxXQUFXLEtBQUssVUFBVSxDQUFDO0lBQ2xEOztJQzdPQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLHlCQUF5QixHQUFHLGlCQUFpQixDQUFDLE1BQU07SUFDMUQsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUUsZ0JBQWdCO0lBQzFCLElBQUksU0FBUyxHQUFHO0lBQ2hCLE1BQU0sSUFBSSxPQUFPQSxRQUFNLENBQUMsUUFBUSxLQUFLLFdBQVcsRUFBRTtJQUNsRCxRQUFRLFdBQVc7SUFDbkIsVUFBVSxNQUFNLENBQUMsSUFBSSxDQUFDLHFGQUFxRixDQUFDLENBQUM7SUFDN0csUUFBUSxPQUFPO0lBQ2YsT0FBTztBQUNQO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLFlBQVksQ0FBQyxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLE1BQU0sY0FBYyxFQUFFLENBQUM7QUFDdkI7SUFDQTtJQUNBLE1BQU0sZ0NBQWdDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsS0FBSztJQUN6RDtJQUNBLFFBQVEsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxFQUFFLEVBQUU7SUFDL0MsVUFBVSxZQUFZLENBQUMsRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNqRCxVQUFVLGNBQWMsRUFBRSxDQUFDO0lBQzNCLFNBQVM7SUFDVCxPQUFPLENBQUMsQ0FBQztJQUNULEtBQUs7SUFDTCxHQUFHLENBQUM7SUFDSixDQUFDLENBQUM7O0lDakNGLE1BQU1FLGtCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBQzFDO0lBQ0EsTUFBTSwwQkFBMEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEtBQUs7SUFDdEQsRUFBRSxNQUFNLFFBQVEsR0FBRztJQUNuQixJQUFJLE9BQU8sRUFBRSxJQUFJO0lBQ2pCLElBQUksb0JBQW9CLEVBQUUsSUFBSTtJQUM5QixJQUFJLEdBQUcsT0FBTztJQUNkLEdBQUcsQ0FBQztBQUNKO0lBQ0EsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUVBLGtCQUFnQjtJQUMxQixJQUFJLFNBQVMsR0FBRztJQUNoQixNQUFNLEtBQUssQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO0lBQ2pDLEtBQUs7SUFDTCxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7SUFDbEIsTUFBTSxJQUFJLFFBQVEsQ0FBQyxPQUFPLEVBQUU7SUFDNUIsUUFBUSw0QkFBNEIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QyxRQUFRLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BDLE9BQU87SUFDUCxNQUFNLElBQUksUUFBUSxDQUFDLG9CQUFvQixFQUFFO0lBQ3pDLFFBQVEseUNBQXlDLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUQsUUFBUSxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ2pELE9BQU87SUFDUCxLQUFLO0lBQ0wsR0FBRyxDQUFDO0lBQ0osQ0FBQyxDQUFDLEVBQUU7QUFDSjtJQUNBLE1BQU0seUJBQXlCLEdBQUcsaUJBQWlCLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUNoRjtJQUNBLFNBQVMsNEJBQTRCLENBQUMsTUFBTSxFQUFFO0lBQzlDLEVBQUUsb0NBQW9DLENBQUMsSUFBSSxJQUFJO0lBQy9DLElBQUksTUFBTSxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLFVBQVUsRUFBRSxDQUFDO0FBQzNEO0lBQ0EsSUFBSSxJQUFJLFNBQVMsRUFBRSxLQUFLLE1BQU0sSUFBSSxtQkFBbUIsRUFBRSxFQUFFO0lBQ3pELE1BQU0sT0FBTztJQUNiLEtBQUs7QUFDTDtJQUNBLElBQUksTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDbkQ7SUFDQSxJQUFJLE1BQU0sS0FBSyxHQUFHLDZCQUE2QjtJQUMvQyxNQUFNLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxLQUFLLElBQUksR0FBRyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLENBQUM7SUFDMUYsTUFBTSxHQUFHO0lBQ1QsTUFBTSxJQUFJO0lBQ1YsTUFBTSxNQUFNO0lBQ1osS0FBSyxDQUFDO0FBQ047SUFDQSxJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDO0FBQzFCO0lBQ0EsSUFBSSxZQUFZLENBQUMsS0FBSyxFQUFFO0lBQ3hCLE1BQU0saUJBQWlCLEVBQUUsS0FBSztJQUM5QixNQUFNLFNBQVMsRUFBRTtJQUNqQixRQUFRLE9BQU8sRUFBRSxLQUFLO0lBQ3RCLFFBQVEsSUFBSSxFQUFFLFNBQVM7SUFDdkIsT0FBTztJQUNQLEtBQUssQ0FBQyxDQUFDO0lBQ1AsR0FBRyxDQUFDLENBQUM7SUFDTCxDQUFDO0FBQ0Q7SUFDQSxTQUFTLHlDQUF5QyxDQUFDLE1BQU0sRUFBRTtJQUMzRCxFQUFFLGlEQUFpRCxDQUFDLENBQUMsSUFBSTtJQUN6RCxJQUFJLE1BQU0sRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxVQUFVLEVBQUUsQ0FBQztBQUMzRDtJQUNBLElBQUksSUFBSSxTQUFTLEVBQUUsS0FBSyxNQUFNLElBQUksbUJBQW1CLEVBQUUsRUFBRTtJQUN6RCxNQUFNLE9BQU87SUFDYixLQUFLO0FBQ0w7SUFDQSxJQUFJLE1BQU0sS0FBSyxHQUFHLDJCQUEyQixDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ2xEO0lBQ0EsSUFBSSxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBQ3BDLFFBQVEsZ0NBQWdDLENBQUMsS0FBSyxDQUFDO0lBQy9DLFFBQVEscUJBQXFCLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckY7SUFDQSxJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDO0FBQzFCO0lBQ0EsSUFBSSxZQUFZLENBQUMsS0FBSyxFQUFFO0lBQ3hCLE1BQU0saUJBQWlCLEVBQUUsS0FBSztJQUM5QixNQUFNLFNBQVMsRUFBRTtJQUNqQixRQUFRLE9BQU8sRUFBRSxLQUFLO0lBQ3RCLFFBQVEsSUFBSSxFQUFFLHNCQUFzQjtJQUNwQyxPQUFPO0lBQ1AsS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHLENBQUMsQ0FBQztJQUNMLENBQUM7QUFDRDtJQUNBLFNBQVMsMkJBQTJCLENBQUMsS0FBSyxFQUFFO0lBQzVDLEVBQUUsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDMUIsSUFBSSxPQUFPLEtBQUssQ0FBQztJQUNqQixHQUFHO0FBQ0g7SUFDQTtJQUNBLEVBQUUsSUFBSTtBQUNOO0lBQ0E7SUFDQTtJQUNBLElBQUksSUFBSSxRQUFRLEtBQUssS0FBSyxFQUFFLEVBQUU7SUFDOUIsTUFBTSxPQUFPLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztJQUM3QixLQUFLO0FBQ0w7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSSxJQUFJLFFBQVEsS0FBSyxLQUFLLEVBQUUsSUFBSSxRQUFRLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxFQUFFO0lBQzdELE1BQU0sT0FBTyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3BDLEtBQUs7SUFDTCxHQUFHLENBQUMsTUFBTSxFQUFFO0FBQ1o7SUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxnQ0FBZ0MsQ0FBQyxNQUFNLEVBQUU7SUFDbEQsRUFBRSxPQUFPO0lBQ1QsSUFBSSxTQUFTLEVBQUU7SUFDZixNQUFNLE1BQU0sRUFBRTtJQUNkLFFBQVE7SUFDUixVQUFVLElBQUksRUFBRSxvQkFBb0I7SUFDcEM7SUFDQSxVQUFVLEtBQUssRUFBRSxDQUFDLGlEQUFpRCxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3JGLFNBQVM7SUFDVCxPQUFPO0lBQ1AsS0FBSztJQUNMLEdBQUcsQ0FBQztJQUNKLENBQUM7QUFDRDtJQUNBLFNBQVMsNkJBQTZCO0lBQ3RDLEVBQUUsS0FBSztJQUNQLEVBQUUsR0FBRztJQUNMLEVBQUUsSUFBSTtJQUNOLEVBQUUsTUFBTTtJQUNSLEVBQUU7SUFDRjtJQUNBLEVBQUUsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3REO0lBQ0EsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUM7SUFDekM7SUFDQSxFQUFFLE1BQU0sR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDcEM7SUFDQSxFQUFFLE1BQU0sSUFBSSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN2RDtJQUNBLEVBQUUsTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ2xEO0lBQ0EsRUFBRSxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUM7SUFDdkIsRUFBRSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUM7SUFDdEIsRUFBRSxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLGVBQWUsRUFBRSxDQUFDO0FBQzdFO0lBQ0E7SUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDMUIsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDO0lBQ2YsTUFBTSxLQUFLO0lBQ1gsTUFBTSxRQUFRO0lBQ2QsTUFBTSxRQUFRLEVBQUUsZ0JBQWdCO0lBQ2hDLE1BQU0sTUFBTSxFQUFFLElBQUk7SUFDbEIsTUFBTSxNQUFNO0lBQ1osS0FBSyxDQUFDLENBQUM7SUFDUCxHQUFHO0FBQ0g7SUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNEO0lBQ0EsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7SUFDaEMsRUFBRSxXQUFXLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0FBQ0Q7SUFDQSxTQUFTLFVBQVUsR0FBRztJQUN0QixFQUFFLE1BQU0sTUFBTSxHQUFHLFNBQVMsRUFBRSxDQUFDO0lBQzdCLEVBQUUsTUFBTSxPQUFPLEdBQUcsTUFBTSxFQUFFLFVBQVUsRUFBRSxJQUFJO0lBQzFDLElBQUksV0FBVyxFQUFFLE1BQU0sRUFBRTtJQUN6QixJQUFJLGdCQUFnQixFQUFFLEtBQUs7SUFDM0IsR0FBRyxDQUFDO0lBQ0osRUFBRSxPQUFPLE9BQU8sQ0FBQztJQUNqQjs7SUNuTEE7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLHNCQUFzQixHQUFHLGlCQUFpQixDQUFDLE1BQU07SUFDdkQsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUUsYUFBYTtJQUN2QixJQUFJLGVBQWUsQ0FBQyxLQUFLLEVBQUU7SUFDM0I7SUFDQSxNQUFNLElBQUksQ0FBQ0YsUUFBTSxDQUFDLFNBQVMsSUFBSSxDQUFDQSxRQUFNLENBQUMsUUFBUSxJQUFJLENBQUNBLFFBQU0sQ0FBQyxRQUFRLEVBQUU7SUFDckUsUUFBUSxPQUFPO0lBQ2YsT0FBTztBQUNQO0lBQ0E7SUFDQSxNQUFNLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO0lBQzFELE1BQU0sTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHQSxRQUFNLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQztJQUNqRCxNQUFNLE1BQU0sRUFBRSxTQUFTLEVBQUUsR0FBR0EsUUFBTSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUM7QUFDbkQ7SUFDQSxNQUFNLE1BQU0sT0FBTyxHQUFHO0lBQ3RCLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLE9BQU87SUFDakMsUUFBUSxJQUFJLFFBQVEsSUFBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUM5QyxRQUFRLElBQUksU0FBUyxJQUFJLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxDQUFDO0lBQ3JELE9BQU8sQ0FBQztJQUNSLE1BQU0sTUFBTSxPQUFPLEdBQUc7SUFDdEIsUUFBUSxHQUFHLEtBQUssQ0FBQyxPQUFPO0lBQ3hCLFFBQVEsSUFBSSxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUMzQixRQUFRLE9BQU87SUFDZixPQUFPLENBQUM7QUFDUjtJQUNBLE1BQU0sS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDOUIsS0FBSztJQUNMLEdBQUcsQ0FBQztJQUNKLENBQUMsQ0FBQzs7SUNoQ0YsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDO0lBQzVCLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN4QjtJQUNBLE1BQU0sZ0JBQWdCLEdBQUcsY0FBYyxDQUFDO0FBQ3hDO0lBQ0EsTUFBTSx3QkFBd0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEtBQUs7SUFDcEQsRUFBRSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxJQUFJLGFBQWEsQ0FBQztJQUMvQyxFQUFFLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLElBQUksV0FBVyxDQUFDO0FBQ3pDO0lBQ0EsRUFBRSxPQUFPO0lBQ1QsSUFBSSxJQUFJLEVBQUUsZ0JBQWdCO0lBQzFCLElBQUksZUFBZSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFO0lBQ3pDLE1BQU0sTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQzFDO0lBQ0EsTUFBTSwyQkFBMkI7SUFDakM7SUFDQSxRQUFRLGtCQUFrQjtJQUMxQixRQUFRLE9BQU8sQ0FBQyxXQUFXO0lBQzNCLFFBQVEsR0FBRztJQUNYLFFBQVEsS0FBSztJQUNiLFFBQVEsS0FBSztJQUNiLFFBQVEsSUFBSTtJQUNaLE9BQU8sQ0FBQztJQUNSLEtBQUs7SUFDTCxHQUFHLENBQUM7SUFDSixDQUFDLENBQUMsRUFBRTtBQUNKO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsTUFBTSx1QkFBdUIsR0FBRyxpQkFBaUIsQ0FBQyx3QkFBd0IsQ0FBQzs7SUNwQjNFO0lBQ0EsU0FBUyxzQkFBc0IsQ0FBQyxRQUFRLEVBQUU7SUFDMUM7SUFDQTtJQUNBO0lBQ0E7SUFDQSxFQUFFLE9BQU87SUFDVDtJQUNBO0lBQ0EsSUFBSSx5QkFBeUIsRUFBRTtJQUMvQixJQUFJLDJCQUEyQixFQUFFO0lBQ2pDLElBQUksMkJBQTJCLEVBQUU7SUFDakMsSUFBSSxzQkFBc0IsRUFBRTtJQUM1QixJQUFJLHlCQUF5QixFQUFFO0lBQy9CLElBQUksdUJBQXVCLEVBQUU7SUFDN0IsSUFBSSxpQkFBaUIsRUFBRTtJQUN2QixJQUFJLHNCQUFzQixFQUFFO0lBQzVCLElBQUkseUJBQXlCLEVBQUU7SUFDL0IsR0FBRyxDQUFDO0lBQ0o7O0lDaENBLElBQU0sTUFBTSxHQUFHO0lBQ2IsSUFBQSxRQUFRLEVBQXNDLDRCQUE0QjtJQUMxRSxJQUFBLEdBQUcsRUFBeUIsaUNBQWlDO0tBQzlEOztJQ0dELElBQU0sbUJBQW1CLEdBQUcsVUFBVSxDQUFDO0FBRXZDLHdCQUFlLENBQUEsWUFBQSxFQUFBLE9BQUEsU0FBQSxDQUFBLEtBQUEsQ0FBQSxFQUFBLEtBQUEsQ0FBQSxFQUFBLEtBQUEsQ0FBQSxFQUFBLFlBQUE7Ozs7O0lBQ2IsZ0JBQUEsTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJO0lBQzdCLG9CQUFBLE1BQU0sRUFBRTtJQUNOLHdCQUFBLFFBQVEsRUFBRSxRQUFRO0lBQ2xCLHdCQUFBLE9BQU8sRUFBRSxVQUFVO0lBQ25CLHdCQUFBLE1BQU0sRUFBRSw4Q0FBOEM7SUFDdkQscUJBQUE7cUJBQ0YsQ0FBQztvQkFFSSxLQUFLLEdBQUcsVUFBQyxZQUFvQixFQUFBO0lBQ2pDLG9CQUFBLE9BQUEsSUFBSSxPQUFPLENBQUMsVUFBQSxPQUFPLEVBQUksRUFBQSxPQUFBLFVBQVUsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUEsRUFBQSxDQUFDLENBQUE7SUFBekQsaUJBQXlELENBQUM7SUFFdEQsZ0JBQUEsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxRCxnQkFBQSxnQkFBZ0IsQ0FBQyxHQUFHLEdBQUcsMENBQTBDLENBQUM7SUFDbEUsZ0JBQUEsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLGlCQUFpQixDQUFDO0lBQzFDLGdCQUFBLGdCQUFnQixDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDOUIsZ0JBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUV2QixnQkFBQSxPQUFBLENBQUEsQ0FBQSxZQUFNLElBQUksT0FBTyxDQUFTLFVBQUEsT0FBTyxFQUFBO0lBQ3BELHdCQUFBLElBQU0sZUFBZSxHQUFHLFlBQUEsRUFBQSxPQUFBLFNBQUEsQ0FBQSxLQUFBLENBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxZQUFBOzs7O0lBQ3RCLGdDQUFBLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsQ0FBQztvQ0FDOUQsSUFBSTtJQUVJLG9DQUFBLEVBQUUsR0FBRyxPQUFPLGFBQWEsS0FBSyxVQUFVLEdBQUUsQ0FBQSxFQUFBLEdBQUMsYUFBYSxFQUFFLDBDQUFFLFFBQVEsR0FBRyxJQUFJLENBQUM7d0NBQ2xGLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNiLGlDQUFBO0lBQUMsZ0NBQUEsT0FBTyxHQUFHLEVBQUU7d0NBQ1osT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2IsaUNBQUE7OztpQ0FDRixDQUFDO0lBRUYsd0JBQUEsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQzdELHFCQUFDLENBQUMsQ0FBQSxDQUFBOztJQWJJLGdCQUFBLFlBQVksR0FBRyxFQWFuQixDQUFBLElBQUEsRUFBQSxDQUFBO3lCQUVFLENBQUMsWUFBWSxFQUFiLE9BQWEsQ0FBQSxDQUFBLFlBQUEsQ0FBQSxDQUFBLENBQUE7SUFHVCxnQkFBQSxRQUFBLEdBQVMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoRCxnQkFBQSxRQUFNLENBQUMsR0FBRyxHQUFHLHVDQUF1QyxDQUFDO0lBQ3JELGdCQUFBLFFBQU0sQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLENBQUM7SUFDaEMsZ0JBQUEsUUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDcEIsZ0JBQUEsUUFBTSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDOUMsZ0JBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBTSxDQUFDLENBQUM7SUFFYixnQkFBQSxPQUFBLENBQUEsQ0FBQSxZQUFNLElBQUksT0FBTyxDQUFTLFVBQUEsT0FBTyxFQUFBO0lBQ3BELHdCQUFBLElBQU0sZUFBZSxHQUFHLFlBQUEsRUFBQSxPQUFBLFNBQUEsQ0FBQSxLQUFBLENBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxLQUFBLENBQUEsRUFBQSxZQUFBOzs7Ozs7SUFDdEIsd0NBQUEsUUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsQ0FBQzs7SUFFcEQsd0NBQUEsT0FBQSxDQUFBLENBQUEsWUFBTSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUEsQ0FBQTs7O0lBQWhCLHdDQUFBLEVBQUEsQ0FBQSxJQUFBLEVBQWdCLENBQUM7NENBQ2pCLElBQUk7Z0RBQ0ksRUFBRSxHQUFBLENBQUEsRUFBQSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLE1BQUUsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENBQUEsUUFBUSxDQUFDO2dEQUNoRCxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDYix5Q0FBQTtJQUFDLHdDQUFBLE9BQU8sR0FBRyxFQUFFO2dEQUNaLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNiLHlDQUFBOzs7O2lDQUNGLENBQUM7SUFDRix3QkFBQSxRQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQ25ELHFCQUFDLENBQUMsQ0FBQSxDQUFBOztJQWJJLGdCQUFBLFlBQVksR0FBRyxFQWFuQixDQUFBLElBQUEsRUFBQSxDQUFBO0lBQ0YsZ0JBQUEsT0FBQSxDQUFBLENBQUEsYUFBTyxZQUFZLENBQUMsQ0FBQTtJQUd0QixZQUFBLEtBQUEsQ0FBQSxFQUFBLE9BQUEsQ0FBQSxDQUFBLGFBQU8sWUFBWSxDQUFDLENBQUE7OztTQUNyQixFQUFDO0lBRUssSUFBTSxjQUFjLEdBQUcsWUFBQTtRQUM1QixJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEQsSUFBQSxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQUEsTUFBTSxFQUFBO1lBQ3BCLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsRUFBRTtnQkFDNUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2pCLFNBQUE7SUFDSCxLQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Ozs7Ozs7O0lDNUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBTyxFQUFFLFlBQVksRUFBRTtJQUM3QyxFQUFFLEtBQUssRUFBRSxJQUFJO0lBQ2IsQ0FBQyxDQUFDLENBQUM7SUFDWSxVQUFBLENBQUEsT0FBQSxHQUFHLElBQUk7SUFDdEI7SUFDQTtJQUNBO0lBQ0EsSUFBSSxlQUFlLENBQUM7SUFDcEIsTUFBTSxLQUFLLEdBQUcsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDakM7SUFDQSxTQUFTLEdBQUcsR0FBRztJQUNmO0lBQ0EsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO0lBQ3hCO0lBQ0EsSUFBSSxlQUFlLEdBQUcsT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLE1BQU0sQ0FBQyxlQUFlLElBQUksTUFBTSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDckg7SUFDQSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7SUFDMUIsTUFBTSxNQUFNLElBQUksS0FBSyxDQUFDLDBHQUEwRyxDQUFDLENBQUM7SUFDbEksS0FBSztJQUNMLEdBQUc7QUFDSDtJQUNBLEVBQUUsT0FBTyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEM7Ozs7Ozs7O0lDdEJBLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBTyxFQUFFLFlBQVksRUFBRTtJQUM3QyxFQUFFLEtBQUssRUFBRSxJQUFJO0lBQ2IsQ0FBQyxDQUFDLENBQUM7SUFDWSxLQUFBLENBQUEsT0FBQSxHQUFHLEtBQUssRUFBRTtJQUN6QixJQUFJSSxVQUFRLEdBQUcscUhBQXFILENBQUM7SUFDckksS0FBQSxDQUFBLE9BQWUsR0FBR0EsVUFBUTs7SUNMMUIsTUFBTSxDQUFDLGNBQWMsQ0FBQ0MsVUFBTyxFQUFFLFlBQVksRUFBRTtJQUM3QyxFQUFFLEtBQUssRUFBRSxJQUFJO0lBQ2IsQ0FBQyxDQUFDLENBQUM7QUFDWUEsY0FBQSxDQUFBLE9BQUEsR0FBRyxLQUFLLEVBQUU7QUFDekI7SUFDQSxJQUFJLE1BQU0sR0FBR0Msd0JBQXNCLENBQUNiLEtBQXFCLENBQUMsQ0FBQztBQUMzRDtJQUNBLFNBQVNhLHdCQUFzQixDQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUU7QUFDL0Y7SUFDQSxTQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUU7SUFDeEIsRUFBRSxPQUFPLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvRCxDQUFDO0FBQ0Q7SUFDQSxJQUFJRixVQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ3hCQyxjQUFBLENBQUEsT0FBZSxHQUFHRCxVQUFROztJQ2QxQixNQUFNLENBQUMsY0FBYyxDQUFDRyxXQUFPLEVBQUUsWUFBWSxFQUFFO0lBQzdDLEVBQUUsS0FBSyxFQUFFLElBQUk7SUFDYixDQUFDLENBQUMsQ0FBQztBQUNZQSxlQUFBLENBQUEsT0FBQSxHQUFHLEtBQUssRUFBRTtBQUNGQSxlQUFBLENBQUEsZUFBQSxHQUFHLGdCQUFnQjtBQUMxQztJQUNBLElBQUlDLFdBQVMsR0FBR0Ysd0JBQXNCLENBQUNiLFVBQXdCLENBQUMsQ0FBQztBQUNqRTtJQUNBLFNBQVNhLHdCQUFzQixDQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUU7QUFDL0Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztBQUNyQjtJQUNBLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUU7SUFDOUIsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQztBQUNEO0lBQ0EsU0FBUyxlQUFlLENBQUMsR0FBRyxFQUFFLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDMUM7SUFDQTtJQUNBLEVBQUUsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxN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QUNBLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxTQUFTLElBQUksS0FBSyxHQUFHLEtBQUssSUFBSSxXQUFXLENBQUM7SUFDakUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztJQUM1QixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQzVCLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDM0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0FBQ3JCO0lBQ0EsRUFBRSxNQUFNLEdBQUcsR0FBRyxLQUFLLEdBQUcsV0FBVyxHQUFHLEtBQUssR0FBRyxTQUFTLENBQUM7SUFDdEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztJQUM1QixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDdEI7SUFDQSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztBQUNuQztJQUNBLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDN0I7SUFDQSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ2pDO0lBQ0EsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQzNCO0lBQ0EsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO0lBQzlCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLEdBQUcsSUFBSSxJQUFJQyxZQUFVLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7QUFDRDtJQUNBLElBQUlQLFVBQVEsR0FBRyxFQUFFLENBQUM7QUFDbEJLLFFBQUEsQ0FBQSxPQUFlLEdBQUdMLFVBQVE7Ozs7Ozs7O0lDeEcxQixNQUFNLENBQUMsY0FBYyxDQUFDUSxPQUFPLEVBQUUsWUFBWSxFQUFFO0lBQzdDLEVBQUUsS0FBSyxFQUFFLElBQUk7SUFDYixDQUFDLENBQUMsQ0FBQztBQUNZQSxXQUFBLENBQUEsT0FBQSxHQUFHLEtBQUssRUFBRTtBQUN6QjtJQUNBLElBQUlKLFdBQVMsR0FBR0Ysd0JBQXNCLENBQUNiLFVBQXdCLENBQUMsQ0FBQztBQUNqRTtJQUNBLFNBQVNhLHdCQUFzQixDQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUU7QUFDL0Y7SUFDQSxTQUFTLEtBQUssQ0FBQyxJQUFJLEVBQUU7SUFDckIsRUFBRSxJQUFJLENBQUMsSUFBSUUsV0FBUyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRTtJQUNyQyxJQUFJLE1BQU0sU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ3BDLEdBQUc7QUFDSDtJQUNBLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDUixFQUFFLE1BQU0sR0FBRyxHQUFHLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2pDO0lBQ0EsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN2RCxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztJQUMzQixFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztJQUMxQixFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3BCO0lBQ0EsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN2RCxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3BCO0lBQ0EsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4RCxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3BCO0lBQ0EsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4RCxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ3BCO0FBQ0E7SUFDQSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENB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QUUsR0FBRyxFQUFFO0lBQzVCO0lBQ0EsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2xDLEVBQUUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDcEMsRUFBRSxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUM7SUFDckIsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQztJQUNyQixFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO0lBQ3RCLEVBQUUsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDO0FBQ3BCO0lBQ0EsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO0lBQ3pDLElBQUksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQy9DLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ25ELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDckQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ25ELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDckQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ25ELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2hELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDckQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN0RCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDckQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNoRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQy9DLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEQsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNuRCxJQUFJLENB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QUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLEVBQUUsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDOUIsRUFBRSxNQUFNLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QjtJQUNBLEVBQUUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtJQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3BDO0lBQ0EsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0lBQ2pDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMxSSxLQUFLO0FBQ0w7SUFDQSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDZixHQUFHO0FBQ0g7SUFDQSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUQsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUM7QUFDckQ7SUFDQSxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7SUFDOUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNsQztJQUNBLElBQUksS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtJQUNqQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsS0FBSztBQUNMO0lBQ0EsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0lBQ2xDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLEtBQUs7QUFDTDtJQUNBLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pCO0lBQ0EsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0lBQ2pDLE1BQU0sTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDbkMsTUFBTSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1osS0FBSztBQUNMO0lBQ0EsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsR0FBRztBQUNIO0lBQ0EsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJ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QUEsQ0FBRSxRQUFRLE1BQUUsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENBQUEsWUFBWSxLQUFJLEtBQUssQ0FBQztvQkFDcEUsaUJBQWlCLEdBQUcsQ0FBQSxDQUFBLEVBQUEsR0FBQSxDQUFBLEVBQUEsR0FBQSxDQUFBLEVBQUEsR0FBQSxVQUFVLE1BQUUsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENBQUEsUUFBUSxNQUFFLElBQUEsSUFBQSxFQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsRUFBQSxDQUFBLFlBQVksTUFBRSxJQUFBLElBQUEsRUFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUEsQ0FBQSxLQUFLLEtBQUksRUFBRSxDQUFDO29CQUNwRSxpQkFBaUIsR0FBRyxhQUFBLFVBQVUsTUFBQSxJQUFBLElBQUEsRUFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUEsQ0FBRSxRQUFRLE1BQUUsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENBQUEsUUFBUSxLQUFJLEtBQUssQ0FBQztvQkFDNUQsZUFBZSxHQUFHLGFBQUEsVUFBVSxNQUFBLElBQUEsSUFBQSxFQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsRUFBQSxDQUFFLFFBQVEsTUFBRSxJQUFBLElBQUEsRUFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUEsQ0FBQSxTQUFTLEtBQUksS0FBSyxDQUFDO29CQUMzRCxpQkFBaUIsR0FDckIsQ0FBQSxDQUFBLEVBQUEsR0FBQSxDQUFBLEVBQUEsR0FBQSxDQUFBLEVBQUEsR0FBQSxVQUFVLE1BQUUsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENB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
window.alloy = alloy.default || alloy;
